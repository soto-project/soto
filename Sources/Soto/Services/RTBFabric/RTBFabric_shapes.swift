//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RTBFabric {
    // MARK: Enums

    public enum FilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum LinkDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case request = "REQUEST"
        case response = "RESPONSE"
        public var description: String { return self.rawValue }
    }

    public enum LinkStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case active = "ACTIVE"
        case deleted = "DELETED"
        case failed = "FAILED"
        case isolated = "ISOLATED"
        case pendingCreation = "PENDING_CREATION"
        case pendingDeletion = "PENDING_DELETION"
        case pendingIsolation = "PENDING_ISOLATION"
        case pendingRequest = "PENDING_REQUEST"
        case pendingRestoration = "PENDING_RESTORATION"
        case pendingUpdate = "PENDING_UPDATE"
        case rejected = "REJECTED"
        case requested = "REQUESTED"
        public var description: String { return self.rawValue }
    }

    public enum RequesterGatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case error = "ERROR"
        case isolated = "ISOLATED"
        case pendingCreation = "PENDING_CREATION"
        case pendingDeletion = "PENDING_DELETION"
        case pendingIsolation = "PENDING_ISOLATION"
        case pendingRestoration = "PENDING_RESTORATION"
        case pendingUpdate = "PENDING_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum ResponderErrorMaskingAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noBid = "NO_BID"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum ResponderErrorMaskingLoggingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case metric = "METRIC"
        case none = "NONE"
        case response = "RESPONSE"
        public var description: String { return self.rawValue }
    }

    public enum ResponderGatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case error = "ERROR"
        case isolated = "ISOLATED"
        case pendingCreation = "PENDING_CREATION"
        case pendingDeletion = "PENDING_DELETION"
        case pendingIsolation = "PENDING_ISOLATION"
        case pendingRestoration = "PENDING_RESTORATION"
        case pendingUpdate = "PENDING_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum `Protocol`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "HTTP"
        case https = "HTTPS"
        public var description: String { return self.rawValue }
    }

    public enum Action: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Describes the header tag for a bid action.
        case headerTag(HeaderTagAction)
        /// Describes a no bid action.
        case noBid(NoBidAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .headerTag:
                let value = try container.decode(HeaderTagAction.self, forKey: .headerTag)
                self = .headerTag(value)
            case .noBid:
                let value = try container.decode(NoBidAction.self, forKey: .noBid)
                self = .noBid(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .headerTag(let value):
                try container.encode(value, forKey: .headerTag)
            case .noBid(let value):
                try container.encode(value, forKey: .noBid)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case headerTag = "headerTag"
            case noBid = "noBid"
        }
    }

    public enum ManagedEndpointConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Describes the configuration of an auto scaling group.
        case autoScalingGroups(AutoScalingGroupsConfiguration)
        /// Describes the configuration of an Amazon Elastic Kubernetes Service endpoint.
        case eksEndpoints(EksEndpointsConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .autoScalingGroups:
                let value = try container.decode(AutoScalingGroupsConfiguration.self, forKey: .autoScalingGroups)
                self = .autoScalingGroups(value)
            case .eksEndpoints:
                let value = try container.decode(EksEndpointsConfiguration.self, forKey: .eksEndpoints)
                self = .eksEndpoints(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .autoScalingGroups(let value):
                try container.encode(value, forKey: .autoScalingGroups)
            case .eksEndpoints(let value):
                try container.encode(value, forKey: .eksEndpoints)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .eksEndpoints(let value):
                try value.validate(name: "\(name).eksEndpoints")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingGroups = "autoScalingGroups"
            case eksEndpoints = "eksEndpoints"
        }
    }

    public enum ModuleParameters: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Describes the parameters of a no bid module.
        case noBid(NoBidModuleParameters)
        /// Describes the parameters of an open RTB attribute module.
        case openRtbAttribute(OpenRtbAttributeModuleParameters)
        /// Describes the parameters of a rate limit.
        case rateLimiter(RateLimiterModuleParameters)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .noBid:
                let value = try container.decode(NoBidModuleParameters.self, forKey: .noBid)
                self = .noBid(value)
            case .openRtbAttribute:
                let value = try container.decode(OpenRtbAttributeModuleParameters.self, forKey: .openRtbAttribute)
                self = .openRtbAttribute(value)
            case .rateLimiter:
                let value = try container.decode(RateLimiterModuleParameters.self, forKey: .rateLimiter)
                self = .rateLimiter(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .noBid(let value):
                try container.encode(value, forKey: .noBid)
            case .openRtbAttribute(let value):
                try container.encode(value, forKey: .openRtbAttribute)
            case .rateLimiter(let value):
                try container.encode(value, forKey: .rateLimiter)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case noBid = "noBid"
            case openRtbAttribute = "openRtbAttribute"
            case rateLimiter = "rateLimiter"
        }
    }

    // MARK: Shapes

    public struct AcceptLinkRequest: AWSEncodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// Settings for the application logs.
        public let logSettings: LinkLogSettings

        @inlinable
        public init(attributes: LinkAttributes? = nil, gatewayId: String, linkId: String, logSettings: LinkLogSettings) {
            self.attributes = attributes
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.logSettings = logSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
            try container.encode(self.logSettings, forKey: .logSettings)
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case logSettings = "logSettings"
        }
    }

    public struct AcceptLinkResponse: AWSDecodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the link was created.
        public let createdAt: Date
        /// The direction of the link.
        public let direction: LinkDirection?
        /// The configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// The configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the link.
        public let status: LinkStatus
        /// The timestamp of when the link was updated.
        public let updatedAt: Date

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date, direction: LinkDirection? = nil, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, peerGatewayId: String, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, updatedAt: Date) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case direction = "direction"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case peerGatewayId = "peerGatewayId"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AutoScalingGroupsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The names of the auto scaling group.
        public let autoScalingGroupNames: [String]
        /// The role ARN of the auto scaling group.
        public let roleArn: String

        @inlinable
        public init(autoScalingGroupNames: [String], roleArn: String) {
            self.autoScalingGroupNames = autoScalingGroupNames
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingGroupNames = "autoScalingGroupNames"
            case roleArn = "roleArn"
        }
    }

    public struct CreateInboundExternalLinkRequest: AWSEncodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The unique client token.
        public let clientToken: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        public let logSettings: LinkLogSettings
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributes: LinkAttributes? = nil, clientToken: String = CreateInboundExternalLinkRequest.idempotencyToken(), gatewayId: String, logSettings: LinkLogSettings, tags: [String: String]? = nil) {
            self.attributes = attributes
            self.clientToken = clientToken
            self.gatewayId = gatewayId
            self.logSettings = logSettings
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encode(self.logSettings, forKey: .logSettings)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case clientToken = "clientToken"
            case logSettings = "logSettings"
            case tags = "tags"
        }
    }

    public struct CreateInboundExternalLinkResponse: AWSDecodableShape {
        /// The domain name.
        public let domainName: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(domainName: String, gatewayId: String, linkId: String, status: LinkStatus) {
            self.domainName = domainName
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct CreateLinkRequest: AWSEncodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// Boolean to specify if an HTTP responder is allowed.
        public let httpResponderAllowed: Bool?
        /// Settings for the application logs.
        public let logSettings: LinkLogSettings
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributes: LinkAttributes? = nil, gatewayId: String, httpResponderAllowed: Bool? = nil, logSettings: LinkLogSettings, peerGatewayId: String, tags: [String: String]? = nil) {
            self.attributes = attributes
            self.gatewayId = gatewayId
            self.httpResponderAllowed = httpResponderAllowed
            self.logSettings = logSettings
            self.peerGatewayId = peerGatewayId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encodeIfPresent(self.httpResponderAllowed, forKey: .httpResponderAllowed)
            try container.encode(self.logSettings, forKey: .logSettings)
            try container.encode(self.peerGatewayId, forKey: .peerGatewayId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.peerGatewayId, name: "peerGatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case httpResponderAllowed = "httpResponderAllowed"
            case logSettings = "logSettings"
            case peerGatewayId = "peerGatewayId"
            case tags = "tags"
        }
    }

    public struct CreateLinkResponse: AWSDecodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the link was created.
        public let createdAt: Date
        /// The customer-provided unique identifier of the link.
        public let customerProvidedId: String?
        /// The direction of the link.
        public let direction: LinkDirection?
        /// The configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// The configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the request.
        public let status: LinkStatus
        /// The timestamp of when the link was updated.
        public let updatedAt: Date

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date, customerProvidedId: String? = nil, direction: LinkDirection? = nil, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, peerGatewayId: String, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, updatedAt: Date) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.customerProvidedId = customerProvidedId
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case customerProvidedId = "customerProvidedId"
            case direction = "direction"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case peerGatewayId = "peerGatewayId"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateOutboundExternalLinkRequest: AWSEncodableShape {
        public let attributes: LinkAttributes?
        /// The unique client token.
        public let clientToken: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        public let logSettings: LinkLogSettings
        /// The public endpoint of the link.
        public let publicEndpoint: String
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributes: LinkAttributes? = nil, clientToken: String = CreateOutboundExternalLinkRequest.idempotencyToken(), gatewayId: String, logSettings: LinkLogSettings, publicEndpoint: String, tags: [String: String]? = nil) {
            self.attributes = attributes
            self.clientToken = clientToken
            self.gatewayId = gatewayId
            self.logSettings = logSettings
            self.publicEndpoint = publicEndpoint
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encode(self.logSettings, forKey: .logSettings)
            try container.encode(self.publicEndpoint, forKey: .publicEndpoint)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.publicEndpoint, name: "publicEndpoint", parent: name, max: 255)
            try self.validate(self.publicEndpoint, name: "publicEndpoint", parent: name, pattern: "^(https|http)://.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case clientToken = "clientToken"
            case logSettings = "logSettings"
            case publicEndpoint = "publicEndpoint"
            case tags = "tags"
        }
    }

    public struct CreateOutboundExternalLinkResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(gatewayId: String, linkId: String, status: LinkStatus) {
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct CreateRequesterGatewayRequest: AWSEncodableShape {
        /// The unique client token.
        public let clientToken: String
        /// An optional description for the requester gateway.
        public let description: String?
        /// The unique identifiers of the security groups.
        public let securityGroupIds: [String]
        /// The unique identifiers of the subnets.
        public let subnetIds: [String]
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?
        /// The unique identifier of the Virtual Private Cloud (VPC).
        public let vpcId: String

        @inlinable
        public init(clientToken: String = CreateRequesterGatewayRequest.idempotencyToken(), description: String? = nil, securityGroupIds: [String], subnetIds: [String], tags: [String: String]? = nil, vpcId: String) {
            self.clientToken = clientToken
            self.description = description
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-f]{8,40}$")
            }
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-\\w{8,17}$")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-f0-9]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct CreateRequesterGatewayResponse: AWSDecodableShape {
        /// The domain name of the requester gateway.
        public let domainName: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: RequesterGatewayStatus

        @inlinable
        public init(domainName: String, gatewayId: String, status: RequesterGatewayStatus) {
            self.domainName = domainName
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }

    public struct CreateResponderGatewayRequest: AWSEncodableShape {
        /// The unique client token.
        public let clientToken: String
        /// An optional description for the responder gateway.
        public let description: String?
        /// The domain name for the responder gateway.
        public let domainName: String?
        /// The configuration for the managed endpoint.
        public let managedEndpointConfiguration: ManagedEndpointConfiguration?
        /// The networking port to use.
        public let port: Int
        /// The networking protocol to use.
        public let `protocol`: `Protocol`
        /// The unique identifiers of the security groups.
        public let securityGroupIds: [String]
        /// The unique identifiers of the subnets.
        public let subnetIds: [String]
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?
        /// The configuration of the trust store.
        public let trustStoreConfiguration: TrustStoreConfiguration?
        /// The unique identifier of the Virtual Private Cloud (VPC).
        public let vpcId: String

        @inlinable
        public init(clientToken: String = CreateResponderGatewayRequest.idempotencyToken(), description: String? = nil, domainName: String? = nil, managedEndpointConfiguration: ManagedEndpointConfiguration? = nil, port: Int, protocol: `Protocol`, securityGroupIds: [String], subnetIds: [String], tags: [String: String]? = nil, trustStoreConfiguration: TrustStoreConfiguration? = nil, vpcId: String) {
            self.clientToken = clientToken
            self.description = description
            self.domainName = domainName
            self.managedEndpointConfiguration = managedEndpointConfiguration
            self.port = port
            self.`protocol` = `protocol`
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.trustStoreConfiguration = trustStoreConfiguration
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)(?:\\.(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?))+$")
            try self.managedEndpointConfiguration?.validate(name: "\(name).managedEndpointConfiguration")
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-f]{8,40}$")
            }
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-\\w{8,17}$")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
            try self.trustStoreConfiguration?.validate(name: "\(name).trustStoreConfiguration")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-f0-9]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case domainName = "domainName"
            case managedEndpointConfiguration = "managedEndpointConfiguration"
            case port = "port"
            case `protocol` = "protocol"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case trustStoreConfiguration = "trustStoreConfiguration"
            case vpcId = "vpcId"
        }
    }

    public struct CreateResponderGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: ResponderGatewayStatus

        @inlinable
        public init(gatewayId: String, status: ResponderGatewayStatus) {
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }

    public struct DeleteInboundExternalLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInboundExternalLinkResponse: AWSDecodableShape {
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(linkId: String, status: LinkStatus) {
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct DeleteLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLinkResponse: AWSDecodableShape {
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the link.
        public let status: LinkStatus

        @inlinable
        public init(linkId: String, status: LinkStatus) {
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct DeleteOutboundExternalLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOutboundExternalLinkResponse: AWSDecodableShape {
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(linkId: String, status: LinkStatus) {
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct DeleteRequesterGatewayRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRequesterGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: RequesterGatewayStatus

        @inlinable
        public init(gatewayId: String, status: RequesterGatewayStatus) {
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }

    public struct DeleteResponderGatewayRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResponderGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: ResponderGatewayStatus

        @inlinable
        public init(gatewayId: String, status: ResponderGatewayStatus) {
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }

    public struct EksEndpointsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The CA certificate chain of the cluster API server.
        public let clusterApiServerCaCertificateChain: String
        /// The URI of the cluster API server endpoint.
        public let clusterApiServerEndpointUri: String
        /// The name of the cluster.
        public let clusterName: String
        /// The name of the endpoint resource.
        public let endpointsResourceName: String
        /// The namespace of the endpoint resource.
        public let endpointsResourceNamespace: String
        /// The role ARN for the cluster.
        public let roleArn: String

        @inlinable
        public init(clusterApiServerCaCertificateChain: String, clusterApiServerEndpointUri: String, clusterName: String, endpointsResourceName: String, endpointsResourceNamespace: String, roleArn: String) {
            self.clusterApiServerCaCertificateChain = clusterApiServerCaCertificateChain
            self.clusterApiServerEndpointUri = clusterApiServerEndpointUri
            self.clusterName = clusterName
            self.endpointsResourceName = endpointsResourceName
            self.endpointsResourceNamespace = endpointsResourceNamespace
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterApiServerCaCertificateChain, name: "clusterApiServerCaCertificateChain", parent: name, max: 2097152)
            try self.validate(self.clusterApiServerCaCertificateChain, name: "clusterApiServerCaCertificateChain", parent: name, min: 1)
            try self.validate(self.clusterApiServerEndpointUri, name: "clusterApiServerEndpointUri", parent: name, max: 255)
            try self.validate(self.clusterApiServerEndpointUri, name: "clusterApiServerEndpointUri", parent: name, pattern: "^(https|http)://(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)(?:\\.(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?))+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9]$")
            try self.validate(self.endpointsResourceName, name: "endpointsResourceName", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9]$")
            try self.validate(self.endpointsResourceNamespace, name: "endpointsResourceNamespace", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterApiServerCaCertificateChain = "clusterApiServerCaCertificateChain"
            case clusterApiServerEndpointUri = "clusterApiServerEndpointUri"
            case clusterName = "clusterName"
            case endpointsResourceName = "endpointsResourceName"
            case endpointsResourceNamespace = "endpointsResourceNamespace"
            case roleArn = "roleArn"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// Describes the criteria for a filter.
        public let criteria: [FilterCriterion]

        @inlinable
        public init(criteria: [FilterCriterion]) {
            self.criteria = criteria
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
        }
    }

    public struct FilterCriterion: AWSEncodableShape & AWSDecodableShape {
        /// The path to filter.
        public let path: String
        /// The value to filter.
        public let values: [String]

        @inlinable
        public init(path: String, values: [String]) {
            self.path = path
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
            case values = "values"
        }
    }

    public struct GetInboundExternalLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInboundExternalLinkResponse: AWSDecodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the inbound external link was created.
        public let createdAt: Date?
        /// The domain name.
        public let domainName: String
        /// The configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        public let logSettings: LinkLogSettings?
        /// The configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the request.
        public let status: LinkStatus
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?
        /// The timestamp of when the inbound external link was updated.
        public let updatedAt: Date?

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date? = nil, domainName: String, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, logSettings: LinkLogSettings? = nil, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.domainName = domainName
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.logSettings = logSettings
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case logSettings = "logSettings"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLinkResponse: AWSDecodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the link was created.
        public let createdAt: Date
        /// The direction of the link.
        public let direction: LinkDirection?
        /// The configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// Settings for the application logs.
        public let logSettings: LinkLogSettings?
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// The configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the link.
        public let status: LinkStatus
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?
        /// The timestamp of when the link was updated.
        public let updatedAt: Date

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date, direction: LinkDirection? = nil, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, logSettings: LinkLogSettings? = nil, peerGatewayId: String, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, tags: [String: String]? = nil, updatedAt: Date) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.logSettings = logSettings
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case direction = "direction"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case logSettings = "logSettings"
            case peerGatewayId = "peerGatewayId"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetOutboundExternalLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOutboundExternalLinkResponse: AWSDecodableShape {
        /// The timestamp of when the outbound external link was created.
        public let createdAt: Date?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        public let logSettings: LinkLogSettings?
        /// The public endpoint for the link.
        public let publicEndpoint: String
        /// The status of the request.
        public let status: LinkStatus
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?
        /// The timestamp of when the outbound external link was updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, gatewayId: String, linkId: String, logSettings: LinkLogSettings? = nil, publicEndpoint: String, status: LinkStatus, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.logSettings = logSettings
            self.publicEndpoint = publicEndpoint
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case logSettings = "logSettings"
            case publicEndpoint = "publicEndpoint"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetRequesterGatewayRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRequesterGatewayResponse: AWSDecodableShape {
        /// The count of active links for the requester gateway.
        public let activeLinksCount: Int?
        /// The timestamp of when the requester gateway was created.
        public let createdAt: Date?
        /// The description of the requester gateway.
        public let description: String?
        /// The domain name of the requester gateway.
        public let domainName: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifiers of the security groups.
        public let securityGroupIds: [String]
        /// The status of the request.
        public let status: RequesterGatewayStatus
        /// The unique identifiers of the subnets.
        public let subnetIds: [String]
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?
        /// The total count of links for the requester gateway.
        public let totalLinksCount: Int?
        /// The timestamp of when the requester gateway was updated.
        public let updatedAt: Date?
        /// The unique identifier of the Virtual Private Cloud (VPC).
        public let vpcId: String

        @inlinable
        public init(activeLinksCount: Int? = nil, createdAt: Date? = nil, description: String? = nil, domainName: String, gatewayId: String, securityGroupIds: [String], status: RequesterGatewayStatus, subnetIds: [String], tags: [String: String]? = nil, totalLinksCount: Int? = nil, updatedAt: Date? = nil, vpcId: String) {
            self.activeLinksCount = activeLinksCount
            self.createdAt = createdAt
            self.description = description
            self.domainName = domainName
            self.gatewayId = gatewayId
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.tags = tags
            self.totalLinksCount = totalLinksCount
            self.updatedAt = updatedAt
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case activeLinksCount = "activeLinksCount"
            case createdAt = "createdAt"
            case description = "description"
            case domainName = "domainName"
            case gatewayId = "gatewayId"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case totalLinksCount = "totalLinksCount"
            case updatedAt = "updatedAt"
            case vpcId = "vpcId"
        }
    }

    public struct GetResponderGatewayRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResponderGatewayResponse: AWSDecodableShape {
        /// The count of active links for the responder gateway.
        public let activeLinksCount: Int?
        /// The timestamp of when the responder gateway was created.
        public let createdAt: Date?
        /// The description of the responder gateway.
        public let description: String?
        /// The domain name of the responder gateway.
        public let domainName: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The count of inbound links for the responder gateway.
        public let inboundLinksCount: Int?
        /// The configuration of the managed endpoint.
        public let managedEndpointConfiguration: ManagedEndpointConfiguration?
        /// The networking port.
        public let port: Int
        /// The networking protocol.
        public let `protocol`: `Protocol`
        /// The unique identifiers of the security groups.
        public let securityGroupIds: [String]
        /// The status of the request.
        public let status: ResponderGatewayStatus
        /// The unique identifiers of the subnets.
        public let subnetIds: [String]
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?
        /// The total count of links for the responder gateway.
        public let totalLinksCount: Int?
        /// The configuration of the trust store.
        public let trustStoreConfiguration: TrustStoreConfiguration?
        /// The timestamp of when the responder gateway was updated.
        public let updatedAt: Date?
        /// The unique identifier of the Virtual Private Cloud (VPC).
        public let vpcId: String

        @inlinable
        public init(activeLinksCount: Int? = nil, createdAt: Date? = nil, description: String? = nil, domainName: String? = nil, gatewayId: String, inboundLinksCount: Int? = nil, managedEndpointConfiguration: ManagedEndpointConfiguration? = nil, port: Int, protocol: `Protocol`, securityGroupIds: [String], status: ResponderGatewayStatus, subnetIds: [String], tags: [String: String]? = nil, totalLinksCount: Int? = nil, trustStoreConfiguration: TrustStoreConfiguration? = nil, updatedAt: Date? = nil, vpcId: String) {
            self.activeLinksCount = activeLinksCount
            self.createdAt = createdAt
            self.description = description
            self.domainName = domainName
            self.gatewayId = gatewayId
            self.inboundLinksCount = inboundLinksCount
            self.managedEndpointConfiguration = managedEndpointConfiguration
            self.port = port
            self.`protocol` = `protocol`
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.tags = tags
            self.totalLinksCount = totalLinksCount
            self.trustStoreConfiguration = trustStoreConfiguration
            self.updatedAt = updatedAt
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case activeLinksCount = "activeLinksCount"
            case createdAt = "createdAt"
            case description = "description"
            case domainName = "domainName"
            case gatewayId = "gatewayId"
            case inboundLinksCount = "inboundLinksCount"
            case managedEndpointConfiguration = "managedEndpointConfiguration"
            case port = "port"
            case `protocol` = "protocol"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case totalLinksCount = "totalLinksCount"
            case trustStoreConfiguration = "trustStoreConfiguration"
            case updatedAt = "updatedAt"
            case vpcId = "vpcId"
        }
    }

    public struct HeaderTagAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the bid action.
        public let name: String
        /// The value of the bid action.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct LinkApplicationLogConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Describes a link application log sample.
        public let sampling: LinkApplicationLogSampling

        @inlinable
        public init(sampling: LinkApplicationLogSampling) {
            self.sampling = sampling
        }

        private enum CodingKeys: String, CodingKey {
            case sampling = "sampling"
        }
    }

    public struct LinkApplicationLogSampling: AWSEncodableShape & AWSDecodableShape {
        /// An error log entry.
        public let errorLog: Double
        /// A filter log entry.
        public let filterLog: Double

        @inlinable
        public init(errorLog: Double, filterLog: Double) {
            self.errorLog = errorLog
            self.filterLog = filterLog
        }

        private enum CodingKeys: String, CodingKey {
            case errorLog = "errorLog"
            case filterLog = "filterLog"
        }
    }

    public struct LinkAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The customer-provided unique identifier of the link.
        public let customerProvidedId: String?
        /// Describes the masking for HTTP error codes.
        public let responderErrorMasking: [ResponderErrorMaskingForHttpCode]?

        @inlinable
        public init(customerProvidedId: String? = nil, responderErrorMasking: [ResponderErrorMaskingForHttpCode]? = nil) {
            self.customerProvidedId = customerProvidedId
            self.responderErrorMasking = responderErrorMasking
        }

        public func validate(name: String) throws {
            try self.validate(self.customerProvidedId, name: "customerProvidedId", parent: name, max: 255)
            try self.validate(self.customerProvidedId, name: "customerProvidedId", parent: name, min: 1)
            try self.validate(self.customerProvidedId, name: "customerProvidedId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.responderErrorMasking?.forEach {
                try $0.validate(name: "\(name).responderErrorMasking[]")
            }
            try self.validate(self.responderErrorMasking, name: "responderErrorMasking", parent: name, max: 200)
            try self.validate(self.responderErrorMasking, name: "responderErrorMasking", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customerProvidedId = "customerProvidedId"
            case responderErrorMasking = "responderErrorMasking"
        }
    }

    public struct LinkLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// Describes the configuration of a link application log.
        public let applicationLogs: LinkApplicationLogConfiguration

        @inlinable
        public init(applicationLogs: LinkApplicationLogConfiguration) {
            self.applicationLogs = applicationLogs
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogs = "applicationLogs"
        }
    }

    public struct ListLinksRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(gatewayId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gatewayId = gatewayId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLinksResponse: AWSDecodableShape {
        /// Information about created links.
        public let links: [ListLinksResponseStructure]?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(links: [ListLinksResponseStructure]? = nil, nextToken: String? = nil) {
            self.links = links
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case links = "links"
            case nextToken = "nextToken"
        }
    }

    public struct ListLinksResponseStructure: AWSDecodableShape {
        /// Describes attributes of a link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the link was created.
        public let createdAt: Date
        /// The direction of the link.
        public let direction: LinkDirection?
        /// Describes the configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// Describes the configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the link.
        public let status: LinkStatus
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?
        /// The timestamp of when the link was updated.
        public let updatedAt: Date

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date, direction: LinkDirection? = nil, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, peerGatewayId: String, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, tags: [String: String]? = nil, updatedAt: Date) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case direction = "direction"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case peerGatewayId = "peerGatewayId"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct ListRequesterGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRequesterGatewaysResponse: AWSDecodableShape {
        /// The unique identifier of the gateways.
        public let gatewayIds: [String]?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(gatewayIds: [String]? = nil, nextToken: String? = nil) {
            self.gatewayIds = gatewayIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayIds = "gatewayIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListResponderGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResponderGatewaysResponse: AWSDecodableShape {
        /// The unique identifier of the gateways.
        public let gatewayIds: [String]?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(gatewayIds: [String]? = nil, nextToken: String? = nil) {
            self.gatewayIds = gatewayIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayIds = "gatewayIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:rtbfabric:[a-zA-Z0-9_-]+:[0-9]{12}:gateway/[a-zA-Z0-9-]+(/link/[a-zA-Z0-9-]+)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ModuleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dependencies of the module.
        public let dependsOn: [String]?
        /// Describes the parameters of a module.
        public let moduleParameters: ModuleParameters?
        /// The name of the module.
        public let name: String
        /// The version of the module.
        public let version: String?

        @inlinable
        public init(dependsOn: [String]? = nil, moduleParameters: ModuleParameters? = nil, name: String, version: String? = nil) {
            self.dependsOn = dependsOn
            self.moduleParameters = moduleParameters
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.dependsOn?.forEach {
                try validate($0, name: "dependsOn[]", parent: name, max: 255)
                try validate($0, name: "dependsOn[]", parent: name, pattern: "^[A-Za-z0-9 -]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9 -]+$")
            try self.validate(self.version, name: "version", parent: name, pattern: "^[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dependsOn = "dependsOn"
            case moduleParameters = "moduleParameters"
            case name = "name"
            case version = "version"
        }
    }

    public struct NoBidAction: AWSEncodableShape & AWSDecodableShape {
        /// The reason code for the no bid action.
        public let noBidReasonCode: Int?

        @inlinable
        public init(noBidReasonCode: Int? = nil) {
            self.noBidReasonCode = noBidReasonCode
        }

        private enum CodingKeys: String, CodingKey {
            case noBidReasonCode = "noBidReasonCode"
        }
    }

    public struct NoBidModuleParameters: AWSEncodableShape & AWSDecodableShape {
        /// The pass through percentage.
        public let passThroughPercentage: Float?
        /// The reason description.
        public let reason: String?
        /// The reason code.
        public let reasonCode: Int?

        @inlinable
        public init(passThroughPercentage: Float? = nil, reason: String? = nil, reasonCode: Int? = nil) {
            self.passThroughPercentage = passThroughPercentage
            self.reason = reason
            self.reasonCode = reasonCode
        }

        private enum CodingKeys: String, CodingKey {
            case passThroughPercentage = "passThroughPercentage"
            case reason = "reason"
            case reasonCode = "reasonCode"
        }
    }

    public struct OpenRtbAttributeModuleParameters: AWSEncodableShape & AWSDecodableShape {
        /// Describes a bid action.
        public let action: Action
        /// Describes the configuration of a filter.
        public let filterConfiguration: [Filter]
        /// The filter type.
        public let filterType: FilterType
        /// The hold back percentage.
        public let holdbackPercentage: Float

        @inlinable
        public init(action: Action, filterConfiguration: [Filter], filterType: FilterType, holdbackPercentage: Float) {
            self.action = action
            self.filterConfiguration = filterConfiguration
            self.filterType = filterType
            self.holdbackPercentage = holdbackPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case filterConfiguration = "filterConfiguration"
            case filterType = "filterType"
            case holdbackPercentage = "holdbackPercentage"
        }
    }

    public struct RateLimiterModuleParameters: AWSEncodableShape & AWSDecodableShape {
        /// The transactions per second rate limit.
        public let tps: Float?

        @inlinable
        public init(tps: Float? = nil) {
            self.tps = tps
        }

        private enum CodingKeys: String, CodingKey {
            case tps = "tps"
        }
    }

    public struct RejectLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String

        @inlinable
        public init(gatewayId: String, linkId: String) {
            self.gatewayId = gatewayId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectLinkResponse: AWSDecodableShape {
        /// Attributes of the link.
        public let attributes: LinkAttributes?
        /// The timestamp of when the link was created.
        public let createdAt: Date
        /// The direction of the link.
        public let direction: LinkDirection?
        /// The configuration of flow modules.
        public let flowModules: [ModuleConfiguration]?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The unique identifier of the peer gateway.
        public let peerGatewayId: String
        /// The configuration of pending flow modules.
        public let pendingFlowModules: [ModuleConfiguration]?
        /// The status of the link.
        public let status: LinkStatus
        /// The timestamp of when the link was updated.
        public let updatedAt: Date

        @inlinable
        public init(attributes: LinkAttributes? = nil, createdAt: Date, direction: LinkDirection? = nil, flowModules: [ModuleConfiguration]? = nil, gatewayId: String, linkId: String, peerGatewayId: String, pendingFlowModules: [ModuleConfiguration]? = nil, status: LinkStatus, updatedAt: Date) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case createdAt = "createdAt"
            case direction = "direction"
            case flowModules = "flowModules"
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case peerGatewayId = "peerGatewayId"
            case pendingFlowModules = "pendingFlowModules"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ResponderErrorMaskingForHttpCode: AWSEncodableShape & AWSDecodableShape {
        /// The action for the error..
        public let action: ResponderErrorMaskingAction
        /// The HTTP error code.
        public let httpCode: String
        /// The error log type.
        public let loggingTypes: [ResponderErrorMaskingLoggingType]
        /// The percentage of response logging.
        public let responseLoggingPercentage: Float?

        @inlinable
        public init(action: ResponderErrorMaskingAction, httpCode: String, loggingTypes: [ResponderErrorMaskingLoggingType], responseLoggingPercentage: Float? = nil) {
            self.action = action
            self.httpCode = httpCode
            self.loggingTypes = loggingTypes
            self.responseLoggingPercentage = responseLoggingPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.loggingTypes, name: "loggingTypes", parent: name, max: 2)
            try self.validate(self.loggingTypes, name: "loggingTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case httpCode = "httpCode"
            case loggingTypes = "loggingTypes"
            case responseLoggingPercentage = "responseLoggingPercentage"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:rtbfabric:[a-zA-Z0-9_-]+:[0-9]{12}:gateway/[a-zA-Z0-9-]+(/link/[a-zA-Z0-9-]+)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 1600)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrustStoreConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The certificate authority certificate.
        public let certificateAuthorityCertificates: [String]

        @inlinable
        public init(certificateAuthorityCertificates: [String]) {
            self.certificateAuthorityCertificates = certificateAuthorityCertificates
        }

        public func validate(name: String) throws {
            try self.certificateAuthorityCertificates.forEach {
                try validate($0, name: "certificateAuthorityCertificates[]", parent: name, max: 2097152)
                try validate($0, name: "certificateAuthorityCertificates[]", parent: name, min: 1)
            }
            try self.validate(self.certificateAuthorityCertificates, name: "certificateAuthorityCertificates", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityCertificates = "certificateAuthorityCertificates"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:rtbfabric:[a-zA-Z0-9_-]+:[0-9]{12}:gateway/[a-zA-Z0-9-]+(/link/[a-zA-Z0-9-]+)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(resourceArn|internalId|(?!aws:)[a-zA-Z0-9+\\-=._:/@]+)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLinkModuleFlowRequest: AWSEncodableShape {
        /// The unique client token.
        public let clientToken: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The configuration of a module.
        public let modules: [ModuleConfiguration]

        @inlinable
        public init(clientToken: String = UpdateLinkModuleFlowRequest.idempotencyToken(), gatewayId: String, linkId: String, modules: [ModuleConfiguration]) {
            self.clientToken = clientToken
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.modules = modules
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
            try container.encode(self.modules, forKey: .modules)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
            try self.modules.forEach {
                try $0.validate(name: "\(name).modules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modules = "modules"
        }
    }

    public struct UpdateLinkModuleFlowResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(gatewayId: String, linkId: String, status: LinkStatus) {
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct UpdateLinkRequest: AWSEncodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The unique identifier of the link.
        public let linkId: String
        /// Settings for the application logs.
        public let logSettings: LinkLogSettings?

        @inlinable
        public init(gatewayId: String, linkId: String, logSettings: LinkLogSettings? = nil) {
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.logSettings = logSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            request.encodePath(self.linkId, key: "linkId")
            try container.encodeIfPresent(self.logSettings, forKey: .logSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^link-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: String, CodingKey {
            case logSettings = "logSettings"
        }
    }

    public struct UpdateLinkResponse: AWSDecodableShape {
        /// The unique identifier of the link.
        public let linkId: String
        /// The status of the request.
        public let status: LinkStatus

        @inlinable
        public init(linkId: String, status: LinkStatus) {
            self.linkId = linkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case linkId = "linkId"
            case status = "status"
        }
    }

    public struct UpdateRequesterGatewayRequest: AWSEncodableShape {
        /// The unique client token.
        public let clientToken: String
        /// An optional description for the requester gateway.
        public let description: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String

        @inlinable
        public init(clientToken: String = UpdateRequesterGatewayRequest.idempotencyToken(), description: String? = nil, gatewayId: String) {
            self.clientToken = clientToken
            self.description = description
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateRequesterGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: RequesterGatewayStatus

        @inlinable
        public init(gatewayId: String, status: RequesterGatewayStatus) {
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }

    public struct UpdateResponderGatewayRequest: AWSEncodableShape {
        /// The unique client token.
        public let clientToken: String
        /// An optional description for the responder gateway.
        public let description: String?
        /// The domain name for the responder gateway.
        public let domainName: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The configuration for the managed endpoint.
        public let managedEndpointConfiguration: ManagedEndpointConfiguration?
        /// The networking port to use.
        public let port: Int
        /// The networking protocol to use.
        public let `protocol`: `Protocol`
        /// The configuration of the trust store.
        public let trustStoreConfiguration: TrustStoreConfiguration?

        @inlinable
        public init(clientToken: String = UpdateResponderGatewayRequest.idempotencyToken(), description: String? = nil, domainName: String? = nil, gatewayId: String, managedEndpointConfiguration: ManagedEndpointConfiguration? = nil, port: Int, protocol: `Protocol`, trustStoreConfiguration: TrustStoreConfiguration? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainName = domainName
            self.gatewayId = gatewayId
            self.managedEndpointConfiguration = managedEndpointConfiguration
            self.port = port
            self.`protocol` = `protocol`
            self.trustStoreConfiguration = trustStoreConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.domainName, forKey: .domainName)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encodeIfPresent(self.managedEndpointConfiguration, forKey: .managedEndpointConfiguration)
            try container.encode(self.port, forKey: .port)
            try container.encode(self.`protocol`, forKey: .`protocol`)
            try container.encodeIfPresent(self.trustStoreConfiguration, forKey: .trustStoreConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)(?:\\.(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?))+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^rtb-gw-[a-z0-9-]{1,25}$")
            try self.managedEndpointConfiguration?.validate(name: "\(name).managedEndpointConfiguration")
            try self.trustStoreConfiguration?.validate(name: "\(name).trustStoreConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case domainName = "domainName"
            case managedEndpointConfiguration = "managedEndpointConfiguration"
            case port = "port"
            case `protocol` = "protocol"
            case trustStoreConfiguration = "trustStoreConfiguration"
        }
    }

    public struct UpdateResponderGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The status of the request.
        public let status: ResponderGatewayStatus

        @inlinable
        public init(gatewayId: String, status: ResponderGatewayStatus) {
            self.gatewayId = gatewayId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
        }
    }
}

// MARK: - Errors

/// Error enum for RTBFabric
public struct RTBFabricErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RTBFabric
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request could not be completed because you do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed because of a conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request could not be completed because of an internal server error. Try your call again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request could not be completed because the resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request could not be completed because you exceeded a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request could not be completed because it fails satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension RTBFabricErrorType: Equatable {
    public static func == (lhs: RTBFabricErrorType, rhs: RTBFabricErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RTBFabricErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
