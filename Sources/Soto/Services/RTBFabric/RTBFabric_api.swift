//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS RTBFabric service.
///
/// Amazon Web Services RTB Fabric provides secure, low-latency infrastructure for connecting real-time bidding (RTB) applications. Rather than hosting applications directly, RTB Fabric acts as the connecting fabric that enables your applications to communicate efficiently over private networks instead of the public internet. You maintain complete control over your applications, data, and bidding decisions, while RTB Fabric provides the underlying infrastructure for secure, reliable connectivity. You can use these APIs to complete RTB Fabric tasks, such as setting up audit log ingestions or viewing user access. For more information about RTB Fabric, including the required permissions to use the service, see the Amazon Web Services RTB Fabric User Guide.
public struct RTBFabric: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the RTBFabric client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "RTBFabric",
            serviceIdentifier: "rtbfabric",
            serviceProtocol: .restjson,
            apiVersion: "2023-05-15",
            endpoint: endpoint,
            errorType: RTBFabricErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Accepts a link request between gateways. When a requester gateway requests to link with a responder gateway, the responder can use this operation to accept the link request and establish the connection.
    @Sendable
    @inlinable
    public func acceptLink(_ input: AcceptLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AcceptLinkResponse {
        try await self.client.execute(
            operation: "AcceptLink", 
            path: "/gateway/{gatewayId}/link/{linkId}/accept", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Accepts a link request between gateways. When a requester gateway requests to link with a responder gateway, the responder can use this operation to accept the link request and establish the connection.
    ///
    /// Parameters:
    ///   - attributes: Attributes of the link.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logSettings: Settings for the application logs.
    ///   - logger: Logger use during operation
    @inlinable
    public func acceptLink(
        attributes: LinkAttributes? = nil,
        gatewayId: String,
        linkId: String,
        logSettings: LinkLogSettings,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AcceptLinkResponse {
        let input = AcceptLinkRequest(
            attributes: attributes, 
            gatewayId: gatewayId, 
            linkId: linkId, 
            logSettings: logSettings
        )
        return try await self.acceptLink(input, logger: logger)
    }

    /// Creates an inbound external link.
    @Sendable
    @inlinable
    public func createInboundExternalLink(_ input: CreateInboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInboundExternalLinkResponse {
        try await self.client.execute(
            operation: "CreateInboundExternalLink", 
            path: "/responder-gateway/{gatewayId}/inbound-external-link", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an inbound external link.
    ///
    /// Parameters:
    ///   - attributes: Attributes of the link.
    ///   - clientToken: The unique client token.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logSettings: 
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createInboundExternalLink(
        attributes: LinkAttributes? = nil,
        clientToken: String = CreateInboundExternalLinkRequest.idempotencyToken(),
        gatewayId: String,
        logSettings: LinkLogSettings,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInboundExternalLinkResponse {
        let input = CreateInboundExternalLinkRequest(
            attributes: attributes, 
            clientToken: clientToken, 
            gatewayId: gatewayId, 
            logSettings: logSettings, 
            tags: tags
        )
        return try await self.createInboundExternalLink(input, logger: logger)
    }

    /// Creates a new link between gateways. Establishes a connection that allows gateways to communicate and exchange bid requests and responses.
    @Sendable
    @inlinable
    public func createLink(_ input: CreateLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLinkResponse {
        try await self.client.execute(
            operation: "CreateLink", 
            path: "/gateway/{gatewayId}/create-link", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new link between gateways. Establishes a connection that allows gateways to communicate and exchange bid requests and responses.
    ///
    /// Parameters:
    ///   - attributes: Attributes of the link.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - httpResponderAllowed: Boolean to specify if an HTTP responder is allowed.
    ///   - logSettings: Settings for the application logs.
    ///   - peerGatewayId: The unique identifier of the peer gateway.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLink(
        attributes: LinkAttributes? = nil,
        gatewayId: String,
        httpResponderAllowed: Bool? = nil,
        logSettings: LinkLogSettings,
        peerGatewayId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLinkResponse {
        let input = CreateLinkRequest(
            attributes: attributes, 
            gatewayId: gatewayId, 
            httpResponderAllowed: httpResponderAllowed, 
            logSettings: logSettings, 
            peerGatewayId: peerGatewayId, 
            tags: tags
        )
        return try await self.createLink(input, logger: logger)
    }

    /// Creates an outbound external link.
    @Sendable
    @inlinable
    public func createOutboundExternalLink(_ input: CreateOutboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateOutboundExternalLinkResponse {
        try await self.client.execute(
            operation: "CreateOutboundExternalLink", 
            path: "/requester-gateway/{gatewayId}/outbound-external-link", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an outbound external link.
    ///
    /// Parameters:
    ///   - attributes: 
    ///   - clientToken: The unique client token.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logSettings: 
    ///   - publicEndpoint: The public endpoint of the link.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createOutboundExternalLink(
        attributes: LinkAttributes? = nil,
        clientToken: String = CreateOutboundExternalLinkRequest.idempotencyToken(),
        gatewayId: String,
        logSettings: LinkLogSettings,
        publicEndpoint: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateOutboundExternalLinkResponse {
        let input = CreateOutboundExternalLinkRequest(
            attributes: attributes, 
            clientToken: clientToken, 
            gatewayId: gatewayId, 
            logSettings: logSettings, 
            publicEndpoint: publicEndpoint, 
            tags: tags
        )
        return try await self.createOutboundExternalLink(input, logger: logger)
    }

    /// Creates a requester gateway.
    @Sendable
    @inlinable
    public func createRequesterGateway(_ input: CreateRequesterGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRequesterGatewayResponse {
        try await self.client.execute(
            operation: "CreateRequesterGateway", 
            path: "/requester-gateway", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a requester gateway.
    ///
    /// Parameters:
    ///   - clientToken: The unique client token.
    ///   - description: An optional description for the requester gateway.
    ///   - securityGroupIds: The unique identifiers of the security groups.
    ///   - subnetIds: The unique identifiers of the subnets.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - vpcId: The unique identifier of the Virtual Private Cloud (VPC).
    ///   - logger: Logger use during operation
    @inlinable
    public func createRequesterGateway(
        clientToken: String = CreateRequesterGatewayRequest.idempotencyToken(),
        description: String? = nil,
        securityGroupIds: [String],
        subnetIds: [String],
        tags: [String: String]? = nil,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRequesterGatewayResponse {
        let input = CreateRequesterGatewayRequest(
            clientToken: clientToken, 
            description: description, 
            securityGroupIds: securityGroupIds, 
            subnetIds: subnetIds, 
            tags: tags, 
            vpcId: vpcId
        )
        return try await self.createRequesterGateway(input, logger: logger)
    }

    /// Creates a responder gateway.  A domain name or managed endpoint is required.
    @Sendable
    @inlinable
    public func createResponderGateway(_ input: CreateResponderGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResponderGatewayResponse {
        try await self.client.execute(
            operation: "CreateResponderGateway", 
            path: "/responder-gateway", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a responder gateway.  A domain name or managed endpoint is required.
    ///
    /// Parameters:
    ///   - clientToken: The unique client token.
    ///   - description: An optional description for the responder gateway.
    ///   - domainName: The domain name for the responder gateway.
    ///   - managedEndpointConfiguration: The configuration for the managed endpoint.
    ///   - port: The networking port to use.
    ///   - protocol: The networking protocol to use.
    ///   - securityGroupIds: The unique identifiers of the security groups.
    ///   - subnetIds: The unique identifiers of the subnets.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - trustStoreConfiguration: The configuration of the trust store.
    ///   - vpcId: The unique identifier of the Virtual Private Cloud (VPC).
    ///   - logger: Logger use during operation
    @inlinable
    public func createResponderGateway(
        clientToken: String = CreateResponderGatewayRequest.idempotencyToken(),
        description: String? = nil,
        domainName: String? = nil,
        managedEndpointConfiguration: ManagedEndpointConfiguration? = nil,
        port: Int,
        protocol: `Protocol`,
        securityGroupIds: [String],
        subnetIds: [String],
        tags: [String: String]? = nil,
        trustStoreConfiguration: TrustStoreConfiguration? = nil,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResponderGatewayResponse {
        let input = CreateResponderGatewayRequest(
            clientToken: clientToken, 
            description: description, 
            domainName: domainName, 
            managedEndpointConfiguration: managedEndpointConfiguration, 
            port: port, 
            protocol: `protocol`, 
            securityGroupIds: securityGroupIds, 
            subnetIds: subnetIds, 
            tags: tags, 
            trustStoreConfiguration: trustStoreConfiguration, 
            vpcId: vpcId
        )
        return try await self.createResponderGateway(input, logger: logger)
    }

    /// Deletes an inbound external link.
    @Sendable
    @inlinable
    public func deleteInboundExternalLink(_ input: DeleteInboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInboundExternalLinkResponse {
        try await self.client.execute(
            operation: "DeleteInboundExternalLink", 
            path: "/responder-gateway/{gatewayId}/inbound-external-link/{linkId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an inbound external link.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInboundExternalLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteInboundExternalLinkResponse {
        let input = DeleteInboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.deleteInboundExternalLink(input, logger: logger)
    }

    /// Deletes a link between gateways. Permanently removes the connection between gateways. This action cannot be undone.
    @Sendable
    @inlinable
    public func deleteLink(_ input: DeleteLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLinkResponse {
        try await self.client.execute(
            operation: "DeleteLink", 
            path: "/gateway/{gatewayId}/link/{linkId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a link between gateways. Permanently removes the connection between gateways. This action cannot be undone.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLinkResponse {
        let input = DeleteLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.deleteLink(input, logger: logger)
    }

    /// Deletes an outbound external link.
    @Sendable
    @inlinable
    public func deleteOutboundExternalLink(_ input: DeleteOutboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteOutboundExternalLinkResponse {
        try await self.client.execute(
            operation: "DeleteOutboundExternalLink", 
            path: "/requester-gateway/{gatewayId}/outbound-external-link/{linkId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an outbound external link.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteOutboundExternalLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteOutboundExternalLinkResponse {
        let input = DeleteOutboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.deleteOutboundExternalLink(input, logger: logger)
    }

    /// Deletes a requester gateway.
    @Sendable
    @inlinable
    public func deleteRequesterGateway(_ input: DeleteRequesterGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRequesterGatewayResponse {
        try await self.client.execute(
            operation: "DeleteRequesterGateway", 
            path: "/requester-gateway/{gatewayId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a requester gateway.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRequesterGateway(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRequesterGatewayResponse {
        let input = DeleteRequesterGatewayRequest(
            gatewayId: gatewayId
        )
        return try await self.deleteRequesterGateway(input, logger: logger)
    }

    /// Deletes a responder gateway.
    @Sendable
    @inlinable
    public func deleteResponderGateway(_ input: DeleteResponderGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResponderGatewayResponse {
        try await self.client.execute(
            operation: "DeleteResponderGateway", 
            path: "/responder-gateway/{gatewayId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a responder gateway.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResponderGateway(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResponderGatewayResponse {
        let input = DeleteResponderGatewayRequest(
            gatewayId: gatewayId
        )
        return try await self.deleteResponderGateway(input, logger: logger)
    }

    /// Retrieves information about an inbound external link.
    @Sendable
    @inlinable
    public func getInboundExternalLink(_ input: GetInboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetInboundExternalLinkResponse {
        try await self.client.execute(
            operation: "GetInboundExternalLink", 
            path: "/responder-gateway/{gatewayId}/inbound-external-link/{linkId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an inbound external link.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func getInboundExternalLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetInboundExternalLinkResponse {
        let input = GetInboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.getInboundExternalLink(input, logger: logger)
    }

    /// Retrieves information about a link between gateways. Returns detailed information about the link configuration, status, and associated gateways.
    @Sendable
    @inlinable
    public func getLink(_ input: GetLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLinkResponse {
        try await self.client.execute(
            operation: "GetLink", 
            path: "/gateway/{gatewayId}/link/{linkId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a link between gateways. Returns detailed information about the link configuration, status, and associated gateways.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLinkResponse {
        let input = GetLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.getLink(input, logger: logger)
    }

    /// Retrieves information about an outbound external link.
    @Sendable
    @inlinable
    public func getOutboundExternalLink(_ input: GetOutboundExternalLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetOutboundExternalLinkResponse {
        try await self.client.execute(
            operation: "GetOutboundExternalLink", 
            path: "/requester-gateway/{gatewayId}/outbound-external-link/{linkId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an outbound external link.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func getOutboundExternalLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetOutboundExternalLinkResponse {
        let input = GetOutboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.getOutboundExternalLink(input, logger: logger)
    }

    /// Retrieves information about a requester gateway.
    @Sendable
    @inlinable
    public func getRequesterGateway(_ input: GetRequesterGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRequesterGatewayResponse {
        try await self.client.execute(
            operation: "GetRequesterGateway", 
            path: "/requester-gateway/{gatewayId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a requester gateway.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRequesterGateway(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRequesterGatewayResponse {
        let input = GetRequesterGatewayRequest(
            gatewayId: gatewayId
        )
        return try await self.getRequesterGateway(input, logger: logger)
    }

    /// Retrieves information about a responder gateway.
    @Sendable
    @inlinable
    public func getResponderGateway(_ input: GetResponderGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResponderGatewayResponse {
        try await self.client.execute(
            operation: "GetResponderGateway", 
            path: "/responder-gateway/{gatewayId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a responder gateway.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResponderGateway(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResponderGatewayResponse {
        let input = GetResponderGatewayRequest(
            gatewayId: gatewayId
        )
        return try await self.getResponderGateway(input, logger: logger)
    }

    /// Lists links associated with gateways. Returns a list of all links for the specified gateways, including their status and configuration details.
    @Sendable
    @inlinable
    public func listLinks(_ input: ListLinksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLinksResponse {
        try await self.client.execute(
            operation: "ListLinks", 
            path: "/gateway/{gatewayId}/links/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists links associated with gateways. Returns a list of all links for the specified gateways, including their status and configuration details.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLinks(
        gatewayId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLinksResponse {
        let input = ListLinksRequest(
            gatewayId: gatewayId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLinks(input, logger: logger)
    }

    /// Lists requester gateways.
    @Sendable
    @inlinable
    public func listRequesterGateways(_ input: ListRequesterGatewaysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRequesterGatewaysResponse {
        try await self.client.execute(
            operation: "ListRequesterGateways", 
            path: "/requester-gateways", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists requester gateways.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRequesterGateways(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRequesterGatewaysResponse {
        let input = ListRequesterGatewaysRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRequesterGateways(input, logger: logger)
    }

    /// Lists reponder gateways.
    @Sendable
    @inlinable
    public func listResponderGateways(_ input: ListResponderGatewaysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResponderGatewaysResponse {
        try await self.client.execute(
            operation: "ListResponderGateways", 
            path: "/responder-gateways", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists reponder gateways.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listResponderGateways(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResponderGatewaysResponse {
        let input = ListResponderGatewaysRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResponderGateways(input, logger: logger)
    }

    /// Lists tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Rejects a link request between gateways. When a requester gateway requests to link with a responder gateway, the responder can use this operation to decline the link request.
    @Sendable
    @inlinable
    public func rejectLink(_ input: RejectLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RejectLinkResponse {
        try await self.client.execute(
            operation: "RejectLink", 
            path: "/gateway/{gatewayId}/link/{linkId}/reject", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Rejects a link request between gateways. When a requester gateway requests to link with a responder gateway, the responder can use this operation to decline the link request.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger use during operation
    @inlinable
    public func rejectLink(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RejectLinkResponse {
        let input = RejectLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        return try await self.rejectLink(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to tag.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag or tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag or tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to untag.
    ///   - tagKeys: The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of a link between gateways. Allows you to modify settings and parameters for an existing link.
    @Sendable
    @inlinable
    public func updateLink(_ input: UpdateLinkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLinkResponse {
        try await self.client.execute(
            operation: "UpdateLink", 
            path: "/gateway/{gatewayId}/link/{linkId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a link between gateways. Allows you to modify settings and parameters for an existing link.
    ///
    /// Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logSettings: Settings for the application logs.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLink(
        gatewayId: String,
        linkId: String,
        logSettings: LinkLogSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLinkResponse {
        let input = UpdateLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId, 
            logSettings: logSettings
        )
        return try await self.updateLink(input, logger: logger)
    }

    /// Updates a link module flow.
    @Sendable
    @inlinable
    public func updateLinkModuleFlow(_ input: UpdateLinkModuleFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLinkModuleFlowResponse {
        try await self.client.execute(
            operation: "UpdateLinkModuleFlow", 
            path: "/gateway/{gatewayId}/link/{linkId}/module-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a link module flow.
    ///
    /// Parameters:
    ///   - clientToken: The unique client token.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - modules: The configuration of a module.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLinkModuleFlow(
        clientToken: String = UpdateLinkModuleFlowRequest.idempotencyToken(),
        gatewayId: String,
        linkId: String,
        modules: [ModuleConfiguration],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLinkModuleFlowResponse {
        let input = UpdateLinkModuleFlowRequest(
            clientToken: clientToken, 
            gatewayId: gatewayId, 
            linkId: linkId, 
            modules: modules
        )
        return try await self.updateLinkModuleFlow(input, logger: logger)
    }

    /// Updates a requester gateway.
    @Sendable
    @inlinable
    public func updateRequesterGateway(_ input: UpdateRequesterGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRequesterGatewayResponse {
        try await self.client.execute(
            operation: "UpdateRequesterGateway", 
            path: "/requester-gateway/{gatewayId}/update", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a requester gateway.
    ///
    /// Parameters:
    ///   - clientToken: The unique client token.
    ///   - description: An optional description for the requester gateway.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRequesterGateway(
        clientToken: String = UpdateRequesterGatewayRequest.idempotencyToken(),
        description: String? = nil,
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRequesterGatewayResponse {
        let input = UpdateRequesterGatewayRequest(
            clientToken: clientToken, 
            description: description, 
            gatewayId: gatewayId
        )
        return try await self.updateRequesterGateway(input, logger: logger)
    }

    /// Updates a responder gateway.
    @Sendable
    @inlinable
    public func updateResponderGateway(_ input: UpdateResponderGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResponderGatewayResponse {
        try await self.client.execute(
            operation: "UpdateResponderGateway", 
            path: "/responder-gateway/{gatewayId}/update", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a responder gateway.
    ///
    /// Parameters:
    ///   - clientToken: The unique client token.
    ///   - description: An optional description for the responder gateway.
    ///   - domainName: The domain name for the responder gateway.
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - managedEndpointConfiguration: The configuration for the managed endpoint.
    ///   - port: The networking port to use.
    ///   - protocol: The networking protocol to use.
    ///   - trustStoreConfiguration: The configuration of the trust store.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResponderGateway(
        clientToken: String = UpdateResponderGatewayRequest.idempotencyToken(),
        description: String? = nil,
        domainName: String? = nil,
        gatewayId: String,
        managedEndpointConfiguration: ManagedEndpointConfiguration? = nil,
        port: Int,
        protocol: `Protocol`,
        trustStoreConfiguration: TrustStoreConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResponderGatewayResponse {
        let input = UpdateResponderGatewayRequest(
            clientToken: clientToken, 
            description: description, 
            domainName: domainName, 
            gatewayId: gatewayId, 
            managedEndpointConfiguration: managedEndpointConfiguration, 
            port: port, 
            protocol: `protocol`, 
            trustStoreConfiguration: trustStoreConfiguration
        )
        return try await self.updateResponderGateway(input, logger: logger)
    }
}

extension RTBFabric {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: RTBFabric, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RTBFabric {
    /// Return PaginatorSequence for operation ``listLinks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLinksPaginator(
        _ input: ListLinksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLinksRequest, ListLinksResponse> {
        return .init(
            input: input,
            command: self.listLinks,
            inputKey: \ListLinksRequest.nextToken,
            outputKey: \ListLinksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLinks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLinksPaginator(
        gatewayId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLinksRequest, ListLinksResponse> {
        let input = ListLinksRequest(
            gatewayId: gatewayId, 
            maxResults: maxResults
        )
        return self.listLinksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRequesterGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRequesterGatewaysPaginator(
        _ input: ListRequesterGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRequesterGatewaysRequest, ListRequesterGatewaysResponse> {
        return .init(
            input: input,
            command: self.listRequesterGateways,
            inputKey: \ListRequesterGatewaysRequest.nextToken,
            outputKey: \ListRequesterGatewaysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRequesterGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRequesterGatewaysPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRequesterGatewaysRequest, ListRequesterGatewaysResponse> {
        let input = ListRequesterGatewaysRequest(
            maxResults: maxResults
        )
        return self.listRequesterGatewaysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResponderGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResponderGatewaysPaginator(
        _ input: ListResponderGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResponderGatewaysRequest, ListResponderGatewaysResponse> {
        return .init(
            input: input,
            command: self.listResponderGateways,
            inputKey: \ListResponderGatewaysRequest.nextToken,
            outputKey: \ListResponderGatewaysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResponderGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResponderGatewaysPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResponderGatewaysRequest, ListResponderGatewaysResponse> {
        let input = ListResponderGatewaysRequest(
            maxResults: maxResults
        )
        return self.listResponderGatewaysPaginator(input, logger: logger)
    }
}

extension RTBFabric.ListLinksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> RTBFabric.ListLinksRequest {
        return .init(
            gatewayId: self.gatewayId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension RTBFabric.ListRequesterGatewaysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> RTBFabric.ListRequesterGatewaysRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension RTBFabric.ListResponderGatewaysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> RTBFabric.ListResponderGatewaysRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RTBFabric {
    /// Waiter for operation ``getInboundExternalLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInboundExternalLinkActive(
        _ input: GetInboundExternalLinkRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetInboundExternalLinkRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "REJECTED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ISOLATED")),
            ],
            minDelayTime: .seconds(30),
            command: self.getInboundExternalLink
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getInboundExternalLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInboundExternalLinkActive(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetInboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        try await self.waitUntilInboundExternalLinkActive(input, logger: logger)
    }

    /// Waiter for operation ``getLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLinkAccepted(
        _ input: GetLinkRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLinkRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACCEPTED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "REJECTED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
            ],
            minDelayTime: .seconds(30),
            command: self.getLink
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLinkAccepted(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        try await self.waitUntilLinkAccepted(input, logger: logger)
    }

    /// Waiter for operation ``getLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLinkActive(
        _ input: GetLinkRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLinkRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "REJECTED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
            ],
            minDelayTime: .seconds(30),
            command: self.getLink
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLinkActive(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        try await self.waitUntilLinkActive(input, logger: logger)
    }

    /// Waiter for operation ``getOutboundExternalLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilOutboundExternalLinkActive(
        _ input: GetOutboundExternalLinkRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetOutboundExternalLinkRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "REJECTED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ISOLATED")),
            ],
            minDelayTime: .seconds(30),
            command: self.getOutboundExternalLink
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getOutboundExternalLink(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - linkId: The unique identifier of the link.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilOutboundExternalLinkActive(
        gatewayId: String,
        linkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetOutboundExternalLinkRequest(
            gatewayId: gatewayId, 
            linkId: linkId
        )
        try await self.waitUntilOutboundExternalLinkActive(input, logger: logger)
    }

    /// Waiter for operation ``getRequesterGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRequesterGatewayActive(
        _ input: GetRequesterGatewayRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRequesterGatewayRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ERROR")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(120),
            command: self.getRequesterGateway
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRequesterGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRequesterGatewayActive(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRequesterGatewayRequest(
            gatewayId: gatewayId
        )
        try await self.waitUntilRequesterGatewayActive(input, logger: logger)
    }

    /// Waiter for operation ``getRequesterGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRequesterGatewayDeleted(
        _ input: GetRequesterGatewayRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRequesterGatewayRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ERROR")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(120),
            command: self.getRequesterGateway
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRequesterGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRequesterGatewayDeleted(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRequesterGatewayRequest(
            gatewayId: gatewayId
        )
        try await self.waitUntilRequesterGatewayDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getResponderGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilResponderGatewayActive(
        _ input: GetResponderGatewayRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetResponderGatewayRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ERROR")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(120),
            command: self.getResponderGateway
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getResponderGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilResponderGatewayActive(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetResponderGatewayRequest(
            gatewayId: gatewayId
        )
        try await self.waitUntilResponderGatewayActive(input, logger: logger)
    }

    /// Waiter for operation ``getResponderGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilResponderGatewayDeleted(
        _ input: GetResponderGatewayRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetResponderGatewayRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ERROR")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(120),
            command: self.getResponderGateway
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getResponderGateway(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayId: The unique identifier of the gateway.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilResponderGatewayDeleted(
        gatewayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetResponderGatewayRequest(
            gatewayId: gatewayId
        )
        try await self.waitUntilResponderGatewayDeleted(input, logger: logger)
    }
}
