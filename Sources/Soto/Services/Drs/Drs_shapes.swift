//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Drs {
    // MARK: Enums

    public enum DataReplicationErrorString: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentNotSeen = "AGENT_NOT_SEEN"
        case failedToAttachStagingDisks = "FAILED_TO_ATTACH_STAGING_DISKS"
        case failedToAuthenticateWithService = "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case failedToBootReplicationServer = "FAILED_TO_BOOT_REPLICATION_SERVER"
        case failedToConnectAgentToReplicationServer = "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case failedToCreateSecurityGroup = "FAILED_TO_CREATE_SECURITY_GROUP"
        case failedToCreateStagingDisks = "FAILED_TO_CREATE_STAGING_DISKS"
        case failedToDownloadReplicationSoftware = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case failedToLaunchReplicationServer = "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case failedToPairReplicationServerWithAgent = "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case failedToStartDataTransfer = "FAILED_TO_START_DATA_TRANSFER"
        case notConverging = "NOT_CONVERGING"
        case snapshotsFailure = "SNAPSHOTS_FAILURE"
        case unstableNetwork = "UNSTABLE_NETWORK"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachStagingDisks = "ATTACH_STAGING_DISKS"
        case authenticateWithService = "AUTHENTICATE_WITH_SERVICE"
        case bootReplicationServer = "BOOT_REPLICATION_SERVER"
        case connectAgentToReplicationServer = "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case createSecurityGroup = "CREATE_SECURITY_GROUP"
        case createStagingDisks = "CREATE_STAGING_DISKS"
        case downloadReplicationSoftware = "DOWNLOAD_REPLICATION_SOFTWARE"
        case launchReplicationServer = "LAUNCH_REPLICATION_SERVER"
        case pairReplicationServerWithAgent = "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case startDataTransfer = "START_DATA_TRANSFER"
        case wait = "WAIT"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case skipped = "SKIPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backlog = "BACKLOG"
        case continuous = "CONTINUOUS"
        case creatingSnapshot = "CREATING_SNAPSHOT"
        case disconnected = "DISCONNECTED"
        case initialSync = "INITIAL_SYNC"
        case initiating = "INITIATING"
        case paused = "PAUSED"
        case rescan = "RESCAN"
        case stalled = "STALLED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum EC2InstanceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notFound = "NOT_FOUND"
        case pending = "PENDING"
        case running = "RUNNING"
        case shuttingDown = "SHUTTING-DOWN"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum ExtensionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case extended = "EXTENDED"
        case extensionError = "EXTENSION_ERROR"
        case notExtended = "NOT_EXTENDED"
        public var description: String { return self.rawValue }
    }

    public enum FailbackLaunchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case drill = "DRILL"
        case recovery = "RECOVERY"
        public var description: String { return self.rawValue }
    }

    public enum FailbackReplicationError: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentNotSeen = "AGENT_NOT_SEEN"
        case failbackClientNotSeen = "FAILBACK_CLIENT_NOT_SEEN"
        case failedGettingReplicationState = "FAILED_GETTING_REPLICATION_STATE"
        case failedToAttachStagingDisks = "FAILED_TO_ATTACH_STAGING_DISKS"
        case failedToAuthenticateWithService = "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case failedToBootReplicationServer = "FAILED_TO_BOOT_REPLICATION_SERVER"
        case failedToConfigureReplicationSoftware = "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"
        case failedToConnectAgentToReplicationServer = "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case failedToCreateSecurityGroup = "FAILED_TO_CREATE_SECURITY_GROUP"
        case failedToCreateStagingDisks = "FAILED_TO_CREATE_STAGING_DISKS"
        case failedToDownloadReplicationSoftware = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case failedToDownloadReplicationSoftwareToFailbackClient = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
        case failedToEstablishAgentReplicatorSoftwareCommunication = "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
        case failedToEstablishRecoveryInstanceCommunication = "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
        case failedToLaunchReplicationServer = "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case failedToPairAgentWithReplicationSoftware = "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
        case failedToPairReplicationServerWithAgent = "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case failedToStartDataTransfer = "FAILED_TO_START_DATA_TRANSFER"
        case notConverging = "NOT_CONVERGING"
        case snapshotsFailure = "SNAPSHOTS_FAILURE"
        case unstableNetwork = "UNSTABLE_NETWORK"
        public var description: String { return self.rawValue }
    }

    public enum FailbackState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failbackCompleted = "FAILBACK_COMPLETED"
        case failbackError = "FAILBACK_ERROR"
        case failbackInProgress = "FAILBACK_IN_PROGRESS"
        case failbackLaunchStateNotAvailable = "FAILBACK_LAUNCH_STATE_NOT_AVAILABLE"
        case failbackNotReadyForLaunch = "FAILBACK_NOT_READY_FOR_LAUNCH"
        case failbackNotStarted = "FAILBACK_NOT_STARTED"
        case failbackReadyForLaunch = "FAILBACK_READY_FOR_LAUNCH"
        public var description: String { return self.rawValue }
    }

    public enum InitiatedBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associateNetworkRecovery = "ASSOCIATE_NETWORK_RECOVERY"
        case createNetworkRecovery = "CREATE_NETWORK_RECOVERY"
        case diagnostic = "DIAGNOSTIC"
        case failback = "FAILBACK"
        case startDrill = "START_DRILL"
        case startRecovery = "START_RECOVERY"
        case targetAccount = "TARGET_ACCOUNT"
        case terminateRecoveryInstances = "TERMINATE_RECOVERY_INSTANCES"
        case updateNetworkRecovery = "UPDATE_NETWORK_RECOVERY"
        public var description: String { return self.rawValue }
    }

    public enum JobLogEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cleanupEnd = "CLEANUP_END"
        case cleanupFail = "CLEANUP_FAIL"
        case cleanupStart = "CLEANUP_START"
        case conversionEnd = "CONVERSION_END"
        case conversionFail = "CONVERSION_FAIL"
        case conversionStart = "CONVERSION_START"
        case deployNetworkConfigurationEnd = "DEPLOY_NETWORK_CONFIGURATION_END"
        case deployNetworkConfigurationFailed = "DEPLOY_NETWORK_CONFIGURATION_FAILED"
        case deployNetworkConfigurationStart = "DEPLOY_NETWORK_CONFIGURATION_START"
        case jobCancel = "JOB_CANCEL"
        case jobEnd = "JOB_END"
        case jobStart = "JOB_START"
        case launchFailed = "LAUNCH_FAILED"
        case launchStart = "LAUNCH_START"
        case networkRecoveryFail = "NETWORK_RECOVERY_FAIL"
        case serverSkipped = "SERVER_SKIPPED"
        case snapshotEnd = "SNAPSHOT_END"
        case snapshotFail = "SNAPSHOT_FAIL"
        case snapshotStart = "SNAPSHOT_START"
        case updateLaunchTemplateEnd = "UPDATE_LAUNCH_TEMPLATE_END"
        case updateLaunchTemplateFailed = "UPDATE_LAUNCH_TEMPLATE_FAILED"
        case updateLaunchTemplateStart = "UPDATE_LAUNCH_TEMPLATE_START"
        case updateNetworkConfigurationEnd = "UPDATE_NETWORK_CONFIGURATION_END"
        case updateNetworkConfigurationFailed = "UPDATE_NETWORK_CONFIGURATION_FAILED"
        case updateNetworkConfigurationStart = "UPDATE_NETWORK_CONFIGURATION_START"
        case usingPreviousSnapshot = "USING_PREVIOUS_SNAPSHOT"
        case usingPreviousSnapshotFailed = "USING_PREVIOUS_SNAPSHOT_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case pending = "PENDING"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createConvertedSnapshot = "CREATE_CONVERTED_SNAPSHOT"
        case launch = "LAUNCH"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum LastLaunchResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case notStarted = "NOT_STARTED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum LastLaunchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case drill = "DRILL"
        case recovery = "RECOVERY"
        public var description: String { return self.rawValue }
    }

    public enum LaunchActionCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configuration = "CONFIGURATION"
        case monitoring = "MONITORING"
        case other = "OTHER"
        case security = "SECURITY"
        case validation = "VALIDATION"
        public var description: String { return self.rawValue }
    }

    public enum LaunchActionParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dynamic = "DYNAMIC"
        case ssmStore = "SSM_STORE"
        public var description: String { return self.rawValue }
    }

    public enum LaunchActionRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssmAutomation = "SSM_AUTOMATION"
        case ssmCommand = "SSM_COMMAND"
        public var description: String { return self.rawValue }
    }

    public enum LaunchDisposition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case launched = "LAUNCHED"
        case pending = "PENDING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum OriginEnvironment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case onPremises = "ON_PREMISES"
        public var description: String { return self.rawValue }
    }

    public enum PITPolicyRuleUnits: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        public var description: String { return self.rawValue }
    }

    public enum ProductCodeMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryInstanceDataReplicationInitiationStepName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachStagingDisks = "ATTACH_STAGING_DISKS"
        case authenticateWithService = "AUTHENTICATE_WITH_SERVICE"
        case bootReplicationServer = "BOOT_REPLICATION_SERVER"
        case completeVolumeMapping = "COMPLETE_VOLUME_MAPPING"
        case configureReplicationSoftware = "CONFIGURE_REPLICATION_SOFTWARE"
        case connectAgentToReplicationServer = "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case createSecurityGroup = "CREATE_SECURITY_GROUP"
        case createStagingDisks = "CREATE_STAGING_DISKS"
        case downloadReplicationSoftware = "DOWNLOAD_REPLICATION_SOFTWARE"
        case downloadReplicationSoftwareToFailbackClient = "DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
        case establishAgentReplicatorSoftwareCommunication = "ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
        case establishRecoveryInstanceCommunication = "ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
        case launchReplicationServer = "LAUNCH_REPLICATION_SERVER"
        case linkFailbackClientWithRecoveryInstance = "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE"
        case pairAgentWithReplicationSoftware = "PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
        case pairReplicationServerWithAgent = "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case startDataTransfer = "START_DATA_TRANSFER"
        case wait = "WAIT"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryInstanceDataReplicationInitiationStepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case skipped = "SKIPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryInstanceDataReplicationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backlog = "BACKLOG"
        case continuous = "CONTINUOUS"
        case creatingSnapshot = "CREATING_SNAPSHOT"
        case disconnected = "DISCONNECTED"
        case initialSync = "INITIAL_SYNC"
        case initiating = "INITIATING"
        case notStarted = "NOT_STARTED"
        case paused = "PAUSED"
        case replicationStateNotAvailable = "REPLICATION_STATE_NOT_AVAILABLE"
        case rescan = "RESCAN"
        case stalled = "STALLED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associateFail = "ASSOCIATE_FAIL"
        case associateSuccess = "ASSOCIATE_SUCCESS"
        case fail = "FAIL"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case partialSuccess = "PARTIAL_SUCCESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum RecoverySnapshotsOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDataPlaneRouting: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case privateIp = "PRIVATE_IP"
        case publicIp = "PUBLIC_IP"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDefaultLargeStagingDiskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case gp2 = "GP2"
        case gp3 = "GP3"
        case st1 = "ST1"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationEbsEncryption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case `default` = "DEFAULT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case gp2 = "GP2"
        case gp3 = "GP3"
        case io1 = "IO1"
        case sc1 = "SC1"
        case st1 = "ST1"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failback = "FAILBACK"
        case failover = "FAILOVER"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case protected = "PROTECTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum TargetInstanceTypeRightSizingMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case inAws = "IN_AWS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum VolumeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case containsMarketplaceProductCodes = "CONTAINS_MARKETPLACE_PRODUCT_CODES"
        case missingVolumeAttributes = "MISSING_VOLUME_ATTRIBUTES"
        case missingVolumeAttributesAndPrecheckUnavailable = "MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"
        case regular = "REGULAR"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Account: AWSDecodableShape {
        /// Account ID of AWS account.
        public let accountID: String?

        public init(accountID: String? = nil) {
            self.accountID = accountID
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
        }
    }

    public struct AssociateSourceNetworkStackRequest: AWSEncodableShape {
        /// CloudFormation template to associate with a Source Network.
        public let cfnStackName: String
        /// The Source Network ID to associate with CloudFormation template.
        public let sourceNetworkID: String

        public init(cfnStackName: String, sourceNetworkID: String) {
            self.cfnStackName = cfnStackName
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, max: 128)
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, min: 1)
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case cfnStackName = "cfnStackName"
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct AssociateSourceNetworkStackResponse: AWSDecodableShape {
        /// The Source Network association Job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct CPU: AWSDecodableShape {
        /// The number of CPU cores.
        public let cores: Int64?
        /// The model name of the CPU.
        public let modelName: String?

        public init(cores: Int64? = nil, modelName: String? = nil) {
            self.cores = cores
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case cores = "cores"
            case modelName = "modelName"
        }
    }

    public struct ConversionProperties: AWSDecodableShape {
        /// The timestamp of when the snapshot being converted was taken
        public let dataTimestamp: String?
        /// Whether the volume being converted uses UEFI or not
        public let forceUefi: Bool?
        /// The root volume name of a conversion job
        public let rootVolumeName: String?
        /// A mapping between the volumes being converted and the converted snapshot ids
        public let volumeToConversionMap: [String: [String: String]]?
        /// A mapping between the volumes being converted and the product codes associated with them
        public let volumeToProductCodes: [String: [ProductCode]]?
        /// A mapping between the volumes and their sizes
        public let volumeToVolumeSize: [String: Int64]?

        public init(dataTimestamp: String? = nil, forceUefi: Bool? = nil, rootVolumeName: String? = nil, volumeToConversionMap: [String: [String: String]]? = nil, volumeToProductCodes: [String: [ProductCode]]? = nil, volumeToVolumeSize: [String: Int64]? = nil) {
            self.dataTimestamp = dataTimestamp
            self.forceUefi = forceUefi
            self.rootVolumeName = rootVolumeName
            self.volumeToConversionMap = volumeToConversionMap
            self.volumeToProductCodes = volumeToProductCodes
            self.volumeToVolumeSize = volumeToVolumeSize
        }

        private enum CodingKeys: String, CodingKey {
            case dataTimestamp = "dataTimestamp"
            case forceUefi = "forceUefi"
            case rootVolumeName = "rootVolumeName"
            case volumeToConversionMap = "volumeToConversionMap"
            case volumeToProductCodes = "volumeToProductCodes"
            case volumeToVolumeSize = "volumeToVolumeSize"
        }
    }

    public struct CreateExtendedSourceServerRequest: AWSEncodableShape {
        /// This defines the ARN of the source server in staging Account based on which you want to create an extended source server.
        public let sourceServerArn: String
        /// A list of tags associated with the extended source server.
        public let tags: [String: String]?

        public init(sourceServerArn: String, tags: [String: String]? = nil) {
            self.sourceServerArn = sourceServerArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerArn, name: "sourceServerArn", parent: name, max: 2048)
            try self.validate(self.sourceServerArn, name: "sourceServerArn", parent: name, min: 20)
            try self.validate(self.sourceServerArn, name: "sourceServerArn", parent: name, pattern: "^arn:(?:[0-9a-zA-Z_-]+:){3}([0-9]{12,}):source-server/(s-[0-9a-zA-Z]{17})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerArn = "sourceServerArn"
            case tags = "tags"
        }
    }

    public struct CreateExtendedSourceServerResponse: AWSDecodableShape {
        /// Created extended source server.
        public let sourceServer: SourceServer?

        public init(sourceServer: SourceServer? = nil) {
            self.sourceServer = sourceServer
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServer = "sourceServer"
        }
    }

    public struct CreateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Copy private IP.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// S3 bucket ARN to export Source Network templates.
        public let exportBucketArn: String?
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        /// DRS will set the 'launch into instance ID' of any source server when performing a drill, recovery or failback to the previous region or availability zone, using the instance ID of the source instance.
        public let launchIntoSourceInstance: Bool?
        /// Licensing.
        public let licensing: Licensing?
        /// Whether we want to activate post-launch actions.
        public let postLaunchEnabled: Bool?
        /// Request to associate tags during creation of a Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, exportBucketArn: String? = nil, launchDisposition: LaunchDisposition? = nil, launchIntoSourceInstance: Bool? = nil, licensing: Licensing? = nil, postLaunchEnabled: Bool? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.exportBucketArn = exportBucketArn
            self.launchDisposition = launchDisposition
            self.launchIntoSourceInstance = launchIntoSourceInstance
            self.licensing = licensing
            self.postLaunchEnabled = postLaunchEnabled
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, max: 2048)
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, min: 20)
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case exportBucketArn = "exportBucketArn"
            case launchDisposition = "launchDisposition"
            case launchIntoSourceInstance = "launchIntoSourceInstance"
            case licensing = "licensing"
            case postLaunchEnabled = "postLaunchEnabled"
            case tags = "tags"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct CreateLaunchConfigurationTemplateResponse: AWSDecodableShape {
        /// Created Launch Configuration Template.
        public let launchConfigurationTemplate: LaunchConfigurationTemplate?

        public init(launchConfigurationTemplate: LaunchConfigurationTemplate? = nil) {
            self.launchConfigurationTemplate = launchConfigurationTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplate = "launchConfigurationTemplate"
        }
    }

    public struct CreateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
        public let associateDefaultSecurityGroup: Bool
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public let autoReplicateNewDisks: Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public let bandwidthThrottling: Int64
        /// Whether to create a Public IP for the Recovery Instance by default.
        public let createPublicIP: Bool
        /// The data plane routing mechanism that will be used for replication.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting
        /// The Staging Disk EBS volume type to be used during replication.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType
        /// The type of EBS encryption to be used during replication.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption
        /// The ARN of the EBS encryption key to be used during replication.
        public let ebsEncryptionKeyArn: String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public let pitPolicy: [PITPolicyRule]
        /// The instance type to be used for the replication server.
        public let replicationServerInstanceType: String
        /// The security group IDs that will be used by the replication server.
        public let replicationServersSecurityGroupsIDs: [String]
        /// The subnet to be used by the replication staging area.
        public let stagingAreaSubnetId: String
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public let stagingAreaTags: [String: String]
        /// A set of tags to be associated with the Replication Configuration Template resource.
        public let tags: [String: String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public let useDedicatedReplicationServer: Bool

        public init(associateDefaultSecurityGroup: Bool, autoReplicateNewDisks: Bool? = nil, bandwidthThrottling: Int64 = 0, createPublicIP: Bool, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType, ebsEncryption: ReplicationConfigurationEbsEncryption, ebsEncryptionKeyArn: String? = nil, pitPolicy: [PITPolicyRule], replicationServerInstanceType: String, replicationServersSecurityGroupsIDs: [String], stagingAreaSubnetId: String, stagingAreaTags: [String: String], tags: [String: String]? = nil, useDedicatedReplicationServer: Bool) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.pitPolicy = pitPolicy
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.pitPolicy.forEach {
                try $0.validate(name: "\(name).pitPolicy[]")
            }
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, max: 10)
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, min: 1)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case autoReplicateNewDisks = "autoReplicateNewDisks"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case pitPolicy = "pitPolicy"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case tags = "tags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
        }
    }

    public struct CreateSourceNetworkRequest: AWSEncodableShape {
        /// Account containing the VPC to protect.
        public let originAccountID: String
        /// Region containing the VPC to protect.
        public let originRegion: String
        /// A set of tags to be associated with the Source Network resource.
        public let tags: [String: String]?
        /// Which VPC ID to protect.
        public let vpcID: String

        public init(originAccountID: String, originRegion: String, tags: [String: String]? = nil, vpcID: String) {
            self.originAccountID = originAccountID
            self.originRegion = originRegion
            self.tags = tags
            self.vpcID = vpcID
        }

        public func validate(name: String) throws {
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, max: 12)
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, min: 12)
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.originRegion, name: "originRegion", parent: name, max: 255)
            try self.validate(self.originRegion, name: "originRegion", parent: name, pattern: "^(us(-gov)?|ap|ca|cn|eu|sa|af|me|il)-(central|north|(north(?:east|west))|south|south(?:east|west)|east|west)-[0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.vpcID, name: "vpcID", parent: name, max: 21)
            try self.validate(self.vpcID, name: "vpcID", parent: name, min: 12)
            try self.validate(self.vpcID, name: "vpcID", parent: name, pattern: "^vpc-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case originAccountID = "originAccountID"
            case originRegion = "originRegion"
            case tags = "tags"
            case vpcID = "vpcID"
        }
    }

    public struct CreateSourceNetworkResponse: AWSDecodableShape {
        /// ID of the created Source Network.
        public let sourceNetworkID: String?

        public init(sourceNetworkID: String? = nil) {
            self.sourceNetworkID = sourceNetworkID
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct DataReplicationError: AWSDecodableShape {
        /// Error in data replication.
        public let error: DataReplicationErrorString?
        /// Error in data replication.
        public let rawError: String?

        public init(error: DataReplicationErrorString? = nil, rawError: String? = nil) {
            self.error = error
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case rawError = "rawError"
        }
    }

    public struct DataReplicationInfo: AWSDecodableShape {
        /// Error in data replication.
        public let dataReplicationError: DataReplicationError?
        /// Information about whether the data replication has been initiated.
        public let dataReplicationInitiation: DataReplicationInitiation?
        /// The state of the data replication.
        public let dataReplicationState: DataReplicationState?
        /// An estimate of when the data replication will be completed.
        public let etaDateTime: String?
        /// Data replication lag duration.
        public let lagDuration: String?
        /// The disks that should be replicated.
        public let replicatedDisks: [DataReplicationInfoReplicatedDisk]?
        /// AWS Availability zone into which data is being replicated.
        public let stagingAvailabilityZone: String?

        public init(dataReplicationError: DataReplicationError? = nil, dataReplicationInitiation: DataReplicationInitiation? = nil, dataReplicationState: DataReplicationState? = nil, etaDateTime: String? = nil, lagDuration: String? = nil, replicatedDisks: [DataReplicationInfoReplicatedDisk]? = nil, stagingAvailabilityZone: String? = nil) {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
            self.stagingAvailabilityZone = stagingAvailabilityZone
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationError = "dataReplicationError"
            case dataReplicationInitiation = "dataReplicationInitiation"
            case dataReplicationState = "dataReplicationState"
            case etaDateTime = "etaDateTime"
            case lagDuration = "lagDuration"
            case replicatedDisks = "replicatedDisks"
            case stagingAvailabilityZone = "stagingAvailabilityZone"
        }
    }

    public struct DataReplicationInfoReplicatedDisk: AWSDecodableShape {
        /// The size of the replication backlog in bytes.
        public let backloggedStorageBytes: Int64?
        /// The name of the device.
        public let deviceName: String?
        /// The amount of data replicated so far in bytes.
        public let replicatedStorageBytes: Int64?
        /// The amount of data to be rescanned in bytes.
        public let rescannedStorageBytes: Int64?
        /// The total amount of data to be replicated in bytes.
        public let totalStorageBytes: Int64?
        /// The status of the volume.
        public let volumeStatus: VolumeStatus?

        public init(backloggedStorageBytes: Int64? = nil, deviceName: String? = nil, replicatedStorageBytes: Int64? = nil, rescannedStorageBytes: Int64? = nil, totalStorageBytes: Int64? = nil, volumeStatus: VolumeStatus? = nil) {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
            self.volumeStatus = volumeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case backloggedStorageBytes = "backloggedStorageBytes"
            case deviceName = "deviceName"
            case replicatedStorageBytes = "replicatedStorageBytes"
            case rescannedStorageBytes = "rescannedStorageBytes"
            case totalStorageBytes = "totalStorageBytes"
            case volumeStatus = "volumeStatus"
        }
    }

    public struct DataReplicationInitiation: AWSDecodableShape {
        /// The date and time of the next attempt to initiate data replication.
        public let nextAttemptDateTime: String?
        /// The date and time of the current attempt to initiate data replication.
        public let startDateTime: String?
        /// The steps of the current attempt to initiate data replication.
        public let steps: [DataReplicationInitiationStep]?

        public init(nextAttemptDateTime: String? = nil, startDateTime: String? = nil, steps: [DataReplicationInitiationStep]? = nil) {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextAttemptDateTime = "nextAttemptDateTime"
            case startDateTime = "startDateTime"
            case steps = "steps"
        }
    }

    public struct DataReplicationInitiationStep: AWSDecodableShape {
        /// The name of the step.
        public let name: DataReplicationInitiationStepName?
        /// The status of the step.
        public let status: DataReplicationInitiationStepStatus?

        public init(name: DataReplicationInitiationStepName? = nil, status: DataReplicationInitiationStepStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// The ID of the Job to be deleted.
        public let jobID: String

        public init(jobID: String) {
            self.jobID = jobID
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^drsjob-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobID = "jobID"
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchActionRequest: AWSEncodableShape {
        public let actionId: String
        public let resourceId: String

        public init(actionId: String, resourceId: String) {
            self.actionId = actionId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.actionId, name: "actionId", parent: name, max: 64)
            try self.validate(self.actionId, name: "actionId", parent: name, min: 1)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(s-[0-9a-zA-Z]{17}$|lct-[0-9a-zA-Z]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
            case resourceId = "resourceId"
        }
    }

    public struct DeleteLaunchActionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// The ID of the Launch Configuration Template to be deleted.
        public let launchConfigurationTemplateID: String

        public init(launchConfigurationTemplateID: String) {
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
        }
    }

    public struct DeleteLaunchConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRecoveryInstanceRequest: AWSEncodableShape {
        /// The ID of the Recovery Instance to be deleted.
        public let recoveryInstanceID: String

        public init(recoveryInstanceID: String) {
            self.recoveryInstanceID = recoveryInstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceID = "recoveryInstanceID"
        }
    }

    public struct DeleteReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// The ID of the Replication Configuration Template to be deleted.
        public let replicationConfigurationTemplateID: String

        public init(replicationConfigurationTemplateID: String) {
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
        }
    }

    public struct DeleteReplicationConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceNetworkRequest: AWSEncodableShape {
        /// ID of the Source Network to delete.
        public let sourceNetworkID: String

        public init(sourceNetworkID: String) {
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct DeleteSourceNetworkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceServerRequest: AWSEncodableShape {
        /// The ID of the Source Server to be deleted.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct DeleteSourceServerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeJobLogItemsRequest: AWSEncodableShape {
        /// The ID of the Job for which Job log items will be retrieved.
        public let jobID: String
        /// Maximum number of Job log items to retrieve.
        public let maxResults: Int?
        /// The token of the next Job log items to retrieve.
        public let nextToken: String?

        public init(jobID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobID = jobID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^drsjob-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case jobID = "jobID"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobLogItemsResponse: AWSDecodableShape {
        /// An array of Job log items.
        public let items: [JobLog]?
        /// The token of the next Job log items to retrieve.
        public let nextToken: String?

        public init(items: [JobLog]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobsRequest: AWSEncodableShape {
        /// A set of filters by which to return Jobs.
        public let filters: DescribeJobsRequestFilters?
        /// Maximum number of Jobs to retrieve.
        public let maxResults: Int?
        /// The token of the next Job to retrieve.
        public let nextToken: String?

        public init(filters: DescribeJobsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobsRequestFilters: AWSEncodableShape {
        /// The start date in a date range query.
        public let fromDate: String?
        /// An array of Job IDs that should be returned. An empty array means all jobs.
        public let jobIDs: [String]?
        /// The end date in a date range query.
        public let toDate: String?

        public init(fromDate: String? = nil, jobIDs: [String]? = nil, toDate: String? = nil) {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDate, name: "fromDate", parent: name, max: 32)
            try self.validate(self.fromDate, name: "fromDate", parent: name, min: 19)
            try self.validate(self.fromDate, name: "fromDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
            try self.jobIDs?.forEach {
                try validate($0, name: "jobIDs[]", parent: name, max: 24)
                try validate($0, name: "jobIDs[]", parent: name, min: 24)
                try validate($0, name: "jobIDs[]", parent: name, pattern: "^drsjob-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.jobIDs, name: "jobIDs", parent: name, max: 1000)
            try self.validate(self.toDate, name: "toDate", parent: name, max: 32)
            try self.validate(self.toDate, name: "toDate", parent: name, min: 19)
            try self.validate(self.toDate, name: "toDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case fromDate = "fromDate"
            case jobIDs = "jobIDs"
            case toDate = "toDate"
        }
    }

    public struct DescribeJobsResponse: AWSDecodableShape {
        /// An array of Jobs.
        public let items: [Job]?
        /// The token of the next Job to retrieve.
        public let nextToken: String?

        public init(items: [Job]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeLaunchConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
        public let launchConfigurationTemplateIDs: [String]?
        /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
        public let maxResults: Int?
        /// The token of the next Launch Configuration Template to retrieve.
        public let nextToken: String?

        public init(launchConfigurationTemplateIDs: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.launchConfigurationTemplateIDs?.forEach {
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.launchConfigurationTemplateIDs, name: "launchConfigurationTemplateIDs", parent: name, max: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateIDs = "launchConfigurationTemplateIDs"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeLaunchConfigurationTemplatesResponse: AWSDecodableShape {
        /// List of items returned by DescribeLaunchConfigurationTemplates.
        public let items: [LaunchConfigurationTemplate]?
        /// The token of the next Launch Configuration Template to retrieve.
        public let nextToken: String?

        public init(items: [LaunchConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeRecoveryInstancesRequest: AWSEncodableShape {
        /// A set of filters by which to return Recovery Instances.
        public let filters: DescribeRecoveryInstancesRequestFilters?
        /// Maximum number of Recovery Instances to retrieve.
        public let maxResults: Int?
        /// The token of the next Recovery Instance to retrieve.
        public let nextToken: String?

        public init(filters: DescribeRecoveryInstancesRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeRecoveryInstancesRequestFilters: AWSEncodableShape {
        /// An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.
        public let recoveryInstanceIDs: [String]?
        /// An array of Source Server IDs for which associated Recovery Instances should be returned.
        public let sourceServerIDs: [String]?

        public init(recoveryInstanceIDs: [String]? = nil, sourceServerIDs: [String]? = nil) {
            self.recoveryInstanceIDs = recoveryInstanceIDs
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.recoveryInstanceIDs?.forEach {
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, max: 19)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, min: 10)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.recoveryInstanceIDs, name: "recoveryInstanceIDs", parent: name, max: 200)
            try self.sourceServerIDs?.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceIDs = "recoveryInstanceIDs"
            case sourceServerIDs = "sourceServerIDs"
        }
    }

    public struct DescribeRecoveryInstancesResponse: AWSDecodableShape {
        /// An array of Recovery Instances.
        public let items: [RecoveryInstance]?
        /// The token of the next Recovery Instance to retrieve.
        public let nextToken: String?

        public init(items: [RecoveryInstance]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeRecoverySnapshotsRequest: AWSEncodableShape {
        /// A set of filters by which to return Recovery Snapshots.
        public let filters: DescribeRecoverySnapshotsRequestFilters?
        /// Maximum number of Recovery Snapshots to retrieve.
        public let maxResults: Int?
        /// The token of the next Recovery Snapshot to retrieve.
        public let nextToken: String?
        /// The sorted ordering by which to return Recovery Snapshots.
        public let order: RecoverySnapshotsOrder?
        /// Filter Recovery Snapshots by Source Server ID.
        public let sourceServerID: String

        public init(filters: DescribeRecoverySnapshotsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, order: RecoverySnapshotsOrder? = nil, sourceServerID: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.order = order
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case order = "order"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct DescribeRecoverySnapshotsRequestFilters: AWSEncodableShape {
        /// The start date in a date range query.
        public let fromDateTime: String?
        /// The end date in a date range query.
        public let toDateTime: String?

        public init(fromDateTime: String? = nil, toDateTime: String? = nil) {
            self.fromDateTime = fromDateTime
            self.toDateTime = toDateTime
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDateTime, name: "fromDateTime", parent: name, max: 32)
            try self.validate(self.fromDateTime, name: "fromDateTime", parent: name, min: 19)
            try self.validate(self.fromDateTime, name: "fromDateTime", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
            try self.validate(self.toDateTime, name: "toDateTime", parent: name, max: 32)
            try self.validate(self.toDateTime, name: "toDateTime", parent: name, min: 19)
            try self.validate(self.toDateTime, name: "toDateTime", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case fromDateTime = "fromDateTime"
            case toDateTime = "toDateTime"
        }
    }

    public struct DescribeRecoverySnapshotsResponse: AWSDecodableShape {
        /// An array of Recovery Snapshots.
        public let items: [RecoverySnapshot]?
        /// The token of the next Recovery Snapshot to retrieve.
        public let nextToken: String?

        public init(items: [RecoverySnapshot]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeReplicationConfigurationTemplatesRequest: AWSEncodableShape {
        /// Maximum number of Replication Configuration Templates to retrieve.
        public let maxResults: Int?
        /// The token of the next Replication Configuration Template to retrieve.
        public let nextToken: String?
        /// The IDs of the Replication Configuration Templates to retrieve. An empty list means all Replication Configuration Templates.
        public let replicationConfigurationTemplateIDs: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationConfigurationTemplateIDs: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.replicationConfigurationTemplateIDs?.forEach {
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.replicationConfigurationTemplateIDs, name: "replicationConfigurationTemplateIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationConfigurationTemplateIDs = "replicationConfigurationTemplateIDs"
        }
    }

    public struct DescribeReplicationConfigurationTemplatesResponse: AWSDecodableShape {
        /// An array of Replication Configuration Templates.
        public let items: [ReplicationConfigurationTemplate]?
        /// The token of the next Replication Configuration Template to retrieve.
        public let nextToken: String?

        public init(items: [ReplicationConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceNetworksRequest: AWSEncodableShape {
        /// A set of filters by which to return Source Networks.
        public let filters: DescribeSourceNetworksRequestFilters?
        /// Maximum number of Source Networks to retrieve.
        public let maxResults: Int?
        /// The token of the next Source Networks to retrieve.
        public let nextToken: String?

        public init(filters: DescribeSourceNetworksRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceNetworksRequestFilters: AWSEncodableShape {
        /// Filter Source Networks by account ID containing the protected VPCs.
        public let originAccountID: String?
        /// Filter Source Networks by the region containing the protected VPCs.
        public let originRegion: String?
        /// An array of Source Network IDs that should be returned. An empty array means all Source Networks.
        public let sourceNetworkIDs: [String]?

        public init(originAccountID: String? = nil, originRegion: String? = nil, sourceNetworkIDs: [String]? = nil) {
            self.originAccountID = originAccountID
            self.originRegion = originRegion
            self.sourceNetworkIDs = sourceNetworkIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, max: 12)
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, min: 12)
            try self.validate(self.originAccountID, name: "originAccountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.originRegion, name: "originRegion", parent: name, max: 255)
            try self.validate(self.originRegion, name: "originRegion", parent: name, pattern: "^(us(-gov)?|ap|ca|cn|eu|sa|af|me|il)-(central|north|(north(?:east|west))|south|south(?:east|west)|east|west)-[0-9]$")
            try self.sourceNetworkIDs?.forEach {
                try validate($0, name: "sourceNetworkIDs[]", parent: name, max: 20)
                try validate($0, name: "sourceNetworkIDs[]", parent: name, min: 20)
                try validate($0, name: "sourceNetworkIDs[]", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceNetworkIDs, name: "sourceNetworkIDs", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case originAccountID = "originAccountID"
            case originRegion = "originRegion"
            case sourceNetworkIDs = "sourceNetworkIDs"
        }
    }

    public struct DescribeSourceNetworksResponse: AWSDecodableShape {
        /// An array of Source Networks.
        public let items: [SourceNetwork]?
        /// The token of the next Source Networks to retrieve.
        public let nextToken: String?

        public init(items: [SourceNetwork]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceServersRequest: AWSEncodableShape {
        /// A set of filters by which to return Source Servers.
        public let filters: DescribeSourceServersRequestFilters?
        /// Maximum number of Source Servers to retrieve.
        public let maxResults: Int?
        /// The token of the next Source Server to retrieve.
        public let nextToken: String?

        public init(filters: DescribeSourceServersRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceServersRequestFilters: AWSEncodableShape {
        /// An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.
        public let hardwareId: String?
        /// An array of Source Servers IDs that should be returned. An empty array means all Source Servers.
        public let sourceServerIDs: [String]?
        /// An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.
        public let stagingAccountIDs: [String]?

        public init(hardwareId: String? = nil, sourceServerIDs: [String]? = nil, stagingAccountIDs: [String]? = nil) {
            self.hardwareId = hardwareId
            self.sourceServerIDs = sourceServerIDs
            self.stagingAccountIDs = stagingAccountIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.hardwareId, name: "hardwareId", parent: name, max: 256)
            try self.sourceServerIDs?.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.stagingAccountIDs?.forEach {
                try validate($0, name: "stagingAccountIDs[]", parent: name, max: 12)
                try validate($0, name: "stagingAccountIDs[]", parent: name, min: 12)
                try validate($0, name: "stagingAccountIDs[]", parent: name, pattern: "[0-9]{12,}")
            }
            try self.validate(self.stagingAccountIDs, name: "stagingAccountIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case hardwareId = "hardwareId"
            case sourceServerIDs = "sourceServerIDs"
            case stagingAccountIDs = "stagingAccountIDs"
        }
    }

    public struct DescribeSourceServersResponse: AWSDecodableShape {
        /// An array of Source Servers.
        public let items: [SourceServer]?
        /// The token of the next Source Server to retrieve.
        public let nextToken: String?

        public init(items: [SourceServer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DisconnectRecoveryInstanceRequest: AWSEncodableShape {
        /// The ID of the Recovery Instance to disconnect.
        public let recoveryInstanceID: String

        public init(recoveryInstanceID: String) {
            self.recoveryInstanceID = recoveryInstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceID = "recoveryInstanceID"
        }
    }

    public struct DisconnectSourceServerRequest: AWSEncodableShape {
        /// The ID of the Source Server to disconnect.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct Disk: AWSDecodableShape {
        /// The amount of storage on the disk in bytes.
        public let bytes: Int64?
        /// The disk or device name.
        public let deviceName: String?

        public init(bytes: Int64? = nil, deviceName: String? = nil) {
            self.bytes = bytes
            self.deviceName = deviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case deviceName = "deviceName"
        }
    }

    public struct ExportSourceNetworkCfnTemplateRequest: AWSEncodableShape {
        /// The Source Network ID to export its CloudFormation template to an S3 bucket.
        public let sourceNetworkID: String

        public init(sourceNetworkID: String) {
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct ExportSourceNetworkCfnTemplateResponse: AWSDecodableShape {
        /// S3 bucket URL where the Source Network CloudFormation template was exported to.
        public let s3DestinationUrl: String?

        public init(s3DestinationUrl: String? = nil) {
            self.s3DestinationUrl = s3DestinationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case s3DestinationUrl = "s3DestinationUrl"
        }
    }

    public struct GetFailbackReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the Recovery Instance whose failback replication configuration should be returned.
        public let recoveryInstanceID: String

        public init(recoveryInstanceID: String) {
            self.recoveryInstanceID = recoveryInstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceID = "recoveryInstanceID"
        }
    }

    public struct GetFailbackReplicationConfigurationResponse: AWSDecodableShape {
        /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
        public let bandwidthThrottling: Int64?
        /// The name of the Failback Replication Configuration.
        public let name: String?
        /// The ID of the Recovery Instance.
        public let recoveryInstanceID: String
        /// Whether to use Private IP for the failback replication of the Recovery Instance.
        public let usePrivateIP: Bool?

        public init(bandwidthThrottling: Int64? = nil, name: String? = nil, recoveryInstanceID: String, usePrivateIP: Bool? = nil) {
            self.bandwidthThrottling = bandwidthThrottling
            self.name = name
            self.recoveryInstanceID = recoveryInstanceID
            self.usePrivateIP = usePrivateIP
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthThrottling = "bandwidthThrottling"
            case name = "name"
            case recoveryInstanceID = "recoveryInstanceID"
            case usePrivateIP = "usePrivateIP"
        }
    }

    public struct GetLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct GetReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the Source Serve for this Replication Configuration.r
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct IdentificationHints: AWSDecodableShape {
        /// AWS Instance ID identification hint.
        public let awsInstanceID: String?
        /// Fully Qualified Domain Name identification hint.
        public let fqdn: String?
        /// Hostname identification hint.
        public let hostname: String?
        /// vCenter VM path identification hint.
        public let vmWareUuid: String?

        public init(awsInstanceID: String? = nil, fqdn: String? = nil, hostname: String? = nil, vmWareUuid: String? = nil) {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmWareUuid = vmWareUuid
        }

        private enum CodingKeys: String, CodingKey {
            case awsInstanceID = "awsInstanceID"
            case fqdn = "fqdn"
            case hostname = "hostname"
            case vmWareUuid = "vmWareUuid"
        }
    }

    public struct InitializeServiceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct InitializeServiceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Job: AWSDecodableShape {
        /// The ARN of a Job.
        public let arn: String?
        /// The date and time of when the Job was created.
        public let creationDateTime: String?
        /// The date and time of when the Job ended.
        public let endDateTime: String?
        /// A string representing who initiated the Job.
        public let initiatedBy: InitiatedBy?
        /// The ID of the Job.
        public let jobID: String
        /// A list of resources that the Job is acting upon.
        public let participatingResources: [ParticipatingResource]?
        /// A list of servers that the Job is acting upon.
        public let participatingServers: [ParticipatingServer]?
        /// The status of the Job.
        public let status: JobStatus?
        /// A list of tags associated with the Job.
        public let tags: [String: String]?
        /// The type of the Job.
        public let type: JobType?

        public init(arn: String? = nil, creationDateTime: String? = nil, endDateTime: String? = nil, initiatedBy: InitiatedBy? = nil, jobID: String, participatingResources: [ParticipatingResource]? = nil, participatingServers: [ParticipatingServer]? = nil, status: JobStatus? = nil, tags: [String: String]? = nil, type: JobType? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingResources = participatingResources
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case endDateTime = "endDateTime"
            case initiatedBy = "initiatedBy"
            case jobID = "jobID"
            case participatingResources = "participatingResources"
            case participatingServers = "participatingServers"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct JobLog: AWSDecodableShape {
        /// The event represents the type of a log.
        public let event: JobLogEvent?
        /// Metadata associated with a Job log.
        public let eventData: JobLogEventData?
        /// The date and time the log was taken.
        public let logDateTime: String?

        public init(event: JobLogEvent? = nil, eventData: JobLogEventData? = nil, logDateTime: String? = nil) {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case eventData = "eventData"
            case logDateTime = "logDateTime"
        }
    }

    public struct JobLogEventData: AWSDecodableShape {
        /// Properties of a conversion job
        public let conversionProperties: ConversionProperties?
        /// The ID of a conversion server.
        public let conversionServerID: String?
        /// Properties of resource related to a job event.
        public let eventResourceData: EventResourceData?
        /// A string representing a job error.
        public let rawError: String?
        /// The ID of a Source Server.
        public let sourceServerID: String?
        /// The ID of a Recovery Instance.
        public let targetInstanceID: String?

        public init(conversionProperties: ConversionProperties? = nil, conversionServerID: String? = nil, eventResourceData: EventResourceData? = nil, rawError: String? = nil, sourceServerID: String? = nil, targetInstanceID: String? = nil) {
            self.conversionProperties = conversionProperties
            self.conversionServerID = conversionServerID
            self.eventResourceData = eventResourceData
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }

        private enum CodingKeys: String, CodingKey {
            case conversionProperties = "conversionProperties"
            case conversionServerID = "conversionServerID"
            case eventResourceData = "eventResourceData"
            case rawError = "rawError"
            case sourceServerID = "sourceServerID"
            case targetInstanceID = "targetInstanceID"
        }
    }

    public struct LaunchAction: AWSDecodableShape {
        /// Launch action code.
        public let actionCode: String?
        public let actionId: String?
        public let actionVersion: String?
        /// Whether the launch action is active.
        public let active: Bool?
        public let category: LaunchActionCategory?
        public let description: String?
        public let name: String?
        /// Whether the launch will not be marked as failed if this action fails.
        public let optional: Bool?
        public let order: Int?
        public let parameters: [String: LaunchActionParameter]?
        /// Launch action type.
        public let type: LaunchActionType?

        public init(actionCode: String? = nil, actionId: String? = nil, actionVersion: String? = nil, active: Bool? = nil, category: LaunchActionCategory? = nil, description: String? = nil, name: String? = nil, optional: Bool? = nil, order: Int? = nil, parameters: [String: LaunchActionParameter]? = nil, type: LaunchActionType? = nil) {
            self.actionCode = actionCode
            self.actionId = actionId
            self.actionVersion = actionVersion
            self.active = active
            self.category = category
            self.description = description
            self.name = name
            self.optional = optional
            self.order = order
            self.parameters = parameters
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionCode = "actionCode"
            case actionId = "actionId"
            case actionVersion = "actionVersion"
            case active = "active"
            case category = "category"
            case description = "description"
            case name = "name"
            case optional = "optional"
            case order = "order"
            case parameters = "parameters"
            case type = "type"
        }
    }

    public struct LaunchActionParameter: AWSEncodableShape & AWSDecodableShape {
        /// Type.
        public let type: LaunchActionParameterType?
        /// Value.
        public let value: String?

        public init(type: LaunchActionParameterType? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1011)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[A-Za-z0-9.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct LaunchActionRun: AWSDecodableShape {
        /// Action.
        public let action: LaunchAction?
        /// Failure reason.
        public let failureReason: String?
        /// Run Id.
        public let runId: String?
        /// Run status.
        public let status: LaunchActionRunStatus?

        public init(action: LaunchAction? = nil, failureReason: String? = nil, runId: String? = nil, status: LaunchActionRunStatus? = nil) {
            self.action = action
            self.failureReason = failureReason
            self.runId = runId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case failureReason = "failureReason"
            case runId = "runId"
            case status = "status"
        }
    }

    public struct LaunchActionsRequestFilters: AWSEncodableShape {
        /// Launch actions Ids.
        public let actionIds: [String]?

        public init(actionIds: [String]? = nil) {
            self.actionIds = actionIds
        }

        public func validate(name: String) throws {
            try self.actionIds?.forEach {
                try validate($0, name: "actionIds[]", parent: name, max: 64)
                try validate($0, name: "actionIds[]", parent: name, min: 1)
                try validate($0, name: "actionIds[]", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            }
            try self.validate(self.actionIds, name: "actionIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case actionIds = "actionIds"
        }
    }

    public struct LaunchActionsStatus: AWSDecodableShape {
        /// List of post launch action status.
        public let runs: [LaunchActionRun]?
        /// Time where the AWS Systems Manager was detected as running on the launched instance.
        public let ssmAgentDiscoveryDatetime: String?

        public init(runs: [LaunchActionRun]? = nil, ssmAgentDiscoveryDatetime: String? = nil) {
            self.runs = runs
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }

        private enum CodingKeys: String, CodingKey {
            case runs = "runs"
            case ssmAgentDiscoveryDatetime = "ssmAgentDiscoveryDatetime"
        }
    }

    public struct LaunchConfiguration: AWSDecodableShape {
        /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
        public let copyPrivateIp: Bool?
        /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
        public let copyTags: Bool?
        /// The EC2 launch template ID of this launch configuration.
        public let ec2LaunchTemplateID: String?
        /// The state of the Recovery Instance in EC2 after the recovery operation.
        public let launchDisposition: LaunchDisposition?
        /// Launch into existing instance properties.
        public let launchIntoInstanceProperties: LaunchIntoInstanceProperties?
        /// The licensing configuration to be used for this launch configuration.
        public let licensing: Licensing?
        /// The name of the launch configuration.
        public let name: String?
        /// Whether we want to activate post-launch actions for the Source Server.
        public let postLaunchEnabled: Bool?
        /// The ID of the Source Server for this launch configuration.
        public let sourceServerID: String?
        /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, launchDisposition: LaunchDisposition? = nil, launchIntoInstanceProperties: LaunchIntoInstanceProperties? = nil, licensing: Licensing? = nil, name: String? = nil, postLaunchEnabled: Bool? = nil, sourceServerID: String? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.launchDisposition = launchDisposition
            self.launchIntoInstanceProperties = launchIntoInstanceProperties
            self.licensing = licensing
            self.name = name
            self.postLaunchEnabled = postLaunchEnabled
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case ec2LaunchTemplateID = "ec2LaunchTemplateID"
            case launchDisposition = "launchDisposition"
            case launchIntoInstanceProperties = "launchIntoInstanceProperties"
            case licensing = "licensing"
            case name = "name"
            case postLaunchEnabled = "postLaunchEnabled"
            case sourceServerID = "sourceServerID"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct LaunchConfigurationTemplate: AWSDecodableShape {
        /// ARN of the Launch Configuration Template.
        public let arn: String?
        /// Copy private IP.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// S3 bucket ARN to export Source Network templates.
        public let exportBucketArn: String?
        /// ID of the Launch Configuration Template.
        public let launchConfigurationTemplateID: String?
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        /// DRS will set the 'launch into instance ID' of any source server when performing a drill, recovery or failback to the previous region or availability zone, using the instance ID of the source instance.
        public let launchIntoSourceInstance: Bool?
        /// Licensing.
        public let licensing: Licensing?
        /// Post-launch actions activated.
        public let postLaunchEnabled: Bool?
        /// Tags of the Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(arn: String? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, exportBucketArn: String? = nil, launchConfigurationTemplateID: String? = nil, launchDisposition: LaunchDisposition? = nil, launchIntoSourceInstance: Bool? = nil, licensing: Licensing? = nil, postLaunchEnabled: Bool? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.arn = arn
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.exportBucketArn = exportBucketArn
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.launchIntoSourceInstance = launchIntoSourceInstance
            self.licensing = licensing
            self.postLaunchEnabled = postLaunchEnabled
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case exportBucketArn = "exportBucketArn"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case launchDisposition = "launchDisposition"
            case launchIntoSourceInstance = "launchIntoSourceInstance"
            case licensing = "licensing"
            case postLaunchEnabled = "postLaunchEnabled"
            case tags = "tags"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct LaunchIntoInstanceProperties: AWSEncodableShape & AWSDecodableShape {
        /// Optionally holds EC2 instance ID of an instance to launch into, instead of launching a new instance during drill, recovery or failback.
        public let launchIntoEC2InstanceID: String?

        public init(launchIntoEC2InstanceID: String? = nil) {
            self.launchIntoEC2InstanceID = launchIntoEC2InstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.launchIntoEC2InstanceID, name: "launchIntoEC2InstanceID", parent: name, max: 255)
            try self.validate(self.launchIntoEC2InstanceID, name: "launchIntoEC2InstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case launchIntoEC2InstanceID = "launchIntoEC2InstanceID"
        }
    }

    public struct Licensing: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable "Bring your own license" or not.
        public let osByol: Bool?

        public init(osByol: Bool? = nil) {
            self.osByol = osByol
        }

        private enum CodingKeys: String, CodingKey {
            case osByol = "osByol"
        }
    }

    public struct LifeCycle: AWSDecodableShape {
        /// The date and time of when the Source Server was added to the service.
        public let addedToServiceDateTime: String?
        /// The amount of time that the Source Server has been replicating for.
        public let elapsedReplicationDuration: String?
        /// The date and time of the first byte that was replicated from the Source Server.
        public let firstByteDateTime: String?
        /// An object containing information regarding the last launch of the Source Server.
        public let lastLaunch: LifeCycleLastLaunch?
        /// The date and time this Source Server was last seen by the service.
        public let lastSeenByServiceDateTime: String?

        public init(addedToServiceDateTime: String? = nil, elapsedReplicationDuration: String? = nil, firstByteDateTime: String? = nil, lastLaunch: LifeCycleLastLaunch? = nil, lastSeenByServiceDateTime: String? = nil) {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastLaunch = lastLaunch
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case addedToServiceDateTime = "addedToServiceDateTime"
            case elapsedReplicationDuration = "elapsedReplicationDuration"
            case firstByteDateTime = "firstByteDateTime"
            case lastLaunch = "lastLaunch"
            case lastSeenByServiceDateTime = "lastSeenByServiceDateTime"
        }
    }

    public struct LifeCycleLastLaunch: AWSDecodableShape {
        /// An object containing information regarding the initiation of the last launch of a Source Server.
        public let initiated: LifeCycleLastLaunchInitiated?
        /// Status of Source Server's last launch.
        public let status: LaunchStatus?

        public init(initiated: LifeCycleLastLaunchInitiated? = nil, status: LaunchStatus? = nil) {
            self.initiated = initiated
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case initiated = "initiated"
            case status = "status"
        }
    }

    public struct LifeCycleLastLaunchInitiated: AWSDecodableShape {
        /// The date and time the last Source Server launch was initiated.
        public let apiCallDateTime: String?
        /// The ID of the Job that was used to last launch the Source Server.
        public let jobID: String?
        /// The Job type that was used to last launch the Source Server.
        public let type: LastLaunchType?

        public init(apiCallDateTime: String? = nil, jobID: String? = nil, type: LastLaunchType? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
            case jobID = "jobID"
            case type = "type"
        }
    }

    public struct ListExtensibleSourceServersRequest: AWSEncodableShape {
        /// The maximum number of extensible source servers to retrieve.
        public let maxResults: Int?
        /// The token of the next extensible source server to retrieve.
        public let nextToken: String?
        /// The Id of the staging Account to retrieve extensible source servers from.
        public let stagingAccountID: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, stagingAccountID: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stagingAccountID = stagingAccountID
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 300)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.stagingAccountID, name: "stagingAccountID", parent: name, max: 12)
            try self.validate(self.stagingAccountID, name: "stagingAccountID", parent: name, min: 12)
            try self.validate(self.stagingAccountID, name: "stagingAccountID", parent: name, pattern: "[0-9]{12,}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stagingAccountID = "stagingAccountID"
        }
    }

    public struct ListExtensibleSourceServersResponse: AWSDecodableShape {
        /// A list of source servers on a staging Account that are extensible.
        public let items: [StagingSourceServer]?
        /// The token of the next extensible source server to retrieve.
        public let nextToken: String?

        public init(items: [StagingSourceServer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListLaunchActionsRequest: AWSEncodableShape {
        /// Filters to apply when listing resource launch actions.
        public let filters: LaunchActionsRequestFilters?
        /// Maximum amount of items to return when listing resource launch actions.
        public let maxResults: Int?
        /// Next token to use when listing resource launch actions.
        public let nextToken: String?
        public let resourceId: String

        public init(filters: LaunchActionsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(s-[0-9a-zA-Z]{17}$|lct-[0-9a-zA-Z]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceId = "resourceId"
        }
    }

    public struct ListLaunchActionsResponse: AWSDecodableShape {
        /// List of resource launch actions.
        public let items: [LaunchAction]?
        /// Next token returned when listing resource launch actions.
        public let nextToken: String?

        public init(items: [LaunchAction]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListStagingAccountsRequest: AWSEncodableShape {
        /// The maximum number of staging Accounts to retrieve.
        public let maxResults: Int?
        /// The token of the next staging Account to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStagingAccountsResponse: AWSDecodableShape {
        /// An array of staging AWS Accounts.
        public let accounts: [Account]?
        /// The token of the next staging Account to retrieve.
        public let nextToken: String?

        public init(accounts: [Account]? = nil, nextToken: String? = nil) {
            self.accounts = accounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource whose tags should be returned.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.{16,2044}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the requested resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// Network interface IPs.
        public let ips: [String]?
        /// Whether this is the primary network interface.
        public let isPrimary: Bool?
        /// The MAC address of the network interface.
        public let macAddress: String?

        public init(ips: [String]? = nil, isPrimary: Bool? = nil, macAddress: String? = nil) {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ips = "ips"
            case isPrimary = "isPrimary"
            case macAddress = "macAddress"
        }
    }

    public struct OS: AWSDecodableShape {
        /// The long name of the Operating System.
        public let fullString: String?

        public init(fullString: String? = nil) {
            self.fullString = fullString
        }

        private enum CodingKeys: String, CodingKey {
            case fullString = "fullString"
        }
    }

    public struct PITPolicyRule: AWSEncodableShape & AWSDecodableShape {
        /// Whether this rule is enabled or not.
        public let enabled: Bool?
        /// How often, in the chosen units, a snapshot should be taken.
        public let interval: Int
        /// The duration to retain a snapshot for, in the chosen units.
        public let retentionDuration: Int
        /// The ID of the rule.
        public let ruleID: Int64?
        /// The units used to measure the interval and retentionDuration.
        public let units: PITPolicyRuleUnits

        public init(enabled: Bool? = nil, interval: Int, retentionDuration: Int, ruleID: Int64? = nil, units: PITPolicyRuleUnits) {
            self.enabled = enabled
            self.interval = interval
            self.retentionDuration = retentionDuration
            self.ruleID = ruleID
            self.units = units
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
            try self.validate(self.retentionDuration, name: "retentionDuration", parent: name, min: 1)
            try self.validate(self.ruleID, name: "ruleID", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case interval = "interval"
            case retentionDuration = "retentionDuration"
            case ruleID = "ruleID"
            case units = "units"
        }
    }

    public struct ParticipatingResource: AWSDecodableShape {
        /// The launch status of a participating resource.
        public let launchStatus: LaunchStatus?
        /// The ID of a participating resource.
        public let participatingResourceID: ParticipatingResourceID?

        public init(launchStatus: LaunchStatus? = nil, participatingResourceID: ParticipatingResourceID? = nil) {
            self.launchStatus = launchStatus
            self.participatingResourceID = participatingResourceID
        }

        private enum CodingKeys: String, CodingKey {
            case launchStatus = "launchStatus"
            case participatingResourceID = "participatingResourceID"
        }
    }

    public struct ParticipatingServer: AWSDecodableShape {
        /// The post-launch action runs of a participating server.
        public let launchActionsStatus: LaunchActionsStatus?
        /// The launch status of a participating server.
        public let launchStatus: LaunchStatus?
        /// The Recovery Instance ID of a participating server.
        public let recoveryInstanceID: String?
        /// The Source Server ID of a participating server.
        public let sourceServerID: String?

        public init(launchActionsStatus: LaunchActionsStatus? = nil, launchStatus: LaunchStatus? = nil, recoveryInstanceID: String? = nil, sourceServerID: String? = nil) {
            self.launchActionsStatus = launchActionsStatus
            self.launchStatus = launchStatus
            self.recoveryInstanceID = recoveryInstanceID
            self.sourceServerID = sourceServerID
        }

        private enum CodingKeys: String, CodingKey {
            case launchActionsStatus = "launchActionsStatus"
            case launchStatus = "launchStatus"
            case recoveryInstanceID = "recoveryInstanceID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct ProductCode: AWSDecodableShape {
        /// Id of a product code associated with a volume.
        public let productCodeId: String?
        /// Mode of a product code associated with a volume.
        public let productCodeMode: ProductCodeMode?

        public init(productCodeId: String? = nil, productCodeMode: ProductCodeMode? = nil) {
            self.productCodeId = productCodeId
            self.productCodeMode = productCodeMode
        }

        private enum CodingKeys: String, CodingKey {
            case productCodeId = "productCodeId"
            case productCodeMode = "productCodeMode"
        }
    }

    public struct PutLaunchActionRequest: AWSEncodableShape {
        /// Launch action code.
        public let actionCode: String
        public let actionId: String
        public let actionVersion: String
        /// Whether the launch action is active.
        public let active: Bool
        public let category: LaunchActionCategory
        public let description: String
        public let name: String
        /// Whether the launch will not be marked as failed if this action fails.
        public let optional: Bool
        public let order: Int
        public let parameters: [String: LaunchActionParameter]?
        public let resourceId: String

        public init(actionCode: String, actionId: String, actionVersion: String, active: Bool, category: LaunchActionCategory, description: String, name: String, optional: Bool, order: Int, parameters: [String: LaunchActionParameter]? = nil, resourceId: String) {
            self.actionCode = actionCode
            self.actionId = actionId
            self.actionVersion = actionVersion
            self.active = active
            self.category = category
            self.description = description
            self.name = name
            self.optional = optional
            self.order = order
            self.parameters = parameters
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.actionCode, name: "actionCode", parent: name, max: 1011)
            try self.validate(self.actionCode, name: "actionCode", parent: name, min: 1)
            try self.validate(self.actionCode, name: "actionCode", parent: name, pattern: "^([A-Za-z0-9-/:])+$")
            try self.validate(self.actionId, name: "actionId", parent: name, max: 64)
            try self.validate(self.actionId, name: "actionId", parent: name, min: 1)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.actionVersion, name: "actionVersion", parent: name, max: 10)
            try self.validate(self.actionVersion, name: "actionVersion", parent: name, min: 1)
            try self.validate(self.actionVersion, name: "actionVersion", parent: name, pattern: "^(\\$DEFAULT|\\$LATEST|[0-9]+)$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9a-zA-Z ():/.,'-_#*;\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9 /_-]*$")
            try self.validate(self.order, name: "order", parent: name, max: 10000)
            try self.validate(self.order, name: "order", parent: name, min: 2)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(s-[0-9a-zA-Z]{17}$|lct-[0-9a-zA-Z]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionCode = "actionCode"
            case actionId = "actionId"
            case actionVersion = "actionVersion"
            case active = "active"
            case category = "category"
            case description = "description"
            case name = "name"
            case optional = "optional"
            case order = "order"
            case parameters = "parameters"
            case resourceId = "resourceId"
        }
    }

    public struct PutLaunchActionResponse: AWSDecodableShape {
        /// Launch action code.
        public let actionCode: String?
        public let actionId: String?
        public let actionVersion: String?
        /// Whether the launch action is active.
        public let active: Bool?
        public let category: LaunchActionCategory?
        public let description: String?
        public let name: String?
        /// Whether the launch will not be marked as failed if this action fails.
        public let optional: Bool?
        public let order: Int?
        public let parameters: [String: LaunchActionParameter]?
        public let resourceId: String?
        /// Launch action type.
        public let type: LaunchActionType?

        public init(actionCode: String? = nil, actionId: String? = nil, actionVersion: String? = nil, active: Bool? = nil, category: LaunchActionCategory? = nil, description: String? = nil, name: String? = nil, optional: Bool? = nil, order: Int? = nil, parameters: [String: LaunchActionParameter]? = nil, resourceId: String? = nil, type: LaunchActionType? = nil) {
            self.actionCode = actionCode
            self.actionId = actionId
            self.actionVersion = actionVersion
            self.active = active
            self.category = category
            self.description = description
            self.name = name
            self.optional = optional
            self.order = order
            self.parameters = parameters
            self.resourceId = resourceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionCode = "actionCode"
            case actionId = "actionId"
            case actionVersion = "actionVersion"
            case active = "active"
            case category = "category"
            case description = "description"
            case name = "name"
            case optional = "optional"
            case order = "order"
            case parameters = "parameters"
            case resourceId = "resourceId"
            case type = "type"
        }
    }

    public struct RecoveryInstance: AWSDecodableShape {
        /// The version of the DRS agent installed on the recovery instance
        public let agentVersion: String?
        /// The ARN of the Recovery Instance.
        public let arn: String?
        /// The Data Replication Info of the Recovery Instance.
        public let dataReplicationInfo: RecoveryInstanceDataReplicationInfo?
        /// The EC2 instance ID of the Recovery Instance.
        public let ec2InstanceID: String?
        /// The state of the EC2 instance for this Recovery Instance.
        public let ec2InstanceState: EC2InstanceState?
        /// An object representing failback related information of the Recovery Instance.
        public let failback: RecoveryInstanceFailback?
        /// Whether this Recovery Instance was created for a drill or for an actual Recovery event.
        public let isDrill: Bool?
        /// The ID of the Job that created the Recovery Instance.
        public let jobID: String?
        /// AWS availability zone associated with the recovery instance.
        public let originAvailabilityZone: String?
        /// Environment (On Premises / AWS) of the instance that the recovery instance originated from.
        public let originEnvironment: OriginEnvironment?
        /// The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.
        public let pointInTimeSnapshotDateTime: String?
        /// The ID of the Recovery Instance.
        public let recoveryInstanceID: String?
        /// Properties of the Recovery Instance machine.
        public let recoveryInstanceProperties: RecoveryInstanceProperties?
        /// The Source Server ID that this Recovery Instance is associated with.
        public let sourceServerID: String?
        /// An array of tags that are associated with the Recovery Instance.
        public let tags: [String: String]?

        public init(agentVersion: String? = nil, arn: String? = nil, dataReplicationInfo: RecoveryInstanceDataReplicationInfo? = nil, ec2InstanceID: String? = nil, ec2InstanceState: EC2InstanceState? = nil, failback: RecoveryInstanceFailback? = nil, isDrill: Bool? = nil, jobID: String? = nil, originAvailabilityZone: String? = nil, originEnvironment: OriginEnvironment? = nil, pointInTimeSnapshotDateTime: String? = nil, recoveryInstanceID: String? = nil, recoveryInstanceProperties: RecoveryInstanceProperties? = nil, sourceServerID: String? = nil, tags: [String: String]? = nil) {
            self.agentVersion = agentVersion
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.ec2InstanceID = ec2InstanceID
            self.ec2InstanceState = ec2InstanceState
            self.failback = failback
            self.isDrill = isDrill
            self.jobID = jobID
            self.originAvailabilityZone = originAvailabilityZone
            self.originEnvironment = originEnvironment
            self.pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTime
            self.recoveryInstanceID = recoveryInstanceID
            self.recoveryInstanceProperties = recoveryInstanceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
            case arn = "arn"
            case dataReplicationInfo = "dataReplicationInfo"
            case ec2InstanceID = "ec2InstanceID"
            case ec2InstanceState = "ec2InstanceState"
            case failback = "failback"
            case isDrill = "isDrill"
            case jobID = "jobID"
            case originAvailabilityZone = "originAvailabilityZone"
            case originEnvironment = "originEnvironment"
            case pointInTimeSnapshotDateTime = "pointInTimeSnapshotDateTime"
            case recoveryInstanceID = "recoveryInstanceID"
            case recoveryInstanceProperties = "recoveryInstanceProperties"
            case sourceServerID = "sourceServerID"
            case tags = "tags"
        }
    }

    public struct RecoveryInstanceDataReplicationError: AWSDecodableShape {
        /// Error in data replication.
        public let error: FailbackReplicationError?
        /// Error in data replication.
        public let rawError: String?

        public init(error: FailbackReplicationError? = nil, rawError: String? = nil) {
            self.error = error
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case rawError = "rawError"
        }
    }

    public struct RecoveryInstanceDataReplicationInfo: AWSDecodableShape {
        /// Information about Data Replication
        public let dataReplicationError: RecoveryInstanceDataReplicationError?
        /// Information about whether the data replication has been initiated.
        public let dataReplicationInitiation: RecoveryInstanceDataReplicationInitiation?
        /// The state of the data replication.
        public let dataReplicationState: RecoveryInstanceDataReplicationState?
        /// An estimate of when the data replication will be completed.
        public let etaDateTime: String?
        /// Data replication lag duration.
        public let lagDuration: String?
        /// The disks that should be replicated.
        public let replicatedDisks: [RecoveryInstanceDataReplicationInfoReplicatedDisk]?
        /// AWS Availability zone into which data is being replicated.
        public let stagingAvailabilityZone: String?

        public init(dataReplicationError: RecoveryInstanceDataReplicationError? = nil, dataReplicationInitiation: RecoveryInstanceDataReplicationInitiation? = nil, dataReplicationState: RecoveryInstanceDataReplicationState? = nil, etaDateTime: String? = nil, lagDuration: String? = nil, replicatedDisks: [RecoveryInstanceDataReplicationInfoReplicatedDisk]? = nil, stagingAvailabilityZone: String? = nil) {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
            self.stagingAvailabilityZone = stagingAvailabilityZone
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationError = "dataReplicationError"
            case dataReplicationInitiation = "dataReplicationInitiation"
            case dataReplicationState = "dataReplicationState"
            case etaDateTime = "etaDateTime"
            case lagDuration = "lagDuration"
            case replicatedDisks = "replicatedDisks"
            case stagingAvailabilityZone = "stagingAvailabilityZone"
        }
    }

    public struct RecoveryInstanceDataReplicationInfoReplicatedDisk: AWSDecodableShape {
        /// The size of the replication backlog in bytes.
        public let backloggedStorageBytes: Int64?
        /// The name of the device.
        public let deviceName: String?
        /// The amount of data replicated so far in bytes.
        public let replicatedStorageBytes: Int64?
        /// The amount of data to be rescanned in bytes.
        public let rescannedStorageBytes: Int64?
        /// The total amount of data to be replicated in bytes.
        public let totalStorageBytes: Int64?

        public init(backloggedStorageBytes: Int64? = nil, deviceName: String? = nil, replicatedStorageBytes: Int64? = nil, rescannedStorageBytes: Int64? = nil, totalStorageBytes: Int64? = nil) {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }

        private enum CodingKeys: String, CodingKey {
            case backloggedStorageBytes = "backloggedStorageBytes"
            case deviceName = "deviceName"
            case replicatedStorageBytes = "replicatedStorageBytes"
            case rescannedStorageBytes = "rescannedStorageBytes"
            case totalStorageBytes = "totalStorageBytes"
        }
    }

    public struct RecoveryInstanceDataReplicationInitiation: AWSDecodableShape {
        /// The date and time of the current attempt to initiate data replication.
        public let startDateTime: String?
        /// The steps of the current attempt to initiate data replication.
        public let steps: [RecoveryInstanceDataReplicationInitiationStep]?

        public init(startDateTime: String? = nil, steps: [RecoveryInstanceDataReplicationInitiationStep]? = nil) {
            self.startDateTime = startDateTime
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case startDateTime = "startDateTime"
            case steps = "steps"
        }
    }

    public struct RecoveryInstanceDataReplicationInitiationStep: AWSDecodableShape {
        /// The name of the step.
        public let name: RecoveryInstanceDataReplicationInitiationStepName?
        /// The status of the step.
        public let status: RecoveryInstanceDataReplicationInitiationStepStatus?

        public init(name: RecoveryInstanceDataReplicationInitiationStepName? = nil, status: RecoveryInstanceDataReplicationInitiationStepStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct RecoveryInstanceDisk: AWSDecodableShape {
        /// The amount of storage on the disk in bytes.
        public let bytes: Int64?
        /// The EBS Volume ID of this disk.
        public let ebsVolumeID: String?
        /// The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.
        public let internalDeviceName: String?

        public init(bytes: Int64? = nil, ebsVolumeID: String? = nil, internalDeviceName: String? = nil) {
            self.bytes = bytes
            self.ebsVolumeID = ebsVolumeID
            self.internalDeviceName = internalDeviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case ebsVolumeID = "ebsVolumeID"
            case internalDeviceName = "internalDeviceName"
        }
    }

    public struct RecoveryInstanceFailback: AWSDecodableShape {
        /// The date and time the agent on the Recovery Instance was last seen by the service.
        public let agentLastSeenByServiceDateTime: String?
        /// The amount of time that the Recovery Instance has been replicating for.
        public let elapsedReplicationDuration: String?
        /// The ID of the failback client that this Recovery Instance is associated with.
        public let failbackClientID: String?
        /// The date and time that the failback client was last seen by the service.
        public let failbackClientLastSeenByServiceDateTime: String?
        /// The date and time that the failback initiation started.
        public let failbackInitiationTime: String?
        /// The Job ID of the last failback log for this Recovery Instance.
        public let failbackJobID: String?
        /// The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.
        public let failbackLaunchType: FailbackLaunchType?
        /// Whether we are failing back to the original Source Server for this Recovery Instance.
        public let failbackToOriginalServer: Bool?
        /// The date and time of the first byte that was replicated from the Recovery Instance.
        public let firstByteDateTime: String?
        /// The state of the failback process that this Recovery Instance is in.
        public let state: FailbackState?

        public init(agentLastSeenByServiceDateTime: String? = nil, elapsedReplicationDuration: String? = nil, failbackClientID: String? = nil, failbackClientLastSeenByServiceDateTime: String? = nil, failbackInitiationTime: String? = nil, failbackJobID: String? = nil, failbackLaunchType: FailbackLaunchType? = nil, failbackToOriginalServer: Bool? = nil, firstByteDateTime: String? = nil, state: FailbackState? = nil) {
            self.agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.failbackClientID = failbackClientID
            self.failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTime
            self.failbackInitiationTime = failbackInitiationTime
            self.failbackJobID = failbackJobID
            self.failbackLaunchType = failbackLaunchType
            self.failbackToOriginalServer = failbackToOriginalServer
            self.firstByteDateTime = firstByteDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case agentLastSeenByServiceDateTime = "agentLastSeenByServiceDateTime"
            case elapsedReplicationDuration = "elapsedReplicationDuration"
            case failbackClientID = "failbackClientID"
            case failbackClientLastSeenByServiceDateTime = "failbackClientLastSeenByServiceDateTime"
            case failbackInitiationTime = "failbackInitiationTime"
            case failbackJobID = "failbackJobID"
            case failbackLaunchType = "failbackLaunchType"
            case failbackToOriginalServer = "failbackToOriginalServer"
            case firstByteDateTime = "firstByteDateTime"
            case state = "state"
        }
    }

    public struct RecoveryInstanceProperties: AWSDecodableShape {
        /// An array of CPUs.
        public let cpus: [CPU]?
        /// An array of disks.
        public let disks: [RecoveryInstanceDisk]?
        /// Hints used to uniquely identify a machine.
        public let identificationHints: IdentificationHints?
        /// The date and time the Recovery Instance properties were last updated on.
        public let lastUpdatedDateTime: String?
        /// An array of network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// Operating system.
        public let os: OS?
        /// The amount of RAM in bytes.
        public let ramBytes: Int64?

        public init(cpus: [CPU]? = nil, disks: [RecoveryInstanceDisk]? = nil, identificationHints: IdentificationHints? = nil, lastUpdatedDateTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, os: OS? = nil, ramBytes: Int64? = nil) {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
        }

        private enum CodingKeys: String, CodingKey {
            case cpus = "cpus"
            case disks = "disks"
            case identificationHints = "identificationHints"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case networkInterfaces = "networkInterfaces"
            case os = "os"
            case ramBytes = "ramBytes"
        }
    }

    public struct RecoveryLifeCycle: AWSDecodableShape {
        /// The date and time the last Source Network recovery was initiated.
        public let apiCallDateTime: Date?
        /// The ID of the Job that was used to last recover the Source Network.
        public let jobID: String?
        /// The status of the last recovery status of this Source Network.
        public let lastRecoveryResult: RecoveryResult?

        public init(apiCallDateTime: Date? = nil, jobID: String? = nil, lastRecoveryResult: RecoveryResult? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
            self.lastRecoveryResult = lastRecoveryResult
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
            case jobID = "jobID"
            case lastRecoveryResult = "lastRecoveryResult"
        }
    }

    public struct RecoverySnapshot: AWSDecodableShape {
        /// A list of EBS snapshots.
        public let ebsSnapshots: [String]?
        /// The timestamp of when we expect the snapshot to be taken.
        public let expectedTimestamp: String
        /// The ID of the Recovery Snapshot.
        public let snapshotID: String
        /// The ID of the Source Server that the snapshot was taken for.
        public let sourceServerID: String
        /// The actual timestamp that the snapshot was taken.
        public let timestamp: String?

        public init(ebsSnapshots: [String]? = nil, expectedTimestamp: String, snapshotID: String, sourceServerID: String, timestamp: String? = nil) {
            self.ebsSnapshots = ebsSnapshots
            self.expectedTimestamp = expectedTimestamp
            self.snapshotID = snapshotID
            self.sourceServerID = sourceServerID
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case ebsSnapshots = "ebsSnapshots"
            case expectedTimestamp = "expectedTimestamp"
            case snapshotID = "snapshotID"
            case sourceServerID = "sourceServerID"
            case timestamp = "timestamp"
        }
    }

    public struct ReplicationConfiguration: AWSDecodableShape {
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
        public let associateDefaultSecurityGroup: Bool?
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public let autoReplicateNewDisks: Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public let bandwidthThrottling: Int64?
        /// Whether to create a Public IP for the Recovery Instance by default.
        public let createPublicIP: Bool?
        /// The data plane routing mechanism that will be used for replication.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public let ebsEncryptionKeyArn: String?
        /// The name of the Replication Configuration.
        public let name: String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public let pitPolicy: [PITPolicyRule]?
        /// The configuration of the disks of the Source Server to be replicated.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// The instance type to be used for the replication server.
        public let replicationServerInstanceType: String?
        /// The security group IDs that will be used by the replication server.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// The ID of the Source Server for this Replication Configuration.
        public let sourceServerID: String?
        /// The subnet to be used by the replication staging area.
        public let stagingAreaSubnetId: String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public let stagingAreaTags: [String: String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, autoReplicateNewDisks: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, pitPolicy: [PITPolicyRule]? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.pitPolicy = pitPolicy
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case autoReplicateNewDisks = "autoReplicateNewDisks"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case name = "name"
            case pitPolicy = "pitPolicy"
            case replicatedDisks = "replicatedDisks"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case sourceServerID = "sourceServerID"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
        }
    }

    public struct ReplicationConfigurationReplicatedDisk: AWSEncodableShape & AWSDecodableShape {
        /// The name of the device.
        public let deviceName: String?
        /// The requested number of I/O operations per second (IOPS).
        public let iops: Int64?
        /// Whether to boot from this disk or not.
        public let isBootDisk: Bool?
        /// The Staging Disk EBS volume type to be used during replication when stagingDiskType is set to Auto. This is a read-only field.
        public let optimizedStagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// The Staging Disk EBS volume type to be used during replication.
        public let stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.
        public let throughput: Int64?

        public init(deviceName: String? = nil, iops: Int64? = nil, isBootDisk: Bool? = nil, optimizedStagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil, stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil, throughput: Int64? = nil) {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.optimizedStagingDiskType = optimizedStagingDiskType
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 256)
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case iops = "iops"
            case isBootDisk = "isBootDisk"
            case optimizedStagingDiskType = "optimizedStagingDiskType"
            case stagingDiskType = "stagingDiskType"
            case throughput = "throughput"
        }
    }

    public struct ReplicationConfigurationTemplate: AWSDecodableShape {
        /// The Replication Configuration Template ARN.
        public let arn: String?
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
        public let associateDefaultSecurityGroup: Bool?
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public let autoReplicateNewDisks: Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public let bandwidthThrottling: Int64?
        /// Whether to create a Public IP for the Recovery Instance by default.
        public let createPublicIP: Bool?
        /// The data plane routing mechanism that will be used for replication.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public let ebsEncryptionKeyArn: String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public let pitPolicy: [PITPolicyRule]?
        /// The Replication Configuration Template ID.
        public let replicationConfigurationTemplateID: String
        /// The instance type to be used for the replication server.
        public let replicationServerInstanceType: String?
        /// The security group IDs that will be used by the replication server.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// The subnet to be used by the replication staging area.
        public let stagingAreaSubnetId: String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public let stagingAreaTags: [String: String]?
        /// A set of tags to be associated with the Replication Configuration Template resource.
        public let tags: [String: String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, autoReplicateNewDisks: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, pitPolicy: [PITPolicyRule]? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, tags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.pitPolicy = pitPolicy
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case autoReplicateNewDisks = "autoReplicateNewDisks"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case pitPolicy = "pitPolicy"
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case tags = "tags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
        }
    }

    public struct RetryDataReplicationRequest: AWSEncodableShape {
        /// The ID of the Source Server whose data replication should be retried.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct ReverseReplicationRequest: AWSEncodableShape {
        /// The ID of the Recovery Instance that we want to reverse the replication for.
        public let recoveryInstanceID: String

        public init(recoveryInstanceID: String) {
            self.recoveryInstanceID = recoveryInstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceID = "recoveryInstanceID"
        }
    }

    public struct ReverseReplicationResponse: AWSDecodableShape {
        /// ARN of created SourceServer.
        public let reversedDirectionSourceServerArn: String?

        public init(reversedDirectionSourceServerArn: String? = nil) {
            self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
        }

        private enum CodingKeys: String, CodingKey {
            case reversedDirectionSourceServerArn = "reversedDirectionSourceServerArn"
        }
    }

    public struct SourceCloudProperties: AWSDecodableShape {
        /// AWS Account ID for an EC2-originated Source Server.
        public let originAccountID: String?
        /// AWS Availability Zone for an EC2-originated Source Server.
        public let originAvailabilityZone: String?
        /// AWS Region for an EC2-originated Source Server.
        public let originRegion: String?

        public init(originAccountID: String? = nil, originAvailabilityZone: String? = nil, originRegion: String? = nil) {
            self.originAccountID = originAccountID
            self.originAvailabilityZone = originAvailabilityZone
            self.originRegion = originRegion
        }

        private enum CodingKeys: String, CodingKey {
            case originAccountID = "originAccountID"
            case originAvailabilityZone = "originAvailabilityZone"
            case originRegion = "originRegion"
        }
    }

    public struct SourceNetwork: AWSDecodableShape {
        /// The ARN of the Source Network.
        public let arn: String?
        /// CloudFormation stack name that was deployed for recovering the Source Network.
        public let cfnStackName: String?
        /// An object containing information regarding the last recovery of the Source Network.
        public let lastRecovery: RecoveryLifeCycle?
        /// ID of the recovered VPC following Source Network recovery.
        public let launchedVpcID: String?
        /// Status of Source Network Replication. Possible values: (a) STOPPED - Source Network is not replicating. (b) IN_PROGRESS - Source Network is being replicated. (c) PROTECTED - Source Network was replicated successfully and is being synchronized for changes. (d) ERROR - Source Network replication has failed
        public let replicationStatus: ReplicationStatus?
        /// Error details in case Source Network replication status is ERROR.
        public let replicationStatusDetails: String?
        /// Account ID containing the VPC protected by the Source Network.
        public let sourceAccountID: String?
        /// Source Network ID.
        public let sourceNetworkID: String?
        /// Region containing the VPC protected by the Source Network.
        public let sourceRegion: String?
        /// VPC ID protected by the Source Network.
        public let sourceVpcID: String?
        /// A list of tags associated with the Source Network.
        public let tags: [String: String]?

        public init(arn: String? = nil, cfnStackName: String? = nil, lastRecovery: RecoveryLifeCycle? = nil, launchedVpcID: String? = nil, replicationStatus: ReplicationStatus? = nil, replicationStatusDetails: String? = nil, sourceAccountID: String? = nil, sourceNetworkID: String? = nil, sourceRegion: String? = nil, sourceVpcID: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cfnStackName = cfnStackName
            self.lastRecovery = lastRecovery
            self.launchedVpcID = launchedVpcID
            self.replicationStatus = replicationStatus
            self.replicationStatusDetails = replicationStatusDetails
            self.sourceAccountID = sourceAccountID
            self.sourceNetworkID = sourceNetworkID
            self.sourceRegion = sourceRegion
            self.sourceVpcID = sourceVpcID
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cfnStackName = "cfnStackName"
            case lastRecovery = "lastRecovery"
            case launchedVpcID = "launchedVpcID"
            case replicationStatus = "replicationStatus"
            case replicationStatusDetails = "replicationStatusDetails"
            case sourceAccountID = "sourceAccountID"
            case sourceNetworkID = "sourceNetworkID"
            case sourceRegion = "sourceRegion"
            case sourceVpcID = "sourceVpcID"
            case tags = "tags"
        }
    }

    public struct SourceNetworkData: AWSDecodableShape {
        /// Source Network ID.
        public let sourceNetworkID: String?
        /// VPC ID protected by the Source Network.
        public let sourceVpc: String?
        /// CloudFormation stack name that was deployed for recovering the Source Network.
        public let stackName: String?
        /// ID of the recovered VPC following Source Network recovery.
        public let targetVpc: String?

        public init(sourceNetworkID: String? = nil, sourceVpc: String? = nil, stackName: String? = nil, targetVpc: String? = nil) {
            self.sourceNetworkID = sourceNetworkID
            self.sourceVpc = sourceVpc
            self.stackName = stackName
            self.targetVpc = targetVpc
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
            case sourceVpc = "sourceVpc"
            case stackName = "stackName"
            case targetVpc = "targetVpc"
        }
    }

    public struct SourceProperties: AWSDecodableShape {
        /// An array of CPUs.
        public let cpus: [CPU]?
        /// An array of disks.
        public let disks: [Disk]?
        /// Hints used to uniquely identify a machine.
        public let identificationHints: IdentificationHints?
        /// The date and time the Source Properties were last updated on.
        public let lastUpdatedDateTime: String?
        /// An array of network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// Operating system.
        public let os: OS?
        /// The amount of RAM in bytes.
        public let ramBytes: Int64?
        /// The recommended EC2 instance type that will be used when recovering the Source Server.
        public let recommendedInstanceType: String?
        /// Are EC2 nitro instance types supported when recovering the Source Server.
        public let supportsNitroInstances: Bool?

        public init(cpus: [CPU]? = nil, disks: [Disk]? = nil, identificationHints: IdentificationHints? = nil, lastUpdatedDateTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, os: OS? = nil, ramBytes: Int64? = nil, recommendedInstanceType: String? = nil, supportsNitroInstances: Bool? = nil) {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
            self.supportsNitroInstances = supportsNitroInstances
        }

        private enum CodingKeys: String, CodingKey {
            case cpus = "cpus"
            case disks = "disks"
            case identificationHints = "identificationHints"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case networkInterfaces = "networkInterfaces"
            case os = "os"
            case ramBytes = "ramBytes"
            case recommendedInstanceType = "recommendedInstanceType"
            case supportsNitroInstances = "supportsNitroInstances"
        }
    }

    public struct SourceServer: AWSDecodableShape {
        /// The version of the DRS agent installed on the source server
        public let agentVersion: String?
        /// The ARN of the Source Server.
        public let arn: String?
        /// The Data Replication Info of the Source Server.
        public let dataReplicationInfo: DataReplicationInfo?
        /// The status of the last recovery launch of this Source Server.
        public let lastLaunchResult: LastLaunchResult?
        /// The lifecycle information of this Source Server.
        public let lifeCycle: LifeCycle?
        /// The ID of the Recovery Instance associated with this Source Server.
        public let recoveryInstanceId: String?
        /// Replication direction of the Source Server.
        public let replicationDirection: ReplicationDirection?
        /// For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.
        public let reversedDirectionSourceServerArn: String?
        /// Source cloud properties of the Source Server.
        public let sourceCloudProperties: SourceCloudProperties?
        /// ID of the Source Network which is protecting this Source Server's network.
        public let sourceNetworkID: String?
        /// The source properties of the Source Server.
        public let sourceProperties: SourceProperties?
        /// The ID of the Source Server.
        public let sourceServerID: String?
        /// The staging area of the source server.
        public let stagingArea: StagingArea?
        /// The tags associated with the Source Server.
        public let tags: [String: String]?

        public init(agentVersion: String? = nil, arn: String? = nil, dataReplicationInfo: DataReplicationInfo? = nil, lastLaunchResult: LastLaunchResult? = nil, lifeCycle: LifeCycle? = nil, recoveryInstanceId: String? = nil, replicationDirection: ReplicationDirection? = nil, reversedDirectionSourceServerArn: String? = nil, sourceCloudProperties: SourceCloudProperties? = nil, sourceNetworkID: String? = nil, sourceProperties: SourceProperties? = nil, sourceServerID: String? = nil, stagingArea: StagingArea? = nil, tags: [String: String]? = nil) {
            self.agentVersion = agentVersion
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.lastLaunchResult = lastLaunchResult
            self.lifeCycle = lifeCycle
            self.recoveryInstanceId = recoveryInstanceId
            self.replicationDirection = replicationDirection
            self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
            self.sourceCloudProperties = sourceCloudProperties
            self.sourceNetworkID = sourceNetworkID
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.stagingArea = stagingArea
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
            case arn = "arn"
            case dataReplicationInfo = "dataReplicationInfo"
            case lastLaunchResult = "lastLaunchResult"
            case lifeCycle = "lifeCycle"
            case recoveryInstanceId = "recoveryInstanceId"
            case replicationDirection = "replicationDirection"
            case reversedDirectionSourceServerArn = "reversedDirectionSourceServerArn"
            case sourceCloudProperties = "sourceCloudProperties"
            case sourceNetworkID = "sourceNetworkID"
            case sourceProperties = "sourceProperties"
            case sourceServerID = "sourceServerID"
            case stagingArea = "stagingArea"
            case tags = "tags"
        }
    }

    public struct StagingArea: AWSDecodableShape {
        /// Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR
        public let errorMessage: String?
        /// Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.
        public let stagingAccountID: String?
        /// Arn of the staging source server if this source server is extended
        public let stagingSourceServerArn: String?
        /// Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.
        public let status: ExtensionStatus?

        public init(errorMessage: String? = nil, stagingAccountID: String? = nil, stagingSourceServerArn: String? = nil, status: ExtensionStatus? = nil) {
            self.errorMessage = errorMessage
            self.stagingAccountID = stagingAccountID
            self.stagingSourceServerArn = stagingSourceServerArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case stagingAccountID = "stagingAccountID"
            case stagingSourceServerArn = "stagingSourceServerArn"
            case status = "status"
        }
    }

    public struct StagingSourceServer: AWSDecodableShape {
        /// The ARN of the source server.
        public let arn: String?
        /// Hostname of staging source server.
        public let hostname: String?
        /// A list of tags associated with the staging source server.
        public let tags: [String: String]?

        public init(arn: String? = nil, hostname: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.hostname = hostname
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case hostname = "hostname"
            case tags = "tags"
        }
    }

    public struct StartFailbackLaunchRequest: AWSEncodableShape {
        /// The IDs of the Recovery Instance whose failback launch we want to request.
        public let recoveryInstanceIDs: [String]
        /// The tags to be associated with the failback launch Job.
        public let tags: [String: String]?

        public init(recoveryInstanceIDs: [String], tags: [String: String]? = nil) {
            self.recoveryInstanceIDs = recoveryInstanceIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.recoveryInstanceIDs.forEach {
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, max: 19)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, min: 10)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.recoveryInstanceIDs, name: "recoveryInstanceIDs", parent: name, max: 200)
            try self.validate(self.recoveryInstanceIDs, name: "recoveryInstanceIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceIDs = "recoveryInstanceIDs"
            case tags = "tags"
        }
    }

    public struct StartFailbackLaunchResponse: AWSDecodableShape {
        /// The failback launch Job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct StartRecoveryRequest: AWSEncodableShape {
        /// Whether this Source Server Recovery operation is a drill or not.
        public let isDrill: Bool?
        /// The Source Servers that we want to start a Recovery Job for.
        public let sourceServers: [StartRecoveryRequestSourceServer]
        /// The tags to be associated with the Recovery Job.
        public let tags: [String: String]?

        public init(isDrill: Bool? = nil, sourceServers: [StartRecoveryRequestSourceServer], tags: [String: String]? = nil) {
            self.isDrill = isDrill
            self.sourceServers = sourceServers
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServers.forEach {
                try $0.validate(name: "\(name).sourceServers[]")
            }
            try self.validate(self.sourceServers, name: "sourceServers", parent: name, max: 200)
            try self.validate(self.sourceServers, name: "sourceServers", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case isDrill = "isDrill"
            case sourceServers = "sourceServers"
            case tags = "tags"
        }
    }

    public struct StartRecoveryRequestSourceServer: AWSEncodableShape {
        /// The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.
        public let recoverySnapshotID: String?
        /// The ID of the Source Server you want to recover.
        public let sourceServerID: String

        public init(recoverySnapshotID: String? = nil, sourceServerID: String) {
            self.recoverySnapshotID = recoverySnapshotID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoverySnapshotID, name: "recoverySnapshotID", parent: name, max: 21)
            try self.validate(self.recoverySnapshotID, name: "recoverySnapshotID", parent: name, min: 21)
            try self.validate(self.recoverySnapshotID, name: "recoverySnapshotID", parent: name, pattern: "^pit-[0-9a-zA-Z]{17}$")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoverySnapshotID = "recoverySnapshotID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct StartRecoveryResponse: AWSDecodableShape {
        /// The Recovery Job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct StartReplicationRequest: AWSEncodableShape {
        /// The ID of the Source Server to start replication for.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct StartReplicationResponse: AWSDecodableShape {
        /// The Source Server that this action was targeted on.
        public let sourceServer: SourceServer?

        public init(sourceServer: SourceServer? = nil) {
            self.sourceServer = sourceServer
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServer = "sourceServer"
        }
    }

    public struct StartSourceNetworkRecoveryRequest: AWSEncodableShape {
        /// Don't update existing CloudFormation Stack, recover the network using a new stack.
        public let deployAsNew: Bool?
        /// The Source Networks that we want to start a Recovery Job for.
        public let sourceNetworks: [StartSourceNetworkRecoveryRequestNetworkEntry]
        /// The tags to be associated with the Source Network recovery Job.
        public let tags: [String: String]?

        public init(deployAsNew: Bool? = nil, sourceNetworks: [StartSourceNetworkRecoveryRequestNetworkEntry], tags: [String: String]? = nil) {
            self.deployAsNew = deployAsNew
            self.sourceNetworks = sourceNetworks
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceNetworks.forEach {
                try $0.validate(name: "\(name).sourceNetworks[]")
            }
            try self.validate(self.sourceNetworks, name: "sourceNetworks", parent: name, max: 100)
            try self.validate(self.sourceNetworks, name: "sourceNetworks", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deployAsNew = "deployAsNew"
            case sourceNetworks = "sourceNetworks"
            case tags = "tags"
        }
    }

    public struct StartSourceNetworkRecoveryRequestNetworkEntry: AWSEncodableShape {
        /// CloudFormation stack name to be used for recovering the network.
        public let cfnStackName: String?
        /// The ID of the Source Network you want to recover.
        public let sourceNetworkID: String

        public init(cfnStackName: String? = nil, sourceNetworkID: String) {
            self.cfnStackName = cfnStackName
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, max: 128)
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, min: 1)
            try self.validate(self.cfnStackName, name: "cfnStackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case cfnStackName = "cfnStackName"
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct StartSourceNetworkRecoveryResponse: AWSDecodableShape {
        /// The Source Network recovery Job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct StartSourceNetworkReplicationRequest: AWSEncodableShape {
        /// ID of the Source Network to replicate.
        public let sourceNetworkID: String

        public init(sourceNetworkID: String) {
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct StartSourceNetworkReplicationResponse: AWSDecodableShape {
        /// Source Network which was requested for replication.
        public let sourceNetwork: SourceNetwork?

        public init(sourceNetwork: SourceNetwork? = nil) {
            self.sourceNetwork = sourceNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetwork = "sourceNetwork"
        }
    }

    public struct StopFailbackRequest: AWSEncodableShape {
        /// The ID of the Recovery Instance we want to stop failback for.
        public let recoveryInstanceID: String

        public init(recoveryInstanceID: String) {
            self.recoveryInstanceID = recoveryInstanceID
        }

        public func validate(name: String) throws {
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceID = "recoveryInstanceID"
        }
    }

    public struct StopReplicationRequest: AWSEncodableShape {
        /// The ID of the Source Server to stop replication for.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID = "sourceServerID"
        }
    }

    public struct StopReplicationResponse: AWSDecodableShape {
        /// The Source Server that this action was targeted on.
        public let sourceServer: SourceServer?

        public init(sourceServer: SourceServer? = nil) {
            self.sourceServer = sourceServer
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServer = "sourceServer"
        }
    }

    public struct StopSourceNetworkReplicationRequest: AWSEncodableShape {
        /// ID of the Source Network to stop replication.
        public let sourceNetworkID: String

        public init(sourceNetworkID: String) {
            self.sourceNetworkID = sourceNetworkID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, max: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, min: 20)
            try self.validate(self.sourceNetworkID, name: "sourceNetworkID", parent: name, pattern: "^sn-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }

    public struct StopSourceNetworkReplicationResponse: AWSDecodableShape {
        /// Source Network which was requested to stop replication.
        public let sourceNetwork: SourceNetwork?

        public init(sourceNetwork: SourceNetwork? = nil) {
            self.sourceNetwork = sourceNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetwork = "sourceNetwork"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// ARN of the resource for which tags are to be added or updated.
        public let resourceArn: String
        /// Array of tags to be added or updated.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TerminateRecoveryInstancesRequest: AWSEncodableShape {
        /// The IDs of the Recovery Instances that should be terminated.
        public let recoveryInstanceIDs: [String]

        public init(recoveryInstanceIDs: [String]) {
            self.recoveryInstanceIDs = recoveryInstanceIDs
        }

        public func validate(name: String) throws {
            try self.recoveryInstanceIDs.forEach {
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, max: 19)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, min: 10)
                try validate($0, name: "recoveryInstanceIDs[]", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.recoveryInstanceIDs, name: "recoveryInstanceIDs", parent: name, max: 200)
            try self.validate(self.recoveryInstanceIDs, name: "recoveryInstanceIDs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryInstanceIDs = "recoveryInstanceIDs"
        }
    }

    public struct TerminateRecoveryInstancesResponse: AWSDecodableShape {
        /// The Job for terminating the Recovery Instances.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// ARN of the resource for which tags are to be removed.
        public let resourceArn: String
        /// Array of tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateFailbackReplicationConfigurationRequest: AWSEncodableShape {
        /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
        public let bandwidthThrottling: Int64?
        /// The name of the Failback Replication Configuration.
        public let name: String?
        /// The ID of the Recovery Instance.
        public let recoveryInstanceID: String
        /// Whether to use Private IP for the failback replication of the Recovery Instance.
        public let usePrivateIP: Bool?

        public init(bandwidthThrottling: Int64? = nil, name: String? = nil, recoveryInstanceID: String, usePrivateIP: Bool? = nil) {
            self.bandwidthThrottling = bandwidthThrottling
            self.name = name
            self.recoveryInstanceID = recoveryInstanceID
            self.usePrivateIP = usePrivateIP
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, max: 19)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, min: 10)
            try self.validate(self.recoveryInstanceID, name: "recoveryInstanceID", parent: name, pattern: "^i-[0-9a-fA-F]{8,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthThrottling = "bandwidthThrottling"
            case name = "name"
            case recoveryInstanceID = "recoveryInstanceID"
            case usePrivateIP = "usePrivateIP"
        }
    }

    public struct UpdateLaunchConfigurationRequest: AWSEncodableShape {
        /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
        public let copyPrivateIp: Bool?
        /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
        public let copyTags: Bool?
        /// The state of the Recovery Instance in EC2 after the recovery operation.
        public let launchDisposition: LaunchDisposition?
        /// Launch into existing instance properties.
        public let launchIntoInstanceProperties: LaunchIntoInstanceProperties?
        /// The licensing configuration to be used for this launch configuration.
        public let licensing: Licensing?
        /// The name of the launch configuration.
        public let name: String?
        /// Whether we want to enable post-launch actions for the Source Server.
        public let postLaunchEnabled: Bool?
        /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
        public let sourceServerID: String
        /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, launchDisposition: LaunchDisposition? = nil, launchIntoInstanceProperties: LaunchIntoInstanceProperties? = nil, licensing: Licensing? = nil, name: String? = nil, postLaunchEnabled: Bool? = nil, sourceServerID: String, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.launchDisposition = launchDisposition
            self.launchIntoInstanceProperties = launchIntoInstanceProperties
            self.licensing = licensing
            self.name = name
            self.postLaunchEnabled = postLaunchEnabled
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.launchIntoInstanceProperties?.validate(name: "\(name).launchIntoInstanceProperties")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case launchDisposition = "launchDisposition"
            case launchIntoInstanceProperties = "launchIntoInstanceProperties"
            case licensing = "licensing"
            case name = "name"
            case postLaunchEnabled = "postLaunchEnabled"
            case sourceServerID = "sourceServerID"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct UpdateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Copy private IP.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// S3 bucket ARN to export Source Network templates.
        public let exportBucketArn: String?
        /// Launch Configuration Template ID.
        public let launchConfigurationTemplateID: String
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        /// DRS will set the 'launch into instance ID' of any source server when performing a drill, recovery or failback to the previous region or availability zone, using the instance ID of the source instance.
        public let launchIntoSourceInstance: Bool?
        /// Licensing.
        public let licensing: Licensing?
        /// Whether we want to activate post-launch actions.
        public let postLaunchEnabled: Bool?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, exportBucketArn: String? = nil, launchConfigurationTemplateID: String, launchDisposition: LaunchDisposition? = nil, launchIntoSourceInstance: Bool? = nil, licensing: Licensing? = nil, postLaunchEnabled: Bool? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.exportBucketArn = exportBucketArn
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.launchIntoSourceInstance = launchIntoSourceInstance
            self.licensing = licensing
            self.postLaunchEnabled = postLaunchEnabled
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, max: 2048)
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, min: 20)
            try self.validate(self.exportBucketArn, name: "exportBucketArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case exportBucketArn = "exportBucketArn"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case launchDisposition = "launchDisposition"
            case launchIntoSourceInstance = "launchIntoSourceInstance"
            case licensing = "licensing"
            case postLaunchEnabled = "postLaunchEnabled"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct UpdateLaunchConfigurationTemplateResponse: AWSDecodableShape {
        /// Updated Launch Configuration Template.
        public let launchConfigurationTemplate: LaunchConfigurationTemplate?

        public init(launchConfigurationTemplate: LaunchConfigurationTemplate? = nil) {
            self.launchConfigurationTemplate = launchConfigurationTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplate = "launchConfigurationTemplate"
        }
    }

    public struct UpdateReplicationConfigurationRequest: AWSEncodableShape {
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
        public let associateDefaultSecurityGroup: Bool?
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public let autoReplicateNewDisks: Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public let bandwidthThrottling: Int64?
        /// Whether to create a Public IP for the Recovery Instance by default.
        public let createPublicIP: Bool?
        /// The data plane routing mechanism that will be used for replication.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public let ebsEncryptionKeyArn: String?
        /// The name of the Replication Configuration.
        public let name: String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public let pitPolicy: [PITPolicyRule]?
        /// The configuration of the disks of the Source Server to be replicated.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// The instance type to be used for the replication server.
        public let replicationServerInstanceType: String?
        /// The security group IDs that will be used by the replication server.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// The ID of the Source Server for this Replication Configuration.
        public let sourceServerID: String
        /// The subnet to be used by the replication staging area.
        public let stagingAreaSubnetId: String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public let stagingAreaTags: [String: String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, autoReplicateNewDisks: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, pitPolicy: [PITPolicyRule]? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.pitPolicy = pitPolicy
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.pitPolicy?.forEach {
                try $0.validate(name: "\(name).pitPolicy[]")
            }
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, max: 10)
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, min: 1)
            try self.replicatedDisks?.forEach {
                try $0.validate(name: "\(name).replicatedDisks[]")
            }
            try self.validate(self.replicatedDisks, name: "replicatedDisks", parent: name, max: 60)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case autoReplicateNewDisks = "autoReplicateNewDisks"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case name = "name"
            case pitPolicy = "pitPolicy"
            case replicatedDisks = "replicatedDisks"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case sourceServerID = "sourceServerID"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
        }
    }

    public struct UpdateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// The Replication Configuration Template ARN.
        public let arn: String?
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
        public let associateDefaultSecurityGroup: Bool?
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public let autoReplicateNewDisks: Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public let bandwidthThrottling: Int64?
        /// Whether to create a Public IP for the Recovery Instance by default.
        public let createPublicIP: Bool?
        /// The data plane routing mechanism that will be used for replication.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public let ebsEncryptionKeyArn: String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public let pitPolicy: [PITPolicyRule]?
        /// The Replication Configuration Template ID.
        public let replicationConfigurationTemplateID: String
        /// The instance type to be used for the replication server.
        public let replicationServerInstanceType: String?
        /// The security group IDs that will be used by the replication server.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// The subnet to be used by the replication staging area.
        public let stagingAreaSubnetId: String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public let stagingAreaTags: [String: String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, autoReplicateNewDisks: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, pitPolicy: [PITPolicyRule]? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.pitPolicy = pitPolicy
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, pattern: "^arn:.{16,2044}$")
            try self.pitPolicy?.forEach {
                try $0.validate(name: "\(name).pitPolicy[]")
            }
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, max: 10)
            try self.validate(self.pitPolicy, name: "pitPolicy", parent: name, min: 1)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case autoReplicateNewDisks = "autoReplicateNewDisks"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case pitPolicy = "pitPolicy"
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
        }
    }

    public struct EventResourceData: AWSDecodableShape {
        /// Source Network properties.
        public let sourceNetworkData: SourceNetworkData?

        public init(sourceNetworkData: SourceNetworkData? = nil) {
            self.sourceNetworkData = sourceNetworkData
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkData = "sourceNetworkData"
        }
    }

    public struct ParticipatingResourceID: AWSDecodableShape {
        /// Source Network ID.
        public let sourceNetworkID: String?

        public init(sourceNetworkID: String? = nil) {
            self.sourceNetworkID = sourceNetworkID
        }

        private enum CodingKeys: String, CodingKey {
            case sourceNetworkID = "sourceNetworkID"
        }
    }
}

// MARK: - Errors

/// Error enum for Drs
public struct DrsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case uninitializedAccountException = "UninitializedAccountException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Drs
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed due to a conflict with the current state of the target resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource for this operation was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request could not be completed because its exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The account performing the request has not been initialized.
    public static var uninitializedAccountException: Self { .init(.uninitializedAccountException) }
    /// The input fails to satisfy the constraints specified by the AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension DrsErrorType: Equatable {
    public static func == (lhs: DrsErrorType, rhs: DrsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DrsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
