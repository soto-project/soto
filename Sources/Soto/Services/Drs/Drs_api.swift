//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Drs service.
///
/// AWS Elastic Disaster Recovery Service.
public struct Drs: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Drs client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Drs",
            serviceIdentifier: "drs",
            serviceProtocol: .restjson,
            apiVersion: "2020-02-26",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: DrsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "drs-fips.us-east-1.amazonaws.com",
            "us-east-2": "drs-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "drs-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "drs-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "drs-fips.us-west-1.amazonaws.com",
            "us-west-2": "drs-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Associate a Source Network to an existing CloudFormation Stack and modify launch templates to use this network. Can be used for reverting to previously deployed CloudFormation stacks.
    @Sendable
    @inlinable
    public func associateSourceNetworkStack(_ input: AssociateSourceNetworkStackRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateSourceNetworkStackResponse {
        try await self.client.execute(
            operation: "AssociateSourceNetworkStack", 
            path: "/AssociateSourceNetworkStack", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate a Source Network to an existing CloudFormation Stack and modify launch templates to use this network. Can be used for reverting to previously deployed CloudFormation stacks.
    ///
    /// Parameters:
    ///   - cfnStackName: CloudFormation template to associate with a Source Network.
    ///   - sourceNetworkID: The Source Network ID to associate with CloudFormation template.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateSourceNetworkStack(
        cfnStackName: String,
        sourceNetworkID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateSourceNetworkStackResponse {
        let input = AssociateSourceNetworkStackRequest(
            cfnStackName: cfnStackName, 
            sourceNetworkID: sourceNetworkID
        )
        return try await self.associateSourceNetworkStack(input, logger: logger)
    }

    /// Create an extended source server in the target Account based on the source server in staging account.
    @Sendable
    @inlinable
    public func createExtendedSourceServer(_ input: CreateExtendedSourceServerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateExtendedSourceServerResponse {
        try await self.client.execute(
            operation: "CreateExtendedSourceServer", 
            path: "/CreateExtendedSourceServer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create an extended source server in the target Account based on the source server in staging account.
    ///
    /// Parameters:
    ///   - sourceServerArn: This defines the ARN of the source server in staging Account based on which you want to create an extended source server.
    ///   - tags: A list of tags associated with the extended source server.
    ///   - logger: Logger use during operation
    @inlinable
    public func createExtendedSourceServer(
        sourceServerArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateExtendedSourceServerResponse {
        let input = CreateExtendedSourceServerRequest(
            sourceServerArn: sourceServerArn, 
            tags: tags
        )
        return try await self.createExtendedSourceServer(input, logger: logger)
    }

    /// Creates a new Launch Configuration Template.
    @Sendable
    @inlinable
    public func createLaunchConfigurationTemplate(_ input: CreateLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLaunchConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "CreateLaunchConfigurationTemplate", 
            path: "/CreateLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Launch Configuration Template.
    ///
    /// Parameters:
    ///   - copyPrivateIp: Copy private IP.
    ///   - copyTags: Copy tags.
    ///   - exportBucketArn: S3 bucket ARN to export Source Network templates.
    ///   - launchDisposition: Launch disposition.
    ///   - launchIntoSourceInstance: DRS will set the 'launch into instance ID' of any source server when performing a drill, recovery or failback to the previous region or availability zone, using the instance ID of the source instance.
    ///   - licensing: Licensing.
    ///   - postLaunchEnabled: Whether we want to activate post-launch actions.
    ///   - tags: Request to associate tags during creation of a Launch Configuration Template.
    ///   - targetInstanceTypeRightSizingMethod: Target instance type right-sizing method.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLaunchConfigurationTemplate(
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        exportBucketArn: String? = nil,
        launchDisposition: LaunchDisposition? = nil,
        launchIntoSourceInstance: Bool? = nil,
        licensing: Licensing? = nil,
        postLaunchEnabled: Bool? = nil,
        tags: [String: String]? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLaunchConfigurationTemplateResponse {
        let input = CreateLaunchConfigurationTemplateRequest(
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            exportBucketArn: exportBucketArn, 
            launchDisposition: launchDisposition, 
            launchIntoSourceInstance: launchIntoSourceInstance, 
            licensing: licensing, 
            postLaunchEnabled: postLaunchEnabled, 
            tags: tags, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.createLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Creates a new ReplicationConfigurationTemplate.
    @Sendable
    @inlinable
    public func createReplicationConfigurationTemplate(_ input: CreateReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfigurationTemplate {
        try await self.client.execute(
            operation: "CreateReplicationConfigurationTemplate", 
            path: "/CreateReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new ReplicationConfigurationTemplate.
    ///
    /// Parameters:
    ///   - associateDefaultSecurityGroup: Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    ///   - autoReplicateNewDisks: Whether to allow the AWS replication agent to automatically replicate newly added disks.
    ///   - bandwidthThrottling: Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    ///   - createPublicIP: Whether to create a Public IP for the Recovery Instance by default.
    ///   - dataPlaneRouting: The data plane routing mechanism that will be used for replication.
    ///   - defaultLargeStagingDiskType: The Staging Disk EBS volume type to be used during replication.
    ///   - ebsEncryption: The type of EBS encryption to be used during replication.
    ///   - ebsEncryptionKeyArn: The ARN of the EBS encryption key to be used during replication.
    ///   - pitPolicy: The Point in time (PIT) policy to manage snapshots taken during replication.
    ///   - replicationServerInstanceType: The instance type to be used for the replication server.
    ///   - replicationServersSecurityGroupsIDs: The security group IDs that will be used by the replication server.
    ///   - stagingAreaSubnetId: The subnet to be used by the replication staging area.
    ///   - stagingAreaTags: A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    ///   - tags: A set of tags to be associated with the Replication Configuration Template resource.
    ///   - useDedicatedReplicationServer: Whether to use a dedicated Replication Server in the replication staging area.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReplicationConfigurationTemplate(
        associateDefaultSecurityGroup: Bool,
        autoReplicateNewDisks: Bool? = nil,
        bandwidthThrottling: Int64 = 0,
        createPublicIP: Bool,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType,
        ebsEncryption: ReplicationConfigurationEbsEncryption,
        ebsEncryptionKeyArn: String? = nil,
        pitPolicy: [PITPolicyRule],
        replicationServerInstanceType: String,
        replicationServersSecurityGroupsIDs: [String],
        stagingAreaSubnetId: String,
        stagingAreaTags: [String: String],
        tags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfigurationTemplate {
        let input = CreateReplicationConfigurationTemplateRequest(
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            autoReplicateNewDisks: autoReplicateNewDisks, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            pitPolicy: pitPolicy, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            tags: tags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer
        )
        return try await self.createReplicationConfigurationTemplate(input, logger: logger)
    }

    /// Create a new Source Network resource for a provided VPC ID.
    @Sendable
    @inlinable
    public func createSourceNetwork(_ input: CreateSourceNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSourceNetworkResponse {
        try await self.client.execute(
            operation: "CreateSourceNetwork", 
            path: "/CreateSourceNetwork", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new Source Network resource for a provided VPC ID.
    ///
    /// Parameters:
    ///   - originAccountID: Account containing the VPC to protect.
    ///   - originRegion: Region containing the VPC to protect.
    ///   - tags: A set of tags to be associated with the Source Network resource.
    ///   - vpcID: Which VPC ID to protect.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSourceNetwork(
        originAccountID: String,
        originRegion: String,
        tags: [String: String]? = nil,
        vpcID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSourceNetworkResponse {
        let input = CreateSourceNetworkRequest(
            originAccountID: originAccountID, 
            originRegion: originRegion, 
            tags: tags, 
            vpcID: vpcID
        )
        return try await self.createSourceNetwork(input, logger: logger)
    }

    /// Deletes a single Job by ID.
    @Sendable
    @inlinable
    public func deleteJob(_ input: DeleteJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobResponse {
        try await self.client.execute(
            operation: "DeleteJob", 
            path: "/DeleteJob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Job by ID.
    ///
    /// Parameters:
    ///   - jobID: The ID of the Job to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJob(
        jobID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobResponse {
        let input = DeleteJobRequest(
            jobID: jobID
        )
        return try await self.deleteJob(input, logger: logger)
    }

    /// Deletes a resource launch action.
    @Sendable
    @inlinable
    public func deleteLaunchAction(_ input: DeleteLaunchActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLaunchActionResponse {
        try await self.client.execute(
            operation: "DeleteLaunchAction", 
            path: "/DeleteLaunchAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a resource launch action.
    ///
    /// Parameters:
    ///   - actionId: 
    ///   - resourceId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLaunchAction(
        actionId: String,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLaunchActionResponse {
        let input = DeleteLaunchActionRequest(
            actionId: actionId, 
            resourceId: resourceId
        )
        return try await self.deleteLaunchAction(input, logger: logger)
    }

    /// Deletes a single Launch Configuration Template by ID.
    @Sendable
    @inlinable
    public func deleteLaunchConfigurationTemplate(_ input: DeleteLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLaunchConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "DeleteLaunchConfigurationTemplate", 
            path: "/DeleteLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Launch Configuration Template by ID.
    ///
    /// Parameters:
    ///   - launchConfigurationTemplateID: The ID of the Launch Configuration Template to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLaunchConfigurationTemplate(
        launchConfigurationTemplateID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLaunchConfigurationTemplateResponse {
        let input = DeleteLaunchConfigurationTemplateRequest(
            launchConfigurationTemplateID: launchConfigurationTemplateID
        )
        return try await self.deleteLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Deletes a single Recovery Instance by ID. This deletes the Recovery Instance resource from Elastic Disaster Recovery. The Recovery Instance must be disconnected first in order to delete it.
    @Sendable
    @inlinable
    public func deleteRecoveryInstance(_ input: DeleteRecoveryInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRecoveryInstance", 
            path: "/DeleteRecoveryInstance", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Recovery Instance by ID. This deletes the Recovery Instance resource from Elastic Disaster Recovery. The Recovery Instance must be disconnected first in order to delete it.
    ///
    /// Parameters:
    ///   - recoveryInstanceID: The ID of the Recovery Instance to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRecoveryInstance(
        recoveryInstanceID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRecoveryInstanceRequest(
            recoveryInstanceID: recoveryInstanceID
        )
        return try await self.deleteRecoveryInstance(input, logger: logger)
    }

    /// Deletes a single Replication Configuration Template by ID
    @Sendable
    @inlinable
    public func deleteReplicationConfigurationTemplate(_ input: DeleteReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "DeleteReplicationConfigurationTemplate", 
            path: "/DeleteReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Replication Configuration Template by ID
    ///
    /// Parameters:
    ///   - replicationConfigurationTemplateID: The ID of the Replication Configuration Template to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReplicationConfigurationTemplate(
        replicationConfigurationTemplateID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReplicationConfigurationTemplateResponse {
        let input = DeleteReplicationConfigurationTemplateRequest(
            replicationConfigurationTemplateID: replicationConfigurationTemplateID
        )
        return try await self.deleteReplicationConfigurationTemplate(input, logger: logger)
    }

    /// Delete Source Network resource.
    @Sendable
    @inlinable
    public func deleteSourceNetwork(_ input: DeleteSourceNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSourceNetworkResponse {
        try await self.client.execute(
            operation: "DeleteSourceNetwork", 
            path: "/DeleteSourceNetwork", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete Source Network resource.
    ///
    /// Parameters:
    ///   - sourceNetworkID: ID of the Source Network to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSourceNetwork(
        sourceNetworkID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSourceNetworkResponse {
        let input = DeleteSourceNetworkRequest(
            sourceNetworkID: sourceNetworkID
        )
        return try await self.deleteSourceNetwork(input, logger: logger)
    }

    /// Deletes a single Source Server by ID. The Source Server must be disconnected first.
    @Sendable
    @inlinable
    public func deleteSourceServer(_ input: DeleteSourceServerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSourceServerResponse {
        try await self.client.execute(
            operation: "DeleteSourceServer", 
            path: "/DeleteSourceServer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Source Server by ID. The Source Server must be disconnected first.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSourceServer(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSourceServerResponse {
        let input = DeleteSourceServerRequest(
            sourceServerID: sourceServerID
        )
        return try await self.deleteSourceServer(input, logger: logger)
    }

    /// Retrieves a detailed Job log with pagination.
    @Sendable
    @inlinable
    public func describeJobLogItems(_ input: DescribeJobLogItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobLogItemsResponse {
        try await self.client.execute(
            operation: "DescribeJobLogItems", 
            path: "/DescribeJobLogItems", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a detailed Job log with pagination.
    ///
    /// Parameters:
    ///   - jobID: The ID of the Job for which Job log items will be retrieved.
    ///   - maxResults: Maximum number of Job log items to retrieve.
    ///   - nextToken: The token of the next Job log items to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobLogItems(
        jobID: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobLogItemsResponse {
        let input = DescribeJobLogItemsRequest(
            jobID: jobID, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeJobLogItems(input, logger: logger)
    }

    /// Returns a list of Jobs. Use the JobsID and fromDate and toDate filters to limit which jobs are returned. The response is sorted by creationDataTime - latest date first. Jobs are created by the StartRecovery, TerminateRecoveryInstances and StartFailbackLaunch APIs. Jobs are also created by DiagnosticLaunch and TerminateDiagnosticInstances, which are APIs available only to *Support* and only used in response to relevant support tickets.
    @Sendable
    @inlinable
    public func describeJobs(_ input: DescribeJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobsResponse {
        try await self.client.execute(
            operation: "DescribeJobs", 
            path: "/DescribeJobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of Jobs. Use the JobsID and fromDate and toDate filters to limit which jobs are returned. The response is sorted by creationDataTime - latest date first. Jobs are created by the StartRecovery, TerminateRecoveryInstances and StartFailbackLaunch APIs. Jobs are also created by DiagnosticLaunch and TerminateDiagnosticInstances, which are APIs available only to *Support* and only used in response to relevant support tickets.
    ///
    /// Parameters:
    ///   - filters: A set of filters by which to return Jobs.
    ///   - maxResults: Maximum number of Jobs to retrieve.
    ///   - nextToken: The token of the next Job to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobs(
        filters: DescribeJobsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobsResponse {
        let input = DescribeJobsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeJobs(input, logger: logger)
    }

    /// Lists all Launch Configuration Templates, filtered by Launch Configuration Template IDs
    @Sendable
    @inlinable
    public func describeLaunchConfigurationTemplates(_ input: DescribeLaunchConfigurationTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLaunchConfigurationTemplatesResponse {
        try await self.client.execute(
            operation: "DescribeLaunchConfigurationTemplates", 
            path: "/DescribeLaunchConfigurationTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Launch Configuration Templates, filtered by Launch Configuration Template IDs
    ///
    /// Parameters:
    ///   - launchConfigurationTemplateIDs: Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    ///   - maxResults: Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    ///   - nextToken: The token of the next Launch Configuration Template to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLaunchConfigurationTemplates(
        launchConfigurationTemplateIDs: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLaunchConfigurationTemplatesResponse {
        let input = DescribeLaunchConfigurationTemplatesRequest(
            launchConfigurationTemplateIDs: launchConfigurationTemplateIDs, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeLaunchConfigurationTemplates(input, logger: logger)
    }

    /// Lists all Recovery Instances or multiple Recovery Instances by ID.
    @Sendable
    @inlinable
    public func describeRecoveryInstances(_ input: DescribeRecoveryInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRecoveryInstancesResponse {
        try await self.client.execute(
            operation: "DescribeRecoveryInstances", 
            path: "/DescribeRecoveryInstances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Recovery Instances or multiple Recovery Instances by ID.
    ///
    /// Parameters:
    ///   - filters: A set of filters by which to return Recovery Instances.
    ///   - maxResults: Maximum number of Recovery Instances to retrieve.
    ///   - nextToken: The token of the next Recovery Instance to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRecoveryInstances(
        filters: DescribeRecoveryInstancesRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRecoveryInstancesResponse {
        let input = DescribeRecoveryInstancesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeRecoveryInstances(input, logger: logger)
    }

    /// Lists all Recovery Snapshots for a single Source Server.
    @Sendable
    @inlinable
    public func describeRecoverySnapshots(_ input: DescribeRecoverySnapshotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRecoverySnapshotsResponse {
        try await self.client.execute(
            operation: "DescribeRecoverySnapshots", 
            path: "/DescribeRecoverySnapshots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Recovery Snapshots for a single Source Server.
    ///
    /// Parameters:
    ///   - filters: A set of filters by which to return Recovery Snapshots.
    ///   - maxResults: Maximum number of Recovery Snapshots to retrieve.
    ///   - nextToken: The token of the next Recovery Snapshot to retrieve.
    ///   - order: The sorted ordering by which to return Recovery Snapshots.
    ///   - sourceServerID: Filter Recovery Snapshots by Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRecoverySnapshots(
        filters: DescribeRecoverySnapshotsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: RecoverySnapshotsOrder? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRecoverySnapshotsResponse {
        let input = DescribeRecoverySnapshotsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order, 
            sourceServerID: sourceServerID
        )
        return try await self.describeRecoverySnapshots(input, logger: logger)
    }

    /// Lists all ReplicationConfigurationTemplates, filtered by Source Server IDs.
    @Sendable
    @inlinable
    public func describeReplicationConfigurationTemplates(_ input: DescribeReplicationConfigurationTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationConfigurationTemplatesResponse {
        try await self.client.execute(
            operation: "DescribeReplicationConfigurationTemplates", 
            path: "/DescribeReplicationConfigurationTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all ReplicationConfigurationTemplates, filtered by Source Server IDs.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of Replication Configuration Templates to retrieve.
    ///   - nextToken: The token of the next Replication Configuration Template to retrieve.
    ///   - replicationConfigurationTemplateIDs: The IDs of the Replication Configuration Templates to retrieve. An empty list means all Replication Configuration Templates.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReplicationConfigurationTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationConfigurationTemplateIDs: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReplicationConfigurationTemplatesResponse {
        let input = DescribeReplicationConfigurationTemplatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicationConfigurationTemplateIDs: replicationConfigurationTemplateIDs
        )
        return try await self.describeReplicationConfigurationTemplates(input, logger: logger)
    }

    /// Lists all Source Networks or multiple Source Networks filtered by ID.
    @Sendable
    @inlinable
    public func describeSourceNetworks(_ input: DescribeSourceNetworksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSourceNetworksResponse {
        try await self.client.execute(
            operation: "DescribeSourceNetworks", 
            path: "/DescribeSourceNetworks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Source Networks or multiple Source Networks filtered by ID.
    ///
    /// Parameters:
    ///   - filters: A set of filters by which to return Source Networks.
    ///   - maxResults: Maximum number of Source Networks to retrieve.
    ///   - nextToken: The token of the next Source Networks to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSourceNetworks(
        filters: DescribeSourceNetworksRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSourceNetworksResponse {
        let input = DescribeSourceNetworksRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeSourceNetworks(input, logger: logger)
    }

    /// Lists all Source Servers or multiple Source Servers filtered by ID.
    @Sendable
    @inlinable
    public func describeSourceServers(_ input: DescribeSourceServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSourceServersResponse {
        try await self.client.execute(
            operation: "DescribeSourceServers", 
            path: "/DescribeSourceServers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Source Servers or multiple Source Servers filtered by ID.
    ///
    /// Parameters:
    ///   - filters: A set of filters by which to return Source Servers.
    ///   - maxResults: Maximum number of Source Servers to retrieve.
    ///   - nextToken: The token of the next Source Server to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSourceServers(
        filters: DescribeSourceServersRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSourceServersResponse {
        let input = DescribeSourceServersRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeSourceServers(input, logger: logger)
    }

    /// Disconnect a Recovery Instance from Elastic Disaster Recovery. Data replication is stopped immediately. All AWS resources created by Elastic Disaster Recovery for enabling the replication of the Recovery Instance will be terminated / deleted within 90 minutes. If the agent on the Recovery Instance has not been prevented from communicating with the Elastic Disaster Recovery service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the Recovery Instance will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    @Sendable
    @inlinable
    public func disconnectRecoveryInstance(_ input: DisconnectRecoveryInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DisconnectRecoveryInstance", 
            path: "/DisconnectRecoveryInstance", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disconnect a Recovery Instance from Elastic Disaster Recovery. Data replication is stopped immediately. All AWS resources created by Elastic Disaster Recovery for enabling the replication of the Recovery Instance will be terminated / deleted within 90 minutes. If the agent on the Recovery Instance has not been prevented from communicating with the Elastic Disaster Recovery service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the Recovery Instance will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    ///
    /// Parameters:
    ///   - recoveryInstanceID: The ID of the Recovery Instance to disconnect.
    ///   - logger: Logger use during operation
    @inlinable
    public func disconnectRecoveryInstance(
        recoveryInstanceID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DisconnectRecoveryInstanceRequest(
            recoveryInstanceID: recoveryInstanceID
        )
        return try await self.disconnectRecoveryInstance(input, logger: logger)
    }

    /// Disconnects a specific Source Server from Elastic Disaster Recovery. Data replication is stopped immediately. All AWS resources created by Elastic Disaster Recovery for enabling the replication of the Source Server will be terminated / deleted within 90 minutes. You cannot disconnect a Source Server if it has a Recovery Instance. If the agent on the Source Server has not been prevented from communicating with the Elastic Disaster Recovery service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    @Sendable
    @inlinable
    public func disconnectSourceServer(_ input: DisconnectSourceServerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "DisconnectSourceServer", 
            path: "/DisconnectSourceServer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disconnects a specific Source Server from Elastic Disaster Recovery. Data replication is stopped immediately. All AWS resources created by Elastic Disaster Recovery for enabling the replication of the Source Server will be terminated / deleted within 90 minutes. You cannot disconnect a Source Server if it has a Recovery Instance. If the agent on the Source Server has not been prevented from communicating with the Elastic Disaster Recovery service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server to disconnect.
    ///   - logger: Logger use during operation
    @inlinable
    public func disconnectSourceServer(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = DisconnectSourceServerRequest(
            sourceServerID: sourceServerID
        )
        return try await self.disconnectSourceServer(input, logger: logger)
    }

    /// Export the Source Network CloudFormation template to an S3 bucket.
    @Sendable
    @inlinable
    public func exportSourceNetworkCfnTemplate(_ input: ExportSourceNetworkCfnTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ExportSourceNetworkCfnTemplateResponse {
        try await self.client.execute(
            operation: "ExportSourceNetworkCfnTemplate", 
            path: "/ExportSourceNetworkCfnTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Export the Source Network CloudFormation template to an S3 bucket.
    ///
    /// Parameters:
    ///   - sourceNetworkID: The Source Network ID to export its CloudFormation template to an S3 bucket.
    ///   - logger: Logger use during operation
    @inlinable
    public func exportSourceNetworkCfnTemplate(
        sourceNetworkID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ExportSourceNetworkCfnTemplateResponse {
        let input = ExportSourceNetworkCfnTemplateRequest(
            sourceNetworkID: sourceNetworkID
        )
        return try await self.exportSourceNetworkCfnTemplate(input, logger: logger)
    }

    /// Lists all Failback ReplicationConfigurations, filtered by Recovery Instance ID.
    @Sendable
    @inlinable
    public func getFailbackReplicationConfiguration(_ input: GetFailbackReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFailbackReplicationConfigurationResponse {
        try await self.client.execute(
            operation: "GetFailbackReplicationConfiguration", 
            path: "/GetFailbackReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Failback ReplicationConfigurations, filtered by Recovery Instance ID.
    ///
    /// Parameters:
    ///   - recoveryInstanceID: The ID of the Recovery Instance whose failback replication configuration should be returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFailbackReplicationConfiguration(
        recoveryInstanceID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFailbackReplicationConfigurationResponse {
        let input = GetFailbackReplicationConfigurationRequest(
            recoveryInstanceID: recoveryInstanceID
        )
        return try await self.getFailbackReplicationConfiguration(input, logger: logger)
    }

    /// Gets a LaunchConfiguration, filtered by Source Server IDs.
    @Sendable
    @inlinable
    public func getLaunchConfiguration(_ input: GetLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfiguration {
        try await self.client.execute(
            operation: "GetLaunchConfiguration", 
            path: "/GetLaunchConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a LaunchConfiguration, filtered by Source Server IDs.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server that we want to retrieve a Launch Configuration for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchConfiguration(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfiguration {
        let input = GetLaunchConfigurationRequest(
            sourceServerID: sourceServerID
        )
        return try await self.getLaunchConfiguration(input, logger: logger)
    }

    /// Gets a ReplicationConfiguration, filtered by Source Server ID.
    @Sendable
    @inlinable
    public func getReplicationConfiguration(_ input: GetReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfiguration {
        try await self.client.execute(
            operation: "GetReplicationConfiguration", 
            path: "/GetReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a ReplicationConfiguration, filtered by Source Server ID.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Serve for this Replication Configuration.r
    ///   - logger: Logger use during operation
    @inlinable
    public func getReplicationConfiguration(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfiguration {
        let input = GetReplicationConfigurationRequest(
            sourceServerID: sourceServerID
        )
        return try await self.getReplicationConfiguration(input, logger: logger)
    }

    /// Initialize Elastic Disaster Recovery.
    @Sendable
    @inlinable
    public func initializeService(_ input: InitializeServiceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> InitializeServiceResponse {
        try await self.client.execute(
            operation: "InitializeService", 
            path: "/InitializeService", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initialize Elastic Disaster Recovery.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func initializeService(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> InitializeServiceResponse {
        let input = InitializeServiceRequest(
        )
        return try await self.initializeService(input, logger: logger)
    }

    /// Returns a list of source servers on a staging account that are extensible, which means that: a. The source server is not already extended into this Account. b. The source server on the Account we’re reading from is not an extension of another source server.
    @Sendable
    @inlinable
    public func listExtensibleSourceServers(_ input: ListExtensibleSourceServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExtensibleSourceServersResponse {
        try await self.client.execute(
            operation: "ListExtensibleSourceServers", 
            path: "/ListExtensibleSourceServers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of source servers on a staging account that are extensible, which means that: a. The source server is not already extended into this Account. b. The source server on the Account we’re reading from is not an extension of another source server.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of extensible source servers to retrieve.
    ///   - nextToken: The token of the next extensible source server to retrieve.
    ///   - stagingAccountID: The Id of the staging Account to retrieve extensible source servers from.
    ///   - logger: Logger use during operation
    @inlinable
    public func listExtensibleSourceServers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stagingAccountID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListExtensibleSourceServersResponse {
        let input = ListExtensibleSourceServersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            stagingAccountID: stagingAccountID
        )
        return try await self.listExtensibleSourceServers(input, logger: logger)
    }

    /// Lists resource launch actions.
    @Sendable
    @inlinable
    public func listLaunchActions(_ input: ListLaunchActionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLaunchActionsResponse {
        try await self.client.execute(
            operation: "ListLaunchActions", 
            path: "/ListLaunchActions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists resource launch actions.
    ///
    /// Parameters:
    ///   - filters: Filters to apply when listing resource launch actions.
    ///   - maxResults: Maximum amount of items to return when listing resource launch actions.
    ///   - nextToken: Next token to use when listing resource launch actions.
    ///   - resourceId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listLaunchActions(
        filters: LaunchActionsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLaunchActionsResponse {
        let input = ListLaunchActionsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceId: resourceId
        )
        return try await self.listLaunchActions(input, logger: logger)
    }

    /// Returns an array of staging accounts for existing extended source servers.
    @Sendable
    @inlinable
    public func listStagingAccounts(_ input: ListStagingAccountsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStagingAccountsResponse {
        try await self.client.execute(
            operation: "ListStagingAccounts", 
            path: "/ListStagingAccounts", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns an array of staging accounts for existing extended source servers.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of staging Accounts to retrieve.
    ///   - nextToken: The token of the next staging Account to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStagingAccounts(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStagingAccountsResponse {
        let input = ListStagingAccountsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStagingAccounts(input, logger: logger)
    }

    /// List all tags for your Elastic Disaster Recovery resources.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all tags for your Elastic Disaster Recovery resources.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource whose tags should be returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Puts a resource launch action.
    @Sendable
    @inlinable
    public func putLaunchAction(_ input: PutLaunchActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutLaunchActionResponse {
        try await self.client.execute(
            operation: "PutLaunchAction", 
            path: "/PutLaunchAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Puts a resource launch action.
    ///
    /// Parameters:
    ///   - actionCode: Launch action code.
    ///   - actionId: 
    ///   - actionVersion: 
    ///   - active: Whether the launch action is active.
    ///   - category: 
    ///   - description: 
    ///   - name: 
    ///   - optional: Whether the launch will not be marked as failed if this action fails.
    ///   - order: 
    ///   - parameters: 
    ///   - resourceId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func putLaunchAction(
        actionCode: String,
        actionId: String,
        actionVersion: String,
        active: Bool,
        category: LaunchActionCategory,
        description: String,
        name: String,
        optional: Bool,
        order: Int,
        parameters: [String: LaunchActionParameter]? = nil,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutLaunchActionResponse {
        let input = PutLaunchActionRequest(
            actionCode: actionCode, 
            actionId: actionId, 
            actionVersion: actionVersion, 
            active: active, 
            category: category, 
            description: description, 
            name: name, 
            optional: optional, 
            order: order, 
            parameters: parameters, 
            resourceId: resourceId
        )
        return try await self.putLaunchAction(input, logger: logger)
    }

    /// WARNING: RetryDataReplication is deprecated. Causes the data replication initiation sequence to begin immediately upon next Handshake for the specified Source Server ID, regardless of when the previous initiation started. This command will work only if the Source Server is stalled or is in a DISCONNECTED or STOPPED state.
    @available(*, deprecated, message: "WARNING: RetryDataReplication is deprecated")
    @Sendable
    @inlinable
    public func retryDataReplication(_ input: RetryDataReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "RetryDataReplication", 
            path: "/RetryDataReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// WARNING: RetryDataReplication is deprecated. Causes the data replication initiation sequence to begin immediately upon next Handshake for the specified Source Server ID, regardless of when the previous initiation started. This command will work only if the Source Server is stalled or is in a DISCONNECTED or STOPPED state.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server whose data replication should be retried.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "WARNING: RetryDataReplication is deprecated")
    @inlinable
    public func retryDataReplication(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = RetryDataReplicationRequest(
            sourceServerID: sourceServerID
        )
        return try await self.retryDataReplication(input, logger: logger)
    }

    /// Start replication to origin / target region - applies only to protected instances that originated in EC2. For recovery instances on target region - starts replication back to origin region. For failback instances on origin region - starts replication to target region to re-protect them.
    @Sendable
    @inlinable
    public func reverseReplication(_ input: ReverseReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReverseReplicationResponse {
        try await self.client.execute(
            operation: "ReverseReplication", 
            path: "/ReverseReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start replication to origin / target region - applies only to protected instances that originated in EC2. For recovery instances on target region - starts replication back to origin region. For failback instances on origin region - starts replication to target region to re-protect them.
    ///
    /// Parameters:
    ///   - recoveryInstanceID: The ID of the Recovery Instance that we want to reverse the replication for.
    ///   - logger: Logger use during operation
    @inlinable
    public func reverseReplication(
        recoveryInstanceID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReverseReplicationResponse {
        let input = ReverseReplicationRequest(
            recoveryInstanceID: recoveryInstanceID
        )
        return try await self.reverseReplication(input, logger: logger)
    }

    /// Initiates a Job for launching the machine that is being failed back to from the specified Recovery Instance. This will run conversion on the failback client and will reboot your machine, thus completing the failback process.
    @Sendable
    @inlinable
    public func startFailbackLaunch(_ input: StartFailbackLaunchRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartFailbackLaunchResponse {
        try await self.client.execute(
            operation: "StartFailbackLaunch", 
            path: "/StartFailbackLaunch", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates a Job for launching the machine that is being failed back to from the specified Recovery Instance. This will run conversion on the failback client and will reboot your machine, thus completing the failback process.
    ///
    /// Parameters:
    ///   - recoveryInstanceIDs: The IDs of the Recovery Instance whose failback launch we want to request.
    ///   - tags: The tags to be associated with the failback launch Job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startFailbackLaunch(
        recoveryInstanceIDs: [String],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartFailbackLaunchResponse {
        let input = StartFailbackLaunchRequest(
            recoveryInstanceIDs: recoveryInstanceIDs, 
            tags: tags
        )
        return try await self.startFailbackLaunch(input, logger: logger)
    }

    /// Launches Recovery Instances for the specified Source Servers. For each Source Server you may choose a point in time snapshot to launch from, or use an on demand snapshot.
    @Sendable
    @inlinable
    public func startRecovery(_ input: StartRecoveryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartRecoveryResponse {
        try await self.client.execute(
            operation: "StartRecovery", 
            path: "/StartRecovery", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Launches Recovery Instances for the specified Source Servers. For each Source Server you may choose a point in time snapshot to launch from, or use an on demand snapshot.
    ///
    /// Parameters:
    ///   - isDrill: Whether this Source Server Recovery operation is a drill or not.
    ///   - sourceServers: The Source Servers that we want to start a Recovery Job for.
    ///   - tags: The tags to be associated with the Recovery Job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startRecovery(
        isDrill: Bool? = nil,
        sourceServers: [StartRecoveryRequestSourceServer],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartRecoveryResponse {
        let input = StartRecoveryRequest(
            isDrill: isDrill, 
            sourceServers: sourceServers, 
            tags: tags
        )
        return try await self.startRecovery(input, logger: logger)
    }

    /// Starts replication for a stopped Source Server. This action would make the Source Server protected again and restart billing for it.
    @Sendable
    @inlinable
    public func startReplication(_ input: StartReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReplicationResponse {
        try await self.client.execute(
            operation: "StartReplication", 
            path: "/StartReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts replication for a stopped Source Server. This action would make the Source Server protected again and restart billing for it.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server to start replication for.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReplication(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartReplicationResponse {
        let input = StartReplicationRequest(
            sourceServerID: sourceServerID
        )
        return try await self.startReplication(input, logger: logger)
    }

    /// Deploy VPC for the specified Source Network and modify launch templates to use this network. The VPC will be deployed using a dedicated CloudFormation stack.
    @Sendable
    @inlinable
    public func startSourceNetworkRecovery(_ input: StartSourceNetworkRecoveryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartSourceNetworkRecoveryResponse {
        try await self.client.execute(
            operation: "StartSourceNetworkRecovery", 
            path: "/StartSourceNetworkRecovery", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deploy VPC for the specified Source Network and modify launch templates to use this network. The VPC will be deployed using a dedicated CloudFormation stack.
    ///
    /// Parameters:
    ///   - deployAsNew: Don't update existing CloudFormation Stack, recover the network using a new stack.
    ///   - sourceNetworks: The Source Networks that we want to start a Recovery Job for.
    ///   - tags: The tags to be associated with the Source Network recovery Job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startSourceNetworkRecovery(
        deployAsNew: Bool? = nil,
        sourceNetworks: [StartSourceNetworkRecoveryRequestNetworkEntry],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartSourceNetworkRecoveryResponse {
        let input = StartSourceNetworkRecoveryRequest(
            deployAsNew: deployAsNew, 
            sourceNetworks: sourceNetworks, 
            tags: tags
        )
        return try await self.startSourceNetworkRecovery(input, logger: logger)
    }

    /// Starts replication for a Source Network. This action would make the Source Network protected.
    @Sendable
    @inlinable
    public func startSourceNetworkReplication(_ input: StartSourceNetworkReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartSourceNetworkReplicationResponse {
        try await self.client.execute(
            operation: "StartSourceNetworkReplication", 
            path: "/StartSourceNetworkReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts replication for a Source Network. This action would make the Source Network protected.
    ///
    /// Parameters:
    ///   - sourceNetworkID: ID of the Source Network to replicate.
    ///   - logger: Logger use during operation
    @inlinable
    public func startSourceNetworkReplication(
        sourceNetworkID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartSourceNetworkReplicationResponse {
        let input = StartSourceNetworkReplicationRequest(
            sourceNetworkID: sourceNetworkID
        )
        return try await self.startSourceNetworkReplication(input, logger: logger)
    }

    /// Stops the failback process for a specified Recovery Instance. This changes the Failback State of the Recovery Instance back to FAILBACK_NOT_STARTED.
    @Sendable
    @inlinable
    public func stopFailback(_ input: StopFailbackRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "StopFailback", 
            path: "/StopFailback", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops the failback process for a specified Recovery Instance. This changes the Failback State of the Recovery Instance back to FAILBACK_NOT_STARTED.
    ///
    /// Parameters:
    ///   - recoveryInstanceID: The ID of the Recovery Instance we want to stop failback for.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopFailback(
        recoveryInstanceID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = StopFailbackRequest(
            recoveryInstanceID: recoveryInstanceID
        )
        return try await self.stopFailback(input, logger: logger)
    }

    /// Stops replication for a Source Server. This action would make the Source Server unprotected, delete its existing snapshots and stop billing for it.
    @Sendable
    @inlinable
    public func stopReplication(_ input: StopReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopReplicationResponse {
        try await self.client.execute(
            operation: "StopReplication", 
            path: "/StopReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops replication for a Source Server. This action would make the Source Server unprotected, delete its existing snapshots and stop billing for it.
    ///
    /// Parameters:
    ///   - sourceServerID: The ID of the Source Server to stop replication for.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopReplication(
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopReplicationResponse {
        let input = StopReplicationRequest(
            sourceServerID: sourceServerID
        )
        return try await self.stopReplication(input, logger: logger)
    }

    /// Stops replication for a Source Network. This action would make the Source Network unprotected.
    @Sendable
    @inlinable
    public func stopSourceNetworkReplication(_ input: StopSourceNetworkReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopSourceNetworkReplicationResponse {
        try await self.client.execute(
            operation: "StopSourceNetworkReplication", 
            path: "/StopSourceNetworkReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops replication for a Source Network. This action would make the Source Network unprotected.
    ///
    /// Parameters:
    ///   - sourceNetworkID: ID of the Source Network to stop replication.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopSourceNetworkReplication(
        sourceNetworkID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopSourceNetworkReplicationResponse {
        let input = StopSourceNetworkReplicationRequest(
            sourceNetworkID: sourceNetworkID
        )
        return try await self.stopSourceNetworkReplication(input, logger: logger)
    }

    /// Adds or overwrites only the specified tags for the specified Elastic Disaster Recovery resource or resources. When you specify an existing tag key, the value is overwritten with the new value. Each resource can have a maximum of 50 tags. Each tag consists of a key and optional value.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds or overwrites only the specified tags for the specified Elastic Disaster Recovery resource or resources. When you specify an existing tag key, the value is overwritten with the new value. Each resource can have a maximum of 50 tags. Each tag consists of a key and optional value.
    ///
    /// Parameters:
    ///   - resourceArn: ARN of the resource for which tags are to be added or updated.
    ///   - tags: Array of tags to be added or updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Initiates a Job for terminating the EC2 resources associated with the specified Recovery Instances, and then will delete the Recovery Instances from the Elastic Disaster Recovery service.
    @Sendable
    @inlinable
    public func terminateRecoveryInstances(_ input: TerminateRecoveryInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TerminateRecoveryInstancesResponse {
        try await self.client.execute(
            operation: "TerminateRecoveryInstances", 
            path: "/TerminateRecoveryInstances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates a Job for terminating the EC2 resources associated with the specified Recovery Instances, and then will delete the Recovery Instances from the Elastic Disaster Recovery service.
    ///
    /// Parameters:
    ///   - recoveryInstanceIDs: The IDs of the Recovery Instances that should be terminated.
    ///   - logger: Logger use during operation
    @inlinable
    public func terminateRecoveryInstances(
        recoveryInstanceIDs: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TerminateRecoveryInstancesResponse {
        let input = TerminateRecoveryInstancesRequest(
            recoveryInstanceIDs: recoveryInstanceIDs
        )
        return try await self.terminateRecoveryInstances(input, logger: logger)
    }

    /// Deletes the specified set of tags from the specified set of Elastic Disaster Recovery resources.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified set of tags from the specified set of Elastic Disaster Recovery resources.
    ///
    /// Parameters:
    ///   - resourceArn: ARN of the resource for which tags are to be removed.
    ///   - tagKeys: Array of tags to be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Allows you to update the failback replication configuration of a Recovery Instance by ID.
    @Sendable
    @inlinable
    public func updateFailbackReplicationConfiguration(_ input: UpdateFailbackReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateFailbackReplicationConfiguration", 
            path: "/UpdateFailbackReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows you to update the failback replication configuration of a Recovery Instance by ID.
    ///
    /// Parameters:
    ///   - bandwidthThrottling: Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
    ///   - name: The name of the Failback Replication Configuration.
    ///   - recoveryInstanceID: The ID of the Recovery Instance.
    ///   - usePrivateIP: Whether to use Private IP for the failback replication of the Recovery Instance.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFailbackReplicationConfiguration(
        bandwidthThrottling: Int64? = nil,
        name: String? = nil,
        recoveryInstanceID: String,
        usePrivateIP: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateFailbackReplicationConfigurationRequest(
            bandwidthThrottling: bandwidthThrottling, 
            name: name, 
            recoveryInstanceID: recoveryInstanceID, 
            usePrivateIP: usePrivateIP
        )
        return try await self.updateFailbackReplicationConfiguration(input, logger: logger)
    }

    /// Updates a LaunchConfiguration by Source Server ID.
    @Sendable
    @inlinable
    public func updateLaunchConfiguration(_ input: UpdateLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfiguration {
        try await self.client.execute(
            operation: "UpdateLaunchConfiguration", 
            path: "/UpdateLaunchConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a LaunchConfiguration by Source Server ID.
    ///
    /// Parameters:
    ///   - copyPrivateIp: Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    ///   - copyTags: Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    ///   - launchDisposition: The state of the Recovery Instance in EC2 after the recovery operation.
    ///   - launchIntoInstanceProperties: Launch into existing instance properties.
    ///   - licensing: The licensing configuration to be used for this launch configuration.
    ///   - name: The name of the launch configuration.
    ///   - postLaunchEnabled: Whether we want to enable post-launch actions for the Source Server.
    ///   - sourceServerID: The ID of the Source Server that we want to retrieve a Launch Configuration for.
    ///   - targetInstanceTypeRightSizingMethod: Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchConfiguration(
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        launchDisposition: LaunchDisposition? = nil,
        launchIntoInstanceProperties: LaunchIntoInstanceProperties? = nil,
        licensing: Licensing? = nil,
        name: String? = nil,
        postLaunchEnabled: Bool? = nil,
        sourceServerID: String,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfiguration {
        let input = UpdateLaunchConfigurationRequest(
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            launchDisposition: launchDisposition, 
            launchIntoInstanceProperties: launchIntoInstanceProperties, 
            licensing: licensing, 
            name: name, 
            postLaunchEnabled: postLaunchEnabled, 
            sourceServerID: sourceServerID, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.updateLaunchConfiguration(input, logger: logger)
    }

    /// Updates an existing Launch Configuration Template by ID.
    @Sendable
    @inlinable
    public func updateLaunchConfigurationTemplate(_ input: UpdateLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLaunchConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "UpdateLaunchConfigurationTemplate", 
            path: "/UpdateLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing Launch Configuration Template by ID.
    ///
    /// Parameters:
    ///   - copyPrivateIp: Copy private IP.
    ///   - copyTags: Copy tags.
    ///   - exportBucketArn: S3 bucket ARN to export Source Network templates.
    ///   - launchConfigurationTemplateID: Launch Configuration Template ID.
    ///   - launchDisposition: Launch disposition.
    ///   - launchIntoSourceInstance: DRS will set the 'launch into instance ID' of any source server when performing a drill, recovery or failback to the previous region or availability zone, using the instance ID of the source instance.
    ///   - licensing: Licensing.
    ///   - postLaunchEnabled: Whether we want to activate post-launch actions.
    ///   - targetInstanceTypeRightSizingMethod: Target instance type right-sizing method.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchConfigurationTemplate(
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        exportBucketArn: String? = nil,
        launchConfigurationTemplateID: String,
        launchDisposition: LaunchDisposition? = nil,
        launchIntoSourceInstance: Bool? = nil,
        licensing: Licensing? = nil,
        postLaunchEnabled: Bool? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLaunchConfigurationTemplateResponse {
        let input = UpdateLaunchConfigurationTemplateRequest(
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            exportBucketArn: exportBucketArn, 
            launchConfigurationTemplateID: launchConfigurationTemplateID, 
            launchDisposition: launchDisposition, 
            launchIntoSourceInstance: launchIntoSourceInstance, 
            licensing: licensing, 
            postLaunchEnabled: postLaunchEnabled, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.updateLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Allows you to update a ReplicationConfiguration by Source Server ID.
    @Sendable
    @inlinable
    public func updateReplicationConfiguration(_ input: UpdateReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfiguration {
        try await self.client.execute(
            operation: "UpdateReplicationConfiguration", 
            path: "/UpdateReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows you to update a ReplicationConfiguration by Source Server ID.
    ///
    /// Parameters:
    ///   - associateDefaultSecurityGroup: Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    ///   - autoReplicateNewDisks: Whether to allow the AWS replication agent to automatically replicate newly added disks.
    ///   - bandwidthThrottling: Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    ///   - createPublicIP: Whether to create a Public IP for the Recovery Instance by default.
    ///   - dataPlaneRouting: The data plane routing mechanism that will be used for replication.
    ///   - defaultLargeStagingDiskType: The Staging Disk EBS volume type to be used during replication.
    ///   - ebsEncryption: The type of EBS encryption to be used during replication.
    ///   - ebsEncryptionKeyArn: The ARN of the EBS encryption key to be used during replication.
    ///   - name: The name of the Replication Configuration.
    ///   - pitPolicy: The Point in time (PIT) policy to manage snapshots taken during replication.
    ///   - replicatedDisks: The configuration of the disks of the Source Server to be replicated.
    ///   - replicationServerInstanceType: The instance type to be used for the replication server.
    ///   - replicationServersSecurityGroupsIDs: The security group IDs that will be used by the replication server.
    ///   - sourceServerID: The ID of the Source Server for this Replication Configuration.
    ///   - stagingAreaSubnetId: The subnet to be used by the replication staging area.
    ///   - stagingAreaTags: A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    ///   - useDedicatedReplicationServer: Whether to use a dedicated Replication Server in the replication staging area.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationConfiguration(
        associateDefaultSecurityGroup: Bool? = nil,
        autoReplicateNewDisks: Bool? = nil,
        bandwidthThrottling: Int64? = nil,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        name: String? = nil,
        pitPolicy: [PITPolicyRule]? = nil,
        replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        sourceServerID: String,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfiguration {
        let input = UpdateReplicationConfigurationRequest(
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            autoReplicateNewDisks: autoReplicateNewDisks, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            name: name, 
            pitPolicy: pitPolicy, 
            replicatedDisks: replicatedDisks, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            sourceServerID: sourceServerID, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer
        )
        return try await self.updateReplicationConfiguration(input, logger: logger)
    }

    /// Updates a ReplicationConfigurationTemplate by ID.
    @Sendable
    @inlinable
    public func updateReplicationConfigurationTemplate(_ input: UpdateReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfigurationTemplate {
        try await self.client.execute(
            operation: "UpdateReplicationConfigurationTemplate", 
            path: "/UpdateReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a ReplicationConfigurationTemplate by ID.
    ///
    /// Parameters:
    ///   - arn: The Replication Configuration Template ARN.
    ///   - associateDefaultSecurityGroup: Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    ///   - autoReplicateNewDisks: Whether to allow the AWS replication agent to automatically replicate newly added disks.
    ///   - bandwidthThrottling: Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    ///   - createPublicIP: Whether to create a Public IP for the Recovery Instance by default.
    ///   - dataPlaneRouting: The data plane routing mechanism that will be used for replication.
    ///   - defaultLargeStagingDiskType: The Staging Disk EBS volume type to be used during replication.
    ///   - ebsEncryption: The type of EBS encryption to be used during replication.
    ///   - ebsEncryptionKeyArn: The ARN of the EBS encryption key to be used during replication.
    ///   - pitPolicy: The Point in time (PIT) policy to manage snapshots taken during replication.
    ///   - replicationConfigurationTemplateID: The Replication Configuration Template ID.
    ///   - replicationServerInstanceType: The instance type to be used for the replication server.
    ///   - replicationServersSecurityGroupsIDs: The security group IDs that will be used by the replication server.
    ///   - stagingAreaSubnetId: The subnet to be used by the replication staging area.
    ///   - stagingAreaTags: A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    ///   - useDedicatedReplicationServer: Whether to use a dedicated Replication Server in the replication staging area.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationConfigurationTemplate(
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        autoReplicateNewDisks: Bool? = nil,
        bandwidthThrottling: Int64? = nil,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        pitPolicy: [PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: String,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfigurationTemplate {
        let input = UpdateReplicationConfigurationTemplateRequest(
            arn: arn, 
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            autoReplicateNewDisks: autoReplicateNewDisks, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            pitPolicy: pitPolicy, 
            replicationConfigurationTemplateID: replicationConfigurationTemplateID, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer
        )
        return try await self.updateReplicationConfigurationTemplate(input, logger: logger)
    }
}

extension Drs {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Drs, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Drs {
    /// Return PaginatorSequence for operation ``describeJobLogItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobLogItemsPaginator(
        _ input: DescribeJobLogItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeJobLogItemsRequest, DescribeJobLogItemsResponse> {
        return .init(
            input: input,
            command: self.describeJobLogItems,
            inputKey: \DescribeJobLogItemsRequest.nextToken,
            outputKey: \DescribeJobLogItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeJobLogItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobID: The ID of the Job for which Job log items will be retrieved.
    ///   - maxResults: Maximum number of Job log items to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobLogItemsPaginator(
        jobID: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeJobLogItemsRequest, DescribeJobLogItemsResponse> {
        let input = DescribeJobLogItemsRequest(
            jobID: jobID, 
            maxResults: maxResults
        )
        return self.describeJobLogItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobsPaginator(
        _ input: DescribeJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeJobsRequest, DescribeJobsResponse> {
        return .init(
            input: input,
            command: self.describeJobs,
            inputKey: \DescribeJobsRequest.nextToken,
            outputKey: \DescribeJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: A set of filters by which to return Jobs.
    ///   - maxResults: Maximum number of Jobs to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobsPaginator(
        filters: DescribeJobsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeJobsRequest, DescribeJobsResponse> {
        let input = DescribeJobsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeLaunchConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeLaunchConfigurationTemplatesPaginator(
        _ input: DescribeLaunchConfigurationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeLaunchConfigurationTemplatesRequest, DescribeLaunchConfigurationTemplatesResponse> {
        return .init(
            input: input,
            command: self.describeLaunchConfigurationTemplates,
            inputKey: \DescribeLaunchConfigurationTemplatesRequest.nextToken,
            outputKey: \DescribeLaunchConfigurationTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeLaunchConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - launchConfigurationTemplateIDs: Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    ///   - maxResults: Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeLaunchConfigurationTemplatesPaginator(
        launchConfigurationTemplateIDs: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeLaunchConfigurationTemplatesRequest, DescribeLaunchConfigurationTemplatesResponse> {
        let input = DescribeLaunchConfigurationTemplatesRequest(
            launchConfigurationTemplateIDs: launchConfigurationTemplateIDs, 
            maxResults: maxResults
        )
        return self.describeLaunchConfigurationTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeRecoveryInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeRecoveryInstancesPaginator(
        _ input: DescribeRecoveryInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeRecoveryInstancesRequest, DescribeRecoveryInstancesResponse> {
        return .init(
            input: input,
            command: self.describeRecoveryInstances,
            inputKey: \DescribeRecoveryInstancesRequest.nextToken,
            outputKey: \DescribeRecoveryInstancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeRecoveryInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: A set of filters by which to return Recovery Instances.
    ///   - maxResults: Maximum number of Recovery Instances to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeRecoveryInstancesPaginator(
        filters: DescribeRecoveryInstancesRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeRecoveryInstancesRequest, DescribeRecoveryInstancesResponse> {
        let input = DescribeRecoveryInstancesRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeRecoveryInstancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeRecoverySnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeRecoverySnapshotsPaginator(
        _ input: DescribeRecoverySnapshotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeRecoverySnapshotsRequest, DescribeRecoverySnapshotsResponse> {
        return .init(
            input: input,
            command: self.describeRecoverySnapshots,
            inputKey: \DescribeRecoverySnapshotsRequest.nextToken,
            outputKey: \DescribeRecoverySnapshotsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeRecoverySnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: A set of filters by which to return Recovery Snapshots.
    ///   - maxResults: Maximum number of Recovery Snapshots to retrieve.
    ///   - order: The sorted ordering by which to return Recovery Snapshots.
    ///   - sourceServerID: Filter Recovery Snapshots by Source Server ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeRecoverySnapshotsPaginator(
        filters: DescribeRecoverySnapshotsRequestFilters? = nil,
        maxResults: Int? = nil,
        order: RecoverySnapshotsOrder? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeRecoverySnapshotsRequest, DescribeRecoverySnapshotsResponse> {
        let input = DescribeRecoverySnapshotsRequest(
            filters: filters, 
            maxResults: maxResults, 
            order: order, 
            sourceServerID: sourceServerID
        )
        return self.describeRecoverySnapshotsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeReplicationConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReplicationConfigurationTemplatesPaginator(
        _ input: DescribeReplicationConfigurationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationConfigurationTemplatesRequest, DescribeReplicationConfigurationTemplatesResponse> {
        return .init(
            input: input,
            command: self.describeReplicationConfigurationTemplates,
            inputKey: \DescribeReplicationConfigurationTemplatesRequest.nextToken,
            outputKey: \DescribeReplicationConfigurationTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeReplicationConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of Replication Configuration Templates to retrieve.
    ///   - replicationConfigurationTemplateIDs: The IDs of the Replication Configuration Templates to retrieve. An empty list means all Replication Configuration Templates.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReplicationConfigurationTemplatesPaginator(
        maxResults: Int? = nil,
        replicationConfigurationTemplateIDs: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeReplicationConfigurationTemplatesRequest, DescribeReplicationConfigurationTemplatesResponse> {
        let input = DescribeReplicationConfigurationTemplatesRequest(
            maxResults: maxResults, 
            replicationConfigurationTemplateIDs: replicationConfigurationTemplateIDs
        )
        return self.describeReplicationConfigurationTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeSourceNetworks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceNetworksPaginator(
        _ input: DescribeSourceNetworksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSourceNetworksRequest, DescribeSourceNetworksResponse> {
        return .init(
            input: input,
            command: self.describeSourceNetworks,
            inputKey: \DescribeSourceNetworksRequest.nextToken,
            outputKey: \DescribeSourceNetworksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSourceNetworks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: A set of filters by which to return Source Networks.
    ///   - maxResults: Maximum number of Source Networks to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceNetworksPaginator(
        filters: DescribeSourceNetworksRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeSourceNetworksRequest, DescribeSourceNetworksResponse> {
        let input = DescribeSourceNetworksRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeSourceNetworksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceServersPaginator(
        _ input: DescribeSourceServersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSourceServersRequest, DescribeSourceServersResponse> {
        return .init(
            input: input,
            command: self.describeSourceServers,
            inputKey: \DescribeSourceServersRequest.nextToken,
            outputKey: \DescribeSourceServersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: A set of filters by which to return Source Servers.
    ///   - maxResults: Maximum number of Source Servers to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceServersPaginator(
        filters: DescribeSourceServersRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeSourceServersRequest, DescribeSourceServersResponse> {
        let input = DescribeSourceServersRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeSourceServersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listExtensibleSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listExtensibleSourceServersPaginator(
        _ input: ListExtensibleSourceServersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExtensibleSourceServersRequest, ListExtensibleSourceServersResponse> {
        return .init(
            input: input,
            command: self.listExtensibleSourceServers,
            inputKey: \ListExtensibleSourceServersRequest.nextToken,
            outputKey: \ListExtensibleSourceServersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listExtensibleSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of extensible source servers to retrieve.
    ///   - stagingAccountID: The Id of the staging Account to retrieve extensible source servers from.
    ///   - logger: Logger used for logging
    @inlinable
    public func listExtensibleSourceServersPaginator(
        maxResults: Int? = nil,
        stagingAccountID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListExtensibleSourceServersRequest, ListExtensibleSourceServersResponse> {
        let input = ListExtensibleSourceServersRequest(
            maxResults: maxResults, 
            stagingAccountID: stagingAccountID
        )
        return self.listExtensibleSourceServersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLaunchActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchActionsPaginator(
        _ input: ListLaunchActionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLaunchActionsRequest, ListLaunchActionsResponse> {
        return .init(
            input: input,
            command: self.listLaunchActions,
            inputKey: \ListLaunchActionsRequest.nextToken,
            outputKey: \ListLaunchActionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLaunchActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filters to apply when listing resource launch actions.
    ///   - maxResults: Maximum amount of items to return when listing resource launch actions.
    ///   - resourceId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchActionsPaginator(
        filters: LaunchActionsRequestFilters? = nil,
        maxResults: Int? = nil,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLaunchActionsRequest, ListLaunchActionsResponse> {
        let input = ListLaunchActionsRequest(
            filters: filters, 
            maxResults: maxResults, 
            resourceId: resourceId
        )
        return self.listLaunchActionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStagingAccounts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStagingAccountsPaginator(
        _ input: ListStagingAccountsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStagingAccountsRequest, ListStagingAccountsResponse> {
        return .init(
            input: input,
            command: self.listStagingAccounts,
            inputKey: \ListStagingAccountsRequest.nextToken,
            outputKey: \ListStagingAccountsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStagingAccounts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of staging Accounts to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStagingAccountsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStagingAccountsRequest, ListStagingAccountsResponse> {
        let input = ListStagingAccountsRequest(
            maxResults: maxResults
        )
        return self.listStagingAccountsPaginator(input, logger: logger)
    }
}

extension Drs.DescribeJobLogItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeJobLogItemsRequest {
        return .init(
            jobID: self.jobID,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.DescribeJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeJobsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.DescribeLaunchConfigurationTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeLaunchConfigurationTemplatesRequest {
        return .init(
            launchConfigurationTemplateIDs: self.launchConfigurationTemplateIDs,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.DescribeRecoveryInstancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeRecoveryInstancesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.DescribeRecoverySnapshotsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeRecoverySnapshotsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order,
            sourceServerID: self.sourceServerID
        )
    }
}

extension Drs.DescribeReplicationConfigurationTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeReplicationConfigurationTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            replicationConfigurationTemplateIDs: self.replicationConfigurationTemplateIDs
        )
    }
}

extension Drs.DescribeSourceNetworksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeSourceNetworksRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.DescribeSourceServersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.DescribeSourceServersRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Drs.ListExtensibleSourceServersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.ListExtensibleSourceServersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            stagingAccountID: self.stagingAccountID
        )
    }
}

extension Drs.ListLaunchActionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.ListLaunchActionsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceId: self.resourceId
        )
    }
}

extension Drs.ListStagingAccountsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Drs.ListStagingAccountsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
