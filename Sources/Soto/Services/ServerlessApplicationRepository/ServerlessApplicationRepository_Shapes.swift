//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension ServerlessApplicationRepository {
    // MARK: Enums

    public enum Capability: String, CustomStringConvertible, Codable {
        case capabilityAutoExpand = "CAPABILITY_AUTO_EXPAND"
        case capabilityIam = "CAPABILITY_IAM"
        case capabilityNamedIam = "CAPABILITY_NAMED_IAM"
        case capabilityResourcePolicy = "CAPABILITY_RESOURCE_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case expired = "EXPIRED"
        case preparing = "PREPARING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApplicationDependencySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the nested application.
        public let applicationId: String
        /// The semantic version of the nested application.
        public let semanticVersion: String

        public init(applicationId: String, semanticVersion: String) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case semanticVersion
        }
    }

    public struct ApplicationPolicyStatement: AWSEncodableShape & AWSDecodableShape {
        /// For the list of actions supported for this operation, see Application  Permissions.
        public let actions: [String]
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM aws:PrincipalOrgID global condition key.
        public let principalOrgIDs: [String]?
        /// An array of AWS account IDs, or * to make the application public.
        public let principals: [String]
        /// A unique ID for the statement.
        public let statementId: String?

        public init(actions: [String], principalOrgIDs: [String]? = nil, principals: [String], statementId: String? = nil) {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case principalOrgIDs
            case principals
            case statementId
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?

        public init(applicationId: String, author: String, creationTime: String? = nil, description: String, homePageUrl: String? = nil, labels: [String]? = nil, name: String, spdxLicenseId: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case labels
            case name
            case spdxLicenseId
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A local text file that contains the license of the app that matches the spdxLicenseID value of your application. The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
        public let licenseBody: String?
        /// A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
        public let licenseUrl: String?
        /// The name of the application that you want to publish.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String
        /// A local text readme file in Markdown language that contains a more detailed description of the application and how it works. The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
        public let readmeBody: String?
        /// A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
        public let readmeUrl: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The local raw packaged AWS SAM template file of your application. The file has the format file://&lt;path>/&lt;filename>.You can specify only one of templateBody and templateUrl; otherwise an error results.
        public let templateBody: String?
        /// A link to the S3 object containing the packaged AWS SAM template of your application.You can specify only one of templateBody and templateUrl; otherwise an error results.
        public let templateUrl: String?

        public init(author: String, description: String, homePageUrl: String? = nil, labels: [String]? = nil, licenseBody: String? = nil, licenseUrl: String? = nil, name: String, readmeBody: String? = nil, readmeUrl: String? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, spdxLicenseId: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.licenseBody = licenseBody
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.spdxLicenseId = spdxLicenseId
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case author
            case description
            case homePageUrl
            case labels
            case licenseBody
            case licenseUrl
            case name
            case readmeBody
            case readmeUrl
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case spdxLicenseId
            case templateBody
            case templateUrl
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct CreateApplicationVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId")),
            AWSMemberEncoding(label: "semanticVersion", location: .uri(locationName: "SemanticVersion"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the new version.
        public let semanticVersion: String
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// The raw packaged AWS SAM template of your application.
        public let templateBody: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String?

        public init(applicationId: String, semanticVersion: String, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateBody
            case templateUrl
        }
    }

    public struct CreateApplicationVersionResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// An array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let requiredCapabilities: [Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        public let resourcesSupported: Bool?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, requiredCapabilities: [Capability]? = nil, resourcesSupported: Bool? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case parameterDefinitions
            case requiredCapabilities
            case resourcesSupported
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateUrl
        }
    }

    public struct CreateCloudFormationChangeSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS:TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let capabilities: [String]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let changeSetName: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let clientToken: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let description: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let notificationArns: [String]?
        /// A list of parameter values for the parameters of the application.
        public let parameterOverrides: [ParameterValue]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let resourceTypes: [String]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let rollbackConfiguration: RollbackConfiguration?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let stackName: String
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let tags: [Tag]?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?

        public init(applicationId: String, capabilities: [String]? = nil, changeSetName: String? = nil, clientToken: String? = nil, description: String? = nil, notificationArns: [String]? = nil, parameterOverrides: [ParameterValue]? = nil, resourceTypes: [String]? = nil, rollbackConfiguration: RollbackConfiguration? = nil, semanticVersion: String? = nil, stackName: String, tags: [Tag]? = nil, templateId: String? = nil) {
            self.applicationId = applicationId
            self.capabilities = capabilities
            self.changeSetName = changeSetName
            self.clientToken = clientToken
            self.description = description
            self.notificationArns = notificationArns
            self.parameterOverrides = parameterOverrides
            self.resourceTypes = resourceTypes
            self.rollbackConfiguration = rollbackConfiguration
            self.semanticVersion = semanticVersion
            self.stackName = stackName
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case changeSetName
            case clientToken
            case description
            case notificationArns
            case parameterOverrides
            case resourceTypes
            case rollbackConfiguration
            case semanticVersion
            case stackName
            case tags
            case templateId
        }
    }

    public struct CreateCloudFormationChangeSetResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The Amazon Resource Name (ARN) of the change set.Length constraints: Minimum length of 1.Pattern: ARN:[-a-zA-Z0-9:/]*
        public let changeSetId: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// The unique ID of the stack.
        public let stackId: String?

        public init(applicationId: String? = nil, changeSetId: String? = nil, semanticVersion: String? = nil, stackId: String? = nil) {
            self.applicationId = applicationId
            self.changeSetId = changeSetId
            self.semanticVersion = semanticVersion
            self.stackId = stackId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case changeSetId
            case semanticVersion
            case stackId
        }
    }

    public struct CreateCloudFormationTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?

        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case semanticVersion
        }
    }

    public struct CreateCloudFormationTemplateResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The date and time this template expires. Templates expire 1 hour after creation.
        public let expirationTime: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
        public let status: Status?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?
        /// A link to the template that can be used to deploy the application using AWS CloudFormation.
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case expirationTime
            case semanticVersion
            case status
            case templateId
            case templateUrl
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationPolicyResponse: AWSDecodableShape {
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId")),
            AWSMemberEncoding(label: "semanticVersion", location: .querystring(locationName: "semanticVersion"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the application to get.
        public let semanticVersion: String?

        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct GetCloudFormationTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String

        public init(applicationId: String, templateId: String) {
            self.applicationId = applicationId
            self.templateId = templateId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudFormationTemplateResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The date and time this template expires. Templates expire 1 hour after creation.
        public let expirationTime: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
        public let status: Status?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?
        /// A link to the template that can be used to deploy the application using AWS CloudFormation.
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case expirationTime
            case semanticVersion
            case status
            case templateId
            case templateUrl
        }
    }

    public struct ListApplicationDependenciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "semanticVersion", location: .querystring(locationName: "semanticVersion"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?
        /// The semantic version of the application to get.
        public let semanticVersion: String?

        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
            self.semanticVersion = semanticVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationDependenciesResponse: AWSDecodableShape {
        /// An array of application summaries nested in the application.
        public let dependencies: [ApplicationDependencySummary]?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(dependencies: [ApplicationDependencySummary]? = nil, nextToken: String? = nil) {
            self.dependencies = dependencies
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies
            case nextToken
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?

        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// The token to request the next page of results.
        public let nextToken: String?
        /// An array of version summaries for the application.
        public let versions: [VersionSummary]?

        public init(nextToken: String? = nil, versions: [VersionSummary]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case versions
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?

        public init(maxItems: Int? = nil, nextToken: String? = nil) {
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// An array of application summaries.
        public let applications: [ApplicationSummary]?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(applications: [ApplicationSummary]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications
            case nextToken
        }
    }

    public struct ParameterDefinition: AWSDecodableShape {
        /// A regular expression that represents the patterns to allow for String types.
        public let allowedPattern: String?
        /// An array containing the list of values allowed for the parameter.
        public let allowedValues: [String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display the following customized error message: Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public let constraintDescription: String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created. If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public let defaultValue: String?
        /// A string of up to 4,000 characters that describes the parameter.
        public let description: String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public let maxLength: Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public let maxValue: Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public let minLength: Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public let minValue: Int?
        /// The name of the parameter.
        public let name: String
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the value to true, the parameter value is masked with asterisks (*****).
        public let noEcho: Bool?
        /// A list of AWS SAM resources that use this parameter.
        public let referencedByResources: [String]
        /// The type of the parameter.Valid values: String | Number | List&lt;Number> | CommaDelimitedList  String: A literal string.For example, users can specify "MyUserName". Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888". List&lt;Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"]. CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas. Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public let type: String?

        public init(allowedPattern: String? = nil, allowedValues: [String]? = nil, constraintDescription: String? = nil, defaultValue: String? = nil, description: String? = nil, maxLength: Int? = nil, maxValue: Int? = nil, minLength: Int? = nil, minValue: Int? = nil, name: String, noEcho: Bool? = nil, referencedByResources: [String], type: String? = nil) {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPattern
            case allowedValues
            case constraintDescription
            case defaultValue
            case description
            case maxLength
            case maxValue
            case minLength
            case minValue
            case name
            case noEcho
            case referencedByResources
            case type
        }
    }

    public struct ParameterValue: AWSEncodableShape {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        public let name: String
        /// The input value associated with the parameter.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct PutApplicationPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]

        public init(applicationId: String, statements: [ApplicationPolicyStatement]) {
            self.applicationId = applicationId
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct PutApplicationPolicyResponse: AWSDecodableShape {
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct RollbackConfiguration: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration Data Type.
        public let monitoringTimeInMinutes: Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration Data Type.
        public let rollbackTriggers: [RollbackTrigger]?

        public init(monitoringTimeInMinutes: Int? = nil, rollbackTriggers: [RollbackTrigger]? = nil) {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringTimeInMinutes
            case rollbackTriggers
        }
    }

    public struct RollbackTrigger: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger Data Type.
        public let arn: String
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger Data Type.
        public let type: String

        public init(arn: String, type: String) {
            self.arn = arn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case type
        }
    }

    public struct Tag: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation Tag Data Type.
        public let key: String
        /// This property corresponds to the content of the same name for the AWS CloudFormation  Tag  Data Type.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct UnshareApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The AWS Organization ID to unshare the application from.
        public let organizationId: String

        public init(applicationId: String, organizationId: String) {
            self.applicationId = applicationId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "ApplicationId"))
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A text readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeBody: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?

        public init(applicationId: String, author: String? = nil, description: String? = nil, homePageUrl: String? = nil, labels: [String]? = nil, readmeBody: String? = nil, readmeUrl: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
        }

        private enum CodingKeys: String, CodingKey {
            case author
            case description
            case homePageUrl
            case labels
            case readmeBody
            case readmeUrl
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct Version: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The date and time this resource was created.
        public let creationTime: String
        /// An array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let requiredCapabilities: [Capability]
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        public let resourcesSupported: Bool
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String

        public init(applicationId: String, creationTime: String, parameterDefinitions: [ParameterDefinition], requiredCapabilities: [Capability], resourcesSupported: Bool, semanticVersion: String, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case parameterDefinitions
            case requiredCapabilities
            case resourcesSupported
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateUrl
        }
    }

    public struct VersionSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The date and time this resource was created.
        public let creationTime: String
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?

        public init(applicationId: String, creationTime: String, semanticVersion: String, sourceCodeUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case semanticVersion
            case sourceCodeUrl
        }
    }
}
