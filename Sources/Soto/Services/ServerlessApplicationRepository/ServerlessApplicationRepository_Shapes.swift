//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ServerlessApplicationRepository {
    // MARK: Enums

    public enum Capability: String, CustomStringConvertible, Codable {
        case capabilityAutoExpand = "CAPABILITY_AUTO_EXPAND"
        case capabilityIam = "CAPABILITY_IAM"
        case capabilityNamedIam = "CAPABILITY_NAMED_IAM"
        case capabilityResourcePolicy = "CAPABILITY_RESOURCE_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case expired = "EXPIRED"
        case preparing = "PREPARING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApplicationDependencySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the nested application.
        public let applicationId: String
        /// The semantic version of the nested application.
        public let semanticVersion: String

        public init(applicationId: String, semanticVersion: String) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case semanticVersion
        }
    }

    public struct ApplicationPolicyStatement: AWSEncodableShape & AWSDecodableShape {
        /// For the list of actions supported for this operation, see Application
        ///  Permissions.
        public let actions: [String]
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM aws:PrincipalOrgID global condition key.
        public let principalOrgIDs: [String]?
        /// An array of AWS account IDs, or * to make the application public.
        public let principals: [String]
        /// A unique ID for the statement.
        public let statementId: String?

        public init(actions: [String], principalOrgIDs: [String]? = nil, principals: [String], statementId: String? = nil) {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case principalOrgIDs
            case principals
            case statementId
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?

        public init(applicationId: String, author: String, creationTime: String? = nil, description: String, homePageUrl: String? = nil, labels: [String]? = nil, name: String, spdxLicenseId: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case labels
            case name
            case spdxLicenseId
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        public let author: String
        public let description: String
        public let homePageUrl: String?
        public let labels: [String]?
        public let licenseBody: String?
        public let licenseUrl: String?
        public let name: String
        public let readmeBody: String?
        public let readmeUrl: String?
        public let semanticVersion: String?
        public let sourceCodeArchiveUrl: String?
        public let sourceCodeUrl: String?
        public let spdxLicenseId: String?
        public let templateBody: String?
        public let templateUrl: String?

        public init(author: String, description: String, homePageUrl: String? = nil, labels: [String]? = nil, licenseBody: String? = nil, licenseUrl: String? = nil, name: String, readmeBody: String? = nil, readmeUrl: String? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, spdxLicenseId: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.licenseBody = licenseBody
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.spdxLicenseId = spdxLicenseId
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case author
            case description
            case homePageUrl
            case labels
            case licenseBody
            case licenseUrl
            case name
            case readmeBody
            case readmeUrl
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case spdxLicenseId
            case templateBody
            case templateUrl
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        public let applicationId: String?
        public let author: String?
        public let creationTime: String?
        public let description: String?
        public let homePageUrl: String?
        public let isVerifiedAuthor: Bool?
        public let labels: [String]?
        public let licenseUrl: String?
        public let name: String?
        public let readmeUrl: String?
        public let spdxLicenseId: String?
        public let verifiedAuthorUrl: String?
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct CreateApplicationVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId")),
            AWSMemberEncoding(label: "semanticVersion", location: .uri(locationName: "semanticVersion"))
        ]

        public let applicationId: String
        public let semanticVersion: String
        public let sourceCodeArchiveUrl: String?
        public let sourceCodeUrl: String?
        public let templateBody: String?
        public let templateUrl: String?

        public init(applicationId: String, semanticVersion: String, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateBody
            case templateUrl
        }
    }

    public struct CreateApplicationVersionResponse: AWSDecodableShape {
        public let applicationId: String?
        public let creationTime: String?
        public let parameterDefinitions: [ParameterDefinition]?
        public let requiredCapabilities: [Capability]?
        public let resourcesSupported: Bool?
        public let semanticVersion: String?
        public let sourceCodeArchiveUrl: String?
        public let sourceCodeUrl: String?
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, requiredCapabilities: [Capability]? = nil, resourcesSupported: Bool? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case parameterDefinitions
            case requiredCapabilities
            case resourcesSupported
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateUrl
        }
    }

    public struct CreateCloudFormationChangeSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String
        public let capabilities: [String]?
        public let changeSetName: String?
        public let clientToken: String?
        public let description: String?
        public let notificationArns: [String]?
        public let parameterOverrides: [ParameterValue]?
        public let resourceTypes: [String]?
        public let rollbackConfiguration: RollbackConfiguration?
        public let semanticVersion: String?
        public let stackName: String
        public let tags: [Tag]?
        public let templateId: String?

        public init(applicationId: String, capabilities: [String]? = nil, changeSetName: String? = nil, clientToken: String? = nil, description: String? = nil, notificationArns: [String]? = nil, parameterOverrides: [ParameterValue]? = nil, resourceTypes: [String]? = nil, rollbackConfiguration: RollbackConfiguration? = nil, semanticVersion: String? = nil, stackName: String, tags: [Tag]? = nil, templateId: String? = nil) {
            self.applicationId = applicationId
            self.capabilities = capabilities
            self.changeSetName = changeSetName
            self.clientToken = clientToken
            self.description = description
            self.notificationArns = notificationArns
            self.parameterOverrides = parameterOverrides
            self.resourceTypes = resourceTypes
            self.rollbackConfiguration = rollbackConfiguration
            self.semanticVersion = semanticVersion
            self.stackName = stackName
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case changeSetName
            case clientToken
            case description
            case notificationArns
            case parameterOverrides
            case resourceTypes
            case rollbackConfiguration
            case semanticVersion
            case stackName
            case tags
            case templateId
        }
    }

    public struct CreateCloudFormationChangeSetResponse: AWSDecodableShape {
        public let applicationId: String?
        public let changeSetId: String?
        public let semanticVersion: String?
        public let stackId: String?

        public init(applicationId: String? = nil, changeSetId: String? = nil, semanticVersion: String? = nil, stackId: String? = nil) {
            self.applicationId = applicationId
            self.changeSetId = changeSetId
            self.semanticVersion = semanticVersion
            self.stackId = stackId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case changeSetId
            case semanticVersion
            case stackId
        }
    }

    public struct CreateCloudFormationTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String
        public let semanticVersion: String?

        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case semanticVersion
        }
    }

    public struct CreateCloudFormationTemplateResponse: AWSDecodableShape {
        public let applicationId: String?
        public let creationTime: String?
        public let expirationTime: String?
        public let semanticVersion: String?
        public let status: Status?
        public let templateId: String?
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case expirationTime
            case semanticVersion
            case status
            case templateId
            case templateUrl
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationPolicyResponse: AWSDecodableShape {
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId")),
            AWSMemberEncoding(label: "semanticVersion", location: .querystring(locationName: "semanticVersion"))
        ]

        public let applicationId: String
        public let semanticVersion: String?

        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        public let applicationId: String?
        public let author: String?
        public let creationTime: String?
        public let description: String?
        public let homePageUrl: String?
        public let isVerifiedAuthor: Bool?
        public let labels: [String]?
        public let licenseUrl: String?
        public let name: String?
        public let readmeUrl: String?
        public let spdxLicenseId: String?
        public let verifiedAuthorUrl: String?
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct GetCloudFormationTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "templateId"))
        ]

        public let applicationId: String
        public let templateId: String

        public init(applicationId: String, templateId: String) {
            self.applicationId = applicationId
            self.templateId = templateId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudFormationTemplateResponse: AWSDecodableShape {
        public let applicationId: String?
        public let creationTime: String?
        public let expirationTime: String?
        public let semanticVersion: String?
        public let status: Status?
        public let templateId: String?
        public let templateUrl: String?

        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case expirationTime
            case semanticVersion
            case status
            case templateId
            case templateUrl
        }
    }

    public struct ListApplicationDependenciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "semanticVersion", location: .querystring(locationName: "semanticVersion"))
        ]

        public let applicationId: String
        public let maxItems: Int?
        public let nextToken: String?
        public let semanticVersion: String?

        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
            self.semanticVersion = semanticVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationDependenciesResponse: AWSDecodableShape {
        public let dependencies: [ApplicationDependencySummary]?
        public let nextToken: String?

        public init(dependencies: [ApplicationDependencySummary]? = nil, nextToken: String? = nil) {
            self.dependencies = dependencies
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies
            case nextToken
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let applicationId: String
        public let maxItems: Int?
        public let nextToken: String?

        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let versions: [VersionSummary]?

        public init(nextToken: String? = nil, versions: [VersionSummary]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case versions
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "maxItems")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxItems: Int?
        public let nextToken: String?

        public init(maxItems: Int? = nil, nextToken: String? = nil) {
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        public let applications: [ApplicationSummary]?
        public let nextToken: String?

        public init(applications: [ApplicationSummary]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications
            case nextToken
        }
    }

    public struct ParameterDefinition: AWSDecodableShape {
        /// A regular expression that represents the patterns to allow for String types.
        public let allowedPattern: String?
        /// An array containing the list of values allowed for the parameter.
        public let allowedValues: [String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description,
        ///  a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user
        ///  specifies an invalid value:
        ///  Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+
        ///  By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display
        ///  the following customized error message:
        ///  Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public let constraintDescription: String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created.
        ///  If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public let defaultValue: String?
        /// A string of up to 4,000 characters that describes the parameter.
        public let description: String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public let maxLength: Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public let maxValue: Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public let minLength: Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public let minValue: Int?
        /// The name of the parameter.
        public let name: String
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the
        ///  value to true, the parameter value is masked with asterisks (*****).
        public let noEcho: Bool?
        /// A list of AWS SAM resources that use this parameter.
        public let referencedByResources: [String]
        /// The type of the parameter.Valid values: String | Number | List&lt;Number> | CommaDelimitedList
        ///
        ///  String: A literal string.For example, users can specify "MyUserName".
        ///  Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the
        ///  parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888".
        ///  List&lt;Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when
        ///  you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"].
        ///  CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas.
        ///  Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public let type: String?

        public init(allowedPattern: String? = nil, allowedValues: [String]? = nil, constraintDescription: String? = nil, defaultValue: String? = nil, description: String? = nil, maxLength: Int? = nil, maxValue: Int? = nil, minLength: Int? = nil, minValue: Int? = nil, name: String, noEcho: Bool? = nil, referencedByResources: [String], type: String? = nil) {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPattern
            case allowedValues
            case constraintDescription
            case defaultValue
            case description
            case maxLength
            case maxValue
            case minLength
            case minValue
            case name
            case noEcho
            case referencedByResources
            case type
        }
    }

    public struct ParameterValue: AWSEncodableShape {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation
        ///  uses the default value that is specified in your template.
        public let name: String
        /// The input value associated with the parameter.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct PutApplicationPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String
        public let statements: [ApplicationPolicyStatement]

        public init(applicationId: String, statements: [ApplicationPolicyStatement]) {
            self.applicationId = applicationId
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct PutApplicationPolicyResponse: AWSDecodableShape {
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements
        }
    }

    public struct RollbackConfiguration: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration
        ///   Data Type.
        public let monitoringTimeInMinutes: Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration
        ///   Data Type.
        public let rollbackTriggers: [RollbackTrigger]?

        public init(monitoringTimeInMinutes: Int? = nil, rollbackTriggers: [RollbackTrigger]? = nil) {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringTimeInMinutes
            case rollbackTriggers
        }
    }

    public struct RollbackTrigger: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger
        ///   Data Type.
        public let arn: String
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger
        ///   Data Type.
        public let type: String

        public init(arn: String, type: String) {
            self.arn = arn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case type
        }
    }

    public struct Tag: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation Tag
        ///   Data Type.
        public let key: String
        /// This property corresponds to the content of the same name for the AWS CloudFormation
        ///  Tag
        ///
        ///  Data Type.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct UnshareApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String
        public let organizationId: String

        public init(applicationId: String, organizationId: String) {
            self.applicationId = applicationId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri(locationName: "applicationId"))
        ]

        public let applicationId: String
        public let author: String?
        public let description: String?
        public let homePageUrl: String?
        public let labels: [String]?
        public let readmeBody: String?
        public let readmeUrl: String?

        public init(applicationId: String, author: String? = nil, description: String? = nil, homePageUrl: String? = nil, labels: [String]? = nil, readmeBody: String? = nil, readmeUrl: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
        }

        private enum CodingKeys: String, CodingKey {
            case author
            case description
            case homePageUrl
            case labels
            case readmeBody
            case readmeUrl
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        public let applicationId: String?
        public let author: String?
        public let creationTime: String?
        public let description: String?
        public let homePageUrl: String?
        public let isVerifiedAuthor: Bool?
        public let labels: [String]?
        public let licenseUrl: String?
        public let name: String?
        public let readmeUrl: String?
        public let spdxLicenseId: String?
        public let verifiedAuthorUrl: String?
        public let version: Version?

        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case author
            case creationTime
            case description
            case homePageUrl
            case isVerifiedAuthor
            case labels
            case licenseUrl
            case name
            case readmeUrl
            case spdxLicenseId
            case verifiedAuthorUrl
            case version
        }
    }

    public struct Version: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The date and time this resource was created.
        public let creationTime: String
        /// An array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]
        /// A list of values that you must specify before you can deploy certain applications.
        ///  Some applications might include resources that can affect permissions in your AWS
        ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
        ///  For those applications, you must explicitly acknowledge their capabilities by
        ///  specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
        ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or
        ///  CAPABILITY_NAMED_IAM:
        ///  AWS::IAM::Group,
        ///  AWS::IAM::InstanceProfile,
        ///  AWS::IAM::Policy, and
        ///  AWS::IAM::Role.
        ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
        ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
        ///  with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
        ///  AWS::Lambda::Permission,
        ///  AWS::IAM:Policy,
        ///  AWS::ApplicationAutoScaling::ScalingPolicy,
        ///  AWS::S3::BucketPolicy,
        ///  AWS::SQS::QueuePolicy, and
        ///  AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify
        ///  CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review
        ///  all permissions associated with the application before deploying. If you don't specify
        ///  this parameter for an application that requires capabilities, the call will fail.
        public let requiredCapabilities: [Capability]
        /// Whether all of the AWS resources contained in this application are supported in the region
        ///  in which it is being retrieved.
        public let resourcesSupported: Bool
        /// The semantic version of the application:
        ///  https://semver.org/
        public let semanticVersion: String
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String

        public init(applicationId: String, creationTime: String, parameterDefinitions: [ParameterDefinition], requiredCapabilities: [Capability], resourcesSupported: Bool, semanticVersion: String, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case parameterDefinitions
            case requiredCapabilities
            case resourcesSupported
            case semanticVersion
            case sourceCodeArchiveUrl
            case sourceCodeUrl
            case templateUrl
        }
    }

    public struct VersionSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String
        /// The date and time this resource was created.
        public let creationTime: String
        /// The semantic version of the application:
        ///  https://semver.org/
        public let semanticVersion: String
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?

        public init(applicationId: String, creationTime: String, semanticVersion: String, sourceCodeUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case creationTime
            case semanticVersion
            case sourceCodeUrl
        }
    }
}
