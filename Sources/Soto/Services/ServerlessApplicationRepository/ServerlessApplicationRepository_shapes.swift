//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ServerlessApplicationRepository {
    // MARK: Enums

    public enum Capability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capabilityAutoExpand = "CAPABILITY_AUTO_EXPAND"
        case capabilityIam = "CAPABILITY_IAM"
        case capabilityNamedIam = "CAPABILITY_NAMED_IAM"
        case capabilityResourcePolicy = "CAPABILITY_RESOURCE_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case expired = "EXPIRED"
        case preparing = "PREPARING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApplicationDependencySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the nested application.
        public let applicationId: String?
        /// The semantic version of the nested application.
        public let semanticVersion: String?

        @inlinable
        public init(applicationId: String? = nil, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
        }
    }

    public struct ApplicationPolicyStatement: AWSEncodableShape & AWSDecodableShape {
        /// For the list of actions supported for this operation, see Application  Permissions.
        public let actions: [String]?
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM aws:PrincipalOrgID global condition key.
        public let principalOrgIDs: [String]?
        /// An array of AWS account IDs, or * to make the application public.
        public let principals: [String]?
        /// A unique ID for the statement.
        public let statementId: String?

        @inlinable
        public init(actions: [String]? = nil, principalOrgIDs: [String]? = nil, principals: [String]? = nil, statementId: String? = nil) {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case principalOrgIDs = "principalOrgIDs"
            case principals = "principals"
            case statementId = "statementId"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?

        @inlinable
        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, labels: [String]? = nil, name: String? = nil, spdxLicenseId: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case author = "author"
            case creationTime = "creationTime"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case labels = "labels"
            case name = "name"
            case spdxLicenseId = "spdxLicenseId"
        }
    }

    public struct BadRequestException: AWSErrorShape {
        /// 400
        public let errorCode: String?
        /// One of the parameters in the request is invalid.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// 409
        public let errorCode: String?
        /// The resource already exists.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A local text file that contains the license of the app that matches the spdxLicenseID value of your application. The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
        public let licenseBody: String?
        /// A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
        public let licenseUrl: String?
        /// The name of the application that you want to publish.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A local text readme file in Markdown language that contains a more detailed description of the application and how it works. The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
        public let readmeBody: String?
        /// A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
        public let readmeUrl: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The local raw packaged AWS SAM template file of your application. The file has the format file://&lt;path>/&lt;filename>.You can specify only one of templateBody and templateUrl; otherwise an error results.
        public let templateBody: String?
        /// A link to the S3 object containing the packaged AWS SAM template of your application.You can specify only one of templateBody and templateUrl; otherwise an error results.
        public let templateUrl: String?

        @inlinable
        public init(author: String? = nil, description: String? = nil, homePageUrl: String? = nil, labels: [String]? = nil, licenseBody: String? = nil, licenseUrl: String? = nil, name: String? = nil, readmeBody: String? = nil, readmeUrl: String? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, spdxLicenseId: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.licenseBody = licenseBody
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.spdxLicenseId = spdxLicenseId
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case author = "author"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case labels = "labels"
            case licenseBody = "licenseBody"
            case licenseUrl = "licenseUrl"
            case name = "name"
            case readmeBody = "readmeBody"
            case readmeUrl = "readmeUrl"
            case semanticVersion = "semanticVersion"
            case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
            case sourceCodeUrl = "sourceCodeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case templateBody = "templateBody"
            case templateUrl = "templateUrl"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        @inlinable
        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case author = "author"
            case creationTime = "creationTime"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case isVerifiedAuthor = "isVerifiedAuthor"
            case labels = "labels"
            case licenseUrl = "licenseUrl"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case verifiedAuthorUrl = "verifiedAuthorUrl"
            case version = "version"
        }
    }

    public struct CreateApplicationVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the new version.
        public let semanticVersion: String
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// The raw packaged AWS SAM template of your application.
        public let templateBody: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String?

        @inlinable
        public init(applicationId: String, semanticVersion: String, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.semanticVersion, key: "SemanticVersion")
            try container.encodeIfPresent(self.sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
            try container.encodeIfPresent(self.sourceCodeUrl, forKey: .sourceCodeUrl)
            try container.encodeIfPresent(self.templateBody, forKey: .templateBody)
            try container.encodeIfPresent(self.templateUrl, forKey: .templateUrl)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
            case sourceCodeUrl = "sourceCodeUrl"
            case templateBody = "templateBody"
            case templateUrl = "templateUrl"
        }
    }

    public struct CreateApplicationVersionResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// An array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let requiredCapabilities: [Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        public let resourcesSupported: Bool?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String?

        @inlinable
        public init(applicationId: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, requiredCapabilities: [Capability]? = nil, resourcesSupported: Bool? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case parameterDefinitions = "parameterDefinitions"
            case requiredCapabilities = "requiredCapabilities"
            case resourcesSupported = "resourcesSupported"
            case semanticVersion = "semanticVersion"
            case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
            case sourceCodeUrl = "sourceCodeUrl"
            case templateUrl = "templateUrl"
        }
    }

    public struct CreateCloudFormationChangeSetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS:TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let capabilities: [String]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let changeSetName: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let clientToken: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let description: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let notificationArns: [String]?
        /// A list of parameter values for the parameters of the application.
        public let parameterOverrides: [ParameterValue]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let resourceTypes: [String]?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let rollbackConfiguration: RollbackConfiguration?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let stackName: String?
        /// This property corresponds to the parameter of the same name for the AWS CloudFormation CreateChangeSet API.
        public let tags: [Tag]?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?

        @inlinable
        public init(applicationId: String, capabilities: [String]? = nil, changeSetName: String? = nil, clientToken: String? = nil, description: String? = nil, notificationArns: [String]? = nil, parameterOverrides: [ParameterValue]? = nil, resourceTypes: [String]? = nil, rollbackConfiguration: RollbackConfiguration? = nil, semanticVersion: String? = nil, stackName: String? = nil, tags: [Tag]? = nil, templateId: String? = nil) {
            self.applicationId = applicationId
            self.capabilities = capabilities
            self.changeSetName = changeSetName
            self.clientToken = clientToken
            self.description = description
            self.notificationArns = notificationArns
            self.parameterOverrides = parameterOverrides
            self.resourceTypes = resourceTypes
            self.rollbackConfiguration = rollbackConfiguration
            self.semanticVersion = semanticVersion
            self.stackName = stackName
            self.tags = tags
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.changeSetName, forKey: .changeSetName)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.notificationArns, forKey: .notificationArns)
            try container.encodeIfPresent(self.parameterOverrides, forKey: .parameterOverrides)
            try container.encodeIfPresent(self.resourceTypes, forKey: .resourceTypes)
            try container.encodeIfPresent(self.rollbackConfiguration, forKey: .rollbackConfiguration)
            try container.encodeIfPresent(self.semanticVersion, forKey: .semanticVersion)
            try container.encodeIfPresent(self.stackName, forKey: .stackName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.templateId, forKey: .templateId)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case changeSetName = "changeSetName"
            case clientToken = "clientToken"
            case description = "description"
            case notificationArns = "notificationArns"
            case parameterOverrides = "parameterOverrides"
            case resourceTypes = "resourceTypes"
            case rollbackConfiguration = "rollbackConfiguration"
            case semanticVersion = "semanticVersion"
            case stackName = "stackName"
            case tags = "tags"
            case templateId = "templateId"
        }
    }

    public struct CreateCloudFormationChangeSetResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The Amazon Resource Name (ARN) of the change set.Length constraints: Minimum length of 1.Pattern: ARN:[-a-zA-Z0-9:/]*
        public let changeSetId: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// The unique ID of the stack.
        public let stackId: String?

        @inlinable
        public init(applicationId: String? = nil, changeSetId: String? = nil, semanticVersion: String? = nil, stackId: String? = nil) {
            self.applicationId = applicationId
            self.changeSetId = changeSetId
            self.semanticVersion = semanticVersion
            self.stackId = stackId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case changeSetId = "changeSetId"
            case semanticVersion = "semanticVersion"
            case stackId = "stackId"
        }
    }

    public struct CreateCloudFormationTemplateRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?

        @inlinable
        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.semanticVersion, forKey: .semanticVersion)
        }

        private enum CodingKeys: String, CodingKey {
            case semanticVersion = "semanticVersion"
        }
    }

    public struct CreateCloudFormationTemplateResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The date and time this template expires. Templates expire 1 hour after creation.
        public let expirationTime: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
        public let status: Status?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?
        /// A link to the template that can be used to deploy the application using AWS CloudFormation.
        public let templateUrl: String?

        @inlinable
        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case expirationTime = "expirationTime"
            case semanticVersion = "semanticVersion"
            case status = "status"
            case templateId = "templateId"
            case templateUrl = "templateUrl"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ForbiddenException: AWSErrorShape {
        /// 403
        public let errorCode: String?
        /// The client is not authenticated.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct GetApplicationPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationPolicyResponse: AWSDecodableShape {
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        @inlinable
        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The semantic version of the application to get.
        public let semanticVersion: String?

        @inlinable
        public init(applicationId: String, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.semanticVersion, key: "semanticVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        @inlinable
        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case author = "author"
            case creationTime = "creationTime"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case isVerifiedAuthor = "isVerifiedAuthor"
            case labels = "labels"
            case licenseUrl = "licenseUrl"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case verifiedAuthorUrl = "verifiedAuthorUrl"
            case version = "version"
        }
    }

    public struct GetCloudFormationTemplateRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String

        @inlinable
        public init(applicationId: String, templateId: String) {
            self.applicationId = applicationId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudFormationTemplateResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The date and time this template expires. Templates expire 1 hour after creation.
        public let expirationTime: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
        public let status: Status?
        /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
        public let templateId: String?
        /// A link to the template that can be used to deploy the application using AWS CloudFormation.
        public let templateUrl: String?

        @inlinable
        public init(applicationId: String? = nil, creationTime: String? = nil, expirationTime: String? = nil, semanticVersion: String? = nil, status: Status? = nil, templateId: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.semanticVersion = semanticVersion
            self.status = status
            self.templateId = templateId
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case expirationTime = "expirationTime"
            case semanticVersion = "semanticVersion"
            case status = "status"
            case templateId = "templateId"
            case templateUrl = "templateUrl"
        }
    }

    public struct InternalServerErrorException: AWSErrorShape {
        /// 500
        public let errorCode: String?
        /// The AWS Serverless Application Repository service encountered an internal error.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct ListApplicationDependenciesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?
        /// The semantic version of the application to get.
        public let semanticVersion: String?

        @inlinable
        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil, semanticVersion: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
            self.semanticVersion = semanticVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.maxItems, key: "maxItems")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.semanticVersion, key: "semanticVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationDependenciesResponse: AWSDecodableShape {
        /// An array of application summaries nested in the application.
        public let dependencies: [ApplicationDependencySummary]?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(dependencies: [ApplicationDependencySummary]? = nil, nextToken: String? = nil) {
            self.dependencies = dependencies
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case nextToken = "nextToken"
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxItems: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.maxItems, key: "maxItems")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// The token to request the next page of results.
        public let nextToken: String?
        /// An array of version summaries for the application.
        public let versions: [VersionSummary]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionSummary]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case versions = "versions"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The total number of items to return.
        public let maxItems: Int?
        /// A token to specify where to start paginating.
        public let nextToken: String?

        @inlinable
        public init(maxItems: Int? = nil, nextToken: String? = nil) {
            self.maxItems = maxItems
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxItems, key: "maxItems")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// An array of application summaries.
        public let applications: [ApplicationSummary]?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(applications: [ApplicationSummary]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "applications"
            case nextToken = "nextToken"
        }
    }

    public struct NotFoundException: AWSErrorShape {
        /// 404
        public let errorCode: String?
        /// The resource (for example, an access policy statement) specified in the request doesn't exist.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct ParameterDefinition: AWSDecodableShape {
        /// A regular expression that represents the patterns to allow for String types.
        public let allowedPattern: String?
        /// An array containing the list of values allowed for the parameter.
        public let allowedValues: [String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display the following customized error message: Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public let constraintDescription: String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created. If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public let defaultValue: String?
        /// A string of up to 4,000 characters that describes the parameter.
        public let description: String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public let maxLength: Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public let maxValue: Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public let minLength: Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public let minValue: Int?
        /// The name of the parameter.
        public let name: String?
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the value to true, the parameter value is masked with asterisks (*****).
        public let noEcho: Bool?
        /// A list of AWS SAM resources that use this parameter.
        public let referencedByResources: [String]?
        /// The type of the parameter.Valid values: String | Number | List&lt;Number> | CommaDelimitedList  String: A literal string.For example, users can specify "MyUserName". Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888". List&lt;Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"]. CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas. Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public let type: String?

        @inlinable
        public init(allowedPattern: String? = nil, allowedValues: [String]? = nil, constraintDescription: String? = nil, defaultValue: String? = nil, description: String? = nil, maxLength: Int? = nil, maxValue: Int? = nil, minLength: Int? = nil, minValue: Int? = nil, name: String? = nil, noEcho: Bool? = nil, referencedByResources: [String]? = nil, type: String? = nil) {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPattern = "allowedPattern"
            case allowedValues = "allowedValues"
            case constraintDescription = "constraintDescription"
            case defaultValue = "defaultValue"
            case description = "description"
            case maxLength = "maxLength"
            case maxValue = "maxValue"
            case minLength = "minLength"
            case minValue = "minValue"
            case name = "name"
            case noEcho = "noEcho"
            case referencedByResources = "referencedByResources"
            case type = "type"
        }
    }

    public struct ParameterValue: AWSEncodableShape {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        public let name: String?
        /// The input value associated with the parameter.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct PutApplicationPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        @inlinable
        public init(applicationId: String, statements: [ApplicationPolicyStatement]? = nil) {
            self.applicationId = applicationId
            self.statements = statements
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.statements, forKey: .statements)
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct PutApplicationPolicyResponse: AWSDecodableShape {
        /// An array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        @inlinable
        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct RollbackConfiguration: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration Data Type.
        public let monitoringTimeInMinutes: Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackConfiguration Data Type.
        public let rollbackTriggers: [RollbackTrigger]?

        @inlinable
        public init(monitoringTimeInMinutes: Int? = nil, rollbackTriggers: [RollbackTrigger]? = nil) {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringTimeInMinutes = "monitoringTimeInMinutes"
            case rollbackTriggers = "rollbackTriggers"
        }
    }

    public struct RollbackTrigger: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger Data Type.
        public let arn: String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation RollbackTrigger Data Type.
        public let type: String?

        @inlinable
        public init(arn: String? = nil, type: String? = nil) {
            self.arn = arn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case type = "type"
        }
    }

    public struct Tag: AWSEncodableShape {
        /// This property corresponds to the content of the same name for the AWS CloudFormation Tag Data Type.
        public let key: String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation  Tag  Data Type.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TooManyRequestsException: AWSErrorShape {
        /// 429
        public let errorCode: String?
        /// The client is sending more than the allowed number of requests per unit of time.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
        }
    }

    public struct UnshareApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The AWS Organization ID to unshare the application from.
        public let organizationId: String?

        @inlinable
        public init(applicationId: String, organizationId: String? = nil) {
            self.applicationId = applicationId
            self.organizationId = organizationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.organizationId, forKey: .organizationId)
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "organizationId"
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationId: String
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A text readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeBody: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?

        @inlinable
        public init(applicationId: String, author: String? = nil, description: String? = nil, homePageUrl: String? = nil, labels: [String]? = nil, readmeBody: String? = nil, readmeUrl: String? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.author, forKey: .author)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.homePageUrl, forKey: .homePageUrl)
            try container.encodeIfPresent(self.labels, forKey: .labels)
            try container.encodeIfPresent(self.readmeBody, forKey: .readmeBody)
            try container.encodeIfPresent(self.readmeUrl, forKey: .readmeUrl)
        }

        private enum CodingKeys: String, CodingKey {
            case author = "author"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case labels = "labels"
            case readmeBody = "readmeBody"
            case readmeUrl = "readmeUrl"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The description of the application.Minimum length=1. Maximum length=256
        public let description: String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public let homePageUrl: String?
        /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
        public let isVerifiedAuthor: Bool?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
        public let licenseUrl: String?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The URL to the public profile of a verified author. This URL is submitted by the author.
        public let verifiedAuthorUrl: String?
        /// Version information about the application.
        public let version: Version?

        @inlinable
        public init(applicationId: String? = nil, author: String? = nil, creationTime: String? = nil, description: String? = nil, homePageUrl: String? = nil, isVerifiedAuthor: Bool? = nil, labels: [String]? = nil, licenseUrl: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, verifiedAuthorUrl: String? = nil, version: Version? = nil) {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.isVerifiedAuthor = isVerifiedAuthor
            self.labels = labels
            self.licenseUrl = licenseUrl
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.verifiedAuthorUrl = verifiedAuthorUrl
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case author = "author"
            case creationTime = "creationTime"
            case description = "description"
            case homePageUrl = "homePageUrl"
            case isVerifiedAuthor = "isVerifiedAuthor"
            case labels = "labels"
            case licenseUrl = "licenseUrl"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case verifiedAuthorUrl = "verifiedAuthorUrl"
            case version = "version"
        }
    }

    public struct Version: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// An array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: AWS::IAM::Group, AWS::IAM::InstanceProfile, AWS::IAM::Policy, and AWS::IAM::Role. If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: AWS::Lambda::Permission, AWS::IAM:Policy, AWS::ApplicationAutoScaling::ScalingPolicy, AWS::S3::BucketPolicy, AWS::SQS::QueuePolicy, and AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        public let requiredCapabilities: [Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        public let resourcesSupported: Bool?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public let sourceCodeArchiveUrl: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?
        /// A link to the packaged AWS SAM template of your application.
        public let templateUrl: String?

        @inlinable
        public init(applicationId: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, requiredCapabilities: [Capability]? = nil, resourcesSupported: Bool? = nil, semanticVersion: String? = nil, sourceCodeArchiveUrl: String? = nil, sourceCodeUrl: String? = nil, templateUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case parameterDefinitions = "parameterDefinitions"
            case requiredCapabilities = "requiredCapabilities"
            case resourcesSupported = "resourcesSupported"
            case semanticVersion = "semanticVersion"
            case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
            case sourceCodeUrl = "sourceCodeUrl"
            case templateUrl = "templateUrl"
        }
    }

    public struct VersionSummary: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The date and time this resource was created.
        public let creationTime: String?
        /// The semantic version of the application: https://semver.org/
        public let semanticVersion: String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public let sourceCodeUrl: String?

        @inlinable
        public init(applicationId: String? = nil, creationTime: String? = nil, semanticVersion: String? = nil, sourceCodeUrl: String? = nil) {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case semanticVersion = "semanticVersion"
            case sourceCodeUrl = "sourceCodeUrl"
        }
    }
}

// MARK: - Errors

/// Error enum for ServerlessApplicationRepository
public struct ServerlessApplicationRepositoryErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ServerlessApplicationRepository
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// One of the parameters in the request is invalid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The resource already exists.
    public static var conflictException: Self { .init(.conflictException) }
    /// The client is not authenticated.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// The AWS Serverless Application Repository service encountered an internal error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The resource (for example, an access policy statement) specified in the request doesn't exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The client is sending more than the allowed number of requests per unit of time.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension ServerlessApplicationRepositoryErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "BadRequestException": ServerlessApplicationRepository.BadRequestException.self,
        "ConflictException": ServerlessApplicationRepository.ConflictException.self,
        "ForbiddenException": ServerlessApplicationRepository.ForbiddenException.self,
        "InternalServerErrorException": ServerlessApplicationRepository.InternalServerErrorException.self,
        "NotFoundException": ServerlessApplicationRepository.NotFoundException.self,
        "TooManyRequestsException": ServerlessApplicationRepository.TooManyRequestsException.self
    ]
}

extension ServerlessApplicationRepositoryErrorType: Equatable {
    public static func == (lhs: ServerlessApplicationRepositoryErrorType, rhs: ServerlessApplicationRepositoryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ServerlessApplicationRepositoryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
