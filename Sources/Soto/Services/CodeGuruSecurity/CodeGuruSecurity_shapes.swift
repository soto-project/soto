//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CodeGuruSecurity {
    // MARK: Enums

    public enum AnalysisType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "All"
        case security = "Security"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case duplicateIdentifier = "DUPLICATE_IDENTIFIER"
        case internalError = "INTERNAL_ERROR"
        case invalidFindingId = "INVALID_FINDING_ID"
        case invalidScanName = "INVALID_SCAN_NAME"
        case itemDoesNotExist = "ITEM_DOES_NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum ScanState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case express = "Express"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "Critical"
        case high = "High"
        case info = "Info"
        case low = "Low"
        case medium = "Medium"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "All"
        case closed = "Closed"
        case open = "Open"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountFindingsMetric: AWSDecodableShape {
        /// The number of closed findings of each severity in an account on the specified date.
        public let closedFindings: FindingMetricsValuePerSeverity?
        /// The date from which the finding metrics were retrieved.
        public let date: Date?
        /// The average time it takes to close findings of each severity in days.
        public let meanTimeToClose: FindingMetricsValuePerSeverity?
        /// The number of new findings of each severity in account on the specified date.
        public let newFindings: FindingMetricsValuePerSeverity?
        /// The number of open findings of each severity in an account as of the specified date.
        public let openFindings: FindingMetricsValuePerSeverity?

        public init(closedFindings: FindingMetricsValuePerSeverity? = nil, date: Date? = nil, meanTimeToClose: FindingMetricsValuePerSeverity? = nil, newFindings: FindingMetricsValuePerSeverity? = nil, openFindings: FindingMetricsValuePerSeverity? = nil) {
            self.closedFindings = closedFindings
            self.date = date
            self.meanTimeToClose = meanTimeToClose
            self.newFindings = newFindings
            self.openFindings = openFindings
        }

        private enum CodingKeys: String, CodingKey {
            case closedFindings = "closedFindings"
            case date = "date"
            case meanTimeToClose = "meanTimeToClose"
            case newFindings = "newFindings"
            case openFindings = "openFindings"
        }
    }

    public struct BatchGetFindingsError: AWSDecodableShape {
        /// A code associated with the type of error.
        public let errorCode: ErrorCode
        /// The finding ID of the finding that was not fetched.
        public let findingId: String
        /// Describes the error.
        public let message: String
        /// The name of the scan that generated the finding.
        public let scanName: String

        public init(errorCode: ErrorCode, findingId: String, message: String, scanName: String) {
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case findingId = "findingId"
            case message = "message"
            case scanName = "scanName"
        }
    }

    public struct BatchGetFindingsRequest: AWSEncodableShape {
        /// A list of finding identifiers. Each identifier consists of a scanName and a findingId. You retrieve the findingId when you call GetFindings.
        public let findingIdentifiers: [FindingIdentifier]

        public init(findingIdentifiers: [FindingIdentifier]) {
            self.findingIdentifiers = findingIdentifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.findingIdentifiers, name: "findingIdentifiers", parent: name, max: 25)
            try self.validate(self.findingIdentifiers, name: "findingIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIdentifiers = "findingIdentifiers"
        }
    }

    public struct BatchGetFindingsResponse: AWSDecodableShape {
        /// A list of errors for individual findings which were not fetched. Each BatchGetFindingsError contains the scanName, findingId, errorCode and error message.
        public let failedFindings: [BatchGetFindingsError]
        ///  A list of all requested findings.
        public let findings: [Finding]

        public init(failedFindings: [BatchGetFindingsError], findings: [Finding]) {
            self.failedFindings = failedFindings
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case failedFindings = "failedFindings"
            case findings = "findings"
        }
    }

    public struct CategoryWithFindingNum: AWSDecodableShape {
        /// The name of the finding category. A finding category is determined by the detector that detected the finding.
        public let categoryName: String?
        /// The number of open findings in the category.
        public let findingNumber: Int?

        public init(categoryName: String? = nil, findingNumber: Int? = nil) {
            self.categoryName = categoryName
            self.findingNumber = findingNumber
        }

        private enum CodingKeys: String, CodingKey {
            case categoryName = "categoryName"
            case findingNumber = "findingNumber"
        }
    }

    public struct CodeLine: AWSDecodableShape {
        /// The code that contains a vulnerability.
        public let content: String?
        /// The code line number.
        public let number: Int?

        public init(content: String? = nil, number: Int? = nil) {
            self.content = content
            self.number = number
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case number = "number"
        }
    }

    public struct CreateScanRequest: AWSEncodableShape {
        /// The type of analysis you want CodeGuru Security to perform in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings. Defaults to Security type if missing.
        public let analysisType: AnalysisType?
        /// The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
        public let clientToken: String?
        /// The identifier for an input resource used to create a scan.
        public let resourceId: ResourceId
        /// The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a STANDARD scan type. If not specified, it will be auto generated.
        public let scanName: String
        /// The type of scan, either Standard or Express. Defaults to Standard type if missing.  Express scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. Standard scans have standard resource limits and use the full set of detectors to analyze your code.
        public let scanType: ScanType?
        /// An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]?

        public init(analysisType: AnalysisType? = nil, clientToken: String? = CreateScanRequest.idempotencyToken(), resourceId: ResourceId, scanName: String, scanType: ScanType? = nil, tags: [String: String]? = nil) {
            self.analysisType = analysisType
            self.clientToken = clientToken
            self.resourceId = resourceId
            self.scanName = scanName
            self.scanType = scanType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.resourceId.validate(name: "\(name).resourceId")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case clientToken = "clientToken"
            case resourceId = "resourceId"
            case scanName = "scanName"
            case scanType = "scanType"
            case tags = "tags"
        }
    }

    public struct CreateScanResponse: AWSDecodableShape {
        /// The identifier for the resource object that contains resources that were scanned.
        public let resourceId: ResourceId
        /// UUID that identifies the individual scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The current state of the scan. Returns either InProgress, Successful, or Failed.
        public let scanState: ScanState

        public init(resourceId: ResourceId, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState) {
            self.resourceId = resourceId
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "resourceId"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
        }
    }

    public struct CreateUploadUrlRequest: AWSEncodableShape {
        /// The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this  scanName when you call CreateScan on the code resource you upload to this URL.
        public let scanName: String

        public init(scanName: String) {
            self.scanName = scanName
        }

        public func validate(name: String) throws {
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case scanName = "scanName"
        }
    }

    public struct CreateUploadUrlResponse: AWSDecodableShape {
        /// The identifier for the uploaded code resource.
        public let codeArtifactId: String
        /// A set of key-value pairs that contain the required headers when uploading your resource.
        public let requestHeaders: [String: String]
        /// A pre-signed S3 URL. You can upload the code file you want to scan and add the required requestHeaders using any HTTP client.
        public let s3Url: String

        public init(codeArtifactId: String, requestHeaders: [String: String], s3Url: String) {
            self.codeArtifactId = codeArtifactId
            self.requestHeaders = requestHeaders
            self.s3Url = s3Url
        }

        private enum CodingKeys: String, CodingKey {
            case codeArtifactId = "codeArtifactId"
            case requestHeaders = "requestHeaders"
            case s3Url = "s3Url"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The KMS key ARN to use for encryption. This must be provided as a header when uploading your code resource.
        public let kmsKeyArn: String?

        public init(kmsKeyArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[\\S]+:[\\d]{12}:key\\/(([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|(mrk-[0-9a-zA-Z]{32}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct FilePath: AWSDecodableShape {
        /// A list of CodeLine objects that describe where the security vulnerability appears in your code.
        public let codeSnippet: [CodeLine]?
        /// The last line number of the code snippet where the security vulnerability appears in your code.
        public let endLine: Int?
        /// The name of the file.
        public let name: String?
        /// The path to the resource with the security vulnerability.
        public let path: String?
        /// The first line number of the code snippet where the security vulnerability appears in your code.
        public let startLine: Int?

        public init(codeSnippet: [CodeLine]? = nil, endLine: Int? = nil, name: String? = nil, path: String? = nil, startLine: Int? = nil) {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.name = name
            self.path = path
            self.startLine = startLine
        }

        private enum CodingKeys: String, CodingKey {
            case codeSnippet = "codeSnippet"
            case endLine = "endLine"
            case name = "name"
            case path = "path"
            case startLine = "startLine"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The time when the finding was created.
        public let createdAt: Date?
        /// A description of the finding.
        public let description: String?
        /// The identifier for the detector that detected the finding in your code. A detector is a defined rule based on industry standards and AWS best practices.
        public let detectorId: String?
        /// The name of the detector that identified the security vulnerability in your code.
        public let detectorName: String?
        /// One or more tags or categorizations that are associated with a detector. These tags are defined by type, programming language, or other classification such as maintainability or consistency.
        public let detectorTags: [String]?
        /// The identifier for the component that generated a finding such as AWSCodeGuruSecurity or AWSInspector.
        public let generatorId: String?
        /// The identifier for a finding.
        public let id: String?
        /// An object that contains the details about how to remediate a finding.
        public let remediation: Remediation?
        /// The resource where Amazon CodeGuru Security detected a finding.
        public let resource: Resource?
        /// The identifier for the rule that generated the finding.
        public let ruleId: String?
        /// The severity of the finding.
        public let severity: Severity?
        /// The status of the finding. A finding status can be open or closed.
        public let status: Status?
        /// The title of the finding.
        public let title: String?
        /// The type of finding.
        public let type: String?
        /// The time when the finding was last updated. Findings are updated when you remediate them or when the finding code location changes.
        public let updatedAt: Date?
        /// An object that describes the detected security vulnerability.
        public let vulnerability: Vulnerability?

        public init(createdAt: Date? = nil, description: String? = nil, detectorId: String? = nil, detectorName: String? = nil, detectorTags: [String]? = nil, generatorId: String? = nil, id: String? = nil, remediation: Remediation? = nil, resource: Resource? = nil, ruleId: String? = nil, severity: Severity? = nil, status: Status? = nil, title: String? = nil, type: String? = nil, updatedAt: Date? = nil, vulnerability: Vulnerability? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.generatorId = generatorId
            self.id = id
            self.remediation = remediation
            self.resource = resource
            self.ruleId = ruleId
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.vulnerability = vulnerability
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case detectorId = "detectorId"
            case detectorName = "detectorName"
            case detectorTags = "detectorTags"
            case generatorId = "generatorId"
            case id = "id"
            case remediation = "remediation"
            case resource = "resource"
            case ruleId = "ruleId"
            case severity = "severity"
            case status = "status"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
            case vulnerability = "vulnerability"
        }
    }

    public struct FindingIdentifier: AWSEncodableShape {
        /// The identifier for a finding.
        public let findingId: String
        /// The name of the scan that generated the finding.
        public let scanName: String

        public init(findingId: String, scanName: String) {
            self.findingId = findingId
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case findingId = "findingId"
            case scanName = "scanName"
        }
    }

    public struct FindingMetricsValuePerSeverity: AWSDecodableShape {
        /// The severity of the finding is critical and should be addressed immediately.
        public let critical: Double?
        /// The severity of the finding is high and should be addressed as a near-term priority.
        public let high: Double?
        /// The finding is related to quality or readability improvements and not considered actionable.
        public let info: Double?
        /// The severity of the finding is low and does require action on its own.
        public let low: Double?
        /// The severity of the finding is medium and should be addressed as a mid-term priority.
        public let medium: Double?

        public init(critical: Double? = nil, high: Double? = nil, info: Double? = nil, low: Double? = nil, medium: Double? = nil) {
            self.critical = critical
            self.high = high
            self.info = info
            self.low = low
            self.medium = medium
        }

        private enum CodingKeys: String, CodingKey {
            case critical = "critical"
            case high = "high"
            case info = "info"
            case low = "low"
            case medium = "medium"
        }
    }

    public struct GetAccountConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountConfigurationResponse: AWSDecodableShape {
        /// An EncryptionConfig object that contains the KMS key ARN to use for encryption. By default, CodeGuru Security uses an AWS-managed key for encryption. To specify your own key, call UpdateAccountConfiguration.
        public let encryptionConfig: EncryptionConfig

        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The name of the scan you want to retrieve findings from.
        public let scanName: String
        /// The status of the findings you want to get. Pass either Open, Closed, or All.
        public let status: Status?

        public init(maxResults: Int? = nil, nextToken: String? = nil, scanName: String, status: Status? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanName = scanName
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.scanName, key: "scanName")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// A list of findings generated by the specified scan.
        public let findings: [Finding]?
        /// A pagination token. You can use this in future calls to GetFindings to continue listing results after the current page.
        public let nextToken: String?

        public init(findings: [Finding]? = nil, nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct GetMetricsSummaryRequest: AWSEncodableShape {
        /// The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years since metrics data is only stored for two years. If a date outside of this range is passed, the response will be empty.
        public let date: Date

        public init(date: Date) {
            self.date = date
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.date, key: "date")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetricsSummaryResponse: AWSDecodableShape {
        /// The summary metrics from the specified date.
        public let metricsSummary: MetricsSummary?

        public init(metricsSummary: MetricsSummary? = nil) {
            self.metricsSummary = metricsSummary
        }

        private enum CodingKeys: String, CodingKey {
            case metricsSummary = "metricsSummary"
        }
    }

    public struct GetScanRequest: AWSEncodableShape {
        /// UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the CreateScan operation. Defaults to the latest scan run if missing.
        public let runId: String?
        /// The name of the scan you want to view details about.
        public let scanName: String

        public init(runId: String? = nil, scanName: String) {
            self.runId = runId
            self.scanName = scanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.runId, key: "runId")
            request.encodePath(self.scanName, key: "scanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetScanResponse: AWSDecodableShape {
        /// The type of analysis CodeGuru Security performed in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings.
        public let analysisType: AnalysisType
        /// The time the scan was created.
        public let createdAt: Date
        /// The number of times a scan has been re-run on a revised resource.
        public let numberOfRevisions: Int64?
        /// UUID that identifies the individual scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The current state of the scan. Pass either InProgress, Successful, or Failed.
        public let scanState: ScanState
        /// The time when the scan was last updated. Only available for STANDARD scan types.
        public let updatedAt: Date?

        public init(analysisType: AnalysisType, createdAt: Date, numberOfRevisions: Int64? = nil, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState, updatedAt: Date? = nil) {
            self.analysisType = analysisType
            self.createdAt = createdAt
            self.numberOfRevisions = numberOfRevisions
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case createdAt = "createdAt"
            case numberOfRevisions = "numberOfRevisions"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
            case updatedAt = "updatedAt"
        }
    }

    public struct ListFindingsMetricsRequest: AWSEncodableShape {
        /// The end date of the interval which you want to retrieve metrics from.
        public let endDate: Date
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The start date of the interval which you want to retrieve metrics from.
        public let startDate: Date

        public init(endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, startDate: Date) {
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startDate = startDate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startDate, key: "startDate")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsMetricsResponse: AWSDecodableShape {
        /// A list of AccountFindingsMetric objects retrieved from the specified time interval.
        public let findingsMetrics: [AccountFindingsMetric]?
        /// A pagination token. You can use this in future calls to ListFindingMetrics to continue listing results after the current page.
        public let nextToken: String?

        public init(findingsMetrics: [AccountFindingsMetric]? = nil, nextToken: String? = nil) {
            self.findingsMetrics = findingsMetrics
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsMetrics = "findingsMetrics"
            case nextToken = "nextToken"
        }
    }

    public struct ListScansRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScansResponse: AWSDecodableShape {
        /// A pagination token. You can use this in future calls to ListScans to continue listing results after the current page.
        public let nextToken: String?
        /// A list of ScanSummary objects with information about all scans in an account.
        public let summaries: [ScanSummary]?

        public init(nextToken: String? = nil, summaries: [ScanSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MetricsSummary: AWSDecodableShape {
        /// A list of CategoryWithFindingNum objects for the top 5 finding categories with the most open findings in an account.
        public let categoriesWithMostFindings: [CategoryWithFindingNum]?
        /// The date from which the metrics summary information was retrieved.
        public let date: Date?
        /// The number of open findings of each severity in an account.
        public let openFindings: FindingMetricsValuePerSeverity?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open findings in an account.
        public let scansWithMostOpenCriticalFindings: [ScanNameWithFindingNum]?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open critical findings in an account.
        public let scansWithMostOpenFindings: [ScanNameWithFindingNum]?

        public init(categoriesWithMostFindings: [CategoryWithFindingNum]? = nil, date: Date? = nil, openFindings: FindingMetricsValuePerSeverity? = nil, scansWithMostOpenCriticalFindings: [ScanNameWithFindingNum]? = nil, scansWithMostOpenFindings: [ScanNameWithFindingNum]? = nil) {
            self.categoriesWithMostFindings = categoriesWithMostFindings
            self.date = date
            self.openFindings = openFindings
            self.scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindings
            self.scansWithMostOpenFindings = scansWithMostOpenFindings
        }

        private enum CodingKeys: String, CodingKey {
            case categoriesWithMostFindings = "categoriesWithMostFindings"
            case date = "date"
            case openFindings = "openFindings"
            case scansWithMostOpenCriticalFindings = "scansWithMostOpenCriticalFindings"
            case scansWithMostOpenFindings = "scansWithMostOpenFindings"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// The URL address to the recommendation for remediating the finding.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case url = "url"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to remediate a finding.
        public let recommendation: Recommendation?
        /// A list of SuggestedFix objects. Each object contains information about a suggested code fix to remediate the finding.
        public let suggestedFixes: [SuggestedFix]?

        public init(recommendation: Recommendation? = nil, suggestedFixes: [SuggestedFix]? = nil) {
            self.recommendation = recommendation
            self.suggestedFixes = suggestedFixes
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "recommendation"
            case suggestedFixes = "suggestedFixes"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The identifier for the resource.
        public let id: String?
        /// The identifier for a section of the resource, such as an AWS Lambda layer.
        public let subResourceId: String?

        public init(id: String? = nil, subResourceId: String? = nil) {
            self.id = id
            self.subResourceId = subResourceId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case subResourceId = "subResourceId"
        }
    }

    public struct ScanNameWithFindingNum: AWSDecodableShape {
        /// The number of open findings generated by a scan.
        public let findingNumber: Int?
        /// The name of the scan.
        public let scanName: String?

        public init(findingNumber: Int? = nil, scanName: String? = nil) {
            self.findingNumber = findingNumber
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case findingNumber = "findingNumber"
            case scanName = "scanName"
        }
    }

    public struct ScanSummary: AWSDecodableShape {
        ///  The time when the scan was created.
        public let createdAt: Date
        /// The identifier for the scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The state of the scan. A scan can be In Progress,  Complete, or Failed.
        public let scanState: ScanState
        /// The time the scan was last updated. A scan is updated when it is re-run.
        public let updatedAt: Date?

        public init(createdAt: Date, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
            case updatedAt = "updatedAt"
        }
    }

    public struct SuggestedFix: AWSDecodableShape {
        /// The suggested code to add to your file.
        public let code: String?
        /// A description of the suggested code fix and why it is being suggested.
        public let description: String?

        public init(code: String? = nil, description: String? = nil) {
            self.code = code
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case description = "description"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
        public let resourceArn: String
        /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
        public let resourceArn: String
        /// A list of keys for each tag you want to remove from a scan.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccountConfigurationRequest: AWSEncodableShape {
        /// The KMS key ARN you want to use for encryption. Defaults to service-side encryption if missing.
        public let encryptionConfig: EncryptionConfig

        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        public func validate(name: String) throws {
            try self.encryptionConfig.validate(name: "\(name).encryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct UpdateAccountConfigurationResponse: AWSDecodableShape {
        /// An EncryptionConfig object that contains the KMS key ARN to use for encryption.
        public let encryptionConfig: EncryptionConfig

        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct Vulnerability: AWSDecodableShape {
        ///  An object that describes the location of the detected security vulnerability in your code.
        public let filePath: FilePath?
        /// The identifier for the vulnerability.
        public let id: String?
        ///  The number of times the vulnerability appears in your code.
        public let itemCount: Int?
        /// One or more URL addresses that contain details about a vulnerability.
        public let referenceUrls: [String]?
        /// One or more vulnerabilities that are related to the vulnerability being described.
        public let relatedVulnerabilities: [String]?

        public init(filePath: FilePath? = nil, id: String? = nil, itemCount: Int? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil) {
            self.filePath = filePath
            self.id = id
            self.itemCount = itemCount
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
        }

        private enum CodingKeys: String, CodingKey {
            case filePath = "filePath"
            case id = "id"
            case itemCount = "itemCount"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
        }
    }

    public struct ResourceId: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the code file uploaded to the resource where a finding was detected.
        public let codeArtifactId: String?

        public init(codeArtifactId: String? = nil) {
            self.codeArtifactId = codeArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.codeArtifactId, name: "codeArtifactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeArtifactId = "codeArtifactId"
        }
    }
}

// MARK: - Errors

/// Error enum for CodeGuruSecurity
public struct CodeGuruSecurityErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CodeGuruSecurity
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource specified in the request was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension CodeGuruSecurityErrorType: Equatable {
    public static func == (lhs: CodeGuruSecurityErrorType, rhs: CodeGuruSecurityErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CodeGuruSecurityErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
