//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CodeGuruSecurity {
    // MARK: Enums

    public enum AnalysisType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "All"
        case security = "Security"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case duplicateIdentifier = "DUPLICATE_IDENTIFIER"
        case internalError = "INTERNAL_ERROR"
        case invalidFindingId = "INVALID_FINDING_ID"
        case invalidScanName = "INVALID_SCAN_NAME"
        case itemDoesNotExist = "ITEM_DOES_NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum ScanState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case express = "Express"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "Critical"
        case high = "High"
        case info = "Info"
        case low = "Low"
        case medium = "Medium"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "All"
        case closed = "Closed"
        case open = "Open"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case lambdaCodeShaMismatch = "lambdaCodeShaMisMatch"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        /// The identifier for the error.
        public let errorCode: String
        /// Description of the error.
        public let message: String
        /// The identifier for the resource you don't have access to.
        public let resourceId: String?
        /// The type of resource you don't have access to.
        public let resourceType: String?

        @inlinable
        public init(errorCode: String, message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct AccountFindingsMetric: AWSDecodableShape {
        /// The number of closed findings of each severity on the specified date.
        public let closedFindings: FindingMetricsValuePerSeverity?
        /// The date from which the findings metrics were retrieved.
        public let date: Date?
        /// The average time in days it takes to close findings of each severity as of a specified date.
        public let meanTimeToClose: FindingMetricsValuePerSeverity?
        /// The number of new findings of each severity on the specified date.
        public let newFindings: FindingMetricsValuePerSeverity?
        /// The number of open findings of each severity as of the specified date.
        public let openFindings: FindingMetricsValuePerSeverity?

        @inlinable
        public init(closedFindings: FindingMetricsValuePerSeverity? = nil, date: Date? = nil, meanTimeToClose: FindingMetricsValuePerSeverity? = nil, newFindings: FindingMetricsValuePerSeverity? = nil, openFindings: FindingMetricsValuePerSeverity? = nil) {
            self.closedFindings = closedFindings
            self.date = date
            self.meanTimeToClose = meanTimeToClose
            self.newFindings = newFindings
            self.openFindings = openFindings
        }

        private enum CodingKeys: String, CodingKey {
            case closedFindings = "closedFindings"
            case date = "date"
            case meanTimeToClose = "meanTimeToClose"
            case newFindings = "newFindings"
            case openFindings = "openFindings"
        }
    }

    public struct BatchGetFindingsError: AWSDecodableShape {
        /// A code associated with the type of error.
        public let errorCode: ErrorCode
        /// The finding ID of the finding that was not fetched.
        public let findingId: String
        /// Describes the error.
        public let message: String
        /// The name of the scan that generated the finding.
        public let scanName: String

        @inlinable
        public init(errorCode: ErrorCode, findingId: String, message: String, scanName: String) {
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case findingId = "findingId"
            case message = "message"
            case scanName = "scanName"
        }
    }

    public struct BatchGetFindingsRequest: AWSEncodableShape {
        /// A list of finding identifiers. Each identifier consists of a scanName and a findingId. You retrieve the findingId when you call GetFindings.
        public let findingIdentifiers: [FindingIdentifier]

        @inlinable
        public init(findingIdentifiers: [FindingIdentifier]) {
            self.findingIdentifiers = findingIdentifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.findingIdentifiers, name: "findingIdentifiers", parent: name, max: 25)
            try self.validate(self.findingIdentifiers, name: "findingIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIdentifiers = "findingIdentifiers"
        }
    }

    public struct BatchGetFindingsResponse: AWSDecodableShape {
        /// A list of errors for individual findings which were not fetched. Each BatchGetFindingsError contains the scanName, findingId, errorCode and error message.
        public let failedFindings: [BatchGetFindingsError]
        ///  A list of all findings which were successfully fetched.
        public let findings: [Finding]

        @inlinable
        public init(failedFindings: [BatchGetFindingsError], findings: [Finding]) {
            self.failedFindings = failedFindings
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case failedFindings = "failedFindings"
            case findings = "findings"
        }
    }

    public struct CategoryWithFindingNum: AWSDecodableShape {
        /// The name of the finding category. A finding category is determined by the detector that detected the finding.
        public let categoryName: String?
        /// The number of open findings in the category.
        public let findingNumber: Int?

        @inlinable
        public init(categoryName: String? = nil, findingNumber: Int? = nil) {
            self.categoryName = categoryName
            self.findingNumber = findingNumber
        }

        private enum CodingKeys: String, CodingKey {
            case categoryName = "categoryName"
            case findingNumber = "findingNumber"
        }
    }

    public struct CodeLine: AWSDecodableShape {
        /// The code that contains a vulnerability.
        public let content: String?
        /// The code line number.
        public let number: Int?

        @inlinable
        public init(content: String? = nil, number: Int? = nil) {
            self.content = content
            self.number = number
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case number = "number"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// The identifier for the error.
        public let errorCode: String
        /// Description of the error.
        public let message: String
        /// The identifier for the service resource associated with the request.
        public let resourceId: String
        /// The type of resource associated with the request.
        public let resourceType: String

        @inlinable
        public init(errorCode: String, message: String, resourceId: String, resourceType: String) {
            self.errorCode = errorCode
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateScanRequest: AWSEncodableShape {
        /// The type of analysis you want CodeGuru Security to perform in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings. Defaults to Security type if missing.
        public let analysisType: AnalysisType?
        /// The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
        public let clientToken: String?
        /// The identifier for the resource object to be scanned.
        public let resourceId: ResourceId
        /// The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a STANDARD scan type.
        public let scanName: String
        /// The type of scan, either Standard or Express. Defaults to Standard type if missing.  Express scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. Standard scans have standard resource limits and use the full set of detectors to analyze your code.
        public let scanType: ScanType?
        /// An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]?

        @inlinable
        public init(analysisType: AnalysisType? = nil, clientToken: String? = CreateScanRequest.idempotencyToken(), resourceId: ResourceId, scanName: String, scanType: ScanType? = nil, tags: [String: String]? = nil) {
            self.analysisType = analysisType
            self.clientToken = clientToken
            self.resourceId = resourceId
            self.scanName = scanName
            self.scanType = scanType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.resourceId.validate(name: "\(name).resourceId")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case clientToken = "clientToken"
            case resourceId = "resourceId"
            case scanName = "scanName"
            case scanType = "scanType"
            case tags = "tags"
        }
    }

    public struct CreateScanResponse: AWSDecodableShape {
        /// The identifier for the resource object that contains resources that were scanned.
        public let resourceId: ResourceId
        /// UUID that identifies the individual scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The current state of the scan. Returns either InProgress, Successful, or Failed.
        public let scanState: ScanState

        @inlinable
        public init(resourceId: ResourceId, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState) {
            self.resourceId = resourceId
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "resourceId"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
        }
    }

    public struct CreateUploadUrlRequest: AWSEncodableShape {
        /// The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this  scanName when you call CreateScan on the code resource you upload to this URL.
        public let scanName: String

        @inlinable
        public init(scanName: String) {
            self.scanName = scanName
        }

        public func validate(name: String) throws {
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case scanName = "scanName"
        }
    }

    public struct CreateUploadUrlResponse: AWSDecodableShape {
        /// The identifier for the uploaded code resource. Pass this to CreateScan to use the uploaded resources.
        public let codeArtifactId: String
        /// A set of key-value pairs that contain the required headers when uploading your resource.
        public let requestHeaders: [String: String]
        /// A pre-signed S3 URL. You can upload the code file you want to scan with the required requestHeaders using any HTTP client.
        public let s3Url: String

        @inlinable
        public init(codeArtifactId: String, requestHeaders: [String: String], s3Url: String) {
            self.codeArtifactId = codeArtifactId
            self.requestHeaders = requestHeaders
            self.s3Url = s3Url
        }

        private enum CodingKeys: String, CodingKey {
            case codeArtifactId = "codeArtifactId"
            case requestHeaders = "requestHeaders"
            case s3Url = "s3Url"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The KMS key ARN that is used for encryption. If an AWS-managed key is used for encryption, returns empty.
        public let kmsKeyArn: String?

        @inlinable
        public init(kmsKeyArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[\\S]+:[\\d]{12}:key\\/(([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|(mrk-[0-9a-zA-Z]{32}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct FilePath: AWSDecodableShape {
        /// A list of CodeLine objects that describe where the security vulnerability appears in your code.
        public let codeSnippet: [CodeLine]?
        /// The last line number of the code snippet where the security vulnerability appears in your code.
        public let endLine: Int?
        /// The name of the file.
        public let name: String?
        /// The path to the resource with the security vulnerability.
        public let path: String?
        /// The first line number of the code snippet where the security vulnerability appears in your code.
        public let startLine: Int?

        @inlinable
        public init(codeSnippet: [CodeLine]? = nil, endLine: Int? = nil, name: String? = nil, path: String? = nil, startLine: Int? = nil) {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.name = name
            self.path = path
            self.startLine = startLine
        }

        private enum CodingKeys: String, CodingKey {
            case codeSnippet = "codeSnippet"
            case endLine = "endLine"
            case name = "name"
            case path = "path"
            case startLine = "startLine"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The time when the finding was created.
        public let createdAt: Date?
        /// A description of the finding.
        public let description: String?
        /// The identifier for the detector that detected the finding in your code. A detector is a defined rule based on industry standards and AWS best practices.
        public let detectorId: String?
        /// The name of the detector that identified the security vulnerability in your code.
        public let detectorName: String?
        /// One or more tags or categorizations that are associated with a detector. These tags are defined by type, programming language, or other classification such as maintainability or consistency.
        public let detectorTags: [String]?
        /// The identifier for the component that generated a finding such as AmazonCodeGuruSecurity.
        public let generatorId: String?
        /// The identifier for a finding.
        public let id: String?
        /// An object that contains the details about how to remediate a finding.
        public let remediation: Remediation?
        /// The resource where Amazon CodeGuru Security detected a finding.
        public let resource: Resource?
        /// The identifier for the rule that generated the finding.
        public let ruleId: String?
        /// The severity of the finding. Severity can be critical, high, medium, low, or informational. For information on severity levels, see  Finding severity in the  Amazon CodeGuru Security User Guide.
        public let severity: Severity?
        /// The status of the finding. A finding status can be open or closed.
        public let status: Status?
        /// The title of the finding.
        public let title: String?
        /// The type of finding.
        public let type: String?
        /// The time when the finding was last updated. Findings are updated when you remediate them or when the finding code location changes.
        public let updatedAt: Date?
        /// An object that describes the detected security vulnerability.
        public let vulnerability: Vulnerability?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, detectorId: String? = nil, detectorName: String? = nil, detectorTags: [String]? = nil, generatorId: String? = nil, id: String? = nil, remediation: Remediation? = nil, resource: Resource? = nil, ruleId: String? = nil, severity: Severity? = nil, status: Status? = nil, title: String? = nil, type: String? = nil, updatedAt: Date? = nil, vulnerability: Vulnerability? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.generatorId = generatorId
            self.id = id
            self.remediation = remediation
            self.resource = resource
            self.ruleId = ruleId
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.vulnerability = vulnerability
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case detectorId = "detectorId"
            case detectorName = "detectorName"
            case detectorTags = "detectorTags"
            case generatorId = "generatorId"
            case id = "id"
            case remediation = "remediation"
            case resource = "resource"
            case ruleId = "ruleId"
            case severity = "severity"
            case status = "status"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
            case vulnerability = "vulnerability"
        }
    }

    public struct FindingIdentifier: AWSEncodableShape {
        /// The identifier for a finding.
        public let findingId: String
        /// The name of the scan that generated the finding.
        public let scanName: String

        @inlinable
        public init(findingId: String, scanName: String) {
            self.findingId = findingId
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case findingId = "findingId"
            case scanName = "scanName"
        }
    }

    public struct FindingMetricsValuePerSeverity: AWSDecodableShape {
        /// A numeric value corresponding to a critical finding.
        public let critical: Double?
        /// A numeric value corresponding to a high severity finding.
        public let high: Double?
        /// A numeric value corresponding to an informational finding.
        public let info: Double?
        /// A numeric value corresponding to a low severity finding.
        public let low: Double?
        /// A numeric value corresponding to a medium severity finding.
        public let medium: Double?

        @inlinable
        public init(critical: Double? = nil, high: Double? = nil, info: Double? = nil, low: Double? = nil, medium: Double? = nil) {
            self.critical = critical
            self.high = high
            self.info = info
            self.low = low
            self.medium = medium
        }

        private enum CodingKeys: String, CodingKey {
            case critical = "critical"
            case high = "high"
            case info = "info"
            case low = "low"
            case medium = "medium"
        }
    }

    public struct GetAccountConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountConfigurationResponse: AWSDecodableShape {
        /// An EncryptionConfig object that contains the KMS key ARN that is used for encryption. By default, CodeGuru Security uses an AWS-managed key for encryption. To specify your own key, call UpdateAccountConfiguration. If you do not specify a customer-managed key, returns empty.
        public let encryptionConfig: EncryptionConfig

        @inlinable
        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The name of the scan you want to retrieve findings from.
        public let scanName: String
        /// The status of the findings you want to get. Pass either Open, Closed, or All.
        public let status: Status?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, scanName: String, status: Status? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanName = scanName
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.scanName, key: "scanName")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// A list of findings generated by the specified scan.
        public let findings: [Finding]?
        /// A pagination token. You can use this in future calls to GetFindings to continue listing results after the current page.
        public let nextToken: String?

        @inlinable
        public init(findings: [Finding]? = nil, nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct GetMetricsSummaryRequest: AWSEncodableShape {
        /// The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years.
        public let date: Date

        @inlinable
        public init(date: Date) {
            self.date = date
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.date, key: "date")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetricsSummaryResponse: AWSDecodableShape {
        /// The summary metrics from the specified date.
        public let metricsSummary: MetricsSummary?

        @inlinable
        public init(metricsSummary: MetricsSummary? = nil) {
            self.metricsSummary = metricsSummary
        }

        private enum CodingKeys: String, CodingKey {
            case metricsSummary = "metricsSummary"
        }
    }

    public struct GetScanRequest: AWSEncodableShape {
        /// UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the CreateScan operation. Defaults to the latest scan run if missing.
        public let runId: String?
        /// The name of the scan you want to view details about.
        public let scanName: String

        @inlinable
        public init(runId: String? = nil, scanName: String) {
            self.runId = runId
            self.scanName = scanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.runId, key: "runId")
            request.encodePath(self.scanName, key: "scanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 140)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.validate(self.scanName, name: "scanName", parent: name, pattern: "^[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetScanResponse: AWSDecodableShape {
        /// The type of analysis CodeGuru Security performed in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings.
        public let analysisType: AnalysisType
        /// The time the scan was created.
        public let createdAt: Date
        /// Details about the error that causes a scan to fail to be retrieved.
        public let errorMessage: String?
        /// The number of times a scan has been re-run on a revised resource.
        public let numberOfRevisions: Int64?
        /// UUID that identifies the individual scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The current state of the scan. Returns either InProgress, Successful, or Failed.
        public let scanState: ScanState
        /// The time when the scan was last updated. Only available for STANDARD scan types.
        public let updatedAt: Date?

        @inlinable
        public init(analysisType: AnalysisType, createdAt: Date, errorMessage: String? = nil, numberOfRevisions: Int64? = nil, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState, updatedAt: Date? = nil) {
            self.analysisType = analysisType
            self.createdAt = createdAt
            self.errorMessage = errorMessage
            self.numberOfRevisions = numberOfRevisions
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case createdAt = "createdAt"
            case errorMessage = "errorMessage"
            case numberOfRevisions = "numberOfRevisions"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
            case updatedAt = "updatedAt"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        /// The internal error encountered by the server.
        public let error: String?
        /// Description of the error.
        public let message: String?

        @inlinable
        public init(error: String? = nil, message: String? = nil) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct ListFindingsMetricsRequest: AWSEncodableShape {
        /// The end date of the interval which you want to retrieve metrics from. Round to the nearest day.
        public let endDate: Date
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The start date of the interval which you want to retrieve metrics from. Rounds to the nearest day.
        public let startDate: Date

        @inlinable
        public init(endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, startDate: Date) {
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startDate = startDate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startDate, key: "startDate")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsMetricsResponse: AWSDecodableShape {
        /// A list of AccountFindingsMetric objects retrieved from the specified time interval.
        public let findingsMetrics: [AccountFindingsMetric]?
        /// A pagination token. You can use this in future calls to ListFindingMetrics to continue listing results after the current page.
        public let nextToken: String?

        @inlinable
        public init(findingsMetrics: [AccountFindingsMetric]? = nil, nextToken: String? = nil) {
            self.findingsMetrics = findingsMetrics
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsMetrics = "findingsMetrics"
            case nextToken = "nextToken"
        }
    }

    public struct ListScansRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 100 results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScansResponse: AWSDecodableShape {
        /// A pagination token. You can use this in future calls to ListScans to continue listing results after the current page.
        public let nextToken: String?
        /// A list of ScanSummary objects with information about all scans in an account.
        public let summaries: [ScanSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [ScanSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MetricsSummary: AWSDecodableShape {
        /// A list of CategoryWithFindingNum objects for the top 5 finding categories with the most findings.
        public let categoriesWithMostFindings: [CategoryWithFindingNum]?
        /// The date from which the metrics summary information was retrieved.
        public let date: Date?
        /// The number of open findings of each severity.
        public let openFindings: FindingMetricsValuePerSeverity?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open critical findings.
        public let scansWithMostOpenCriticalFindings: [ScanNameWithFindingNum]?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open findings.
        public let scansWithMostOpenFindings: [ScanNameWithFindingNum]?

        @inlinable
        public init(categoriesWithMostFindings: [CategoryWithFindingNum]? = nil, date: Date? = nil, openFindings: FindingMetricsValuePerSeverity? = nil, scansWithMostOpenCriticalFindings: [ScanNameWithFindingNum]? = nil, scansWithMostOpenFindings: [ScanNameWithFindingNum]? = nil) {
            self.categoriesWithMostFindings = categoriesWithMostFindings
            self.date = date
            self.openFindings = openFindings
            self.scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindings
            self.scansWithMostOpenFindings = scansWithMostOpenFindings
        }

        private enum CodingKeys: String, CodingKey {
            case categoriesWithMostFindings = "categoriesWithMostFindings"
            case date = "date"
            case openFindings = "openFindings"
            case scansWithMostOpenCriticalFindings = "scansWithMostOpenCriticalFindings"
            case scansWithMostOpenFindings = "scansWithMostOpenFindings"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// The URL address to the recommendation for remediating the finding.
        public let url: String?

        @inlinable
        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case url = "url"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to remediate a finding.
        public let recommendation: Recommendation?
        /// A list of SuggestedFix objects. Each object contains information about a suggested code fix to remediate the finding.
        public let suggestedFixes: [SuggestedFix]?

        @inlinable
        public init(recommendation: Recommendation? = nil, suggestedFixes: [SuggestedFix]? = nil) {
            self.recommendation = recommendation
            self.suggestedFixes = suggestedFixes
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "recommendation"
            case suggestedFixes = "suggestedFixes"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The scanName of the scan that was run on the resource.
        public let id: String?
        /// The identifier for a section of the resource.
        public let subResourceId: String?

        @inlinable
        public init(id: String? = nil, subResourceId: String? = nil) {
            self.id = id
            self.subResourceId = subResourceId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case subResourceId = "subResourceId"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// The identifier for the error.
        public let errorCode: String
        /// Description of the error.
        public let message: String
        /// The identifier for the resource that was not found.
        public let resourceId: String
        /// The type of resource that was not found.
        public let resourceType: String

        @inlinable
        public init(errorCode: String, message: String, resourceId: String, resourceType: String) {
            self.errorCode = errorCode
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ScanNameWithFindingNum: AWSDecodableShape {
        /// The number of findings generated by a scan.
        public let findingNumber: Int?
        /// The name of the scan.
        public let scanName: String?

        @inlinable
        public init(findingNumber: Int? = nil, scanName: String? = nil) {
            self.findingNumber = findingNumber
            self.scanName = scanName
        }

        private enum CodingKeys: String, CodingKey {
            case findingNumber = "findingNumber"
            case scanName = "scanName"
        }
    }

    public struct ScanSummary: AWSDecodableShape {
        ///  The time when the scan was created.
        public let createdAt: Date
        /// The identifier for the scan run.
        public let runId: String
        /// The name of the scan.
        public let scanName: String
        /// The ARN for the scan name.
        public let scanNameArn: String?
        /// The state of the scan. A scan can be In Progress,  Complete, or Failed.
        public let scanState: ScanState
        /// The time the scan was last updated. A scan is updated when it is re-run.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date, runId: String, scanName: String, scanNameArn: String? = nil, scanState: ScanState, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case runId = "runId"
            case scanName = "scanName"
            case scanNameArn = "scanNameArn"
            case scanState = "scanState"
            case updatedAt = "updatedAt"
        }
    }

    public struct SuggestedFix: AWSDecodableShape {
        /// The suggested code fix. If applicable, includes code patch to replace your source code.
        public let code: String?
        /// A description of the suggested code fix and why it is being suggested.
        public let description: String?

        @inlinable
        public init(code: String? = nil, description: String? = nil) {
            self.code = code
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case description = "description"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
        public let resourceArn: String
        /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        /// The identifier for the error.
        public let errorCode: String
        /// Description of the error.
        public let message: String
        /// The identifier for the originating quota.
        public let quotaCode: String?
        /// The identifier for the originating service.
        public let serviceCode: String?

        @inlinable
        public init(errorCode: String, message: String, quotaCode: String? = nil, serviceCode: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.quotaCode = quotaCode
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
        public let resourceArn: String
        /// A list of keys for each tag you want to remove from a scan.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 300)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:codeguru-security:[\\S]+:[\\d]{12}:scans\\/[a-zA-Z0-9-_$:.]*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccountConfigurationRequest: AWSEncodableShape {
        /// The customer-managed KMS key ARN you want to use for encryption. If not specified, CodeGuru Security will use an AWS-managed key for encryption. If you previously specified a customer-managed KMS key and want CodeGuru Security to use an AWS-managed key for encryption instead, pass nothing.
        public let encryptionConfig: EncryptionConfig

        @inlinable
        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        public func validate(name: String) throws {
            try self.encryptionConfig.validate(name: "\(name).encryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct UpdateAccountConfigurationResponse: AWSDecodableShape {
        /// An EncryptionConfig object that contains the KMS key ARN that is used for encryption. If you did not specify a customer-managed KMS key in the request, returns empty.
        public let encryptionConfig: EncryptionConfig

        @inlinable
        public init(encryptionConfig: EncryptionConfig) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The identifier for the error.
        public let errorCode: String
        /// The field that caused the error, if applicable.
        public let fieldList: [ValidationExceptionField]?
        /// Description of the error.
        public let message: String
        /// The reason the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(errorCode: String, fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.errorCode = errorCode
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// Describes the exception.
        public let message: String
        /// The name of the exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct Vulnerability: AWSDecodableShape {
        ///  An object that describes the location of the detected security vulnerability in your code.
        public let filePath: FilePath?
        /// The identifier for the vulnerability.
        public let id: String?
        /// The number of times the vulnerability appears in your code.
        public let itemCount: Int?
        /// One or more URL addresses that contain details about a vulnerability.
        public let referenceUrls: [String]?
        /// One or more vulnerabilities that are related to the vulnerability being described.
        public let relatedVulnerabilities: [String]?

        @inlinable
        public init(filePath: FilePath? = nil, id: String? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil) {
            self.filePath = filePath
            self.id = id
            self.itemCount = nil
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
        }

        @available(*, deprecated, message: "Members itemCount have been deprecated")
        @inlinable
        public init(filePath: FilePath? = nil, id: String? = nil, itemCount: Int? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil) {
            self.filePath = filePath
            self.id = id
            self.itemCount = itemCount
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
        }

        private enum CodingKeys: String, CodingKey {
            case filePath = "filePath"
            case id = "id"
            case itemCount = "itemCount"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
        }
    }

    public struct ResourceId: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the code file uploaded to the resource object. Returned by CreateUploadUrl when you upload resources to be scanned.
        public let codeArtifactId: String?

        @inlinable
        public init(codeArtifactId: String? = nil) {
            self.codeArtifactId = codeArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.codeArtifactId, name: "codeArtifactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeArtifactId = "codeArtifactId"
        }
    }
}

// MARK: - Errors

/// Error enum for CodeGuruSecurity
public struct CodeGuruSecurityErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CodeGuruSecurity
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource specified in the request was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension CodeGuruSecurityErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": CodeGuruSecurity.AccessDeniedException.self,
        "ConflictException": CodeGuruSecurity.ConflictException.self,
        "InternalServerException": CodeGuruSecurity.InternalServerException.self,
        "ResourceNotFoundException": CodeGuruSecurity.ResourceNotFoundException.self,
        "ThrottlingException": CodeGuruSecurity.ThrottlingException.self,
        "ValidationException": CodeGuruSecurity.ValidationException.self
    ]
}

extension CodeGuruSecurityErrorType: Equatable {
    public static func == (lhs: CodeGuruSecurityErrorType, rhs: CodeGuruSecurityErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CodeGuruSecurityErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
