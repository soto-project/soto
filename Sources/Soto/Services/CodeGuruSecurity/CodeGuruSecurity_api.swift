//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS CodeGuruSecurity service.
///
///  Amazon CodeGuru Security is in preview release and is subject to change.  This section provides documentation for the Amazon CodeGuru Security API operations. CodeGuru Security is a service that uses program analysis and machine learning to detect security policy violations and vulnerabilities, and recommends ways to address these security risks. By proactively detecting and providing recommendations for addressing security risks, CodeGuru Security improves the overall security of your application code. For more information about CodeGuru Security, see the  Amazon CodeGuru Security User Guide.
public struct CodeGuruSecurity: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the CodeGuruSecurity client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "CodeGuruSecurity",
            serviceIdentifier: "codeguru-security",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            errorType: CodeGuruSecurityErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Returns a list of requested findings from standard scans.
    @Sendable
    @inlinable
    public func batchGetFindings(_ input: BatchGetFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetFindingsResponse {
        try await self.client.execute(
            operation: "BatchGetFindings", 
            path: "/batchGetFindings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of requested findings from standard scans.
    ///
    /// Parameters:
    ///   - findingIdentifiers: A list of finding identifiers. Each identifier consists of a scanName and a findingId. You retrieve the findingId when you call GetFindings.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetFindings(
        findingIdentifiers: [FindingIdentifier],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetFindingsResponse {
        let input = BatchGetFindingsRequest(
            findingIdentifiers: findingIdentifiers
        )
        return try await self.batchGetFindings(input, logger: logger)
    }

    /// Use to create a scan using code uploaded to an Amazon S3 bucket.
    @Sendable
    @inlinable
    public func createScan(_ input: CreateScanRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScanResponse {
        try await self.client.execute(
            operation: "CreateScan", 
            path: "/scans", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use to create a scan using code uploaded to an Amazon S3 bucket.
    ///
    /// Parameters:
    ///   - analysisType: The type of analysis you want CodeGuru Security to perform in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings. Defaults to Security type if missing.
    ///   - clientToken: The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
    ///   - resourceId: The identifier for the resource object to be scanned.
    ///   - scanName: The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a STANDARD scan type.
    ///   - scanType: The type of scan, either Standard or Express. Defaults to Standard type if missing.  Express scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. Standard scans have standard resource limits and use the full set of detectors to analyze your code.
    ///   - tags: An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    ///   - logger: Logger use during operation
    @inlinable
    public func createScan(
        analysisType: AnalysisType? = nil,
        clientToken: String? = CreateScanRequest.idempotencyToken(),
        resourceId: ResourceId,
        scanName: String,
        scanType: ScanType? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScanResponse {
        let input = CreateScanRequest(
            analysisType: analysisType, 
            clientToken: clientToken, 
            resourceId: resourceId, 
            scanName: scanName, 
            scanType: scanType, 
            tags: tags
        )
        return try await self.createScan(input, logger: logger)
    }

    /// Generates a pre-signed URL, request headers used to upload a code resource, and code artifact identifier for the uploaded resource. You can upload your code resource to the URL with the request headers using any HTTP client.
    @Sendable
    @inlinable
    public func createUploadUrl(_ input: CreateUploadUrlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUploadUrlResponse {
        try await self.client.execute(
            operation: "CreateUploadUrl", 
            path: "/uploadUrl", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates a pre-signed URL, request headers used to upload a code resource, and code artifact identifier for the uploaded resource. You can upload your code resource to the URL with the request headers using any HTTP client.
    ///
    /// Parameters:
    ///   - scanName: The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this  scanName when you call CreateScan on the code resource you upload to this URL.
    ///   - logger: Logger use during operation
    @inlinable
    public func createUploadUrl(
        scanName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateUploadUrlResponse {
        let input = CreateUploadUrlRequest(
            scanName: scanName
        )
        return try await self.createUploadUrl(input, logger: logger)
    }

    /// Use to get the encryption configuration for an account.
    @Sendable
    @inlinable
    public func getAccountConfiguration(_ input: GetAccountConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAccountConfigurationResponse {
        try await self.client.execute(
            operation: "GetAccountConfiguration", 
            path: "/accountConfiguration/get", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use to get the encryption configuration for an account.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getAccountConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAccountConfigurationResponse {
        let input = GetAccountConfigurationRequest(
        )
        return try await self.getAccountConfiguration(input, logger: logger)
    }

    /// Returns a list of all findings generated by a particular scan.
    @Sendable
    @inlinable
    public func getFindings(_ input: GetFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFindingsResponse {
        try await self.client.execute(
            operation: "GetFindings", 
            path: "/findings/{scanName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all findings generated by a particular scan.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    ///   - nextToken: A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    ///   - scanName: The name of the scan you want to retrieve findings from.
    ///   - status: The status of the findings you want to get. Pass either Open, Closed, or All.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFindings(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scanName: String,
        status: Status? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFindingsResponse {
        let input = GetFindingsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            scanName: scanName, 
            status: status
        )
        return try await self.getFindings(input, logger: logger)
    }

    /// Returns a summary of metrics for an account from a specified date, including number of open findings, the categories with most findings, the scans with most open findings, and scans with most open critical findings.
    @Sendable
    @inlinable
    public func getMetricsSummary(_ input: GetMetricsSummaryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMetricsSummaryResponse {
        try await self.client.execute(
            operation: "GetMetricsSummary", 
            path: "/metrics/summary", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a summary of metrics for an account from a specified date, including number of open findings, the categories with most findings, the scans with most open findings, and scans with most open critical findings.
    ///
    /// Parameters:
    ///   - date: The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMetricsSummary(
        date: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMetricsSummaryResponse {
        let input = GetMetricsSummaryRequest(
            date: date
        )
        return try await self.getMetricsSummary(input, logger: logger)
    }

    /// Returns details about a scan, including whether or not a scan has completed.
    @Sendable
    @inlinable
    public func getScan(_ input: GetScanRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetScanResponse {
        try await self.client.execute(
            operation: "GetScan", 
            path: "/scans/{scanName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns details about a scan, including whether or not a scan has completed.
    ///
    /// Parameters:
    ///   - runId: UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the CreateScan operation. Defaults to the latest scan run if missing.
    ///   - scanName: The name of the scan you want to view details about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getScan(
        runId: String? = nil,
        scanName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetScanResponse {
        let input = GetScanRequest(
            runId: runId, 
            scanName: scanName
        )
        return try await self.getScan(input, logger: logger)
    }

    /// Returns metrics about all findings in an account within a specified time range.
    @Sendable
    @inlinable
    public func listFindingsMetrics(_ input: ListFindingsMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFindingsMetricsResponse {
        try await self.client.execute(
            operation: "ListFindingsMetrics", 
            path: "/metrics/findings", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns metrics about all findings in an account within a specified time range.
    ///
    /// Parameters:
    ///   - endDate: The end date of the interval which you want to retrieve metrics from. Round to the nearest day.
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    ///   - nextToken: A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    ///   - startDate: The start date of the interval which you want to retrieve metrics from. Rounds to the nearest day.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFindingsMetrics(
        endDate: Date,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startDate: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFindingsMetricsResponse {
        let input = ListFindingsMetricsRequest(
            endDate: endDate, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startDate: startDate
        )
        return try await self.listFindingsMetrics(input, logger: logger)
    }

    /// Returns a list of all scans in an account. Does not return EXPRESS scans.
    @Sendable
    @inlinable
    public func listScans(_ input: ListScansRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListScansResponse {
        try await self.client.execute(
            operation: "ListScans", 
            path: "/scans", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all scans in an account. Does not return EXPRESS scans.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 100 results.
    ///   - nextToken: A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    ///   - logger: Logger use during operation
    @inlinable
    public func listScans(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListScansResponse {
        let input = ListScansRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listScans(input, logger: logger)
    }

    /// Returns a list of all tags associated with a scan.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all tags associated with a scan.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Use to add one or more tags to an existing scan.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use to add one or more tags to an existing scan.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    ///   - tags: An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:   A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.   An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Use to remove one or more tags from an existing scan.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use to remove one or more tags from an existing scan.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    ///   - tagKeys: A list of keys for each tag you want to remove from a scan.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Use to update the encryption configuration for an account.
    @Sendable
    @inlinable
    public func updateAccountConfiguration(_ input: UpdateAccountConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAccountConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateAccountConfiguration", 
            path: "/updateAccountConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use to update the encryption configuration for an account.
    ///
    /// Parameters:
    ///   - encryptionConfig: The customer-managed KMS key ARN you want to use for encryption. If not specified, CodeGuru Security will use an AWS-managed key for encryption. If you previously specified a customer-managed KMS key and want CodeGuru Security to use an AWS-managed key for encryption instead, pass nothing.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAccountConfiguration(
        encryptionConfig: EncryptionConfig,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAccountConfigurationResponse {
        let input = UpdateAccountConfigurationRequest(
            encryptionConfig: encryptionConfig
        )
        return try await self.updateAccountConfiguration(input, logger: logger)
    }
}

extension CodeGuruSecurity {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: CodeGuruSecurity, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CodeGuruSecurity {
    /// Return PaginatorSequence for operation ``getFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getFindingsPaginator(
        _ input: GetFindingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetFindingsRequest, GetFindingsResponse> {
        return .init(
            input: input,
            command: self.getFindings,
            inputKey: \GetFindingsRequest.nextToken,
            outputKey: \GetFindingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    ///   - scanName: The name of the scan you want to retrieve findings from.
    ///   - status: The status of the findings you want to get. Pass either Open, Closed, or All.
    ///   - logger: Logger used for logging
    @inlinable
    public func getFindingsPaginator(
        maxResults: Int? = nil,
        scanName: String,
        status: Status? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetFindingsRequest, GetFindingsResponse> {
        let input = GetFindingsRequest(
            maxResults: maxResults, 
            scanName: scanName, 
            status: status
        )
        return self.getFindingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFindingsMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFindingsMetricsPaginator(
        _ input: ListFindingsMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFindingsMetricsRequest, ListFindingsMetricsResponse> {
        return .init(
            input: input,
            command: self.listFindingsMetrics,
            inputKey: \ListFindingsMetricsRequest.nextToken,
            outputKey: \ListFindingsMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFindingsMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endDate: The end date of the interval which you want to retrieve metrics from. Round to the nearest day.
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    ///   - startDate: The start date of the interval which you want to retrieve metrics from. Rounds to the nearest day.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFindingsMetricsPaginator(
        endDate: Date,
        maxResults: Int? = nil,
        startDate: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFindingsMetricsRequest, ListFindingsMetricsResponse> {
        let input = ListFindingsMetricsRequest(
            endDate: endDate, 
            maxResults: maxResults, 
            startDate: startDate
        )
        return self.listFindingsMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listScans(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listScansPaginator(
        _ input: ListScansRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListScansRequest, ListScansResponse> {
        return .init(
            input: input,
            command: self.listScans,
            inputKey: \ListScansRequest.nextToken,
            outputKey: \ListScansResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listScans(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 100 results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listScansPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListScansRequest, ListScansResponse> {
        let input = ListScansRequest(
            maxResults: maxResults
        )
        return self.listScansPaginator(input, logger: logger)
    }
}

extension CodeGuruSecurity.GetFindingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> CodeGuruSecurity.GetFindingsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            scanName: self.scanName,
            status: self.status
        )
    }
}

extension CodeGuruSecurity.ListFindingsMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> CodeGuruSecurity.ListFindingsMetricsRequest {
        return .init(
            endDate: self.endDate,
            maxResults: self.maxResults,
            nextToken: token,
            startDate: self.startDate
        )
    }
}

extension CodeGuruSecurity.ListScansRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> CodeGuruSecurity.ListScansRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
