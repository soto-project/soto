//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ARCRegionSwitch {
    // MARK: Enums

    public enum AlarmCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case green = "green"
        case red = "red"
        public var description: String { return self.rawValue }
    }

    public enum AlarmType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applicationHealth = "applicationHealth"
        case trigger = "trigger"
        public var description: String { return self.rawValue }
    }

    public enum Approval: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approve = "approve"
        case decline = "decline"
        public var description: String { return self.rawValue }
    }

    public enum DocumentDbDefaultBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failover = "failover"
        case switchoverOnly = "switchoverOnly"
        public var description: String { return self.rawValue }
    }

    public enum DocumentDbUngracefulBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failover = "failover"
        public var description: String { return self.rawValue }
    }

    public enum Ec2AsgCapacityMonitoringApproach: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoscalingMaxInLast24Hours = "autoscalingMaxInLast24Hours"
        case sampledMaxInLast24Hours = "sampledMaxInLast24Hours"
        public var description: String { return self.rawValue }
    }

    public enum EcsCapacityMonitoringApproach: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case containerInsightsMaxInLast24Hours = "containerInsightsMaxInLast24Hours"
        case sampledMaxInLast24Hours = "sampledMaxInLast24Hours"
        public var description: String { return self.rawValue }
    }

    public enum EksCapacityMonitoringApproach: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sampledMaxInLast24Hours = "sampledMaxInLast24Hours"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionRequired = "actionRequired"
        case passed = "passed"
        case pendingEvaluation = "pendingEvaluation"
        case unknown = "unknown"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activate = "activate"
        case deactivate = "deactivate"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionBlockType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aurora = "AuroraGlobalDatabase"
        case customActionLambda = "CustomActionLambda"
        case documentdb = "DocumentDb"
        case ec2Asg = "EC2AutoScaling"
        case ecs = "ECSServiceScaling"
        case eksResourceScaling = "EKSResourceScaling"
        case executionApproval = "ManualApproval"
        case parallel = "Parallel"
        case regionSwitch = "ARCRegionSwitchPlan"
        case route53HealthCheck = "Route53HealthCheck"
        case routingControl = "ARCRoutingControl"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executionBehaviorChangedToGraceful = "executionBehaviorChangedToGraceful"
        case executionBehaviorChangedToUngraceful = "executionBehaviorChangedToUngraceful"
        case executionCanceled = "executionCanceled"
        case executionCanceling = "executionCanceling"
        case executionFailed = "executionFailed"
        case executionPaused = "executionPaused"
        case executionPausing = "executionPausing"
        case executionPending = "executionPending"
        case executionPendingApproval = "executionPendingApproval"
        case executionPendingChildPlanManualApproval = "executionPendingChildPlanManualApproval"
        case executionStarted = "executionStarted"
        case executionSucceeded = "executionSucceeded"
        case executionSuccessMonitoringApplicationHealth = "executionSuccessMonitoringApplicationHealth"
        case planEvaluationWarning = "planEvaluationWarning"
        case stepCanceled = "stepCanceled"
        case stepExecutionBehaviorChangedToUngraceful = "stepExecutionBehaviorChangedToUngraceful"
        case stepFailed = "stepFailed"
        case stepPausedByError = "stepPausedByError"
        case stepPausedByOperator = "stepPausedByOperator"
        case stepPendingApplicationHealthMonitor = "stepPendingApplicationHealthMonitor"
        case stepPendingApproval = "stepPendingApproval"
        case stepSkipped = "stepSkipped"
        case stepStarted = "stepStarted"
        case stepSucceeded = "stepSucceeded"
        case stepUpdate = "stepUpdate"
        case unknown = "unknown"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case graceful = "graceful"
        case ungraceful = "ungraceful"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "canceled"
        case completed = "completed"
        case completedMonitoringApplicationHealth = "completedMonitoringApplicationHealth"
        case completedWithExceptions = "completedWithExceptions"
        case failed = "failed"
        case inProgress = "inProgress"
        case pausedByFailedStep = "pausedByFailedStep"
        case pausedByOperator = "pausedByOperator"
        case pending = "pending"
        case pendingManualApproval = "pendingManualApproval"
        case planExecutionTimedOut = "planExecutionTimedOut"
        public var description: String { return self.rawValue }
    }

    public enum FailedReportErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationError = "configurationError"
        case insufficientPermissions = "insufficientPermissions"
        case invalidResource = "invalidResource"
        public var description: String { return self.rawValue }
    }

    public enum GlobalAuroraDefaultBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failover = "failover"
        case switchoverOnly = "switchoverOnly"
        public var description: String { return self.rawValue }
    }

    public enum GlobalAuroraUngracefulBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failover = "failover"
        public var description: String { return self.rawValue }
    }

    public enum LambdaUngracefulBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case skip = "skip"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryApproach: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeActive = "activeActive"
        case activePassive = "activePassive"
        public var description: String { return self.rawValue }
    }

    public enum RegionToRunIn: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activatingRegion = "activatingRegion"
        case deactivatingRegion = "deactivatingRegion"
        public var description: String { return self.rawValue }
    }

    public enum ResourceWarningStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "active"
        case resolved = "resolved"
        public var description: String { return self.rawValue }
    }

    public enum Route53HealthCheckStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "healthy"
        case unhealthy = "unhealthy"
        case unknown = "unknown"
        public var description: String { return self.rawValue }
    }

    public enum RoutingControlStateChange: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "Off"
        case on = "On"
        public var description: String { return self.rawValue }
    }

    public enum StepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "canceled"
        case completed = "completed"
        case failed = "failed"
        case notStarted = "notStarted"
        case pendingApproval = "pendingApproval"
        case running = "running"
        case skipped = "skipped"
        public var description: String { return self.rawValue }
    }

    public enum UpdatePlanExecutionAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pause = "pause"
        case resume = "resume"
        case switchToGraceful = "switchToGraceful"
        case switchToUngraceful = "switchToUngraceful"
        public var description: String { return self.rawValue }
    }

    public enum UpdatePlanExecutionStepAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case skip = "skip"
        case switchToUngraceful = "switchToUngraceful"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowTargetAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activate = "activate"
        case deactivate = "deactivate"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionBlockConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An ARC routing control execution block.
        case arcRoutingControlConfig(ArcRoutingControlConfiguration)
        /// An Amazon Web Services Lambda execution block.
        case customActionLambdaConfig(CustomActionLambdaConfiguration)
        case documentDbConfig(DocumentDbConfiguration)
        /// An EC2 Auto Scaling group execution block.
        case ec2AsgCapacityIncreaseConfig(Ec2AsgCapacityIncreaseConfiguration)
        /// The capacity increase specified for the configuration.
        case ecsCapacityIncreaseConfig(EcsCapacityIncreaseConfiguration)
        /// An Amazon Web Services EKS resource scaling execution block.
        case eksResourceScalingConfig(EksResourceScalingConfiguration)
        /// A manual approval execution block.
        case executionApprovalConfig(ExecutionApprovalConfiguration)
        /// An Aurora Global Database execution block.
        case globalAuroraConfig(GlobalAuroraConfiguration)
        /// A parallel configuration execution block.
        case parallelConfig(ParallelExecutionBlockConfiguration)
        /// A Region switch plan execution block.
        case regionSwitchPlanConfig(RegionSwitchPlanConfiguration)
        /// The Amazon Route 53 health check configuration.
        case route53HealthCheckConfig(Route53HealthCheckConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .arcRoutingControlConfig:
                let value = try container.decode(ArcRoutingControlConfiguration.self, forKey: .arcRoutingControlConfig)
                self = .arcRoutingControlConfig(value)
            case .customActionLambdaConfig:
                let value = try container.decode(CustomActionLambdaConfiguration.self, forKey: .customActionLambdaConfig)
                self = .customActionLambdaConfig(value)
            case .documentDbConfig:
                let value = try container.decode(DocumentDbConfiguration.self, forKey: .documentDbConfig)
                self = .documentDbConfig(value)
            case .ec2AsgCapacityIncreaseConfig:
                let value = try container.decode(Ec2AsgCapacityIncreaseConfiguration.self, forKey: .ec2AsgCapacityIncreaseConfig)
                self = .ec2AsgCapacityIncreaseConfig(value)
            case .ecsCapacityIncreaseConfig:
                let value = try container.decode(EcsCapacityIncreaseConfiguration.self, forKey: .ecsCapacityIncreaseConfig)
                self = .ecsCapacityIncreaseConfig(value)
            case .eksResourceScalingConfig:
                let value = try container.decode(EksResourceScalingConfiguration.self, forKey: .eksResourceScalingConfig)
                self = .eksResourceScalingConfig(value)
            case .executionApprovalConfig:
                let value = try container.decode(ExecutionApprovalConfiguration.self, forKey: .executionApprovalConfig)
                self = .executionApprovalConfig(value)
            case .globalAuroraConfig:
                let value = try container.decode(GlobalAuroraConfiguration.self, forKey: .globalAuroraConfig)
                self = .globalAuroraConfig(value)
            case .parallelConfig:
                let value = try container.decode(ParallelExecutionBlockConfiguration.self, forKey: .parallelConfig)
                self = .parallelConfig(value)
            case .regionSwitchPlanConfig:
                let value = try container.decode(RegionSwitchPlanConfiguration.self, forKey: .regionSwitchPlanConfig)
                self = .regionSwitchPlanConfig(value)
            case .route53HealthCheckConfig:
                let value = try container.decode(Route53HealthCheckConfiguration.self, forKey: .route53HealthCheckConfig)
                self = .route53HealthCheckConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .arcRoutingControlConfig(let value):
                try container.encode(value, forKey: .arcRoutingControlConfig)
            case .customActionLambdaConfig(let value):
                try container.encode(value, forKey: .customActionLambdaConfig)
            case .documentDbConfig(let value):
                try container.encode(value, forKey: .documentDbConfig)
            case .ec2AsgCapacityIncreaseConfig(let value):
                try container.encode(value, forKey: .ec2AsgCapacityIncreaseConfig)
            case .ecsCapacityIncreaseConfig(let value):
                try container.encode(value, forKey: .ecsCapacityIncreaseConfig)
            case .eksResourceScalingConfig(let value):
                try container.encode(value, forKey: .eksResourceScalingConfig)
            case .executionApprovalConfig(let value):
                try container.encode(value, forKey: .executionApprovalConfig)
            case .globalAuroraConfig(let value):
                try container.encode(value, forKey: .globalAuroraConfig)
            case .parallelConfig(let value):
                try container.encode(value, forKey: .parallelConfig)
            case .regionSwitchPlanConfig(let value):
                try container.encode(value, forKey: .regionSwitchPlanConfig)
            case .route53HealthCheckConfig(let value):
                try container.encode(value, forKey: .route53HealthCheckConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .arcRoutingControlConfig(let value):
                try value.validate(name: "\(name).arcRoutingControlConfig")
            case .customActionLambdaConfig(let value):
                try value.validate(name: "\(name).customActionLambdaConfig")
            case .documentDbConfig(let value):
                try value.validate(name: "\(name).documentDbConfig")
            case .ec2AsgCapacityIncreaseConfig(let value):
                try value.validate(name: "\(name).ec2AsgCapacityIncreaseConfig")
            case .ecsCapacityIncreaseConfig(let value):
                try value.validate(name: "\(name).ecsCapacityIncreaseConfig")
            case .eksResourceScalingConfig(let value):
                try value.validate(name: "\(name).eksResourceScalingConfig")
            case .globalAuroraConfig(let value):
                try value.validate(name: "\(name).globalAuroraConfig")
            case .parallelConfig(let value):
                try value.validate(name: "\(name).parallelConfig")
            case .regionSwitchPlanConfig(let value):
                try value.validate(name: "\(name).regionSwitchPlanConfig")
            case .route53HealthCheckConfig(let value):
                try value.validate(name: "\(name).route53HealthCheckConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arcRoutingControlConfig = "arcRoutingControlConfig"
            case customActionLambdaConfig = "customActionLambdaConfig"
            case documentDbConfig = "documentDbConfig"
            case ec2AsgCapacityIncreaseConfig = "ec2AsgCapacityIncreaseConfig"
            case ecsCapacityIncreaseConfig = "ecsCapacityIncreaseConfig"
            case eksResourceScalingConfig = "eksResourceScalingConfig"
            case executionApprovalConfig = "executionApprovalConfig"
            case globalAuroraConfig = "globalAuroraConfig"
            case parallelConfig = "parallelConfig"
            case regionSwitchPlanConfig = "regionSwitchPlanConfig"
            case route53HealthCheckConfig = "route53HealthCheckConfig"
        }
    }

    public enum ReportOutput: AWSDecodableShape, Sendable {
        /// The details about a failed report generation.
        case failedReportOutput(FailedReportOutput)
        /// Information about a report delivered to Amazon S3.
        case s3ReportOutput(S3ReportOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .failedReportOutput:
                let value = try container.decode(FailedReportOutput.self, forKey: .failedReportOutput)
                self = .failedReportOutput(value)
            case .s3ReportOutput:
                let value = try container.decode(S3ReportOutput.self, forKey: .s3ReportOutput)
                self = .s3ReportOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case failedReportOutput = "failedReportOutput"
            case s3ReportOutput = "s3ReportOutput"
        }
    }

    // MARK: Shapes

    public struct AbbreviatedExecution: AWSDecodableShape {
        /// The actual recovery time that Region switch calculates for a plan execution. Actual recovery time includes the time for the plan to run added to the time elapsed until the application health alarms that you've specified are healthy again.
        public let actualRecoveryTime: String?
        /// An optional comment about the plan execution.
        public let comment: String?
        /// The timestamp when the plan execution was ended.
        public let endTime: Date?
        /// The plan execution action. Valid values are Activate, to activate an Amazon Web Services Region, or Deactivate, to deactivate a Region.
        public let executionAction: ExecutionAction
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The Amazon Web Services Region for a plan execution.
        public let executionRegion: String
        /// The plan execution state. Provides the state of a plan execution, for example, In Progress or Paused by Operator.
        public let executionState: ExecutionState
        /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
        public let mode: ExecutionMode
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String
        /// The timestamp when the plan execution was started.
        public let startTime: Date
        /// The timestamp when the plan execution was last updated.
        public let updatedAt: Date?
        /// The version for the plan.
        public let version: String?

        @inlinable
        public init(actualRecoveryTime: String? = nil, comment: String? = nil, endTime: Date? = nil, executionAction: ExecutionAction, executionId: String, executionRegion: String, executionState: ExecutionState, mode: ExecutionMode, planArn: String, startTime: Date, updatedAt: Date? = nil, version: String? = nil) {
            self.actualRecoveryTime = actualRecoveryTime
            self.comment = comment
            self.endTime = endTime
            self.executionAction = executionAction
            self.executionId = executionId
            self.executionRegion = executionRegion
            self.executionState = executionState
            self.mode = mode
            self.planArn = planArn
            self.startTime = startTime
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case actualRecoveryTime = "actualRecoveryTime"
            case comment = "comment"
            case endTime = "endTime"
            case executionAction = "executionAction"
            case executionId = "executionId"
            case executionRegion = "executionRegion"
            case executionState = "executionState"
            case mode = "mode"
            case planArn = "planArn"
            case startTime = "startTime"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct AbbreviatedPlan: AWSDecodableShape {
        /// Specifies if this is the active plan execution at this time.
        public let activePlanExecution: String?
        /// The Amazon Resource Name (ARN) of the Region switch plan.
        public let arn: String
        /// The description of a Region switch plan.
        public let description: String?
        /// The execution role is a way to categorize a Region switch plan.
        public let executionRole: String?
        /// The name of a Region switch plan.
        public let name: String
        /// The owner of a Region switch plan.
        public let owner: String
        /// The primary Region for a plan.
        public let primaryRegion: String?
        /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
        public let recoveryApproach: RecoveryApproach
        /// The recovery time objective that you've specified.
        public let recoveryTimeObjectiveMinutes: Int?
        /// The Amazon Web Services Region specified for a Region switch plan.
        public let regions: [String]
        /// The timestamp when the plan execution was last updated.
        public let updatedAt: Date?
        /// The version for the plan.
        public let version: String?

        @inlinable
        public init(activePlanExecution: String? = nil, arn: String, description: String? = nil, executionRole: String? = nil, name: String, owner: String, primaryRegion: String? = nil, recoveryApproach: RecoveryApproach, recoveryTimeObjectiveMinutes: Int? = nil, regions: [String], updatedAt: Date? = nil, version: String? = nil) {
            self.activePlanExecution = activePlanExecution
            self.arn = arn
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.owner = owner
            self.primaryRegion = primaryRegion
            self.recoveryApproach = recoveryApproach
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.regions = regions
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case activePlanExecution = "activePlanExecution"
            case arn = "arn"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case owner = "owner"
            case primaryRegion = "primaryRegion"
            case recoveryApproach = "recoveryApproach"
            case recoveryTimeObjectiveMinutes = "recoveryTimeObjectiveMinutes"
            case regions = "regions"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct ApprovePlanExecutionStepRequest: AWSEncodableShape {
        /// The status of approval for a plan execution step.
        public let approval: Approval
        /// A comment that you can enter about a plan execution.
        public let comment: String?
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String
        /// The name of a step in a plan execution.
        public let stepName: String

        @inlinable
        public init(approval: Approval, comment: String? = nil, executionId: String, planArn: String, stepName: String) {
            self.approval = approval
            self.comment = comment
            self.executionId = executionId
            self.planArn = planArn
            self.stepName = stepName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1024)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case approval = "approval"
            case comment = "comment"
            case executionId = "executionId"
            case planArn = "planArn"
            case stepName = "stepName"
        }
    }

    public struct ApprovePlanExecutionStepResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ArcRoutingControlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?
        /// The Region and ARC routing controls for the configuration.
        public let regionAndRoutingControls: [String: [ArcRoutingControlState]]
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?

        @inlinable
        public init(crossAccountRole: String? = nil, externalId: String? = nil, regionAndRoutingControls: [String: [ArcRoutingControlState]], timeoutMinutes: Int? = nil) {
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.regionAndRoutingControls = regionAndRoutingControls
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
            case regionAndRoutingControls = "regionAndRoutingControls"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct ArcRoutingControlState: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a routing control.
        public let routingControlArn: String
        /// The state of an ARC routing control, On or Off.
        public let state: RoutingControlStateChange

        @inlinable
        public init(routingControlArn: String, state: RoutingControlStateChange) {
            self.routingControlArn = routingControlArn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case routingControlArn = "routingControlArn"
            case state = "state"
        }
    }

    public struct Asg: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the EC2 Auto Scaling group.
        public let arn: String?
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?

        @inlinable
        public init(arn: String? = nil, crossAccountRole: String? = nil, externalId: String? = nil) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:autoscaling:[a-z0-9-]+:\\d{12}:autoScalingGroup:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}:autoScalingGroupName/[\\S\\s]{1,255}$")
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
        }
    }

    public struct AssociatedAlarm: AWSEncodableShape & AWSDecodableShape {
        /// The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        public let alarmType: AlarmType
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?
        /// The resource identifier for alarms that you associate with a plan.
        public let resourceIdentifier: String

        @inlinable
        public init(alarmType: AlarmType, crossAccountRole: String? = nil, externalId: String? = nil, resourceIdentifier: String) {
            self.alarmType = alarmType
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.resourceIdentifier = resourceIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmType = "alarmType"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
            case resourceIdentifier = "resourceIdentifier"
        }
    }

    public struct CancelPlanExecutionRequest: AWSEncodableShape {
        /// A comment that you can enter about canceling a plan execution step.
        public let comment: String?
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String

        @inlinable
        public init(comment: String? = nil, executionId: String, planArn: String) {
            self.comment = comment
            self.executionId = executionId
            self.planArn = planArn
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1024)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case executionId = "executionId"
            case planArn = "planArn"
        }
    }

    public struct CancelPlanExecutionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreatePlanRequest: AWSEncodableShape {
        /// The alarms associated with a Region switch plan.
        public let associatedAlarms: [String: AssociatedAlarm]?
        /// The description of a Region switch plan.
        public let description: String?
        /// An execution role is a way to categorize a Region switch plan.
        public let executionRole: String
        /// The name of a Region switch plan.
        public let name: String
        /// The primary Amazon Web Services Region for the application. This is the Region where the application normally runs before any Region switch occurs.
        public let primaryRegion: String?
        /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
        public let recoveryApproach: RecoveryApproach
        /// Optionally, you can specify an recovery time objective for a Region switch plan, in minutes.
        public let recoveryTimeObjectiveMinutes: Int?
        /// An array that specifies the Amazon Web Services Regions for a Region switch plan. Specify two Regions.
        public let regions: [String]
        public let reportConfiguration: ReportConfiguration?
        /// The tags to apply to the Region switch plan.
        public let tags: [String: String]?
        /// The triggers associated with a Region switch plan.
        public let triggers: [Trigger]?
        /// An array of workflows included in a Region switch plan.
        public let workflows: [Workflow]

        @inlinable
        public init(associatedAlarms: [String: AssociatedAlarm]? = nil, description: String? = nil, executionRole: String, name: String, primaryRegion: String? = nil, recoveryApproach: RecoveryApproach, recoveryTimeObjectiveMinutes: Int? = nil, regions: [String], reportConfiguration: ReportConfiguration? = nil, tags: [String: String]? = nil, triggers: [Trigger]? = nil, workflows: [Workflow]) {
            self.associatedAlarms = associatedAlarms
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.primaryRegion = primaryRegion
            self.recoveryApproach = recoveryApproach
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.regions = regions
            self.reportConfiguration = reportConfiguration
            self.tags = tags
            self.triggers = triggers
            self.workflows = workflows
        }

        public func validate(name: String) throws {
            try self.associatedAlarms?.forEach {
                try $0.value.validate(name: "\(name).associatedAlarms[\"\($0.key)\"]")
            }
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?$")
            try self.validate(self.primaryRegion, name: "primaryRegion", parent: name, pattern: "^[a-z]{2}-[a-z-]+-\\d+$")
            try self.regions.forEach {
                try validate($0, name: "regions[]", parent: name, pattern: "^[a-z]{2}-[a-z-]+-\\d+$")
            }
            try self.validate(self.regions, name: "regions", parent: name, max: 2)
            try self.validate(self.regions, name: "regions", parent: name, min: 2)
            try self.reportConfiguration?.validate(name: "\(name).reportConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.triggers?.forEach {
                try $0.validate(name: "\(name).triggers[]")
            }
            try self.workflows.forEach {
                try $0.validate(name: "\(name).workflows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAlarms = "associatedAlarms"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case primaryRegion = "primaryRegion"
            case recoveryApproach = "recoveryApproach"
            case recoveryTimeObjectiveMinutes = "recoveryTimeObjectiveMinutes"
            case regions = "regions"
            case reportConfiguration = "reportConfiguration"
            case tags = "tags"
            case triggers = "triggers"
            case workflows = "workflows"
        }
    }

    public struct CreatePlanResponse: AWSDecodableShape {
        /// The details of the created Region switch plan.
        public let plan: Plan?

        @inlinable
        public init(plan: Plan? = nil) {
            self.plan = plan
        }

        private enum CodingKeys: String, CodingKey {
            case plan = "plan"
        }
    }

    public struct CustomActionLambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Lambda functions for the execution block.
        public let lambdas: [Lambdas]
        /// The Amazon Web Services Region for the function to run in.
        public let regionToRun: RegionToRunIn
        /// The retry interval specified.
        public let retryIntervalMinutes: Float
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: LambdaUngraceful?

        @inlinable
        public init(lambdas: [Lambdas], regionToRun: RegionToRunIn, retryIntervalMinutes: Float, timeoutMinutes: Int? = nil, ungraceful: LambdaUngraceful? = nil) {
            self.lambdas = lambdas
            self.regionToRun = regionToRun
            self.retryIntervalMinutes = retryIntervalMinutes
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.lambdas.forEach {
                try $0.validate(name: "\(name).lambdas[]")
            }
            try self.validate(self.lambdas, name: "lambdas", parent: name, max: 2)
            try self.validate(self.lambdas, name: "lambdas", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lambdas = "lambdas"
            case regionToRun = "regionToRun"
            case retryIntervalMinutes = "retryIntervalMinutes"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct DeletePlanRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the plan.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeletePlanResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DocumentDbConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The behavior for a global cluster, that is, only allow switchover or also allow failover.
        public let behavior: DocumentDbDefaultBehavior
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The database cluster Amazon Resource Names (ARNs) for a DocumentDB global cluster.
        public let databaseClusterArns: [String]
        /// The external ID (secret key) for the configuration.
        public let externalId: String?
        /// The global cluster identifier for a DocumentDB global cluster.
        public let globalClusterIdentifier: String
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: DocumentDbUngraceful?

        @inlinable
        public init(behavior: DocumentDbDefaultBehavior, crossAccountRole: String? = nil, databaseClusterArns: [String], externalId: String? = nil, globalClusterIdentifier: String, timeoutMinutes: Int? = nil, ungraceful: DocumentDbUngraceful? = nil) {
            self.behavior = behavior
            self.crossAccountRole = crossAccountRole
            self.databaseClusterArns = databaseClusterArns
            self.externalId = externalId
            self.globalClusterIdentifier = globalClusterIdentifier
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
            try self.databaseClusterArns.forEach {
                try validate($0, name: "databaseClusterArns[]", parent: name, pattern: "^arn:aws[a-zA-Z-]*:rds:[a-z0-9-]+:\\d{12}:cluster:[a-zA-Z0-9][a-zA-Z0-9-_]{0,99}$")
            }
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case behavior = "behavior"
            case crossAccountRole = "crossAccountRole"
            case databaseClusterArns = "databaseClusterArns"
            case externalId = "externalId"
            case globalClusterIdentifier = "globalClusterIdentifier"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct DocumentDbUngraceful: AWSEncodableShape & AWSDecodableShape {
        /// The settings for ungraceful execution.
        public let ungraceful: DocumentDbUngracefulBehavior?

        @inlinable
        public init(ungraceful: DocumentDbUngracefulBehavior? = nil) {
            self.ungraceful = ungraceful
        }

        private enum CodingKeys: String, CodingKey {
            case ungraceful = "ungraceful"
        }
    }

    public struct Ec2AsgCapacityIncreaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The EC2 Auto Scaling groups for the configuration.
        public let asgs: [Asg]
        /// The monitoring approach that you specify EC2 Auto Scaling groups for the configuration.
        public let capacityMonitoringApproach: Ec2AsgCapacityMonitoringApproach?
        /// The target percentage that you specify for EC2 Auto Scaling groups.
        public let targetPercent: Int?
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: Ec2Ungraceful?

        @inlinable
        public init(asgs: [Asg], capacityMonitoringApproach: Ec2AsgCapacityMonitoringApproach? = nil, targetPercent: Int? = nil, timeoutMinutes: Int? = nil, ungraceful: Ec2Ungraceful? = nil) {
            self.asgs = asgs
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.asgs.forEach {
                try $0.validate(name: "\(name).asgs[]")
            }
            try self.validate(self.asgs, name: "asgs", parent: name, max: 2)
            try self.validate(self.asgs, name: "asgs", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case asgs = "asgs"
            case capacityMonitoringApproach = "capacityMonitoringApproach"
            case targetPercent = "targetPercent"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct Ec2Ungraceful: AWSEncodableShape & AWSDecodableShape {
        /// The minimum success percentage that you specify for EC2 Auto Scaling groups.
        public let minimumSuccessPercentage: Int

        @inlinable
        public init(minimumSuccessPercentage: Int) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case minimumSuccessPercentage = "minimumSuccessPercentage"
        }
    }

    public struct EcsCapacityIncreaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The monitoring approach specified for the configuration, for example, Most_Recent.
        public let capacityMonitoringApproach: EcsCapacityMonitoringApproach?
        /// The services specified for the configuration.
        public let services: [Service]
        /// The target percentage specified for the configuration.
        public let targetPercent: Int?
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: EcsUngraceful?

        @inlinable
        public init(capacityMonitoringApproach: EcsCapacityMonitoringApproach? = nil, services: [Service], targetPercent: Int? = nil, timeoutMinutes: Int? = nil, ungraceful: EcsUngraceful? = nil) {
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.services = services
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.services.forEach {
                try $0.validate(name: "\(name).services[]")
            }
            try self.validate(self.services, name: "services", parent: name, max: 2)
            try self.validate(self.services, name: "services", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityMonitoringApproach = "capacityMonitoringApproach"
            case services = "services"
            case targetPercent = "targetPercent"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct EcsUngraceful: AWSEncodableShape & AWSDecodableShape {
        /// The minimum success percentage specified for the configuration.
        public let minimumSuccessPercentage: Int

        @inlinable
        public init(minimumSuccessPercentage: Int) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case minimumSuccessPercentage = "minimumSuccessPercentage"
        }
    }

    public struct EksCluster: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services EKS cluster.
        public let clusterArn: String
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?

        @inlinable
        public init(clusterArn: String, crossAccountRole: String? = nil, externalId: String? = nil) {
            self.clusterArn = clusterArn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:eks:[a-z0-9-]+:\\d{12}:cluster/[a-zA-Z0-9][a-zA-Z0-9-_]{0,99}$")
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
        }
    }

    public struct EksResourceScalingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.
        public let capacityMonitoringApproach: EksCapacityMonitoringApproach?
        /// The clusters for the configuration.
        public let eksClusters: [EksCluster]?
        /// The Kubernetes resource type for the configuration.
        public let kubernetesResourceType: KubernetesResourceType
        /// The scaling resources for the configuration.
        public let scalingResources: [[String: [String: KubernetesScalingResource]]]?
        /// The target percentage for the configuration.
        public let targetPercent: Int?
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: EksResourceScalingUngraceful?

        @inlinable
        public init(capacityMonitoringApproach: EksCapacityMonitoringApproach? = nil, eksClusters: [EksCluster]? = nil, kubernetesResourceType: KubernetesResourceType, scalingResources: [[String: [String: KubernetesScalingResource]]]? = nil, targetPercent: Int? = nil, timeoutMinutes: Int? = nil, ungraceful: EksResourceScalingUngraceful? = nil) {
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.eksClusters = eksClusters
            self.kubernetesResourceType = kubernetesResourceType
            self.scalingResources = scalingResources
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.eksClusters?.forEach {
                try $0.validate(name: "\(name).eksClusters[]")
            }
            try self.validate(self.eksClusters, name: "eksClusters", parent: name, min: 2)
            try self.validate(self.scalingResources, name: "scalingResources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityMonitoringApproach = "capacityMonitoringApproach"
            case eksClusters = "eksClusters"
            case kubernetesResourceType = "kubernetesResourceType"
            case scalingResources = "scalingResources"
            case targetPercent = "targetPercent"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct EksResourceScalingUngraceful: AWSEncodableShape & AWSDecodableShape {
        /// The minimum success percentage for the configuration.
        public let minimumSuccessPercentage: Int

        @inlinable
        public init(minimumSuccessPercentage: Int) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case minimumSuccessPercentage = "minimumSuccessPercentage"
        }
    }

    public struct ExecutionApprovalConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The IAM approval role for the configuration.
        public let approvalRole: String
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?

        @inlinable
        public init(approvalRole: String, timeoutMinutes: Int? = nil) {
            self.approvalRole = approvalRole
            self.timeoutMinutes = timeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case approvalRole = "approvalRole"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct ExecutionEvent: AWSDecodableShape {
        /// The description for an execution event.
        public let description: String?
        /// Errors for an execution event.
        public let error: String?
        /// The event ID for an execution event.
        public let eventId: String
        /// The execution block type for an execution event.
        public let executionBlockType: ExecutionBlockType?
        /// The event ID of the previous execution event.
        public let previousEventId: String?
        /// The resources for an execution event.
        public let resources: [String]?
        /// The step name for an execution event.
        public let stepName: String?
        /// The timestamp for an execution event.
        public let timestamp: Date?
        /// The type of an execution event.
        public let type: ExecutionEventType?

        @inlinable
        public init(description: String? = nil, error: String? = nil, eventId: String, executionBlockType: ExecutionBlockType? = nil, previousEventId: String? = nil, resources: [String]? = nil, stepName: String? = nil, timestamp: Date? = nil, type: ExecutionEventType? = nil) {
            self.description = description
            self.error = error
            self.eventId = eventId
            self.executionBlockType = executionBlockType
            self.previousEventId = previousEventId
            self.resources = resources
            self.stepName = stepName
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case error = "error"
            case eventId = "eventId"
            case executionBlockType = "executionBlockType"
            case previousEventId = "previousEventId"
            case resources = "resources"
            case stepName = "stepName"
            case timestamp = "timestamp"
            case type = "type"
        }
    }

    public struct FailedReportOutput: AWSDecodableShape {
        /// The error code for the failed report generation.
        public let errorCode: FailedReportErrorCode?
        /// The error message for the failed report generation.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: FailedReportErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct GeneratedReport: AWSDecodableShape {
        /// The timestamp when the report was generated.
        public let reportGenerationTime: Date?
        /// The output location or cause of a failure in report generation.
        public let reportOutput: ReportOutput?

        @inlinable
        public init(reportGenerationTime: Date? = nil, reportOutput: ReportOutput? = nil) {
            self.reportGenerationTime = reportGenerationTime
            self.reportOutput = reportOutput
        }

        private enum CodingKeys: String, CodingKey {
            case reportGenerationTime = "reportGenerationTime"
            case reportOutput = "reportOutput"
        }
    }

    public struct GetPlanEvaluationStatusRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the Region switch plan to retrieve evaluation status for.
        public let planArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, planArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.planArn = planArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case planArn = "planArn"
        }
    }

    public struct GetPlanEvaluationStatusResponse: AWSDecodableShape {
        /// The evaluation state for the plan.
        public let evaluationState: EvaluationStatus?
        /// The version of the last evaluation of the plan.
        public let lastEvaluatedVersion: String?
        /// The time of the last time that Region switch ran an evaluation of the plan.
        public let lastEvaluationTime: Date?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String
        /// The Amazon Web Services Region for the plan.
        public let region: String?
        /// The current evaluation warnings for the plan.
        public let warnings: [ResourceWarning]?

        @inlinable
        public init(evaluationState: EvaluationStatus? = nil, lastEvaluatedVersion: String? = nil, lastEvaluationTime: Date? = nil, nextToken: String? = nil, planArn: String, region: String? = nil, warnings: [ResourceWarning]? = nil) {
            self.evaluationState = evaluationState
            self.lastEvaluatedVersion = lastEvaluatedVersion
            self.lastEvaluationTime = lastEvaluationTime
            self.nextToken = nextToken
            self.planArn = planArn
            self.region = region
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationState = "evaluationState"
            case lastEvaluatedVersion = "lastEvaluatedVersion"
            case lastEvaluationTime = "lastEvaluationTime"
            case nextToken = "nextToken"
            case planArn = "planArn"
            case region = "region"
            case warnings = "warnings"
        }
    }

    public struct GetPlanExecutionRequest: AWSEncodableShape {
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the plan with the execution to retrieve.
        public let planArn: String

        @inlinable
        public init(executionId: String, maxResults: Int? = nil, nextToken: String? = nil, planArn: String) {
            self.executionId = executionId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.planArn = planArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case planArn = "planArn"
        }
    }

    public struct GetPlanExecutionResponse: AWSDecodableShape {
        /// The actual recovery time that Region switch calculates for a plan execution. Actual recovery time includes the time for the plan to run added to the time elapsed until the application health alarms that you've specified are healthy again.
        public let actualRecoveryTime: String?
        /// A comment included on the plan execution.
        public let comment: String?
        /// The time (UTC) when the plan execution ended.
        public let endTime: Date?
        /// The plan execution action. Valid values are Activate, to activate an Amazon Web Services Region, or Deactivate, to deactivate a Region.
        public let executionAction: ExecutionAction
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The Amazon Web Services Region for a plan execution.
        public let executionRegion: String
        /// The plan execution state. Provides the state of a plan execution, for example, In Progress or Paused by Operator.
        public let executionState: ExecutionState
        /// Information about the location of a generated report, or the cause of its failure.
        public let generatedReportDetails: [GeneratedReport]?
        /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
        public let mode: ExecutionMode
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The details of the Region switch plan.
        public let plan: Plan?
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String
        /// The time (UTC) when the plan execution started.
        public let startTime: Date
        /// The states of the steps in the plan execution.
        public let stepStates: [StepState]?
        /// The timestamp when the plan execution was last updated.
        public let updatedAt: Date?
        /// The version for the plan.
        public let version: String?

        @inlinable
        public init(actualRecoveryTime: String? = nil, comment: String? = nil, endTime: Date? = nil, executionAction: ExecutionAction, executionId: String, executionRegion: String, executionState: ExecutionState, generatedReportDetails: [GeneratedReport]? = nil, mode: ExecutionMode, nextToken: String? = nil, plan: Plan? = nil, planArn: String, startTime: Date, stepStates: [StepState]? = nil, updatedAt: Date? = nil, version: String? = nil) {
            self.actualRecoveryTime = actualRecoveryTime
            self.comment = comment
            self.endTime = endTime
            self.executionAction = executionAction
            self.executionId = executionId
            self.executionRegion = executionRegion
            self.executionState = executionState
            self.generatedReportDetails = generatedReportDetails
            self.mode = mode
            self.nextToken = nextToken
            self.plan = plan
            self.planArn = planArn
            self.startTime = startTime
            self.stepStates = stepStates
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case actualRecoveryTime = "actualRecoveryTime"
            case comment = "comment"
            case endTime = "endTime"
            case executionAction = "executionAction"
            case executionId = "executionId"
            case executionRegion = "executionRegion"
            case executionState = "executionState"
            case generatedReportDetails = "generatedReportDetails"
            case mode = "mode"
            case nextToken = "nextToken"
            case plan = "plan"
            case planArn = "planArn"
            case startTime = "startTime"
            case stepStates = "stepStates"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct GetPlanInRegionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the plan in Region.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetPlanInRegionResponse: AWSDecodableShape {
        /// The details of the Region switch plan.
        public let plan: Plan?

        @inlinable
        public init(plan: Plan? = nil) {
            self.plan = plan
        }

        private enum CodingKeys: String, CodingKey {
            case plan = "plan"
        }
    }

    public struct GetPlanRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the plan.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetPlanResponse: AWSDecodableShape {
        /// The detailed information about the requested Region switch plan.
        public let plan: Plan?

        @inlinable
        public init(plan: Plan? = nil) {
            self.plan = plan
        }

        private enum CodingKeys: String, CodingKey {
            case plan = "plan"
        }
    }

    public struct GlobalAuroraConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The behavior for a global database, that is, only allow switchover or also allow failover.
        public let behavior: GlobalAuroraDefaultBehavior
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The database cluster Amazon Resource Names (ARNs) for a global database.
        public let databaseClusterArns: [String]
        /// The external ID (secret key) for the configuration.
        public let externalId: String?
        /// The global cluster identifier for a global database.
        public let globalClusterIdentifier: String
        /// The timeout value specified for the configuration.
        public let timeoutMinutes: Int?
        /// The settings for ungraceful execution.
        public let ungraceful: GlobalAuroraUngraceful?

        @inlinable
        public init(behavior: GlobalAuroraDefaultBehavior, crossAccountRole: String? = nil, databaseClusterArns: [String], externalId: String? = nil, globalClusterIdentifier: String, timeoutMinutes: Int? = nil, ungraceful: GlobalAuroraUngraceful? = nil) {
            self.behavior = behavior
            self.crossAccountRole = crossAccountRole
            self.databaseClusterArns = databaseClusterArns
            self.externalId = externalId
            self.globalClusterIdentifier = globalClusterIdentifier
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case behavior = "behavior"
            case crossAccountRole = "crossAccountRole"
            case databaseClusterArns = "databaseClusterArns"
            case externalId = "externalId"
            case globalClusterIdentifier = "globalClusterIdentifier"
            case timeoutMinutes = "timeoutMinutes"
            case ungraceful = "ungraceful"
        }
    }

    public struct GlobalAuroraUngraceful: AWSEncodableShape & AWSDecodableShape {
        /// The settings for ungraceful execution.
        public let ungraceful: GlobalAuroraUngracefulBehavior?

        @inlinable
        public init(ungraceful: GlobalAuroraUngracefulBehavior? = nil) {
            self.ungraceful = ungraceful
        }

        private enum CodingKeys: String, CodingKey {
            case ungraceful = "ungraceful"
        }
    }

    public struct KubernetesResourceType: AWSEncodableShape & AWSDecodableShape {
        /// The API version type for the Kubernetes resource.
        public let apiVersion: String
        /// The kind for the Kubernetes resource.
        public let kind: String

        @inlinable
        public init(apiVersion: String, kind: String) {
            self.apiVersion = apiVersion
            self.kind = kind
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case kind = "kind"
        }
    }

    public struct KubernetesScalingResource: AWSEncodableShape & AWSDecodableShape {
        /// The hpaname for the Kubernetes resource.
        public let hpaName: String?
        /// The name for the Kubernetes resource.
        public let name: String
        /// The namespace for the Kubernetes resource.
        public let namespace: String

        @inlinable
        public init(hpaName: String? = nil, name: String, namespace: String) {
            self.hpaName = hpaName
            self.name = name
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case hpaName = "hpaName"
            case name = "name"
            case namespace = "namespace"
        }
    }

    public struct LambdaUngraceful: AWSEncodableShape & AWSDecodableShape {
        /// The ungraceful behavior for a Lambda function, which must be set to skip.
        public let behavior: LambdaUngracefulBehavior?

        @inlinable
        public init(behavior: LambdaUngracefulBehavior? = nil) {
            self.behavior = behavior
        }

        private enum CodingKeys: String, CodingKey {
            case behavior = "behavior"
        }
    }

    public struct Lambdas: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        public let arn: String?
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?

        @inlinable
        public init(arn: String? = nil, crossAccountRole: String? = nil, externalId: String? = nil) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
        }
    }

    public struct ListPlanExecutionEventsRequest: AWSEncodableShape {
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The name of the plan execution event.
        public let name: String?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the plan.
        public let planArn: String

        @inlinable
        public init(executionId: String, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, planArn: String) {
            self.executionId = executionId
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.planArn = planArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
            case planArn = "planArn"
        }
    }

    public struct ListPlanExecutionEventsResponse: AWSDecodableShape {
        /// The items in the plan execution event.
        public let items: [ExecutionEvent]?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ExecutionEvent]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlanExecutionsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The ARN for the plan.
        public let planArn: String
        /// The state of the plan execution. For example, the plan execution might be In Progress.
        public let state: ExecutionState?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, planArn: String, state: ExecutionState? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.planArn = planArn
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case planArn = "planArn"
            case state = "state"
        }
    }

    public struct ListPlanExecutionsResponse: AWSDecodableShape {
        /// The items in the plan execution to return.
        public let items: [AbbreviatedExecution]?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [AbbreviatedExecution]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlansInRegionRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlansInRegionResponse: AWSDecodableShape {
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The plans that were requested.
        public let plans: [AbbreviatedPlan]?

        @inlinable
        public init(nextToken: String? = nil, plans: [AbbreviatedPlan]? = nil) {
            self.nextToken = nextToken
            self.plans = plans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case plans = "plans"
        }
    }

    public struct ListPlansRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlansResponse: AWSDecodableShape {
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The plans that were requested.
        public let plans: [AbbreviatedPlan]?

        @inlinable
        public init(nextToken: String? = nil, plans: [AbbreviatedPlan]? = nil) {
            self.nextToken = nextToken
            self.plans = plans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case plans = "plans"
        }
    }

    public struct ListRoute53HealthChecksInRegionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Arc Region Switch Plan.
        public let arn: String
        /// The hosted zone ID for the health checks.
        public let hostedZoneId: String?
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The record name for the health checks.
        public let recordName: String?

        @inlinable
        public init(arn: String, hostedZoneId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, recordName: String? = nil) {
            self.arn = arn
            self.hostedZoneId = hostedZoneId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recordName = recordName
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.recordName, name: "recordName", parent: name, max: 1024)
            try self.validate(self.recordName, name: "recordName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case hostedZoneId = "hostedZoneId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case recordName = "recordName"
        }
    }

    public struct ListRoute53HealthChecksInRegionResponse: AWSDecodableShape {
        /// List of the health checks requested.
        public let healthChecks: [Route53HealthCheck]?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(healthChecks: [Route53HealthCheck]? = nil, nextToken: String? = nil) {
            self.healthChecks = healthChecks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case healthChecks = "healthChecks"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoute53HealthChecksRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Route 53 health check request.
        public let arn: String
        /// The hosted zone ID for the health checks.
        public let hostedZoneId: String?
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?
        /// The record name for the health checks.
        public let recordName: String?

        @inlinable
        public init(arn: String, hostedZoneId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, recordName: String? = nil) {
            self.arn = arn
            self.hostedZoneId = hostedZoneId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recordName = recordName
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.recordName, name: "recordName", parent: name, max: 1024)
            try self.validate(self.recordName, name: "recordName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case hostedZoneId = "hostedZoneId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case recordName = "recordName"
        }
    }

    public struct ListRoute53HealthChecksResponse: AWSDecodableShape {
        /// List of the health checks requested.
        public let healthChecks: [Route53HealthCheck]?
        /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(healthChecks: [Route53HealthCheck]? = nil, nextToken: String? = nil) {
            self.healthChecks = healthChecks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case healthChecks = "healthChecks"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for a resource.
        public let resourceTags: [String: String]?

        @inlinable
        public init(resourceTags: [String: String]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "resourceTags"
        }
    }

    public struct MinimalWorkflow: AWSDecodableShape {
        /// The action for a minimal workflow, which can be Activate or Deactivate.
        public let action: ExecutionAction?
        /// The name for a minimal workflow
        public let name: String?

        @inlinable
        public init(action: ExecutionAction? = nil, name: String? = nil) {
            self.action = action
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case name = "name"
        }
    }

    public struct ParallelExecutionBlockConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The steps for a parallel execution block.
        public let steps: [Step]

        @inlinable
        public init(steps: [Step]) {
            self.steps = steps
        }

        public func validate(name: String) throws {
            try self.steps.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case steps = "steps"
        }
    }

    public struct Plan: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the plan.
        public let arn: String
        /// The associated application health alarms for a plan.
        public let associatedAlarms: [String: AssociatedAlarm]?
        /// The description for a plan.
        public let description: String?
        /// The execution role for a plan.
        public let executionRole: String
        /// The name for a plan.
        public let name: String
        /// The owner of a plan.
        public let owner: String
        /// The primary Region for a plan.
        public let primaryRegion: String?
        /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
        public let recoveryApproach: RecoveryApproach
        /// The recovery time objective for a plan.
        public let recoveryTimeObjectiveMinutes: Int?
        /// The Amazon Web Services Regions for a plan.
        public let regions: [String]
        /// The report configuration for a plan.
        public let reportConfiguration: ReportConfiguration?
        /// The triggers for a plan.
        public let triggers: [Trigger]?
        /// The timestamp when the plan was last updated.
        public let updatedAt: Date?
        /// The version for the plan.
        public let version: String?
        /// The workflows for a plan.
        public let workflows: [Workflow]

        @inlinable
        public init(arn: String, associatedAlarms: [String: AssociatedAlarm]? = nil, description: String? = nil, executionRole: String, name: String, owner: String, primaryRegion: String? = nil, recoveryApproach: RecoveryApproach, recoveryTimeObjectiveMinutes: Int? = nil, regions: [String], reportConfiguration: ReportConfiguration? = nil, triggers: [Trigger]? = nil, updatedAt: Date? = nil, version: String? = nil, workflows: [Workflow]) {
            self.arn = arn
            self.associatedAlarms = associatedAlarms
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.owner = owner
            self.primaryRegion = primaryRegion
            self.recoveryApproach = recoveryApproach
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.regions = regions
            self.reportConfiguration = reportConfiguration
            self.triggers = triggers
            self.updatedAt = updatedAt
            self.version = version
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatedAlarms = "associatedAlarms"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case owner = "owner"
            case primaryRegion = "primaryRegion"
            case recoveryApproach = "recoveryApproach"
            case recoveryTimeObjectiveMinutes = "recoveryTimeObjectiveMinutes"
            case regions = "regions"
            case reportConfiguration = "reportConfiguration"
            case triggers = "triggers"
            case updatedAt = "updatedAt"
            case version = "version"
            case workflows = "workflows"
        }
    }

    public struct RegionSwitchPlanConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the plan configuration.
        public let arn: String
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?

        @inlinable
        public init(arn: String, crossAccountRole: String? = nil, externalId: String? = nil) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
        }
    }

    public struct ReportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The output configuration for the report.
        public let reportOutput: [ReportOutputConfiguration]?

        @inlinable
        public init(reportOutput: [ReportOutputConfiguration]? = nil) {
            self.reportOutput = reportOutput
        }

        public func validate(name: String) throws {
            try self.reportOutput?.forEach {
                try $0.validate(name: "\(name).reportOutput[]")
            }
            try self.validate(self.reportOutput, name: "reportOutput", parent: name, max: 1)
            try self.validate(self.reportOutput, name: "reportOutput", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case reportOutput = "reportOutput"
        }
    }

    public struct ResourceWarning: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// The name of the step for the resource warning.
        public let stepName: String?
        /// The version for the resource warning.
        public let version: String
        /// The warning message about what needs to be corrected.
        public let warningMessage: String
        /// The status of the resource warning.
        public let warningStatus: ResourceWarningStatus
        /// The timestamp when the warning was last updated.
        public let warningUpdatedTime: Date
        /// The workflow for the resource warning.
        public let workflow: MinimalWorkflow?

        @inlinable
        public init(resourceArn: String? = nil, stepName: String? = nil, version: String, warningMessage: String, warningStatus: ResourceWarningStatus, warningUpdatedTime: Date, workflow: MinimalWorkflow? = nil) {
            self.resourceArn = resourceArn
            self.stepName = stepName
            self.version = version
            self.warningMessage = warningMessage
            self.warningStatus = warningStatus
            self.warningUpdatedTime = warningUpdatedTime
            self.workflow = workflow
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case stepName = "stepName"
            case version = "version"
            case warningMessage = "warningMessage"
            case warningStatus = "warningStatus"
            case warningUpdatedTime = "warningUpdatedTime"
            case workflow = "workflow"
        }
    }

    public struct Route53HealthCheck: AWSDecodableShape {
        /// The Amazon Route 53 health check ID.
        public let healthCheckId: String?
        /// The Amazon Route 53 health check hosted zone ID.
        public let hostedZoneId: String
        /// The Amazon Route 53 record name.
        public let recordName: String
        /// The Amazon Route 53 Region.
        public let region: String
        /// The Amazon Route 53 health check status.
        public let status: Route53HealthCheckStatus?

        @inlinable
        public init(healthCheckId: String? = nil, hostedZoneId: String, recordName: String, region: String, status: Route53HealthCheckStatus? = nil) {
            self.healthCheckId = healthCheckId
            self.hostedZoneId = hostedZoneId
            self.recordName = recordName
            self.region = region
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheckId = "healthCheckId"
            case hostedZoneId = "hostedZoneId"
            case recordName = "recordName"
            case region = "region"
            case status = "status"
        }
    }

    public struct Route53HealthCheckConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cross account role for the configuration.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the configuration.
        public let externalId: String?
        /// The Amazon Route 53 health check configuration hosted zone ID.
        public let hostedZoneId: String
        /// The Amazon Route 53 health check configuration record name.
        public let recordName: String
        /// The Amazon Route 53 health check configuration record sets.
        public let recordSets: [Route53ResourceRecordSet]?
        /// The Amazon Route 53 health check configuration time out (in minutes).
        public let timeoutMinutes: Int?

        @inlinable
        public init(crossAccountRole: String? = nil, externalId: String? = nil, hostedZoneId: String, recordName: String, recordSets: [Route53ResourceRecordSet]? = nil, timeoutMinutes: Int? = nil) {
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.hostedZoneId = hostedZoneId
            self.recordName = recordName
            self.recordSets = recordSets
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.recordName, name: "recordName", parent: name, max: 1024)
            try self.validate(self.recordName, name: "recordName", parent: name, min: 1)
            try self.recordSets?.forEach {
                try $0.validate(name: "\(name).recordSets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
            case hostedZoneId = "hostedZoneId"
            case recordName = "recordName"
            case recordSets = "recordSets"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct Route53ResourceRecordSet: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Route 53 record set identifier.
        public let recordSetIdentifier: String?
        /// The Amazon Route 53 record set Region.
        public let region: String?

        @inlinable
        public init(recordSetIdentifier: String? = nil, region: String? = nil) {
            self.recordSetIdentifier = recordSetIdentifier
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.recordSetIdentifier, name: "recordSetIdentifier", parent: name, max: 1024)
            try self.validate(self.recordSetIdentifier, name: "recordSetIdentifier", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z]{2}-[a-z-]+-\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recordSetIdentifier = "recordSetIdentifier"
            case region = "region"
        }
    }

    public struct S3ReportOutput: AWSDecodableShape {
        /// The S3 object key where the generated report is stored.
        public let s3ObjectKey: String?

        @inlinable
        public init(s3ObjectKey: String? = nil) {
            self.s3ObjectKey = s3ObjectKey
        }

        private enum CodingKeys: String, CodingKey {
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct S3ReportOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account ID that owns the S3 bucket. Required to ensure the bucket is still owned by the same expected owner at generation time.
        public let bucketOwner: String?
        /// The S3 bucket name and optional prefix where reports are stored. Format: bucket-name or bucket-name/prefix.
        public let bucketPath: String?

        @inlinable
        public init(bucketOwner: String? = nil, bucketPath: String? = nil) {
            self.bucketOwner = bucketOwner
            self.bucketPath = bucketPath
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwner = "bucketOwner"
            case bucketPath = "bucketPath"
        }
    }

    public struct Service: AWSEncodableShape & AWSDecodableShape {
        /// The cluster Amazon Resource Name (ARN) for a service.
        public let clusterArn: String?
        /// The cross account role for a service.
        public let crossAccountRole: String?
        /// The external ID (secret key) for the service.
        public let externalId: String?
        /// The Amazon Resource Name (ARN) for a service.
        public let serviceArn: String?

        @inlinable
        public init(clusterArn: String? = nil, crossAccountRole: String? = nil, externalId: String? = nil, serviceArn: String? = nil) {
            self.clusterArn = clusterArn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:ecs:[a-z0-9-]+:\\d{12}:cluster/[a-zA-Z0-9_-]{1,255}$")
            try self.validate(self.crossAccountRole, name: "crossAccountRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:ecs:[a-z0-9-]+:\\d{12}:service/[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]{1,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case crossAccountRole = "crossAccountRole"
            case externalId = "externalId"
            case serviceArn = "serviceArn"
        }
    }

    public struct StartPlanExecutionRequest: AWSEncodableShape {
        /// The action to perform. Valid values are ACTIVATE (to shift traffic to the target Region) or DEACTIVATE (to shift traffic away from the target Region).
        public let action: ExecutionAction
        /// An optional comment explaining why the plan execution is being started.
        public let comment: String?
        /// A boolean value indicating whether to use the latest version of the plan. If set to false, you must specify a specific version.
        public let latestVersion: String?
        /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
        public let mode: ExecutionMode?
        /// The Amazon Resource Name (ARN) of the plan to execute.
        public let planArn: String
        /// The Amazon Web Services Region to target with this execution. This is the Region that traffic will be shifted to or from, depending on the action.
        public let targetRegion: String

        @inlinable
        public init(action: ExecutionAction, comment: String? = nil, latestVersion: String? = nil, mode: ExecutionMode? = nil, planArn: String, targetRegion: String) {
            self.action = action
            self.comment = comment
            self.latestVersion = latestVersion
            self.mode = mode
            self.planArn = planArn
            self.targetRegion = targetRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1024)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case comment = "comment"
            case latestVersion = "latestVersion"
            case mode = "mode"
            case planArn = "planArn"
            case targetRegion = "targetRegion"
        }
    }

    public struct StartPlanExecutionResponse: AWSDecodableShape {
        /// The Amazon Web Services Region to activate.
        public let activateRegion: String?
        /// The Amazon Web Services Region to deactivate.
        public let deactivateRegion: String?
        /// The execution identifier of a plan execution.
        public let executionId: String?
        /// The details of the Region switch plan.
        public let plan: String?
        /// The version of the plan, a unique number generated by Region switch.
        public let planVersion: String?

        @inlinable
        public init(activateRegion: String? = nil, deactivateRegion: String? = nil, executionId: String? = nil, plan: String? = nil, planVersion: String? = nil) {
            self.activateRegion = activateRegion
            self.deactivateRegion = deactivateRegion
            self.executionId = executionId
            self.plan = plan
            self.planVersion = planVersion
        }

        private enum CodingKeys: String, CodingKey {
            case activateRegion = "activateRegion"
            case deactivateRegion = "deactivateRegion"
            case executionId = "executionId"
            case plan = "plan"
            case planVersion = "planVersion"
        }
    }

    public struct Step: AWSEncodableShape & AWSDecodableShape {
        /// The description of a step in a workflow.
        public let description: String?
        /// The configuration for an execution block in a workflow.
        public let executionBlockConfiguration: ExecutionBlockConfiguration
        /// The type of an execution block in a workflow.
        public let executionBlockType: ExecutionBlockType
        /// The name of a step in a workflow.
        public let name: String

        @inlinable
        public init(description: String? = nil, executionBlockConfiguration: ExecutionBlockConfiguration, executionBlockType: ExecutionBlockType, name: String) {
            self.description = description
            self.executionBlockConfiguration = executionBlockConfiguration
            self.executionBlockType = executionBlockType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.executionBlockConfiguration.validate(name: "\(name).executionBlockConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case executionBlockConfiguration = "executionBlockConfiguration"
            case executionBlockType = "executionBlockType"
            case name = "name"
        }
    }

    public struct StepState: AWSDecodableShape {
        /// The timestamp when a step endeded execution.
        public let endTime: Date?
        /// The name of a step in a workflow.
        public let name: String?
        /// The timestamp when a step started execution.
        public let startTime: Date?
        /// The status of a step in a workflow. For example, a status might be Completed or Pending Approval.
        public let status: StepStatus?
        /// The mode for a step execution. The mode can be Graceful or Ungraceful.
        public let stepMode: ExecutionMode?

        @inlinable
        public init(endTime: Date? = nil, name: String? = nil, startTime: Date? = nil, status: StepStatus? = nil, stepMode: ExecutionMode? = nil) {
            self.endTime = endTime
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stepMode = stepMode
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case name = "name"
            case startTime = "startTime"
            case status = "status"
            case stepMode = "stepMode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag that you add to a resource.
        public let arn: String
        /// Tags that you add to a resource. You can add a maximum of 50 tags in Region switch.
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Trigger: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        public let action: WorkflowTargetAction
        /// The conditions that must be met for the trigger to fire.
        public let conditions: [TriggerCondition]
        /// The description for a trigger.
        public let description: String?
        /// The minimum time, in minutes, that must elapse between automatic executions of the plan.
        public let minDelayMinutesBetweenExecutions: Int
        /// The Amazon Web Services Region for a trigger.
        public let targetRegion: String

        @inlinable
        public init(action: WorkflowTargetAction, conditions: [TriggerCondition], description: String? = nil, minDelayMinutesBetweenExecutions: Int, targetRegion: String) {
            self.action = action
            self.conditions = conditions
            self.description = description
            self.minDelayMinutesBetweenExecutions = minDelayMinutesBetweenExecutions
            self.targetRegion = targetRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.conditions, name: "conditions", parent: name, max: 10)
            try self.validate(self.conditions, name: "conditions", parent: name, min: 1)
            try self.validate(self.targetRegion, name: "targetRegion", parent: name, pattern: "^[a-z]{2}-[a-z-]+-\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case conditions = "conditions"
            case description = "description"
            case minDelayMinutesBetweenExecutions = "minDelayMinutesBetweenExecutions"
            case targetRegion = "targetRegion"
        }
    }

    public struct TriggerCondition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the CloudWatch alarm associated with the condition.
        public let associatedAlarmName: String
        /// The condition that must be met. Valid values include ALARM and OK.
        public let condition: AlarmCondition

        @inlinable
        public init(associatedAlarmName: String, condition: AlarmCondition) {
            self.associatedAlarmName = associatedAlarmName
            self.condition = condition
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAlarmName = "associatedAlarmName"
            case condition = "condition"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
        public let arn: String
        /// Tag keys that you remove from a resource.
        public let resourceTagKeys: [String]

        @inlinable
        public init(arn: String, resourceTagKeys: [String]) {
            self.arn = arn
            self.resourceTagKeys = resourceTagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.resourceTagKeys.forEach {
                try validate($0, name: "resourceTagKeys[]", parent: name, max: 128)
                try validate($0, name: "resourceTagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTagKeys, name: "resourceTagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case resourceTagKeys = "resourceTagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePlanExecutionRequest: AWSEncodableShape {
        /// The action specified for a plan execution, for example, Switch to Graceful or Pause.
        public let action: UpdatePlanExecutionAction
        /// An optional comment about the plan execution.
        public let comment: String?
        /// The execution identifier of a plan execution.
        public let executionId: String
        /// The Amazon Resource Name (ARN) of the plan with the execution to update.
        public let planArn: String

        @inlinable
        public init(action: UpdatePlanExecutionAction, comment: String? = nil, executionId: String, planArn: String) {
            self.action = action
            self.comment = comment
            self.executionId = executionId
            self.planArn = planArn
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1024)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case comment = "comment"
            case executionId = "executionId"
            case planArn = "planArn"
        }
    }

    public struct UpdatePlanExecutionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePlanExecutionStepRequest: AWSEncodableShape {
        /// The updated action to take for the step. This can be used to skip or retry a step.
        public let actionToTake: UpdatePlanExecutionStepAction
        /// An optional comment about the plan execution.
        public let comment: String
        /// The unique identifier of the plan execution containing the step to update.
        public let executionId: String
        /// The Amazon Resource Name (ARN) of the plan containing the execution step to update.
        public let planArn: String
        /// The name of the execution step to update.
        public let stepName: String

        @inlinable
        public init(actionToTake: UpdatePlanExecutionStepAction, comment: String, executionId: String, planArn: String, stepName: String) {
            self.actionToTake = actionToTake
            self.comment = comment
            self.executionId = executionId
            self.planArn = planArn
            self.stepName = stepName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1024)
            try self.validate(self.planArn, name: "planArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionToTake = "actionToTake"
            case comment = "comment"
            case executionId = "executionId"
            case planArn = "planArn"
            case stepName = "stepName"
        }
    }

    public struct UpdatePlanExecutionStepResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePlanRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the plan.
        public let arn: String
        /// The updated CloudWatch alarms associated with the plan.
        public let associatedAlarms: [String: AssociatedAlarm]?
        /// The updated description for the Region switch plan.
        public let description: String?
        /// The updated IAM role ARN that grants Region switch the permissions needed to execute the plan steps.
        public let executionRole: String
        /// The updated target recovery time objective (RTO) in minutes for the plan.
        public let recoveryTimeObjectiveMinutes: Int?
        /// The updated report configuration for the plan.
        public let reportConfiguration: ReportConfiguration?
        /// The updated conditions that can automatically trigger the execution of the plan.
        public let triggers: [Trigger]?
        /// The updated workflows for the Region switch plan.
        public let workflows: [Workflow]

        @inlinable
        public init(arn: String, associatedAlarms: [String: AssociatedAlarm]? = nil, description: String? = nil, executionRole: String, recoveryTimeObjectiveMinutes: Int? = nil, reportConfiguration: ReportConfiguration? = nil, triggers: [Trigger]? = nil, workflows: [Workflow]) {
            self.arn = arn
            self.associatedAlarms = associatedAlarms
            self.description = description
            self.executionRole = executionRole
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.reportConfiguration = reportConfiguration
            self.triggers = triggers
            self.workflows = workflows
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:arc-region-switch::[0-9]{12}:plan/([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,30}[a-zA-Z0-9])?):([a-z0-9]{6})$")
            try self.associatedAlarms?.forEach {
                try $0.value.validate(name: "\(name).associatedAlarms[\"\($0.key)\"]")
            }
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-zA-Z0-9-]*:iam::[0-9]{12}:role/.+$")
            try self.reportConfiguration?.validate(name: "\(name).reportConfiguration")
            try self.triggers?.forEach {
                try $0.validate(name: "\(name).triggers[]")
            }
            try self.workflows.forEach {
                try $0.validate(name: "\(name).workflows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatedAlarms = "associatedAlarms"
            case description = "description"
            case executionRole = "executionRole"
            case recoveryTimeObjectiveMinutes = "recoveryTimeObjectiveMinutes"
            case reportConfiguration = "reportConfiguration"
            case triggers = "triggers"
            case workflows = "workflows"
        }
    }

    public struct UpdatePlanResponse: AWSDecodableShape {
        /// The details of the updated Region switch plan.
        public let plan: Plan?

        @inlinable
        public init(plan: Plan? = nil) {
            self.plan = plan
        }

        private enum CodingKeys: String, CodingKey {
            case plan = "plan"
        }
    }

    public struct Workflow: AWSEncodableShape & AWSDecodableShape {
        /// The steps that make up the workflow.
        public let steps: [Step]?
        /// The description of the workflow.
        public let workflowDescription: String?
        /// The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        public let workflowTargetAction: WorkflowTargetAction
        /// The Amazon Web Services Region that the workflow targets.
        public let workflowTargetRegion: String?

        @inlinable
        public init(steps: [Step]? = nil, workflowDescription: String? = nil, workflowTargetAction: WorkflowTargetAction, workflowTargetRegion: String? = nil) {
            self.steps = steps
            self.workflowDescription = workflowDescription
            self.workflowTargetAction = workflowTargetAction
            self.workflowTargetRegion = workflowTargetRegion
        }

        public func validate(name: String) throws {
            try self.steps?.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
            try self.validate(self.workflowTargetRegion, name: "workflowTargetRegion", parent: name, pattern: "^[a-z]{2}-[a-z-]+-\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case steps = "steps"
            case workflowDescription = "workflowDescription"
            case workflowTargetAction = "workflowTargetAction"
            case workflowTargetRegion = "workflowTargetRegion"
        }
    }

    public struct ReportOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for delivering reports to an Amazon S3 bucket.
        public let s3Configuration: S3ReportOutputConfiguration?

        @inlinable
        public init(s3Configuration: S3ReportOutputConfiguration? = nil) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "s3Configuration"
        }
    }
}

// MARK: - Errors

/// Error enum for ARCRegionSwitch
public struct ARCRegionSwitchErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case illegalArgumentException = "IllegalArgumentException"
        case illegalStateException = "IllegalStateException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ARCRegionSwitch
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action. HTTP Status Code: 403
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has an invalid argument.
    public static var illegalArgumentException: Self { .init(.illegalArgumentException) }
    /// The operation failed because the current state of the resource doesn't allow the operation to proceed. HTTP Status Code: 400
    public static var illegalStateException: Self { .init(.illegalStateException) }
    /// The request processing has failed because of an unknown error, exception, or failure. HTTP Status Code: 500
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found. HTTP Status Code: 404
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension ARCRegionSwitchErrorType: Equatable {
    public static func == (lhs: ARCRegionSwitchErrorType, rhs: ARCRegionSwitchErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ARCRegionSwitchErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
