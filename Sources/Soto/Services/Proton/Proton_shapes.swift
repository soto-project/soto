//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Proton {
    // MARK: Enums

    public enum BlockerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum BlockerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automated = "AUTOMATED"
        public var description: String { return self.rawValue }
    }

    public enum ComponentDeploymentUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case currentVersion = "CURRENT_VERSION"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case deleteComplete = "DELETE_COMPLETE"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentTargetResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case component = "COMPONENT"
        case environment = "ENVIRONMENT"
        case serviceInstance = "SERVICE_INSTANCE"
        case servicePipeline = "SERVICE_PIPELINE"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case currentVersion = "CURRENT_VERSION"
        case majorVersion = "MAJOR_VERSION"
        case minorVersion = "MINOR_VERSION"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentAccountConnectionRequesterAccountType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case environmentAccount = "ENVIRONMENT_ACCOUNT"
        case managementAccount = "MANAGEMENT_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentAccountConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ListServiceInstancesFilterBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAtAfter = "createdAtAfter"
        case createdAtBefore = "createdAtBefore"
        case deployedTemplateVersionStatus = "deployedTemplateVersionStatus"
        case deploymentStatus = "deploymentStatus"
        case environmentName = "environmentName"
        case lastDeploymentAttemptedAtAfter = "lastDeploymentAttemptedAtAfter"
        case lastDeploymentAttemptedAtBefore = "lastDeploymentAttemptedAtBefore"
        case name = "name"
        case serviceName = "serviceName"
        case templateName = "templateName"
        public var description: String { return self.rawValue }
    }

    public enum ListServiceInstancesSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAt = "createdAt"
        case deploymentStatus = "deploymentStatus"
        case environmentName = "environmentName"
        case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
        case name = "name"
        case serviceName = "serviceName"
        case templateName = "templateName"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedResourceEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudformation = "CLOUDFORMATION"
        case terraform = "TERRAFORM"
        public var description: String { return self.rawValue }
    }

    public enum Provisioning: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerManaged = "CUSTOMER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum RepositoryProvider: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bitbucket = "BITBUCKET"
        case github = "GITHUB"
        case githubEnterprise = "GITHUB_ENTERPRISE"
        public var description: String { return self.rawValue }
    }

    public enum RepositorySyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     The repository sync attempt has failed.
        case failed = "FAILED"
        ///    A repository sync attempt has been created and will begin soon.
        case initiated = "INITIATED"
        ///     A repository sync attempt has started and work is being done to reconcile the branch.
        case inProgress = "IN_PROGRESS"
        ///     The repository sync attempt didn't execute and was queued.
        case queued = "QUEUED"
        ///     The repository sync attempt has completed successfully.
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceDeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceSyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     Syncing has failed.
        case failed = "FAILED"
        ///    A sync attempt has been created and will begin soon.
        case initiated = "INITIATED"
        ///     Syncing has started and work is being done to reconcile state.
        case inProgress = "IN_PROGRESS"
        ///     Syncing has completed successfully.
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ServiceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createFailedCleanupComplete = "CREATE_FAILED_CLEANUP_COMPLETE"
        case createFailedCleanupFailed = "CREATE_FAILED_CLEANUP_FAILED"
        case createFailedCleanupInProgress = "CREATE_FAILED_CLEANUP_IN_PROGRESS"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateCompleteCleanupFailed = "UPDATE_COMPLETE_CLEANUP_FAILED"
        case updateFailed = "UPDATE_FAILED"
        case updateFailedCleanupComplete = "UPDATE_FAILED_CLEANUP_COMPLETE"
        case updateFailedCleanupFailed = "UPDATE_FAILED_CLEANUP_FAILED"
        case updateFailedCleanupInProgress = "UPDATE_FAILED_CLEANUP_IN_PROGRESS"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceTemplateSupportedComponentSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directlyDefined = "DIRECTLY_DEFINED"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SyncType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     Syncs services and service instances to Proton.
        case serviceSync = "SERVICE_SYNC"
        ///     Syncs environment and service templates to Proton.
        case templateSync = "TEMPLATE_SYNC"
        public var description: String { return self.rawValue }
    }

    public enum TemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case environment = "ENVIRONMENT"
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum TemplateVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case draft = "DRAFT"
        case published = "PUBLISHED"
        case registrationFailed = "REGISTRATION_FAILED"
        case registrationInProgress = "REGISTRATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentState: AWSDecodableShape, Sendable {
        /// The state of the component associated with the deployment.
        case component(ComponentState)
        /// The state of the environment associated with the deployment.
        case environment(EnvironmentState)
        /// The state of the service instance associated with the deployment.
        case serviceInstance(ServiceInstanceState)
        /// The state of the service pipeline associated with the deployment.
        case servicePipeline(ServicePipelineState)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .component:
                let value = try container.decode(ComponentState.self, forKey: .component)
                self = .component(value)
            case .environment:
                let value = try container.decode(EnvironmentState.self, forKey: .environment)
                self = .environment(value)
            case .serviceInstance:
                let value = try container.decode(ServiceInstanceState.self, forKey: .serviceInstance)
                self = .serviceInstance(value)
            case .servicePipeline:
                let value = try container.decode(ServicePipelineState.self, forKey: .servicePipeline)
                self = .servicePipeline(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
            case environment = "environment"
            case serviceInstance = "serviceInstance"
            case servicePipeline = "servicePipeline"
        }
    }

    // MARK: Shapes

    public struct AcceptEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// The ID of the environment account connection.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct AcceptEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The environment account connection data that's returned by Proton.
        public let environmentAccountConnection: EnvironmentAccountConnection

        public init(environmentAccountConnection: EnvironmentAccountConnection) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct AccountSettings: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service role that Proton uses for provisioning pipelines. Proton assumes this role for CodeBuild-based provisioning.
        public let pipelineCodebuildRoleArn: String?
        /// The linked repository for pipeline provisioning. Required if you have environments configured for self-managed provisioning with services that include pipelines. A linked repository is a repository that has been registered with Proton. For more information, see CreateRepository.
        public let pipelineProvisioningRepository: RepositoryBranch?
        /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Assumed by Proton for Amazon Web Services-managed provisioning, and by customer-owned automation for self-managed provisioning.
        public let pipelineServiceRoleArn: String?

        public init(pipelineCodebuildRoleArn: String? = nil, pipelineProvisioningRepository: RepositoryBranch? = nil, pipelineServiceRoleArn: String? = nil) {
            self.pipelineCodebuildRoleArn = pipelineCodebuildRoleArn
            self.pipelineProvisioningRepository = pipelineProvisioningRepository
            self.pipelineServiceRoleArn = pipelineServiceRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineCodebuildRoleArn = "pipelineCodebuildRoleArn"
            case pipelineProvisioningRepository = "pipelineProvisioningRepository"
            case pipelineServiceRoleArn = "pipelineServiceRoleArn"
        }
    }

    public struct CancelComponentDeploymentInput: AWSEncodableShape {
        /// The name of the component with the deployment to cancel.
        public let componentName: String

        public init(componentName: String) {
            self.componentName = componentName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 100)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
        }
    }

    public struct CancelComponentDeploymentOutput: AWSDecodableShape {
        /// The detailed data of the component with the deployment that is being canceled.
        public let component: Component

        public init(component: Component) {
            self.component = component
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
        }
    }

    public struct CancelEnvironmentDeploymentInput: AWSEncodableShape {
        /// The name of the environment with the deployment to cancel.
        public let environmentName: String

        public init(environmentName: String) {
            self.environmentName = environmentName
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "environmentName"
        }
    }

    public struct CancelEnvironmentDeploymentOutput: AWSDecodableShape {
        /// The environment summary data that's returned by Proton.
        public let environment: Environment

        public init(environment: Environment) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct CancelServiceInstanceDeploymentInput: AWSEncodableShape {
        /// The name of the service instance with the deployment to cancel.
        public let serviceInstanceName: String
        /// The name of the service with the service instance deployment to cancel.
        public let serviceName: String

        public init(serviceInstanceName: String, serviceName: String) {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct CancelServiceInstanceDeploymentOutput: AWSDecodableShape {
        /// The service instance summary data that's returned by Proton.
        public let serviceInstance: ServiceInstance

        public init(serviceInstance: ServiceInstance) {
            self.serviceInstance = serviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstance = "serviceInstance"
        }
    }

    public struct CancelServicePipelineDeploymentInput: AWSEncodableShape {
        /// The name of the service with the service pipeline deployment to cancel.
        public let serviceName: String

        public init(serviceName: String) {
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct CancelServicePipelineDeploymentOutput: AWSDecodableShape {
        /// The service pipeline detail data that's returned by Proton.
        public let pipeline: ServicePipeline

        public init(pipeline: ServicePipeline) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "pipeline"
        }
    }

    public struct CompatibleEnvironmentTemplate: AWSDecodableShape {
        /// The major version of the compatible environment template.
        public let majorVersion: String
        /// The compatible environment template name.
        public let templateName: String

        public init(majorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case templateName = "templateName"
        }
    }

    public struct CompatibleEnvironmentTemplateInput: AWSEncodableShape {
        /// The major version of the compatible environment template.
        public let majorVersion: String
        /// The compatible environment template name.
        public let templateName: String

        public init(majorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case templateName = "templateName"
        }
    }

    public struct Component: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String
        /// The time when the component was created.
        public let createdAt: Date
        /// The component deployment status.
        public let deploymentStatus: DeploymentStatus
        /// The message associated with the component deployment status.
        public let deploymentStatusMessage: String?
        /// A description of the component.
        public let description: String?
        /// The name of the Proton environment that this component is associated with.
        public let environmentName: String
        /// The ID of the last attempted deployment of this component.
        public let lastAttemptedDeploymentId: String?
        /// The last token the client requested.
        public let lastClientRequestToken: String?
        /// The time when a deployment of the component was last attempted.
        public let lastDeploymentAttemptedAt: Date?
        /// The time when the component was last deployed successfully.
        public let lastDeploymentSucceededAt: Date?
        /// The time when the component was last modified.
        public let lastModifiedAt: Date
        /// The ID of the last successful deployment of this component.
        public let lastSucceededDeploymentId: String?
        /// The name of the component.
        public let name: String
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public let serviceInstanceName: String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public let serviceName: String?
        /// The service spec that the component uses to access service inputs. Provided when a component is attached to a service instance.
        public let serviceSpec: String?

        public init(arn: String, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, description: String? = nil, environmentName: String, lastAttemptedDeploymentId: String? = nil, lastClientRequestToken: String? = nil, lastDeploymentAttemptedAt: Date? = nil, lastDeploymentSucceededAt: Date? = nil, lastModifiedAt: Date, lastSucceededDeploymentId: String? = nil, name: String, serviceInstanceName: String? = nil, serviceName: String? = nil, serviceSpec: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastClientRequestToken = lastClientRequestToken
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
            case environmentName = "environmentName"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastClientRequestToken = "lastClientRequestToken"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastModifiedAt = "lastModifiedAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case serviceSpec = "serviceSpec"
        }
    }

    public struct ComponentState: AWSDecodableShape {
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public let serviceInstanceName: String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public let serviceName: String?
        /// The service spec that the component uses to access service inputs. Provided when a component is attached to a service instance.
        public let serviceSpec: String?
        /// The template file used.
        public let templateFile: String?

        public init(serviceInstanceName: String? = nil, serviceName: String? = nil, serviceSpec: String? = nil, templateFile: String? = nil) {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
            self.templateFile = templateFile
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case serviceSpec = "serviceSpec"
            case templateFile = "templateFile"
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String
        /// The time when the component was created.
        public let createdAt: Date
        /// The component deployment status.
        public let deploymentStatus: DeploymentStatus
        /// The message associated with the component deployment status.
        public let deploymentStatusMessage: String?
        /// The name of the Proton environment that this component is associated with.
        public let environmentName: String
        /// The ID of the last attempted deployment of this component.
        public let lastAttemptedDeploymentId: String?
        /// The time when a deployment of the component was last attempted.
        public let lastDeploymentAttemptedAt: Date?
        /// The time when the component was last deployed successfully.
        public let lastDeploymentSucceededAt: Date?
        /// The time when the component was last modified.
        public let lastModifiedAt: Date
        /// The ID of the last successful deployment of this component.
        public let lastSucceededDeploymentId: String?
        /// The name of the component.
        public let name: String
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public let serviceInstanceName: String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public let serviceName: String?

        public init(arn: String, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, environmentName: String, lastAttemptedDeploymentId: String? = nil, lastDeploymentAttemptedAt: Date? = nil, lastDeploymentSucceededAt: Date? = nil, lastModifiedAt: Date, lastSucceededDeploymentId: String? = nil, name: String, serviceInstanceName: String? = nil, serviceName: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case environmentName = "environmentName"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastModifiedAt = "lastModifiedAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct CountsSummary: AWSDecodableShape {
        /// The total number of components in the Amazon Web Services account. The semantics of the components field are different from the semantics of results for other infrastructure-provisioning resources. That's because at this time components don't have associated templates, therefore they don't have the concept of staleness. The components object will only contain total and failed members.
        public let components: ResourceCountsSummary?
        /// The staleness counts for Proton environments in the Amazon Web Services account. The environments object will only contain total members.
        public let environments: ResourceCountsSummary?
        /// The total number of environment templates in the Amazon Web Services account. The environmentTemplates object will only contain total members.
        public let environmentTemplates: ResourceCountsSummary?
        /// The staleness counts for Proton pipelines in the Amazon Web Services account.
        public let pipelines: ResourceCountsSummary?
        /// The staleness counts for Proton service instances in the Amazon Web Services account.
        public let serviceInstances: ResourceCountsSummary?
        /// The staleness counts for Proton services in the Amazon Web Services account.
        public let services: ResourceCountsSummary?
        /// The total number of service templates in the Amazon Web Services account. The serviceTemplates object will only contain total members.
        public let serviceTemplates: ResourceCountsSummary?

        public init(components: ResourceCountsSummary? = nil, environments: ResourceCountsSummary? = nil, environmentTemplates: ResourceCountsSummary? = nil, pipelines: ResourceCountsSummary? = nil, serviceInstances: ResourceCountsSummary? = nil, services: ResourceCountsSummary? = nil, serviceTemplates: ResourceCountsSummary? = nil) {
            self.components = components
            self.environments = environments
            self.environmentTemplates = environmentTemplates
            self.pipelines = pipelines
            self.serviceInstances = serviceInstances
            self.services = services
            self.serviceTemplates = serviceTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case components = "components"
            case environments = "environments"
            case environmentTemplates = "environmentTemplates"
            case pipelines = "pipelines"
            case serviceInstances = "serviceInstances"
            case services = "services"
            case serviceTemplates = "serviceTemplates"
        }
    }

    public struct CreateComponentInput: AWSEncodableShape {
        /// The client token for the created component.
        public let clientToken: String?
        /// An optional customer-provided description of the component.
        public let description: String?
        /// The name of the Proton environment that you want to associate this component with. You must specify this when you don't specify serviceInstanceName and serviceName.
        public let environmentName: String?
        /// A path to a manifest file that lists the Infrastructure as Code (IaC) file, template language, and rendering engine for infrastructure that a custom component provisions.
        public let manifest: String
        /// The customer-provided name of the component.
        public let name: String
        /// The name of the service instance that you want to attach this component to. If you don't specify this, the component isn't attached to any service instance. Specify both serviceInstanceName and serviceName or neither of them.
        public let serviceInstanceName: String?
        /// The name of the service that serviceInstanceName is associated with. If you don't specify this, the component isn't attached to any service instance. Specify both serviceInstanceName and serviceName or neither of them.
        public let serviceName: String?
        /// The service spec that you want the component to use to access service inputs. Set this only when you attach the component to a service instance.
        public let serviceSpec: String?
        /// An optional list of metadata items that you can associate with the Proton component. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.  Components support a single IaC file, even if you use Terraform as your template language.
        public let templateFile: String

        public init(clientToken: String? = CreateComponentInput.idempotencyToken(), description: String? = nil, environmentName: String? = nil, manifest: String, name: String, serviceInstanceName: String? = nil, serviceName: String? = nil, serviceSpec: String? = nil, tags: [Tag]? = nil, templateFile: String) {
            self.clientToken = clientToken
            self.description = description
            self.environmentName = environmentName
            self.manifest = manifest
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
            self.tags = tags
            self.templateFile = templateFile
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.manifest, name: "manifest", parent: name, max: 1024)
            try self.validate(self.manifest, name: "manifest", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceSpec, name: "serviceSpec", parent: name, max: 51200)
            try self.validate(self.serviceSpec, name: "serviceSpec", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateFile, name: "templateFile", parent: name, max: 51200)
            try self.validate(self.templateFile, name: "templateFile", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case environmentName = "environmentName"
            case manifest = "manifest"
            case name = "name"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case serviceSpec = "serviceSpec"
            case tags = "tags"
            case templateFile = "templateFile"
        }
    }

    public struct CreateComponentOutput: AWSDecodableShape {
        /// The detailed data of the created component.
        public let component: Component

        public init(component: Component) {
            self.component = component
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
        }
    }

    public struct CreateEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// When included, if two identical requests are made with the same client token, Proton returns the environment account connection that the first request created.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. You must specify componentRoleArn to allow directly defined components to be associated with any environments running in this account. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The name of the Proton environment that's created in the associated management account.
        public let environmentName: String
        /// The ID of the management account that accepts or rejects the environment account connection. You create and manage the Proton environment in this account. If the management account accepts the environment account connection, Proton can use the associated IAM role to provision environment infrastructure resources in the associated environment account.
        public let managementAccountId: String
        /// The Amazon Resource Name (ARN) of the IAM service role that's created in the environment account. Proton uses this role to provision infrastructure resources in the associated environment account.
        public let roleArn: String?
        /// An optional list of metadata items that you can associate with the Proton environment account connection. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateEnvironmentAccountConnectionInput.idempotencyToken(), codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, environmentName: String, managementAccountId: String, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.environmentName = environmentName
            self.managementAccountId = managementAccountId
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, max: 2048)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, min: 1)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, max: 2048)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, min: 1)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.managementAccountId, name: "managementAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case environmentName = "environmentName"
            case managementAccountId = "managementAccountId"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The environment account connection detail data that's returned by Proton.
        public let environmentAccountConnection: EnvironmentAccountConnection

        public init(environmentAccountConnection: EnvironmentAccountConnection) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct CreateEnvironmentInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf. To use CodeBuild-based provisioning for the environment or for any service instance running in the environment, specify either the environmentAccountConnectionId or codebuildRoleArn parameter.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. You must specify componentRoleArn to allow directly defined components to be associated with this environment. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// A description of the environment that's being created and deployed.
        public let description: String?
        /// The ID of the environment account connection that you provide if you're provisioning your environment infrastructure resources to an environment account. For more information, see Environment account connections in the Proton User guide. To use Amazon Web Services-managed provisioning for the environment, specify either the environmentAccountConnectionId or protonServiceRoleArn parameter and omit the provisioningRepository parameter.
        public let environmentAccountConnectionId: String?
        /// The name of the environment.
        public let name: String
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf. To use Amazon Web Services-managed provisioning for the environment, specify either the environmentAccountConnectionId or protonServiceRoleArn parameter and omit the provisioningRepository parameter.
        public let protonServiceRoleArn: String?
        /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see CreateRepository. To use self-managed provisioning for the environment, specify this parameter and omit the environmentAccountConnectionId and protonServiceRoleArn parameters.
        public let provisioningRepository: RepositoryBranchInput?
        /// A YAML formatted string that provides inputs as defined in the environment template bundle schema file. For more information, see Environments in the Proton User Guide.
        public let spec: String
        /// An optional list of metadata items that you can associate with the Proton environment. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// The major version of the environment template.
        public let templateMajorVersion: String
        /// The minor version of the environment template.
        public let templateMinorVersion: String?
        /// The name of the environment template. For more information, see Environment Templates in the Proton User Guide.
        public let templateName: String

        public init(codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, description: String? = nil, environmentAccountConnectionId: String? = nil, name: String, protonServiceRoleArn: String? = nil, provisioningRepository: RepositoryBranchInput? = nil, spec: String, tags: [Tag]? = nil, templateMajorVersion: String, templateMinorVersion: String? = nil, templateName: String) {
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioningRepository = provisioningRepository
            self.spec = spec
            self.tags = tags
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, max: 2048)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, min: 1)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, max: 2048)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, min: 1)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.environmentAccountConnectionId, name: "environmentAccountConnectionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, max: 200)
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, min: 1)
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.provisioningRepository?.validate(name: "\(name).provisioningRepository")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case description = "description"
            case environmentAccountConnectionId = "environmentAccountConnectionId"
            case name = "name"
            case protonServiceRoleArn = "protonServiceRoleArn"
            case provisioningRepository = "provisioningRepository"
            case spec = "spec"
            case tags = "tags"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct CreateEnvironmentOutput: AWSDecodableShape {
        /// The environment detail data that's returned by Proton.
        public let environment: Environment

        public init(environment: Environment) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct CreateEnvironmentTemplateInput: AWSEncodableShape {
        /// A description of the environment template.
        public let description: String?
        /// The environment template name as displayed in the developer interface.
        public let displayName: String?
        /// A customer provided encryption key that Proton uses to encrypt data.
        public let encryptionKey: String?
        /// The name of the environment template.
        public let name: String
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public let provisioning: Provisioning?
        /// An optional list of metadata items that you can associate with the Proton environment template. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?

        public init(description: String? = nil, displayName: String? = nil, encryptionKey: String? = nil, name: String, provisioning: Provisioning? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.name = name
            self.provisioning = provisioning
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 200)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case provisioning = "provisioning"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentTemplateOutput: AWSDecodableShape {
        /// The environment template detail data that's returned by Proton.
        public let environmentTemplate: EnvironmentTemplate

        public init(environmentTemplate: EnvironmentTemplate) {
            self.environmentTemplate = environmentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplate = "environmentTemplate"
        }
    }

    public struct CreateEnvironmentTemplateVersionInput: AWSEncodableShape {
        /// When included, if two identical requests are made with the same client token, Proton returns the environment template version that the first request created.
        public let clientToken: String?
        /// A description of the new version of an environment template.
        public let description: String?
        /// To create a new minor version of the environment template, include major Version. To create a new major and minor version of the environment template, exclude major Version.
        public let majorVersion: String?
        /// An object that includes the template bundle S3 bucket path and name for the new version of an template.
        public let source: TemplateVersionSourceInput
        /// An optional list of metadata items that you can associate with the Proton environment template version. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// The name of the environment template.
        public let templateName: String

        public init(clientToken: String? = CreateEnvironmentTemplateVersionInput.idempotencyToken(), description: String? = nil, majorVersion: String? = nil, source: TemplateVersionSourceInput, tags: [Tag]? = nil, templateName: String) {
            self.clientToken = clientToken
            self.description = description
            self.majorVersion = majorVersion
            self.source = source
            self.tags = tags
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case majorVersion = "majorVersion"
            case source = "source"
            case tags = "tags"
            case templateName = "templateName"
        }
    }

    public struct CreateEnvironmentTemplateVersionOutput: AWSDecodableShape {
        /// The environment template detail data that's returned by Proton.
        public let environmentTemplateVersion: EnvironmentTemplateVersion

        public init(environmentTemplateVersion: EnvironmentTemplateVersion) {
            self.environmentTemplateVersion = environmentTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplateVersion = "environmentTemplateVersion"
        }
    }

    public struct CreateRepositoryInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of your AWS CodeStar connection that connects Proton to your repository provider account. For more information, see Setting up for Proton in the Proton User Guide.
        public let connectionArn: String
        /// The ARN of your customer Amazon Web Services Key Management Service (Amazon Web Services KMS) key.
        public let encryptionKey: String?
        /// The repository name (for example, myrepos/myrepo).
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider
        /// An optional list of metadata items that you can associate with the Proton repository. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?

        public init(connectionArn: String, encryptionKey: String? = nil, name: String, provider: RepositoryProvider, tags: [Tag]? = nil) {
            self.connectionArn = connectionArn
            self.encryptionKey = encryptionKey
            self.name = name
            self.provider = provider
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, max: 200)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, min: 1)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 200)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionArn = "connectionArn"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case provider = "provider"
            case tags = "tags"
        }
    }

    public struct CreateRepositoryOutput: AWSDecodableShape {
        /// The repository link's detail data that's returned by Proton.
        public let repository: Repository

        public init(repository: Repository) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct CreateServiceInput: AWSEncodableShape {
        /// The name of the code repository branch that holds the code that's deployed in Proton. Don't include this parameter if your service template doesn't include a service pipeline.
        public let branchName: String?
        /// A description of the Proton service.
        public let description: String?
        /// The service name.
        public let name: String
        /// The Amazon Resource Name (ARN) of the repository connection. For more information, see Setting up an AWS CodeStar connection in the Proton User Guide. Don't include this parameter if your service template doesn't include a service pipeline.
        public let repositoryConnectionArn: String?
        /// The ID of the code repository. Don't include this parameter if your service template doesn't include a service pipeline.
        public let repositoryId: String?
        /// A link to a spec file that provides inputs as defined in the service template bundle schema file. The spec file is in YAML format. Don’t include pipeline inputs in the spec if your service template doesn’t include a service pipeline. For more information, see Create a service in the Proton User Guide.
        public let spec: String
        /// An optional list of metadata items that you can associate with the Proton service. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// The major version of the service template that was used to create the service.
        public let templateMajorVersion: String
        /// The minor version of the service template that was used to create the service.
        public let templateMinorVersion: String?
        /// The name of the service template that's used to create the service.
        public let templateName: String

        public init(branchName: String? = nil, description: String? = nil, name: String, repositoryConnectionArn: String? = nil, repositoryId: String? = nil, spec: String, tags: [Tag]? = nil, templateMajorVersion: String, templateMinorVersion: String? = nil, templateName: String) {
            self.branchName = branchName
            self.description = description
            self.name = name
            self.repositoryConnectionArn = repositoryConnectionArn
            self.repositoryId = repositoryId
            self.spec = spec
            self.tags = tags
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.branchName, name: "branchName", parent: name, max: 200)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.repositoryConnectionArn, name: "repositoryConnectionArn", parent: name, max: 200)
            try self.validate(self.repositoryConnectionArn, name: "repositoryConnectionArn", parent: name, min: 1)
            try self.validate(self.repositoryConnectionArn, name: "repositoryConnectionArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.validate(self.repositoryId, name: "repositoryId", parent: name, max: 200)
            try self.validate(self.repositoryId, name: "repositoryId", parent: name, min: 1)
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case description = "description"
            case name = "name"
            case repositoryConnectionArn = "repositoryConnectionArn"
            case repositoryId = "repositoryId"
            case spec = "spec"
            case tags = "tags"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct CreateServiceInstanceInput: AWSEncodableShape {
        /// The client token of the service instance to create.
        public let clientToken: String?
        /// The name of the service instance to create.
        public let name: String
        /// The name of the service the service instance is added to.
        public let serviceName: String
        /// The spec for the service instance you want to create.
        public let spec: String
        /// An optional list of metadata items that you can associate with the Proton service instance. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// To create a new major and minor version of the service template, exclude major Version.
        public let templateMajorVersion: String?
        /// To create a new minor version of the service template, include a major Version.
        public let templateMinorVersion: String?

        public init(clientToken: String? = CreateServiceInstanceInput.idempotencyToken(), name: String, serviceName: String, spec: String, tags: [Tag]? = nil, templateMajorVersion: String? = nil, templateMinorVersion: String? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.serviceName = serviceName
            self.spec = spec
            self.tags = tags
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case serviceName = "serviceName"
            case spec = "spec"
            case tags = "tags"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
        }
    }

    public struct CreateServiceInstanceOutput: AWSDecodableShape {
        /// The detailed data of the service instance being created.
        public let serviceInstance: ServiceInstance

        public init(serviceInstance: ServiceInstance) {
            self.serviceInstance = serviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstance = "serviceInstance"
        }
    }

    public struct CreateServiceOutput: AWSDecodableShape {
        /// The service detail data that's returned by Proton.
        public let service: Service

        public init(service: Service) {
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case service = "service"
        }
    }

    public struct CreateServiceSyncConfigInput: AWSEncodableShape {
        /// The repository branch for your Proton Ops file.
        public let branch: String
        /// The path to the Proton Ops file.
        public let filePath: String
        /// The repository name.
        public let repositoryName: String
        /// The provider type for your repository.
        public let repositoryProvider: RepositoryProvider
        /// The name of the service the Proton Ops file is for.
        public let serviceName: String

        public init(branch: String, filePath: String, repositoryName: String, repositoryProvider: RepositoryProvider, serviceName: String) {
            self.branch = branch
            self.filePath = filePath
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.filePath, name: "filePath", parent: name, max: 4096)
            try self.validate(self.filePath, name: "filePath", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case filePath = "filePath"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case serviceName = "serviceName"
        }
    }

    public struct CreateServiceSyncConfigOutput: AWSDecodableShape {
        /// The detailed data of the Proton Ops file.
        public let serviceSyncConfig: ServiceSyncConfig?

        public init(serviceSyncConfig: ServiceSyncConfig? = nil) {
            self.serviceSyncConfig = serviceSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSyncConfig = "serviceSyncConfig"
        }
    }

    public struct CreateServiceTemplateInput: AWSEncodableShape {
        /// A description of the service template.
        public let description: String?
        /// The name of the service template as displayed in the developer interface.
        public let displayName: String?
        /// A customer provided encryption key that's used to encrypt data.
        public let encryptionKey: String?
        /// The name of the service template.
        public let name: String
        /// By default, Proton provides a service pipeline for your service. When this parameter is included, it indicates that an Proton service pipeline isn't provided for your service. After it's included, it can't be changed. For more information, see Template bundles in the Proton User Guide.
        public let pipelineProvisioning: Provisioning?
        /// An optional list of metadata items that you can associate with the Proton service template. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?

        public init(description: String? = nil, displayName: String? = nil, encryptionKey: String? = nil, name: String, pipelineProvisioning: Provisioning? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 200)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case pipelineProvisioning = "pipelineProvisioning"
            case tags = "tags"
        }
    }

    public struct CreateServiceTemplateOutput: AWSDecodableShape {
        /// The service template detail data that's returned by Proton.
        public let serviceTemplate: ServiceTemplate

        public init(serviceTemplate: ServiceTemplate) {
            self.serviceTemplate = serviceTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplate = "serviceTemplate"
        }
    }

    public struct CreateServiceTemplateVersionInput: AWSEncodableShape {
        /// When included, if two identical requests are made with the same client token, Proton returns the service template version that the first request created.
        public let clientToken: String?
        /// An array of environment template objects that are compatible with the new service template version. A service instance based on this service template version can run in environments based on compatible templates.
        public let compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplateInput]
        /// A description of the new version of a service template.
        public let description: String?
        /// To create a new minor version of the service template, include a major Version. To create a new major and minor version of the service template, exclude major Version.
        public let majorVersion: String?
        /// An object that includes the template bundle S3 bucket path and name for the new version of a service template.
        public let source: TemplateVersionSourceInput
        /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version. For more information about components, see Proton components in the Proton User Guide.
        public let supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]?
        /// An optional list of metadata items that you can associate with the Proton service template version. A tag is a key-value pair. For more information, see Proton resources and tagging in the Proton User Guide.
        public let tags: [Tag]?
        /// The name of the service template.
        public let templateName: String

        public init(clientToken: String? = CreateServiceTemplateVersionInput.idempotencyToken(), compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplateInput], description: String? = nil, majorVersion: String? = nil, source: TemplateVersionSourceInput, supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]? = nil, tags: [Tag]? = nil, templateName: String) {
            self.clientToken = clientToken
            self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
            self.description = description
            self.majorVersion = majorVersion
            self.source = source
            self.supportedComponentSources = supportedComponentSources
            self.tags = tags
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.compatibleEnvironmentTemplates.forEach {
                try $0.validate(name: "\(name).compatibleEnvironmentTemplates[]")
            }
            try self.validate(self.compatibleEnvironmentTemplates, name: "compatibleEnvironmentTemplates", parent: name, max: 10)
            try self.validate(self.compatibleEnvironmentTemplates, name: "compatibleEnvironmentTemplates", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case compatibleEnvironmentTemplates = "compatibleEnvironmentTemplates"
            case description = "description"
            case majorVersion = "majorVersion"
            case source = "source"
            case supportedComponentSources = "supportedComponentSources"
            case tags = "tags"
            case templateName = "templateName"
        }
    }

    public struct CreateServiceTemplateVersionOutput: AWSDecodableShape {
        /// The service template version summary of detail data that's returned by Proton.
        public let serviceTemplateVersion: ServiceTemplateVersion

        public init(serviceTemplateVersion: ServiceTemplateVersion) {
            self.serviceTemplateVersion = serviceTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplateVersion = "serviceTemplateVersion"
        }
    }

    public struct CreateTemplateSyncConfigInput: AWSEncodableShape {
        /// The repository branch for your template.
        public let branch: String
        /// The repository name (for example, myrepos/myrepo).
        public let repositoryName: String
        /// The provider type for your repository.
        public let repositoryProvider: RepositoryProvider
        /// A repository subdirectory path to your template bundle directory. When included, Proton limits the template bundle search to this repository directory.
        public let subdirectory: String?
        /// The name of your registered template.
        public let templateName: String
        /// The type of the registered template.
        public let templateType: TemplateType

        public init(branch: String, repositoryName: String, repositoryProvider: RepositoryProvider, subdirectory: String? = nil, templateName: String, templateType: TemplateType) {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.subdirectory = subdirectory
            self.templateName = templateName
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
            try self.validate(self.subdirectory, name: "subdirectory", parent: name, max: 4096)
            try self.validate(self.subdirectory, name: "subdirectory", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case subdirectory = "subdirectory"
            case templateName = "templateName"
            case templateType = "templateType"
        }
    }

    public struct CreateTemplateSyncConfigOutput: AWSDecodableShape {
        /// The template sync configuration detail data that's returned by Proton.
        public let templateSyncConfig: TemplateSyncConfig?

        public init(templateSyncConfig: TemplateSyncConfig? = nil) {
            self.templateSyncConfig = templateSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case templateSyncConfig = "templateSyncConfig"
        }
    }

    public struct DeleteComponentInput: AWSEncodableShape {
        /// The name of the component to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteComponentOutput: AWSDecodableShape {
        /// The detailed data of the component being deleted.
        public let component: Component?

        public init(component: Component? = nil) {
            self.component = component
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
        }
    }

    public struct DeleteDeploymentInput: AWSEncodableShape {
        /// The ID of the deployment to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteDeploymentOutput: AWSDecodableShape {
        /// The detailed data of the deployment being deleted.
        public let deployment: Deployment?

        public init(deployment: Deployment? = nil) {
            self.deployment = deployment
        }

        private enum CodingKeys: String, CodingKey {
            case deployment = "deployment"
        }
    }

    public struct DeleteEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// The ID of the environment account connection to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The detailed data of the environment account connection being deleted.
        public let environmentAccountConnection: EnvironmentAccountConnection?

        public init(environmentAccountConnection: EnvironmentAccountConnection? = nil) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct DeleteEnvironmentInput: AWSEncodableShape {
        /// The name of the environment to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteEnvironmentOutput: AWSDecodableShape {
        /// The detailed data of the environment being deleted.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct DeleteEnvironmentTemplateInput: AWSEncodableShape {
        /// The name of the environment template to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteEnvironmentTemplateOutput: AWSDecodableShape {
        /// The detailed data of the environment template being deleted.
        public let environmentTemplate: EnvironmentTemplate?

        public init(environmentTemplate: EnvironmentTemplate? = nil) {
            self.environmentTemplate = environmentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplate = "environmentTemplate"
        }
    }

    public struct DeleteEnvironmentTemplateVersionInput: AWSEncodableShape {
        /// The environment template major version to delete.
        public let majorVersion: String
        /// The environment template minor version to delete.
        public let minorVersion: String
        /// The name of the environment template.
        public let templateName: String

        public init(majorVersion: String, minorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case templateName = "templateName"
        }
    }

    public struct DeleteEnvironmentTemplateVersionOutput: AWSDecodableShape {
        /// The detailed data of the environment template version being deleted.
        public let environmentTemplateVersion: EnvironmentTemplateVersion?

        public init(environmentTemplateVersion: EnvironmentTemplateVersion? = nil) {
            self.environmentTemplateVersion = environmentTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplateVersion = "environmentTemplateVersion"
        }
    }

    public struct DeleteRepositoryInput: AWSEncodableShape {
        /// The repository name.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(name: String, provider: RepositoryProvider) {
            self.name = name
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case provider = "provider"
        }
    }

    public struct DeleteRepositoryOutput: AWSDecodableShape {
        /// The deleted repository link's detail data that's returned by Proton.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DeleteServiceInput: AWSEncodableShape {
        /// The name of the service to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteServiceOutput: AWSDecodableShape {
        /// The detailed data of the service being deleted.
        public let service: Service?

        public init(service: Service? = nil) {
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case service = "service"
        }
    }

    public struct DeleteServiceSyncConfigInput: AWSEncodableShape {
        /// The name of the service that you want to delete the service sync configuration for.
        public let serviceName: String

        public init(serviceName: String) {
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct DeleteServiceSyncConfigOutput: AWSDecodableShape {
        /// The detailed data for the service sync config.
        public let serviceSyncConfig: ServiceSyncConfig?

        public init(serviceSyncConfig: ServiceSyncConfig? = nil) {
            self.serviceSyncConfig = serviceSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSyncConfig = "serviceSyncConfig"
        }
    }

    public struct DeleteServiceTemplateInput: AWSEncodableShape {
        /// The name of the service template to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteServiceTemplateOutput: AWSDecodableShape {
        /// The detailed data of the service template being deleted.
        public let serviceTemplate: ServiceTemplate?

        public init(serviceTemplate: ServiceTemplate? = nil) {
            self.serviceTemplate = serviceTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplate = "serviceTemplate"
        }
    }

    public struct DeleteServiceTemplateVersionInput: AWSEncodableShape {
        /// The service template major version to delete.
        public let majorVersion: String
        /// The service template minor version to delete.
        public let minorVersion: String
        /// The name of the service template.
        public let templateName: String

        public init(majorVersion: String, minorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case templateName = "templateName"
        }
    }

    public struct DeleteServiceTemplateVersionOutput: AWSDecodableShape {
        /// The detailed data of the service template version being deleted.
        public let serviceTemplateVersion: ServiceTemplateVersion?

        public init(serviceTemplateVersion: ServiceTemplateVersion? = nil) {
            self.serviceTemplateVersion = serviceTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplateVersion = "serviceTemplateVersion"
        }
    }

    public struct DeleteTemplateSyncConfigInput: AWSEncodableShape {
        /// The template name.
        public let templateName: String
        /// The template type.
        public let templateType: TemplateType

        public init(templateName: String, templateType: TemplateType) {
            self.templateName = templateName
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case templateName = "templateName"
            case templateType = "templateType"
        }
    }

    public struct DeleteTemplateSyncConfigOutput: AWSDecodableShape {
        /// The template sync configuration detail data that's returned by Proton.
        public let templateSyncConfig: TemplateSyncConfig?

        public init(templateSyncConfig: TemplateSyncConfig? = nil) {
            self.templateSyncConfig = templateSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case templateSyncConfig = "templateSyncConfig"
        }
    }

    public struct Deployment: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deployment.
        public let arn: String
        /// The date and time the deployment was completed.
        public let completedAt: Date?
        /// The name of the component associated with this deployment.
        public let componentName: String?
        /// The date and time the deployment was created.
        public let createdAt: Date
        /// The status of the deployment.
        public let deploymentStatus: DeploymentStatus
        /// The deployment status message.
        public let deploymentStatusMessage: String?
        /// The name of the environment associated with this deployment.
        public let environmentName: String
        /// The ID of the deployment.
        public let id: String
        /// The initial state of the target resource at the time of the deployment.
        public let initialState: DeploymentState?
        /// The ID of the last attempted deployment.
        public let lastAttemptedDeploymentId: String?
        /// The date and time the deployment was last modified.
        public let lastModifiedAt: Date
        /// The ID of the last successful deployment.
        public let lastSucceededDeploymentId: String?
        /// The name of the deployment's service instance.
        public let serviceInstanceName: String?
        /// The name of the service in this deployment.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the target of the deployment.
        public let targetArn: String
        /// The date and time the depoyment target was created.
        public let targetResourceCreatedAt: Date
        /// The resource type of the deployment target. It can be an environment, service, service instance, or component.
        public let targetResourceType: DeploymentTargetResourceType
        /// The target state of the target resource at the time of the deployment.
        public let targetState: DeploymentState?

        public init(arn: String, completedAt: Date? = nil, componentName: String? = nil, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, environmentName: String, id: String, initialState: DeploymentState? = nil, lastAttemptedDeploymentId: String? = nil, lastModifiedAt: Date, lastSucceededDeploymentId: String? = nil, serviceInstanceName: String? = nil, serviceName: String? = nil, targetArn: String, targetResourceCreatedAt: Date, targetResourceType: DeploymentTargetResourceType, targetState: DeploymentState? = nil) {
            self.arn = arn
            self.completedAt = completedAt
            self.componentName = componentName
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.id = id
            self.initialState = initialState
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.targetArn = targetArn
            self.targetResourceCreatedAt = targetResourceCreatedAt
            self.targetResourceType = targetResourceType
            self.targetState = targetState
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case completedAt = "completedAt"
            case componentName = "componentName"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case environmentName = "environmentName"
            case id = "id"
            case initialState = "initialState"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastModifiedAt = "lastModifiedAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case targetArn = "targetArn"
            case targetResourceCreatedAt = "targetResourceCreatedAt"
            case targetResourceType = "targetResourceType"
            case targetState = "targetState"
        }
    }

    public struct DeploymentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deployment.
        public let arn: String
        /// The date and time the deployment was completed.
        public let completedAt: Date?
        /// The name of the component associated with the deployment.
        public let componentName: String?
        /// The date and time the deployment was created.
        public let createdAt: Date
        /// The current status of the deployment.
        public let deploymentStatus: DeploymentStatus
        /// The name of the environment associated with the deployment.
        public let environmentName: String
        /// The ID of the deployment.
        public let id: String
        /// The ID of the last attempted deployment.
        public let lastAttemptedDeploymentId: String?
        /// The date and time the deployment was last modified.
        public let lastModifiedAt: Date
        /// The ID of the last successful deployment.
        public let lastSucceededDeploymentId: String?
        /// The name of the service instance associated with the deployment.
        public let serviceInstanceName: String?
        /// The name of the service associated with the deployment.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the target of the deployment.
        public let targetArn: String
        /// The date and time the target resource was created.
        public let targetResourceCreatedAt: Date
        /// The resource type of the deployment target. It can be an environment, service, service instance, or component.
        public let targetResourceType: DeploymentTargetResourceType

        public init(arn: String, completedAt: Date? = nil, componentName: String? = nil, createdAt: Date, deploymentStatus: DeploymentStatus, environmentName: String, id: String, lastAttemptedDeploymentId: String? = nil, lastModifiedAt: Date, lastSucceededDeploymentId: String? = nil, serviceInstanceName: String? = nil, serviceName: String? = nil, targetArn: String, targetResourceCreatedAt: Date, targetResourceType: DeploymentTargetResourceType) {
            self.arn = arn
            self.completedAt = completedAt
            self.componentName = componentName
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.environmentName = environmentName
            self.id = id
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.targetArn = targetArn
            self.targetResourceCreatedAt = targetResourceCreatedAt
            self.targetResourceType = targetResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case completedAt = "completedAt"
            case componentName = "componentName"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case environmentName = "environmentName"
            case id = "id"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastModifiedAt = "lastModifiedAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case targetArn = "targetArn"
            case targetResourceCreatedAt = "targetResourceCreatedAt"
            case targetResourceType = "targetResourceType"
        }
    }

    public struct Environment: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The time when the environment was created.
        public let createdAt: Date
        /// The environment deployment status.
        public let deploymentStatus: DeploymentStatus
        /// An environment deployment status message.
        public let deploymentStatusMessage: String?
        /// The description of the environment.
        public let description: String?
        /// The ID of the environment account connection that's used to provision infrastructure resources in an environment account.
        public let environmentAccountConnectionId: String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public let environmentAccountId: String?
        /// The ID of the last attempted deployment of this environment.
        public let lastAttemptedDeploymentId: String?
        /// The time when a deployment of the environment was last attempted.
        public let lastDeploymentAttemptedAt: Date
        /// The time when the environment was last deployed successfully.
        public let lastDeploymentSucceededAt: Date
        /// The ID of the last successful deployment of this environment.
        public let lastSucceededDeploymentId: String?
        /// The name of the environment.
        public let name: String
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public let protonServiceRoleArn: String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public let provisioning: Provisioning?
        /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see CreateRepository.
        public let provisioningRepository: RepositoryBranch?
        /// The environment spec.
        public let spec: String?
        /// The major version of the environment template.
        public let templateMajorVersion: String
        /// The minor version of the environment template.
        public let templateMinorVersion: String
        /// The Amazon Resource Name (ARN) of the environment template.
        public let templateName: String

        public init(arn: String, codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, description: String? = nil, environmentAccountConnectionId: String? = nil, environmentAccountId: String? = nil, lastAttemptedDeploymentId: String? = nil, lastDeploymentAttemptedAt: Date, lastDeploymentSucceededAt: Date, lastSucceededDeploymentId: String? = nil, name: String, protonServiceRoleArn: String? = nil, provisioning: Provisioning? = nil, provisioningRepository: RepositoryBranch? = nil, spec: String? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.arn = arn
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.provisioningRepository = provisioningRepository
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
            case environmentAccountConnectionId = "environmentAccountConnectionId"
            case environmentAccountId = "environmentAccountId"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case protonServiceRoleArn = "protonServiceRoleArn"
            case provisioning = "provisioning"
            case provisioningRepository = "provisioningRepository"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct EnvironmentAccountConnection: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        public let arn: String
        /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The environment account that's connected to the environment account connection.
        public let environmentAccountId: String
        /// The name of the environment that's associated with the environment account connection.
        public let environmentName: String
        /// The ID of the environment account connection.
        public let id: String
        /// The time when the environment account connection was last modified.
        public let lastModifiedAt: Date
        /// The ID of the management account that's connected to the environment account connection.
        public let managementAccountId: String
        /// The time when the environment account connection request was made.
        public let requestedAt: Date
        /// The IAM service role that's associated with the environment account connection.
        public let roleArn: String
        /// The status of the environment account connection.
        public let status: EnvironmentAccountConnectionStatus

        public init(arn: String, codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, environmentAccountId: String, environmentName: String, id: String, lastModifiedAt: Date, managementAccountId: String, requestedAt: Date, roleArn: String, status: EnvironmentAccountConnectionStatus) {
            self.arn = arn
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case environmentAccountId = "environmentAccountId"
            case environmentName = "environmentName"
            case id = "id"
            case lastModifiedAt = "lastModifiedAt"
            case managementAccountId = "managementAccountId"
            case requestedAt = "requestedAt"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct EnvironmentAccountConnectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The ID of the environment account that's connected to the environment account connection.
        public let environmentAccountId: String
        /// The name of the environment that's associated with the environment account connection.
        public let environmentName: String
        /// The ID of the environment account connection.
        public let id: String
        /// The time when the environment account connection was last modified.
        public let lastModifiedAt: Date
        /// The ID of the management account that's connected to the environment account connection.
        public let managementAccountId: String
        /// The time when the environment account connection request was made.
        public let requestedAt: Date
        /// The IAM service role that's associated with the environment account connection.
        public let roleArn: String
        /// The status of the environment account connection.
        public let status: EnvironmentAccountConnectionStatus

        public init(arn: String, componentRoleArn: String? = nil, environmentAccountId: String, environmentName: String, id: String, lastModifiedAt: Date, managementAccountId: String, requestedAt: Date, roleArn: String, status: EnvironmentAccountConnectionStatus) {
            self.arn = arn
            self.componentRoleArn = componentRoleArn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case componentRoleArn = "componentRoleArn"
            case environmentAccountId = "environmentAccountId"
            case environmentName = "environmentName"
            case id = "id"
            case lastModifiedAt = "lastModifiedAt"
            case managementAccountId = "managementAccountId"
            case requestedAt = "requestedAt"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct EnvironmentState: AWSDecodableShape {
        /// The environment spec that was used to create the environment.
        public let spec: String?
        /// The major version of the environment template that was used to create the environment.
        public let templateMajorVersion: String
        /// The minor version of the environment template that was used to create the environment.
        public let templateMinorVersion: String
        /// The name of the environment template that was used to create the environment.
        public let templateName: String

        public init(spec: String? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The time when the environment was created.
        public let createdAt: Date
        /// The environment deployment status.
        public let deploymentStatus: DeploymentStatus
        /// An environment deployment status message.
        public let deploymentStatusMessage: String?
        /// The description of the environment.
        public let description: String?
        /// The ID of the environment account connection that the environment is associated with.
        public let environmentAccountConnectionId: String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public let environmentAccountId: String?
        /// The ID of the last attempted deployment of this environment.
        public let lastAttemptedDeploymentId: String?
        /// The time when a deployment of the environment was last attempted.
        public let lastDeploymentAttemptedAt: Date
        /// The time when the environment was last deployed successfully.
        public let lastDeploymentSucceededAt: Date
        /// The ID of the last successful deployment of this environment.
        public let lastSucceededDeploymentId: String?
        /// The name of the environment.
        public let name: String
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public let protonServiceRoleArn: String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public let provisioning: Provisioning?
        /// The major version of the environment template.
        public let templateMajorVersion: String
        /// The minor version of the environment template.
        public let templateMinorVersion: String
        /// The name of the environment template.
        public let templateName: String

        public init(arn: String, componentRoleArn: String? = nil, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, description: String? = nil, environmentAccountConnectionId: String? = nil, environmentAccountId: String? = nil, lastAttemptedDeploymentId: String? = nil, lastDeploymentAttemptedAt: Date, lastDeploymentSucceededAt: Date, lastSucceededDeploymentId: String? = nil, name: String, protonServiceRoleArn: String? = nil, provisioning: Provisioning? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.arn = arn
            self.componentRoleArn = componentRoleArn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case componentRoleArn = "componentRoleArn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
            case environmentAccountConnectionId = "environmentAccountConnectionId"
            case environmentAccountId = "environmentAccountId"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case protonServiceRoleArn = "protonServiceRoleArn"
            case provisioning = "provisioning"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct EnvironmentTemplate: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment template.
        public let arn: String
        /// The time when the environment template was created.
        public let createdAt: Date
        /// A description of the environment template.
        public let description: String?
        /// The name of the environment template as displayed in the developer interface.
        public let displayName: String?
        /// The customer provided encryption key for the environment template.
        public let encryptionKey: String?
        /// The time when the environment template was last modified.
        public let lastModifiedAt: Date
        /// The name of the environment template.
        public let name: String
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public let provisioning: Provisioning?
        /// The ID of the recommended version of the environment template.
        public let recommendedVersion: String?

        public init(arn: String, createdAt: Date, description: String? = nil, displayName: String? = nil, encryptionKey: String? = nil, lastModifiedAt: Date, name: String, provisioning: Provisioning? = nil, recommendedVersion: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case encryptionKey = "encryptionKey"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case provisioning = "provisioning"
            case recommendedVersion = "recommendedVersion"
        }
    }

    public struct EnvironmentTemplateFilter: AWSEncodableShape {
        /// Include majorVersion to filter search for a major version.
        public let majorVersion: String
        /// Include templateName to filter search for a template name.
        public let templateName: String

        public init(majorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case templateName = "templateName"
        }
    }

    public struct EnvironmentTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the environment template.
        public let arn: String
        /// The time when the environment template was created.
        public let createdAt: Date
        /// A description of the environment template.
        public let description: String?
        /// The name of the environment template as displayed in the developer interface.
        public let displayName: String?
        /// The time when the environment template was last modified.
        public let lastModifiedAt: Date
        /// The name of the environment template.
        public let name: String
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public let provisioning: Provisioning?
        /// The recommended version of the environment template.
        public let recommendedVersion: String?

        public init(arn: String, createdAt: Date, description: String? = nil, displayName: String? = nil, lastModifiedAt: Date, name: String, provisioning: Provisioning? = nil, recommendedVersion: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case provisioning = "provisioning"
            case recommendedVersion = "recommendedVersion"
        }
    }

    public struct EnvironmentTemplateVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        public let arn: String
        /// The time when the version of an environment template was created.
        public let createdAt: Date
        /// A description of the minor version of an environment template.
        public let description: String?
        /// The time when the version of an environment template was last modified.
        public let lastModifiedAt: Date
        /// The latest major version that's associated with the version of an environment template.
        public let majorVersion: String
        /// The minor version of an environment template.
        public let minorVersion: String
        /// The recommended minor version of the environment template.
        public let recommendedMinorVersion: String?
        /// The schema of the version of an environment template.
        public let schema: String?
        /// The status of the version of an environment template.
        public let status: TemplateVersionStatus
        /// The status message of the version of an environment template.
        public let statusMessage: String?
        /// The name of the version of an environment template.
        public let templateName: String

        public init(arn: String, createdAt: Date, description: String? = nil, lastModifiedAt: Date, majorVersion: String, minorVersion: String, recommendedMinorVersion: String? = nil, schema: String? = nil, status: TemplateVersionStatus, statusMessage: String? = nil, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case recommendedMinorVersion = "recommendedMinorVersion"
            case schema = "schema"
            case status = "status"
            case statusMessage = "statusMessage"
            case templateName = "templateName"
        }
    }

    public struct EnvironmentTemplateVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        public let arn: String
        /// The time when the version of an environment template was created.
        public let createdAt: Date
        /// A description of the version of an environment template.
        public let description: String?
        /// The time when the version of an environment template was last modified.
        public let lastModifiedAt: Date
        /// The latest major version that's associated with the version of an environment template.
        public let majorVersion: String
        /// The version of an environment template.
        public let minorVersion: String
        /// The recommended minor version of the environment template.
        public let recommendedMinorVersion: String?
        /// The status of the version of an environment template.
        public let status: TemplateVersionStatus
        /// The status message of the version of an environment template.
        public let statusMessage: String?
        /// The name of the environment template.
        public let templateName: String

        public init(arn: String, createdAt: Date, description: String? = nil, lastModifiedAt: Date, majorVersion: String, minorVersion: String, recommendedMinorVersion: String? = nil, status: TemplateVersionStatus, statusMessage: String? = nil, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case recommendedMinorVersion = "recommendedMinorVersion"
            case status = "status"
            case statusMessage = "statusMessage"
            case templateName = "templateName"
        }
    }

    public struct GetAccountSettingsInput: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsOutput: AWSDecodableShape {
        /// The Proton pipeline service role detail data that's returned by Proton.
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct GetComponentInput: AWSEncodableShape {
        /// The name of the component that you want to get the detailed data for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetComponentOutput: AWSDecodableShape {
        /// The detailed data of the requested component.
        public let component: Component?

        public init(component: Component? = nil) {
            self.component = component
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
        }
    }

    public struct GetDeploymentInput: AWSEncodableShape {
        /// The name of a component that you want to get the detailed data for.
        public let componentName: String?
        /// The name of a environment that you want to get the detailed data for.
        public let environmentName: String?
        /// The ID of the deployment that you want to get the detailed data for.
        public let id: String
        /// The name of the service instance associated with the given deployment ID. serviceName must be specified to identify the service instance.
        public let serviceInstanceName: String?
        /// The name of the service associated with the given deployment ID.
        public let serviceName: String?

        public init(componentName: String? = nil, environmentName: String? = nil, id: String, serviceInstanceName: String? = nil, serviceName: String? = nil) {
            self.componentName = componentName
            self.environmentName = environmentName
            self.id = id
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 100)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case environmentName = "environmentName"
            case id = "id"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct GetDeploymentOutput: AWSDecodableShape {
        /// The detailed data of the requested deployment.
        public let deployment: Deployment?

        public init(deployment: Deployment? = nil) {
            self.deployment = deployment
        }

        private enum CodingKeys: String, CodingKey {
            case deployment = "deployment"
        }
    }

    public struct GetEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// The ID of the environment account connection that you want to get the detailed data for.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The detailed data of the requested environment account connection.
        public let environmentAccountConnection: EnvironmentAccountConnection

        public init(environmentAccountConnection: EnvironmentAccountConnection) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct GetEnvironmentInput: AWSEncodableShape {
        /// The name of the environment that you want to get the detailed data for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetEnvironmentOutput: AWSDecodableShape {
        /// The detailed data of the requested environment.
        public let environment: Environment

        public init(environment: Environment) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct GetEnvironmentTemplateInput: AWSEncodableShape {
        /// The name of the environment template that you want to get the detailed data for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetEnvironmentTemplateOutput: AWSDecodableShape {
        /// The detailed data of the requested environment template.
        public let environmentTemplate: EnvironmentTemplate

        public init(environmentTemplate: EnvironmentTemplate) {
            self.environmentTemplate = environmentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplate = "environmentTemplate"
        }
    }

    public struct GetEnvironmentTemplateVersionInput: AWSEncodableShape {
        /// To get environment template major version detail data, include major Version.
        public let majorVersion: String
        /// To get environment template minor version detail data, include minorVersion.
        public let minorVersion: String
        /// The name of the environment template a version of which you want to get detailed data for.
        public let templateName: String

        public init(majorVersion: String, minorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case templateName = "templateName"
        }
    }

    public struct GetEnvironmentTemplateVersionOutput: AWSDecodableShape {
        /// The detailed data of the requested environment template version.
        public let environmentTemplateVersion: EnvironmentTemplateVersion

        public init(environmentTemplateVersion: EnvironmentTemplateVersion) {
            self.environmentTemplateVersion = environmentTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplateVersion = "environmentTemplateVersion"
        }
    }

    public struct GetRepositoryInput: AWSEncodableShape {
        /// The repository name, for example myrepos/myrepo.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(name: String, provider: RepositoryProvider) {
            self.name = name
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case provider = "provider"
        }
    }

    public struct GetRepositoryOutput: AWSDecodableShape {
        /// The repository link's detail data that's returned by Proton.
        public let repository: Repository

        public init(repository: Repository) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct GetRepositorySyncStatusInput: AWSEncodableShape {
        /// The repository branch.
        public let branch: String
        /// The repository name.
        public let repositoryName: String
        /// The repository provider.
        public let repositoryProvider: RepositoryProvider
        /// The repository sync type.
        public let syncType: SyncType

        public init(branch: String, repositoryName: String, repositoryProvider: RepositoryProvider, syncType: SyncType) {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.syncType = syncType
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case syncType = "syncType"
        }
    }

    public struct GetRepositorySyncStatusOutput: AWSDecodableShape {
        /// The repository sync status detail data that's returned by Proton.
        public let latestSync: RepositorySyncAttempt?

        public init(latestSync: RepositorySyncAttempt? = nil) {
            self.latestSync = latestSync
        }

        private enum CodingKeys: String, CodingKey {
            case latestSync = "latestSync"
        }
    }

    public struct GetResourcesSummaryInput: AWSEncodableShape {
        public init() {}
    }

    public struct GetResourcesSummaryOutput: AWSDecodableShape {
        /// Summary counts of each Proton resource type.
        public let counts: CountsSummary

        public init(counts: CountsSummary) {
            self.counts = counts
        }

        private enum CodingKeys: String, CodingKey {
            case counts = "counts"
        }
    }

    public struct GetServiceInput: AWSEncodableShape {
        /// The name of the service that you want to get the detailed data for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetServiceInstanceInput: AWSEncodableShape {
        /// The name of a service instance that you want to get the detailed data for.
        public let name: String
        /// The name of the service that you want the service instance input for.
        public let serviceName: String

        public init(name: String, serviceName: String) {
            self.name = name
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case serviceName = "serviceName"
        }
    }

    public struct GetServiceInstanceOutput: AWSDecodableShape {
        /// The detailed data of the requested service instance.
        public let serviceInstance: ServiceInstance

        public init(serviceInstance: ServiceInstance) {
            self.serviceInstance = serviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstance = "serviceInstance"
        }
    }

    public struct GetServiceInstanceSyncStatusInput: AWSEncodableShape {
        /// The name of the service instance that you want the sync status input for.
        public let serviceInstanceName: String
        /// The name of the service that the service instance belongs to.
        public let serviceName: String

        public init(serviceInstanceName: String, serviceName: String) {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct GetServiceInstanceSyncStatusOutput: AWSDecodableShape {
        /// The service instance sync desired state that's returned by Proton
        public let desiredState: Revision?
        /// The detailed data of the latest successful sync with the service instance.
        public let latestSuccessfulSync: ResourceSyncAttempt?
        /// The detailed data of the latest sync with the service instance.
        public let latestSync: ResourceSyncAttempt?

        public init(desiredState: Revision? = nil, latestSuccessfulSync: ResourceSyncAttempt? = nil, latestSync: ResourceSyncAttempt? = nil) {
            self.desiredState = desiredState
            self.latestSuccessfulSync = latestSuccessfulSync
            self.latestSync = latestSync
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "desiredState"
            case latestSuccessfulSync = "latestSuccessfulSync"
            case latestSync = "latestSync"
        }
    }

    public struct GetServiceOutput: AWSDecodableShape {
        /// The detailed data of the requested service.
        public let service: Service?

        public init(service: Service? = nil) {
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case service = "service"
        }
    }

    public struct GetServiceSyncBlockerSummaryInput: AWSEncodableShape {
        /// The name of the service instance that you want to get the service sync blocker summary for. If given bothe the instance name and the service name, only the instance is blocked.
        public let serviceInstanceName: String?
        /// The name of the service that you want to get the service sync blocker summary for. If given only the service name, all instances are blocked.
        public let serviceName: String

        public init(serviceInstanceName: String? = nil, serviceName: String) {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct GetServiceSyncBlockerSummaryOutput: AWSDecodableShape {
        /// The detailed data of the requested service sync blocker summary.
        public let serviceSyncBlockerSummary: ServiceSyncBlockerSummary?

        public init(serviceSyncBlockerSummary: ServiceSyncBlockerSummary? = nil) {
            self.serviceSyncBlockerSummary = serviceSyncBlockerSummary
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSyncBlockerSummary = "serviceSyncBlockerSummary"
        }
    }

    public struct GetServiceSyncConfigInput: AWSEncodableShape {
        /// The name of the service that you want to get the service sync configuration for.
        public let serviceName: String

        public init(serviceName: String) {
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct GetServiceSyncConfigOutput: AWSDecodableShape {
        /// The detailed data of the requested service sync configuration.
        public let serviceSyncConfig: ServiceSyncConfig?

        public init(serviceSyncConfig: ServiceSyncConfig? = nil) {
            self.serviceSyncConfig = serviceSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSyncConfig = "serviceSyncConfig"
        }
    }

    public struct GetServiceTemplateInput: AWSEncodableShape {
        /// The name of the service template that you want to get detailed data for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetServiceTemplateOutput: AWSDecodableShape {
        /// The detailed data of the requested service template.
        public let serviceTemplate: ServiceTemplate

        public init(serviceTemplate: ServiceTemplate) {
            self.serviceTemplate = serviceTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplate = "serviceTemplate"
        }
    }

    public struct GetServiceTemplateVersionInput: AWSEncodableShape {
        /// To get service template major version detail data, include major Version.
        public let majorVersion: String
        /// To get service template minor version detail data, include minorVersion.
        public let minorVersion: String
        /// The name of the service template a version of which you want to get detailed data for.
        public let templateName: String

        public init(majorVersion: String, minorVersion: String, templateName: String) {
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case templateName = "templateName"
        }
    }

    public struct GetServiceTemplateVersionOutput: AWSDecodableShape {
        /// The detailed data of the requested service template version.
        public let serviceTemplateVersion: ServiceTemplateVersion

        public init(serviceTemplateVersion: ServiceTemplateVersion) {
            self.serviceTemplateVersion = serviceTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplateVersion = "serviceTemplateVersion"
        }
    }

    public struct GetTemplateSyncConfigInput: AWSEncodableShape {
        /// The template name.
        public let templateName: String
        /// The template type.
        public let templateType: TemplateType

        public init(templateName: String, templateType: TemplateType) {
            self.templateName = templateName
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case templateName = "templateName"
            case templateType = "templateType"
        }
    }

    public struct GetTemplateSyncConfigOutput: AWSDecodableShape {
        /// The template sync configuration detail data that's returned by Proton.
        public let templateSyncConfig: TemplateSyncConfig?

        public init(templateSyncConfig: TemplateSyncConfig? = nil) {
            self.templateSyncConfig = templateSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case templateSyncConfig = "templateSyncConfig"
        }
    }

    public struct GetTemplateSyncStatusInput: AWSEncodableShape {
        /// The template name.
        public let templateName: String
        /// The template type.
        public let templateType: TemplateType
        /// The template major version.
        public let templateVersion: String

        public init(templateName: String, templateType: TemplateType, templateVersion: String) {
            self.templateName = templateName
            self.templateType = templateType
            self.templateVersion = templateVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.templateVersion, name: "templateVersion", parent: name, max: 20)
            try self.validate(self.templateVersion, name: "templateVersion", parent: name, min: 1)
            try self.validate(self.templateVersion, name: "templateVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
        }

        private enum CodingKeys: String, CodingKey {
            case templateName = "templateName"
            case templateType = "templateType"
            case templateVersion = "templateVersion"
        }
    }

    public struct GetTemplateSyncStatusOutput: AWSDecodableShape {
        /// The template sync desired state that's returned by Proton.
        public let desiredState: Revision?
        /// The details of the last successful sync that's returned by Proton.
        public let latestSuccessfulSync: ResourceSyncAttempt?
        /// The details of the last sync that's returned by Proton.
        public let latestSync: ResourceSyncAttempt?

        public init(desiredState: Revision? = nil, latestSuccessfulSync: ResourceSyncAttempt? = nil, latestSync: ResourceSyncAttempt? = nil) {
            self.desiredState = desiredState
            self.latestSuccessfulSync = latestSuccessfulSync
            self.latestSync = latestSync
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "desiredState"
            case latestSuccessfulSync = "latestSuccessfulSync"
            case latestSync = "latestSync"
        }
    }

    public struct ListComponentOutputsInput: AWSEncodableShape {
        /// The name of the component whose outputs you want.
        public let componentName: String
        /// The ID of the deployment whose outputs you want.
        public let deploymentId: String?
        /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
        public let nextToken: String?

        public init(componentName: String, deploymentId: String? = nil, nextToken: String? = nil) {
            self.componentName = componentName
            self.deploymentId = deploymentId
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 100)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case deploymentId = "deploymentId"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentOutputsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
        public let nextToken: String?
        /// An array of component Infrastructure as Code (IaC) outputs.
        public let outputs: [Output]

        public init(nextToken: String? = nil, outputs: [Output]) {
            self.nextToken = nextToken
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case outputs = "outputs"
        }
    }

    public struct ListComponentProvisionedResourcesInput: AWSEncodableShape {
        /// The name of the component whose provisioned resources you want.
        public let componentName: String
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
        public let nextToken: String?

        public init(componentName: String, nextToken: String? = nil) {
            self.componentName = componentName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 100)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentProvisionedResourcesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
        public let nextToken: String?
        /// An array of provisioned resources for a component.
        public let provisionedResources: [ProvisionedResource]

        public init(nextToken: String? = nil, provisionedResources: [ProvisionedResource]) {
            self.nextToken = nextToken
            self.provisionedResources = provisionedResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedResources = "provisionedResources"
        }
    }

    public struct ListComponentsInput: AWSEncodableShape {
        /// The name of an environment for result list filtering. Proton returns components associated with the environment or attached to service instances running in it.
        public let environmentName: String?
        /// The maximum number of components to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next component in the array of components, after the list of components that was previously requested.
        public let nextToken: String?
        /// The name of a service instance for result list filtering. Proton returns the component attached to the service instance, if any.
        public let serviceInstanceName: String?
        /// The name of a service for result list filtering. Proton returns components attached to service instances of the service.
        public let serviceName: String?

        public init(environmentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, serviceInstanceName: String? = nil, serviceName: String? = nil) {
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "environmentName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct ListComponentsOutput: AWSDecodableShape {
        /// An array of components with summary data.
        public let components: [ComponentSummary]
        /// A token that indicates the location of the next component in the array of components, after the current requested list of components.
        public let nextToken: String?

        public init(components: [ComponentSummary], nextToken: String? = nil) {
            self.components = components
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case components = "components"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsInput: AWSEncodableShape {
        /// The name of a component for result list filtering. Proton returns deployments associated with that component.
        public let componentName: String?
        /// The name of an environment for result list filtering. Proton returns deployments associated with the environment.
        public let environmentName: String?
        /// The maximum number of deployments to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next deployment in the array of deployment, after the list of deployment that was previously requested.
        public let nextToken: String?
        /// The name of a service instance for result list filtering. Proton returns the deployments associated with the service instance.
        public let serviceInstanceName: String?
        /// The name of a service for result list filtering. Proton returns deployments associated with service instances of the service.
        public let serviceName: String?

        public init(componentName: String? = nil, environmentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, serviceInstanceName: String? = nil, serviceName: String? = nil) {
            self.componentName = componentName
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 100)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case environmentName = "environmentName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct ListDeploymentsOutput: AWSDecodableShape {
        /// An array of deployment with summary data.
        public let deployments: [DeploymentSummary]
        /// A token that indicates the location of the next deployment in the array of deployment, after the current requested list of deployment.
        public let nextToken: String?

        public init(deployments: [DeploymentSummary], nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "deployments"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentAccountConnectionsInput: AWSEncodableShape {
        /// The environment name that's associated with each listed environment account connection.
        public let environmentName: String?
        /// The maximum number of environment account connections to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next environment account connection in the array of environment account connections, after the list of environment account connections that was previously requested.
        public let nextToken: String?
        /// The type of account making the ListEnvironmentAccountConnections request.
        public let requestedBy: EnvironmentAccountConnectionRequesterAccountType
        /// The status details for each listed environment account connection.
        public let statuses: [EnvironmentAccountConnectionStatus]?

        public init(environmentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, requestedBy: EnvironmentAccountConnectionRequesterAccountType, statuses: [EnvironmentAccountConnectionStatus]? = nil) {
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.requestedBy = requestedBy
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "environmentName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case requestedBy = "requestedBy"
            case statuses = "statuses"
        }
    }

    public struct ListEnvironmentAccountConnectionsOutput: AWSDecodableShape {
        /// An array of environment account connections with details that's returned by Proton.
        public let environmentAccountConnections: [EnvironmentAccountConnectionSummary]
        /// A token that indicates the location of the next environment account connection in the array of environment account connections, after the current requested list of environment account connections.
        public let nextToken: String?

        public init(environmentAccountConnections: [EnvironmentAccountConnectionSummary], nextToken: String? = nil) {
            self.environmentAccountConnections = environmentAccountConnections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnections = "environmentAccountConnections"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentOutputsInput: AWSEncodableShape {
        /// The ID of the deployment whose outputs you want.
        public let deploymentId: String?
        /// The environment name.
        public let environmentName: String
        /// A token that indicates the location of the next environment output in the array of environment outputs, after the list of environment outputs that was previously requested.
        public let nextToken: String?

        public init(deploymentId: String? = nil, environmentName: String, nextToken: String? = nil) {
            self.deploymentId = deploymentId
            self.environmentName = environmentName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case environmentName = "environmentName"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentOutputsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next environment output in the array of environment outputs, after the current requested list of environment outputs.
        public let nextToken: String?
        /// An array of environment outputs with detail data.
        public let outputs: [Output]

        public init(nextToken: String? = nil, outputs: [Output]) {
            self.nextToken = nextToken
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case outputs = "outputs"
        }
    }

    public struct ListEnvironmentProvisionedResourcesInput: AWSEncodableShape {
        /// The environment name.
        public let environmentName: String
        /// A token that indicates the location of the next environment provisioned resource in the array of environment provisioned resources, after the list of environment provisioned resources that was previously requested.
        public let nextToken: String?

        public init(environmentName: String, nextToken: String? = nil) {
            self.environmentName = environmentName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 100)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "environmentName"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentProvisionedResourcesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next environment provisioned resource in the array of provisioned resources, after the current requested list of environment provisioned resources.
        public let nextToken: String?
        /// An array of environment provisioned resources.
        public let provisionedResources: [ProvisionedResource]

        public init(nextToken: String? = nil, provisionedResources: [ProvisionedResource]) {
            self.nextToken = nextToken
            self.provisionedResources = provisionedResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedResources = "provisionedResources"
        }
    }

    public struct ListEnvironmentTemplateVersionsInput: AWSEncodableShape {
        /// To view a list of minor of versions under a major version of an environment template, include major Version. To view a list of major versions of an environment template, exclude major Version.
        public let majorVersion: String?
        /// The maximum number of major or minor versions of an environment template to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
        public let nextToken: String?
        /// The name of the environment template.
        public let templateName: String

        public init(majorVersion: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, templateName: String) {
            self.majorVersion = majorVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case templateName = "templateName"
        }
    }

    public struct ListEnvironmentTemplateVersionsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
        public let nextToken: String?
        /// An array of major or minor versions of an environment template detail data.
        public let templateVersions: [EnvironmentTemplateVersionSummary]

        public init(nextToken: String? = nil, templateVersions: [EnvironmentTemplateVersionSummary]) {
            self.nextToken = nextToken
            self.templateVersions = templateVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templateVersions = "templateVersions"
        }
    }

    public struct ListEnvironmentTemplatesInput: AWSEncodableShape {
        /// The maximum number of environment templates to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next environment template in the array of environment templates, after the list of environment templates that was previously requested.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentTemplatesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next environment template in the array of environment templates, after the current requested list of environment templates.
        public let nextToken: String?
        /// An array of environment templates with detail data.
        public let templates: [EnvironmentTemplateSummary]

        public init(nextToken: String? = nil, templates: [EnvironmentTemplateSummary]) {
            self.nextToken = nextToken
            self.templates = templates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templates = "templates"
        }
    }

    public struct ListEnvironmentsInput: AWSEncodableShape {
        /// An array of the versions of the environment template.
        public let environmentTemplates: [EnvironmentTemplateFilter]?
        /// The maximum number of environments to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next environment in the array of environments, after the list of environments that was previously requested.
        public let nextToken: String?

        public init(environmentTemplates: [EnvironmentTemplateFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentTemplates = environmentTemplates
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.environmentTemplates?.forEach {
                try $0.validate(name: "\(name).environmentTemplates[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplates = "environmentTemplates"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentsOutput: AWSDecodableShape {
        /// An array of environment detail data summaries.
        public let environments: [EnvironmentSummary]
        /// A token that indicates the location of the next environment in the array of environments, after the current requested list of environments.
        public let nextToken: String?

        public init(environments: [EnvironmentSummary], nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListRepositoriesInput: AWSEncodableShape {
        /// The maximum number of repositories to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next repository in the array of repositories, after the list of repositories previously requested.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRepositoriesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next repository in the array of repositories, after the current requested list of repositories.
        public let nextToken: String?
        /// An array of repository links.
        public let repositories: [RepositorySummary]

        public init(nextToken: String? = nil, repositories: [RepositorySummary]) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct ListRepositorySyncDefinitionsInput: AWSEncodableShape {
        /// A token that indicates the location of the next repository sync definition in the array of repository sync definitions, after the list of repository sync definitions previously requested.
        public let nextToken: String?
        /// The repository name.
        public let repositoryName: String
        /// The repository provider.
        public let repositoryProvider: RepositoryProvider
        /// The sync type. The only supported value is TEMPLATE_SYNC.
        public let syncType: SyncType

        public init(nextToken: String? = nil, repositoryName: String, repositoryProvider: RepositoryProvider, syncType: SyncType) {
            self.nextToken = nextToken
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.syncType = syncType
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case syncType = "syncType"
        }
    }

    public struct ListRepositorySyncDefinitionsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next repository sync definition in the array of repository sync definitions, after the current requested list of repository sync definitions.
        public let nextToken: String?
        /// An array of repository sync definitions.
        public let syncDefinitions: [RepositorySyncDefinition]

        public init(nextToken: String? = nil, syncDefinitions: [RepositorySyncDefinition]) {
            self.nextToken = nextToken
            self.syncDefinitions = syncDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case syncDefinitions = "syncDefinitions"
        }
    }

    public struct ListServiceInstanceOutputsInput: AWSEncodableShape {
        /// The ID of the deployment whose outputs you want.
        public let deploymentId: String?
        /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
        public let nextToken: String?
        /// The name of the service instance whose outputs you want.
        public let serviceInstanceName: String
        /// The name of the service that serviceInstanceName is associated to.
        public let serviceName: String

        public init(deploymentId: String? = nil, nextToken: String? = nil, serviceInstanceName: String, serviceName: String) {
            self.deploymentId = deploymentId
            self.nextToken = nextToken
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case nextToken = "nextToken"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct ListServiceInstanceOutputsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next output in the array of outputs, after the current requested list of outputs.
        public let nextToken: String?
        /// An array of service instance Infrastructure as Code (IaC) outputs.
        public let outputs: [Output]

        public init(nextToken: String? = nil, outputs: [Output]) {
            self.nextToken = nextToken
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case outputs = "outputs"
        }
    }

    public struct ListServiceInstanceProvisionedResourcesInput: AWSEncodableShape {
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
        public let nextToken: String?
        /// The name of the service instance whose provisioned resources you want.
        public let serviceInstanceName: String
        /// The name of the service that serviceInstanceName is associated to.
        public let serviceName: String

        public init(nextToken: String? = nil, serviceInstanceName: String, serviceName: String) {
            self.nextToken = nextToken
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, min: 1)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct ListServiceInstanceProvisionedResourcesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
        public let nextToken: String?
        /// An array of provisioned resources for a service instance.
        public let provisionedResources: [ProvisionedResource]

        public init(nextToken: String? = nil, provisionedResources: [ProvisionedResource]) {
            self.nextToken = nextToken
            self.provisionedResources = provisionedResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedResources = "provisionedResources"
        }
    }

    public struct ListServiceInstancesFilter: AWSEncodableShape {
        /// The name of a filtering criterion.
        public let key: ListServiceInstancesFilterBy?
        /// A value to filter by. With the date/time keys (*At{Before,After}), the value is a valid RFC 3339 string with no UTC offset and with an optional fractional precision (for example, 1985-04-12T23:20:50.52Z).
        public let value: String?

        public init(key: ListServiceInstancesFilterBy? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ListServiceInstancesInput: AWSEncodableShape {
        /// An array of filtering criteria that scope down the result list. By default, all service instances in the Amazon Web Services account are returned.
        public let filters: [ListServiceInstancesFilter]?
        /// The maximum number of service instances to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next service in the array of service instances, after the list of service instances that was previously requested.
        public let nextToken: String?
        /// The name of the service that the service instance belongs to.
        public let serviceName: String?
        /// The field that the result list is sorted by. When you choose to sort by serviceName, service instances within each service are sorted by service instance name. Default: serviceName
        public let sortBy: ListServiceInstancesSortBy?
        /// Result list sort order. Default: ASCENDING
        public let sortOrder: SortOrder?

        public init(filters: [ListServiceInstancesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, serviceName: String? = nil, sortBy: ListServiceInstancesSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceName = serviceName
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case serviceName = "serviceName"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListServiceInstancesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next service instance in the array of service instances, after the current requested list of service instances.
        public let nextToken: String?
        /// An array of service instances with summary data.
        public let serviceInstances: [ServiceInstanceSummary]

        public init(nextToken: String? = nil, serviceInstances: [ServiceInstanceSummary]) {
            self.nextToken = nextToken
            self.serviceInstances = serviceInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case serviceInstances = "serviceInstances"
        }
    }

    public struct ListServicePipelineOutputsInput: AWSEncodableShape {
        /// The ID of the deployment you want the outputs for.
        public let deploymentId: String?
        /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
        public let nextToken: String?
        /// The name of the service whose pipeline's outputs you want.
        public let serviceName: String

        public init(deploymentId: String? = nil, nextToken: String? = nil, serviceName: String) {
            self.deploymentId = deploymentId
            self.nextToken = nextToken
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case nextToken = "nextToken"
            case serviceName = "serviceName"
        }
    }

    public struct ListServicePipelineOutputsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next output in the array of outputs, after the current requested list of outputs.
        public let nextToken: String?
        /// An array of service pipeline Infrastructure as Code (IaC) outputs.
        public let outputs: [Output]

        public init(nextToken: String? = nil, outputs: [Output]) {
            self.nextToken = nextToken
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case outputs = "outputs"
        }
    }

    public struct ListServicePipelineProvisionedResourcesInput: AWSEncodableShape {
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
        public let nextToken: String?
        /// The name of the service whose pipeline's provisioned resources you want.
        public let serviceName: String

        public init(nextToken: String? = nil, serviceName: String) {
            self.nextToken = nextToken
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 0)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case serviceName = "serviceName"
        }
    }

    public struct ListServicePipelineProvisionedResourcesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
        public let nextToken: String?
        /// An array of provisioned resources for a service and pipeline.
        public let provisionedResources: [ProvisionedResource]

        public init(nextToken: String? = nil, provisionedResources: [ProvisionedResource]) {
            self.nextToken = nextToken
            self.provisionedResources = provisionedResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedResources = "provisionedResources"
        }
    }

    public struct ListServiceTemplateVersionsInput: AWSEncodableShape {
        /// To view a list of minor of versions under a major version of a service template, include major Version. To view a list of major versions of a service template, exclude major Version.
        public let majorVersion: String?
        /// The maximum number of major or minor versions of a service template to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next major or minor version in the array of major or minor versions of a service template, after the list of major or minor versions that was previously requested.
        public let nextToken: String?
        /// The name of the service template.
        public let templateName: String

        public init(majorVersion: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, templateName: String) {
            self.majorVersion = majorVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case majorVersion = "majorVersion"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case templateName = "templateName"
        }
    }

    public struct ListServiceTemplateVersionsOutput: AWSDecodableShape {
        /// A token that indicates the location of the next major or minor version in the array of major or minor versions of a service template, after the current requested list of service major or minor versions.
        public let nextToken: String?
        /// An array of major or minor versions of a service template with detail data.
        public let templateVersions: [ServiceTemplateVersionSummary]

        public init(nextToken: String? = nil, templateVersions: [ServiceTemplateVersionSummary]) {
            self.nextToken = nextToken
            self.templateVersions = templateVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templateVersions = "templateVersions"
        }
    }

    public struct ListServiceTemplatesInput: AWSEncodableShape {
        /// The maximum number of service templates to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next service template in the array of service templates, after the list of service templates previously requested.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceTemplatesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next service template in the array of service templates, after the current requested list of service templates.
        public let nextToken: String?
        /// An array of service templates with detail data.
        public let templates: [ServiceTemplateSummary]

        public init(nextToken: String? = nil, templates: [ServiceTemplateSummary]) {
            self.nextToken = nextToken
            self.templates = templates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templates = "templates"
        }
    }

    public struct ListServicesInput: AWSEncodableShape {
        /// The maximum number of services to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next service in the array of services, after the list of services that was previously requested.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+=/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListServicesOutput: AWSDecodableShape {
        /// A token that indicates the location of the next service in the array of services, after the current requested list of services.
        public let nextToken: String?
        /// An array of services with summaries of detail data.
        public let services: [ServiceSummary]

        public init(nextToken: String? = nil, services: [ServiceSummary]) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case services = "services"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The maximum number of tags to list.
        public let maxResults: Int?
        /// A token that indicates the location of the next resource tag in the array of resource tags, after the list of resource tags that was previously requested.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource for the listed tags.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// A token that indicates the location of the next resource tag in the array of resource tags, after the current requested list of resource tags.
        public let nextToken: String?
        /// A list of resource tags with detail data.
        public let tags: [Tag]

        public init(nextToken: String? = nil, tags: [Tag]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct NotifyResourceDeploymentStatusChangeInput: AWSEncodableShape {
        /// The deployment ID for your provisioned resource.
        public let deploymentId: String?
        /// The provisioned resource state change detail data that's returned by Proton.
        public let outputs: [Output]?
        /// The provisioned resource Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The status of your provisioned resource.
        public let status: ResourceDeploymentStatus?
        /// The deployment status message for your provisioned resource.
        public let statusMessage: String?

        public init(deploymentId: String? = nil, outputs: [Output]? = nil, resourceArn: String, status: ResourceDeploymentStatus? = nil, statusMessage: String? = nil) {
            self.deploymentId = deploymentId
            self.outputs = outputs
            self.resourceArn = resourceArn
            self.status = status
            self.statusMessage = statusMessage
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case outputs = "outputs"
            case resourceArn = "resourceArn"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct NotifyResourceDeploymentStatusChangeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Output: AWSEncodableShape & AWSDecodableShape {
        /// The output key.
        public let key: String?
        /// The output value.
        public let valueString: String?

        public init(key: String? = nil, valueString: String? = nil) {
            self.key = key
            self.valueString = valueString
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.valueString, name: "valueString", parent: name, max: 1024)
            try self.validate(self.valueString, name: "valueString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case valueString = "valueString"
        }
    }

    public struct ProvisionedResource: AWSDecodableShape {
        /// The provisioned resource identifier.
        public let identifier: String?
        /// The provisioned resource name.
        public let name: String?
        /// The resource provisioning engine. At this time, CLOUDFORMATION can be used for Amazon Web Services-managed provisioning, and TERRAFORM can be used for self-managed provisioning. For more information, see Self-managed provisioning in the Proton User Guide.
        public let provisioningEngine: ProvisionedResourceEngine?

        public init(identifier: String? = nil, name: String? = nil, provisioningEngine: ProvisionedResourceEngine? = nil) {
            self.identifier = identifier
            self.name = name
            self.provisioningEngine = provisioningEngine
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case name = "name"
            case provisioningEngine = "provisioningEngine"
        }
    }

    public struct RejectEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// The ID of the environment account connection to reject.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct RejectEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The environment connection account detail data that's returned by Proton.
        public let environmentAccountConnection: EnvironmentAccountConnection

        public init(environmentAccountConnection: EnvironmentAccountConnection) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct Repository: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the linked repository.
        public let arn: String
        /// The Amazon Resource Name (ARN) of your AWS CodeStar connection that connects Proton to your repository provider account.
        public let connectionArn: String
        /// Your customer Amazon Web Services KMS encryption key.
        public let encryptionKey: String?
        /// The repository name.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(arn: String, connectionArn: String, encryptionKey: String? = nil, name: String, provider: RepositoryProvider) {
            self.arn = arn
            self.connectionArn = connectionArn
            self.encryptionKey = encryptionKey
            self.name = name
            self.provider = provider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case connectionArn = "connectionArn"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case provider = "provider"
        }
    }

    public struct RepositoryBranch: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the linked repository.
        public let arn: String
        /// The repository branch.
        public let branch: String
        /// The repository name.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(arn: String, branch: String, name: String, provider: RepositoryProvider) {
            self.arn = arn
            self.branch = branch
            self.name = name
            self.provider = provider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case branch = "branch"
            case name = "name"
            case provider = "provider"
        }
    }

    public struct RepositoryBranchInput: AWSEncodableShape {
        /// The repository branch.
        public let branch: String
        /// The repository name.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(branch: String, name: String, provider: RepositoryProvider) {
            self.branch = branch
            self.name = name
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case name = "name"
            case provider = "provider"
        }
    }

    public struct RepositorySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the linked repository.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the of your connection that connects Proton to your repository.
        public let connectionArn: String
        /// The repository name.
        public let name: String
        /// The repository provider.
        public let provider: RepositoryProvider

        public init(arn: String, connectionArn: String, name: String, provider: RepositoryProvider) {
            self.arn = arn
            self.connectionArn = connectionArn
            self.name = name
            self.provider = provider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case connectionArn = "connectionArn"
            case name = "name"
            case provider = "provider"
        }
    }

    public struct RepositorySyncAttempt: AWSDecodableShape {
        /// Detail data for sync attempt events.
        public let events: [RepositorySyncEvent]
        /// The time when the sync attempt started.
        public let startedAt: Date
        /// The sync attempt status.
        public let status: RepositorySyncStatus

        public init(events: [RepositorySyncEvent], startedAt: Date, status: RepositorySyncStatus) {
            self.events = events
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case startedAt = "startedAt"
            case status = "status"
        }
    }

    public struct RepositorySyncDefinition: AWSDecodableShape {
        /// The repository branch.
        public let branch: String
        /// The directory in the repository.
        public let directory: String
        /// The resource that is synced from.
        public let parent: String
        /// The resource that is synced to.
        public let target: String

        public init(branch: String, directory: String, parent: String, target: String) {
            self.branch = branch
            self.directory = directory
            self.parent = parent
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case directory = "directory"
            case parent = "parent"
            case target = "target"
        }
    }

    public struct RepositorySyncEvent: AWSDecodableShape {
        /// Event detail for a repository sync attempt.
        public let event: String
        /// The external ID of the sync event.
        public let externalId: String?
        /// The time that the sync event occurred.
        public let time: Date
        /// The type of event.
        public let type: String

        public init(event: String, externalId: String? = nil, time: Date, type: String) {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case externalId = "externalId"
            case time = "time"
            case type = "type"
        }
    }

    public struct ResourceCountsSummary: AWSDecodableShape {
        /// The number of resources of this type in the Amazon Web Services account that need a major template version update.
        public let behindMajor: Int?
        /// The number of resources of this type in the Amazon Web Services account that need a minor template version update.
        public let behindMinor: Int?
        /// The number of resources of this type in the Amazon Web Services account that failed to deploy.
        public let failed: Int?
        /// The total number of resources of this type in the Amazon Web Services account.
        public let total: Int
        /// The number of resources of this type in the Amazon Web Services account that are up-to-date with their template.
        public let upToDate: Int?

        public init(behindMajor: Int? = nil, behindMinor: Int? = nil, failed: Int? = nil, total: Int, upToDate: Int? = nil) {
            self.behindMajor = behindMajor
            self.behindMinor = behindMinor
            self.failed = failed
            self.total = total
            self.upToDate = upToDate
        }

        private enum CodingKeys: String, CodingKey {
            case behindMajor = "behindMajor"
            case behindMinor = "behindMinor"
            case failed = "failed"
            case total = "total"
            case upToDate = "upToDate"
        }
    }

    public struct ResourceSyncAttempt: AWSDecodableShape {
        /// An array of events with detail data.
        public let events: [ResourceSyncEvent]
        /// Detail data for the initial repository commit, path and push.
        public let initialRevision: Revision
        /// The time when the sync attempt started.
        public let startedAt: Date
        /// The status of the sync attempt.
        public let status: ResourceSyncStatus
        /// The resource that is synced to.
        public let target: String
        /// Detail data for the target revision.
        public let targetRevision: Revision

        public init(events: [ResourceSyncEvent], initialRevision: Revision, startedAt: Date, status: ResourceSyncStatus, target: String, targetRevision: Revision) {
            self.events = events
            self.initialRevision = initialRevision
            self.startedAt = startedAt
            self.status = status
            self.target = target
            self.targetRevision = targetRevision
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case initialRevision = "initialRevision"
            case startedAt = "startedAt"
            case status = "status"
            case target = "target"
            case targetRevision = "targetRevision"
        }
    }

    public struct ResourceSyncEvent: AWSDecodableShape {
        /// A resource sync event.
        public let event: String
        /// The external ID for the event.
        public let externalId: String?
        /// The time when the event occurred.
        public let time: Date
        /// The type of event.
        public let type: String

        public init(event: String, externalId: String? = nil, time: Date, type: String) {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case externalId = "externalId"
            case time = "time"
            case type = "type"
        }
    }

    public struct Revision: AWSDecodableShape {
        /// The repository branch.
        public let branch: String
        /// The repository directory changed by a commit and push that activated the sync attempt.
        public let directory: String
        /// The repository name.
        public let repositoryName: String
        /// The repository provider.
        public let repositoryProvider: RepositoryProvider
        /// The secure hash algorithm (SHA) hash for the revision.
        public let sha: String

        public init(branch: String, directory: String, repositoryName: String, repositoryProvider: RepositoryProvider, sha: String) {
            self.branch = branch
            self.directory = directory
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.sha = sha
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case directory = "directory"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case sha = "sha"
        }
    }

    public struct S3ObjectSource: AWSEncodableShape {
        /// The name of the S3 bucket that contains a template bundle.
        public let bucket: String
        /// The path to the S3 bucket that contains a template bundle.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9]+[a-z0-9-\\.]+[a-z0-9]+$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct Service: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String
        /// The name of the code repository branch that holds the code that's deployed in Proton.
        public let branchName: String?
        /// The time when the service was created.
        public let createdAt: Date
        /// A description of the service.
        public let description: String?
        /// The time when the service was last modified.
        public let lastModifiedAt: Date
        /// The name of the service.
        public let name: String
        /// The service pipeline detail data.
        public let pipeline: ServicePipeline?
        /// The Amazon Resource Name (ARN) of the repository connection. For more information, see Setting up an AWS CodeStar connection in the Proton User Guide.
        public let repositoryConnectionArn: String?
        /// The ID of the source code repository.
        public let repositoryId: String?
        /// The formatted specification that defines the service.
        public let spec: String
        /// The status of the service.
        public let status: ServiceStatus
        /// A service status message.
        public let statusMessage: String?
        /// The name of the service template.
        public let templateName: String

        public init(arn: String, branchName: String? = nil, createdAt: Date, description: String? = nil, lastModifiedAt: Date, name: String, pipeline: ServicePipeline? = nil, repositoryConnectionArn: String? = nil, repositoryId: String? = nil, spec: String, status: ServiceStatus, statusMessage: String? = nil, templateName: String) {
            self.arn = arn
            self.branchName = branchName
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipeline = pipeline
            self.repositoryConnectionArn = repositoryConnectionArn
            self.repositoryId = repositoryId
            self.spec = spec
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case branchName = "branchName"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case pipeline = "pipeline"
            case repositoryConnectionArn = "repositoryConnectionArn"
            case repositoryId = "repositoryId"
            case spec = "spec"
            case status = "status"
            case statusMessage = "statusMessage"
            case templateName = "templateName"
        }
    }

    public struct ServiceInstance: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service instance.
        public let arn: String
        /// The time when the service instance was created.
        public let createdAt: Date
        /// The service instance deployment status.
        public let deploymentStatus: DeploymentStatus
        /// The message associated with the service instance deployment status.
        public let deploymentStatusMessage: String?
        /// The name of the environment that the service instance was deployed into.
        public let environmentName: String
        /// The ID of the last attempted deployment of this service instance.
        public let lastAttemptedDeploymentId: String?
        /// The last client request token received.
        public let lastClientRequestToken: String?
        /// The time when a deployment of the service instance was last attempted.
        public let lastDeploymentAttemptedAt: Date
        /// The time when the service instance was last deployed successfully.
        public let lastDeploymentSucceededAt: Date
        /// The ID of the last successful deployment of this service instance.
        public let lastSucceededDeploymentId: String?
        /// The name of the service instance.
        public let name: String
        /// The name of the service that the service instance belongs to.
        public let serviceName: String
        /// The service spec that was used to create the service instance.
        public let spec: String?
        /// The major version of the service template that was used to create the service instance.
        public let templateMajorVersion: String
        /// The minor version of the service template that was used to create the service instance.
        public let templateMinorVersion: String
        /// The name of the service template that was used to create the service instance.
        public let templateName: String

        public init(arn: String, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, environmentName: String, lastAttemptedDeploymentId: String? = nil, lastClientRequestToken: String? = nil, lastDeploymentAttemptedAt: Date, lastDeploymentSucceededAt: Date, lastSucceededDeploymentId: String? = nil, name: String, serviceName: String, spec: String? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastClientRequestToken = lastClientRequestToken
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceName = serviceName
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case environmentName = "environmentName"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastClientRequestToken = "lastClientRequestToken"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case serviceName = "serviceName"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct ServiceInstanceState: AWSDecodableShape {
        /// The IDs for the last successful components deployed for this service instance.
        public let lastSuccessfulComponentDeploymentIds: [String]?
        /// The ID for the last successful environment deployed for this service instance.
        public let lastSuccessfulEnvironmentDeploymentId: String?
        /// The ID for the last successful service pipeline deployed for this service instance.
        public let lastSuccessfulServicePipelineDeploymentId: String?
        /// The service spec that was used to create the service instance.
        public let spec: String
        /// The major version of the service template that was used to create the service pipeline.
        public let templateMajorVersion: String
        /// The minor version of the service template that was used to create the service pipeline.
        public let templateMinorVersion: String
        /// The name of the service template that was used to create the service instance.
        public let templateName: String

        public init(lastSuccessfulComponentDeploymentIds: [String]? = nil, lastSuccessfulEnvironmentDeploymentId: String? = nil, lastSuccessfulServicePipelineDeploymentId: String? = nil, spec: String, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.lastSuccessfulComponentDeploymentIds = lastSuccessfulComponentDeploymentIds
            self.lastSuccessfulEnvironmentDeploymentId = lastSuccessfulEnvironmentDeploymentId
            self.lastSuccessfulServicePipelineDeploymentId = lastSuccessfulServicePipelineDeploymentId
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case lastSuccessfulComponentDeploymentIds = "lastSuccessfulComponentDeploymentIds"
            case lastSuccessfulEnvironmentDeploymentId = "lastSuccessfulEnvironmentDeploymentId"
            case lastSuccessfulServicePipelineDeploymentId = "lastSuccessfulServicePipelineDeploymentId"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct ServiceInstanceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service instance.
        public let arn: String
        /// The time when the service instance was created.
        public let createdAt: Date
        /// The service instance deployment status.
        public let deploymentStatus: DeploymentStatus
        /// A service instance deployment status message.
        public let deploymentStatusMessage: String?
        /// The name of the environment that the service instance was deployed into.
        public let environmentName: String
        /// The ID of the last attempted deployment of this service instance.
        public let lastAttemptedDeploymentId: String?
        /// The time when a deployment of the service was last attempted.
        public let lastDeploymentAttemptedAt: Date
        /// The time when the service was last deployed successfully.
        public let lastDeploymentSucceededAt: Date
        /// The ID of the last successful deployment of this service instance.
        public let lastSucceededDeploymentId: String?
        /// The name of the service instance.
        public let name: String
        /// The name of the service that the service instance belongs to.
        public let serviceName: String
        /// The service instance template major version.
        public let templateMajorVersion: String
        /// The service instance template minor version.
        public let templateMinorVersion: String
        /// The name of the service template.
        public let templateName: String

        public init(arn: String, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, environmentName: String, lastAttemptedDeploymentId: String? = nil, lastDeploymentAttemptedAt: Date, lastDeploymentSucceededAt: Date, lastSucceededDeploymentId: String? = nil, name: String, serviceName: String, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceName = serviceName
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case environmentName = "environmentName"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case name = "name"
            case serviceName = "serviceName"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct ServicePipeline: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service pipeline.
        public let arn: String
        /// The time when the service pipeline was created.
        public let createdAt: Date
        /// The deployment status of the service pipeline.
        public let deploymentStatus: DeploymentStatus
        /// A service pipeline deployment status message.
        public let deploymentStatusMessage: String?
        /// The ID of the last attempted deployment of this service pipeline.
        public let lastAttemptedDeploymentId: String?
        /// The time when a deployment of the service pipeline was last attempted.
        public let lastDeploymentAttemptedAt: Date
        /// The time when the service pipeline was last deployed successfully.
        public let lastDeploymentSucceededAt: Date
        /// The ID of the last successful deployment of this service pipeline.
        public let lastSucceededDeploymentId: String?
        /// The service spec that was used to create the service pipeline.
        public let spec: String?
        /// The major version of the service template that was used to create the service pipeline.
        public let templateMajorVersion: String
        /// The minor version of the service template that was used to create the service pipeline.
        public let templateMinorVersion: String
        /// The name of the service template that was used to create the service pipeline.
        public let templateName: String

        public init(arn: String, createdAt: Date, deploymentStatus: DeploymentStatus, deploymentStatusMessage: String? = nil, lastAttemptedDeploymentId: String? = nil, lastDeploymentAttemptedAt: Date, lastDeploymentSucceededAt: Date, lastSucceededDeploymentId: String? = nil, spec: String? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case lastAttemptedDeploymentId = "lastAttemptedDeploymentId"
            case lastDeploymentAttemptedAt = "lastDeploymentAttemptedAt"
            case lastDeploymentSucceededAt = "lastDeploymentSucceededAt"
            case lastSucceededDeploymentId = "lastSucceededDeploymentId"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct ServicePipelineState: AWSDecodableShape {
        /// The service spec that was used to create the service pipeline.
        public let spec: String?
        /// The major version of the service template that was used to create the service pipeline.
        public let templateMajorVersion: String
        /// The minor version of the service template that was used to create the service pipeline.
        public let templateMinorVersion: String
        /// The name of the service template that was used to create the service pipeline.
        public let templateName: String

        public init(spec: String? = nil, templateMajorVersion: String, templateMinorVersion: String, templateName: String) {
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
            case templateName = "templateName"
        }
    }

    public struct ServiceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String
        /// The time when the service was created.
        public let createdAt: Date
        /// A description of the service.
        public let description: String?
        /// The time when the service was last modified.
        public let lastModifiedAt: Date
        /// The name of the service.
        public let name: String
        /// The status of the service.
        public let status: ServiceStatus
        /// A service status message.
        public let statusMessage: String?
        /// The name of the service template.
        public let templateName: String

        public init(arn: String, createdAt: Date, description: String? = nil, lastModifiedAt: Date, name: String, status: ServiceStatus, statusMessage: String? = nil, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case templateName = "templateName"
        }
    }

    public struct ServiceSyncBlockerSummary: AWSDecodableShape {
        /// The latest active blockers for the synced service.
        public let latestBlockers: [SyncBlocker]?
        /// The name of the service instance that you want sync your service configuration with.
        public let serviceInstanceName: String?
        /// The name of the service that you want to get the sync blocker summary for. If given a service instance name and a service name, it will return the blockers only applying to the instance that is blocked. If given only a service name, it will return the blockers that apply to all of the instances. In order to get the blockers for a single instance, you will need to make two distinct calls, one to get the sync blocker summary for the service and the other to get the sync blocker for the service instance.
        public let serviceName: String

        public init(latestBlockers: [SyncBlocker]? = nil, serviceInstanceName: String? = nil, serviceName: String) {
            self.latestBlockers = latestBlockers
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case latestBlockers = "latestBlockers"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
        }
    }

    public struct ServiceSyncConfig: AWSDecodableShape {
        /// The name of the code repository branch that holds the service code Proton will sync with.
        public let branch: String
        /// The file path to the service sync configuration file.
        public let filePath: String
        /// The name of the code repository that holds the service code Proton will sync with.
        public let repositoryName: String
        /// The name of the repository provider that holds the repository Proton will sync with.
        public let repositoryProvider: RepositoryProvider
        /// The name of the service that the service instance is added to.
        public let serviceName: String

        public init(branch: String, filePath: String, repositoryName: String, repositoryProvider: RepositoryProvider, serviceName: String) {
            self.branch = branch
            self.filePath = filePath
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case filePath = "filePath"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case serviceName = "serviceName"
        }
    }

    public struct ServiceTemplate: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service template.
        public let arn: String
        /// The time when the service template was created.
        public let createdAt: Date
        /// A description of the service template.
        public let description: String?
        /// The service template name as displayed in the developer interface.
        public let displayName: String?
        /// The customer provided service template encryption key that's used to encrypt data.
        public let encryptionKey: String?
        /// The time when the service template was last modified.
        public let lastModifiedAt: Date
        /// The name of the service template.
        public let name: String
        /// If pipelineProvisioning is true, a service pipeline is included in the service template. Otherwise, a service pipeline isn't included in the service template.
        public let pipelineProvisioning: Provisioning?
        /// The recommended version of the service template.
        public let recommendedVersion: String?

        public init(arn: String, createdAt: Date, description: String? = nil, displayName: String? = nil, encryptionKey: String? = nil, lastModifiedAt: Date, name: String, pipelineProvisioning: Provisioning? = nil, recommendedVersion: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case encryptionKey = "encryptionKey"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case pipelineProvisioning = "pipelineProvisioning"
            case recommendedVersion = "recommendedVersion"
        }
    }

    public struct ServiceTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service template.
        public let arn: String
        /// The time when the service template was created.
        public let createdAt: Date
        /// A description of the service template.
        public let description: String?
        /// The service template name as displayed in the developer interface.
        public let displayName: String?
        /// The time when the service template was last modified.
        public let lastModifiedAt: Date
        /// The name of the service template.
        public let name: String
        /// If pipelineProvisioning is true, a service pipeline is included in the service template, otherwise a service pipeline isn't included in the service template.
        public let pipelineProvisioning: Provisioning?
        /// The recommended version of the service template.
        public let recommendedVersion: String?

        public init(arn: String, createdAt: Date, description: String? = nil, displayName: String? = nil, lastModifiedAt: Date, name: String, pipelineProvisioning: Provisioning? = nil, recommendedVersion: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case pipelineProvisioning = "pipelineProvisioning"
            case recommendedVersion = "recommendedVersion"
        }
    }

    public struct ServiceTemplateVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        public let arn: String
        /// An array of compatible environment template names for the major version of a service template.
        public let compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplate]
        /// The time when the version of a service template was created.
        public let createdAt: Date
        /// A description of the version of a service template.
        public let description: String?
        /// The time when the version of a service template was last modified.
        public let lastModifiedAt: Date
        /// The latest major version that's associated with the version of a service template.
        public let majorVersion: String
        /// The minor version of a service template.
        public let minorVersion: String
        /// The recommended minor version of the service template.
        public let recommendedMinorVersion: String?
        /// The schema of the version of a service template.
        public let schema: String?
        /// The service template version status.
        public let status: TemplateVersionStatus
        /// A service template version status message.
        public let statusMessage: String?
        /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version. For more information about components, see Proton components in the Proton User Guide.
        public let supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]?
        /// The name of the version of a service template.
        public let templateName: String

        public init(arn: String, compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplate], createdAt: Date, description: String? = nil, lastModifiedAt: Date, majorVersion: String, minorVersion: String, recommendedMinorVersion: String? = nil, schema: String? = nil, status: TemplateVersionStatus, statusMessage: String? = nil, supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]? = nil, templateName: String) {
            self.arn = arn
            self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.supportedComponentSources = supportedComponentSources
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case compatibleEnvironmentTemplates = "compatibleEnvironmentTemplates"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case recommendedMinorVersion = "recommendedMinorVersion"
            case schema = "schema"
            case status = "status"
            case statusMessage = "statusMessage"
            case supportedComponentSources = "supportedComponentSources"
            case templateName = "templateName"
        }
    }

    public struct ServiceTemplateVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        public let arn: String
        /// The time when the version of a service template was created.
        public let createdAt: Date
        /// A description of the version of a service template.
        public let description: String?
        /// The time when the version of a service template was last modified.
        public let lastModifiedAt: Date
        /// The latest major version that's associated with the version of a service template.
        public let majorVersion: String
        /// The minor version of a service template.
        public let minorVersion: String
        /// The recommended minor version of the service template.
        public let recommendedMinorVersion: String?
        /// The service template minor version status.
        public let status: TemplateVersionStatus
        /// A service template minor version status message.
        public let statusMessage: String?
        /// The name of the service template.
        public let templateName: String

        public init(arn: String, createdAt: Date, description: String? = nil, lastModifiedAt: Date, majorVersion: String, minorVersion: String, recommendedMinorVersion: String? = nil, status: TemplateVersionStatus, statusMessage: String? = nil, templateName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case lastModifiedAt = "lastModifiedAt"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case recommendedMinorVersion = "recommendedMinorVersion"
            case status = "status"
            case statusMessage = "statusMessage"
            case templateName = "templateName"
        }
    }

    public struct SyncBlocker: AWSDecodableShape {
        /// The contexts for the sync blocker.
        public let contexts: [SyncBlockerContext]?
        /// The time when the sync blocker was created.
        public let createdAt: Date
        /// The reason why the sync blocker was created.
        public let createdReason: String
        /// The ID of the sync blocker.
        public let id: String
        /// The time the sync blocker was resolved.
        public let resolvedAt: Date?
        /// The reason the sync blocker was resolved.
        public let resolvedReason: String?
        /// The status of the sync blocker.
        public let status: BlockerStatus
        /// The type of the sync blocker.
        public let type: BlockerType

        public init(contexts: [SyncBlockerContext]? = nil, createdAt: Date, createdReason: String, id: String, resolvedAt: Date? = nil, resolvedReason: String? = nil, status: BlockerStatus, type: BlockerType) {
            self.contexts = contexts
            self.createdAt = createdAt
            self.createdReason = createdReason
            self.id = id
            self.resolvedAt = resolvedAt
            self.resolvedReason = resolvedReason
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case contexts = "contexts"
            case createdAt = "createdAt"
            case createdReason = "createdReason"
            case id = "id"
            case resolvedAt = "resolvedAt"
            case resolvedReason = "resolvedReason"
            case status = "status"
            case type = "type"
        }
    }

    public struct SyncBlockerContext: AWSDecodableShape {
        /// The key for the sync blocker context.
        public let key: String
        /// The value of the sync blocker context.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the resource tag.
        public let key: String
        /// The value of the resource tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Proton resource to apply customer tags to.
        public let resourceArn: String
        /// A list of customer tags to apply to the Proton resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TemplateSyncConfig: AWSDecodableShape {
        /// The repository branch.
        public let branch: String
        /// The repository name (for example, myrepos/myrepo).
        public let repositoryName: String
        /// The repository provider.
        public let repositoryProvider: RepositoryProvider
        /// A subdirectory path to your template bundle version.
        public let subdirectory: String?
        /// The template name.
        public let templateName: String
        /// The template type.
        public let templateType: TemplateType

        public init(branch: String, repositoryName: String, repositoryProvider: RepositoryProvider, subdirectory: String? = nil, templateName: String, templateType: TemplateType) {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.subdirectory = subdirectory
            self.templateName = templateName
            self.templateType = templateType
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case subdirectory = "subdirectory"
            case templateName = "templateName"
            case templateType = "templateType"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove customer tags from.
        public let resourceArn: String
        /// A list of customer tag keys that indicate the customer tags to be removed from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccountSettingsInput: AWSEncodableShape {
        /// Set to true to remove a configured pipeline repository from the account settings. Don't set this field if you are updating the configured pipeline repository.
        public let deletePipelineProvisioningRepository: Bool?
        /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Proton assumes this role for CodeBuild-based provisioning.
        public let pipelineCodebuildRoleArn: String?
        /// A linked repository for pipeline provisioning. Specify it if you have environments configured for self-managed provisioning with services that include pipelines. A linked repository is a repository that has been registered with Proton. For more information, see CreateRepository. To remove a previously configured repository, set deletePipelineProvisioningRepository to true, and don't set pipelineProvisioningRepository.
        public let pipelineProvisioningRepository: RepositoryBranchInput?
        /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Assumed by Proton for Amazon Web Services-managed provisioning, and by customer-owned automation for self-managed provisioning. To remove a previously configured ARN, specify an empty string.
        public let pipelineServiceRoleArn: String?

        public init(deletePipelineProvisioningRepository: Bool? = nil, pipelineCodebuildRoleArn: String? = nil, pipelineProvisioningRepository: RepositoryBranchInput? = nil, pipelineServiceRoleArn: String? = nil) {
            self.deletePipelineProvisioningRepository = deletePipelineProvisioningRepository
            self.pipelineCodebuildRoleArn = pipelineCodebuildRoleArn
            self.pipelineProvisioningRepository = pipelineProvisioningRepository
            self.pipelineServiceRoleArn = pipelineServiceRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineCodebuildRoleArn, name: "pipelineCodebuildRoleArn", parent: name, max: 2048)
            try self.validate(self.pipelineCodebuildRoleArn, name: "pipelineCodebuildRoleArn", parent: name, pattern: "(^$)|(^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$)")
            try self.pipelineProvisioningRepository?.validate(name: "\(name).pipelineProvisioningRepository")
            try self.validate(self.pipelineServiceRoleArn, name: "pipelineServiceRoleArn", parent: name, max: 2048)
            try self.validate(self.pipelineServiceRoleArn, name: "pipelineServiceRoleArn", parent: name, pattern: "(^$)|(^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$)")
        }

        private enum CodingKeys: String, CodingKey {
            case deletePipelineProvisioningRepository = "deletePipelineProvisioningRepository"
            case pipelineCodebuildRoleArn = "pipelineCodebuildRoleArn"
            case pipelineProvisioningRepository = "pipelineProvisioningRepository"
            case pipelineServiceRoleArn = "pipelineServiceRoleArn"
        }
    }

    public struct UpdateAccountSettingsOutput: AWSDecodableShape {
        /// The Proton pipeline service role and repository data shared across the Amazon Web Services account.
        public let accountSettings: AccountSettings

        public init(accountSettings: AccountSettings) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct UpdateComponentInput: AWSEncodableShape {
        /// The client token for the updated component.
        public let clientToken: String?
        /// The deployment type. It defines the mode for updating a component, as follows:     NONE  In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. You can only specify description in this mode.     CURRENT_VERSION  In this mode, the component is deployed and updated with the new serviceSpec, templateSource, and/or type that you provide. Only requested parameters are updated.
        public let deploymentType: ComponentDeploymentUpdateType
        /// An optional customer-provided description of the component.
        public let description: String?
        /// The name of the component to update.
        public let name: String
        /// The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both serviceInstanceName and serviceName or for neither of them.
        public let serviceInstanceName: String?
        /// The name of the service that serviceInstanceName is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both serviceInstanceName and serviceName or for neither of them.
        public let serviceName: String?
        /// The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.
        public let serviceSpec: String?
        /// A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.  Components support a single IaC file, even if you use Terraform as your template language.
        public let templateFile: String?

        public init(clientToken: String? = UpdateComponentInput.idempotencyToken(), deploymentType: ComponentDeploymentUpdateType, description: String? = nil, name: String, serviceInstanceName: String? = nil, serviceName: String? = nil, serviceSpec: String? = nil, templateFile: String? = nil) {
            self.clientToken = clientToken
            self.deploymentType = deploymentType
            self.description = description
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
            self.templateFile = templateFile
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, max: 100)
            try self.validate(self.serviceInstanceName, name: "serviceInstanceName", parent: name, pattern: "(^$)|^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "(^$)|^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceSpec, name: "serviceSpec", parent: name, max: 51200)
            try self.validate(self.serviceSpec, name: "serviceSpec", parent: name, min: 1)
            try self.validate(self.templateFile, name: "templateFile", parent: name, max: 51200)
            try self.validate(self.templateFile, name: "templateFile", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case deploymentType = "deploymentType"
            case description = "description"
            case name = "name"
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case serviceSpec = "serviceSpec"
            case templateFile = "templateFile"
        }
    }

    public struct UpdateComponentOutput: AWSDecodableShape {
        /// The detailed data of the updated component.
        public let component: Component

        public init(component: Component) {
            self.component = component
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
        }
    }

    public struct UpdateEnvironmentAccountConnectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// The ID of the environment account connection to update.
        public let id: String
        /// The Amazon Resource Name (ARN) of the IAM service role that's associated with the environment account connection to update.
        public let roleArn: String?

        public init(codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, id: String, roleArn: String? = nil) {
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.id = id
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, max: 2048)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, min: 1)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, max: 2048)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, min: 1)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case id = "id"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateEnvironmentAccountConnectionOutput: AWSDecodableShape {
        /// The environment account connection detail data that's returned by Proton.
        public let environmentAccountConnection: EnvironmentAccountConnection

        public init(environmentAccountConnection: EnvironmentAccountConnection) {
            self.environmentAccountConnection = environmentAccountConnection
        }

        private enum CodingKeys: String, CodingKey {
            case environmentAccountConnection = "environmentAccountConnection"
        }
    }

    public struct UpdateEnvironmentInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf.
        public let codebuildRoleArn: String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see Proton components in the Proton User Guide.
        public let componentRoleArn: String?
        /// There are four modes for updating an environment. The deploymentType field defines the mode.     NONE  In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated.     CURRENT_VERSION  In this mode, the environment is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include major or minor version parameters when you use this deployment-type.     MINOR_VERSION  In this mode, the environment is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use.     MAJOR_VERSION  In this mode, the environment is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can also specify a different major version that is higher than the major version in use and a minor version (optional).
        public let deploymentType: DeploymentUpdateType
        /// A description of the environment update.
        public let description: String?
        /// The ID of the environment account connection. You can only update to a new environment account connection if it was created in the same environment account that the current environment account connection was created in and is associated with the current environment.
        public let environmentAccountConnectionId: String?
        /// The name of the environment to update.
        public let name: String
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make API calls to other services your behalf.
        public let protonServiceRoleArn: String?
        /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see CreateRepository.
        public let provisioningRepository: RepositoryBranchInput?
        /// The formatted specification that defines the update.
        public let spec: String?
        /// The major version of the environment to update.
        public let templateMajorVersion: String?
        /// The minor version of the environment to update.
        public let templateMinorVersion: String?

        public init(codebuildRoleArn: String? = nil, componentRoleArn: String? = nil, deploymentType: DeploymentUpdateType, description: String? = nil, environmentAccountConnectionId: String? = nil, name: String, protonServiceRoleArn: String? = nil, provisioningRepository: RepositoryBranchInput? = nil, spec: String? = nil, templateMajorVersion: String? = nil, templateMinorVersion: String? = nil) {
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.deploymentType = deploymentType
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioningRepository = provisioningRepository
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, max: 2048)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, min: 1)
            try self.validate(self.codebuildRoleArn, name: "codebuildRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, max: 2048)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, min: 1)
            try self.validate(self.componentRoleArn, name: "componentRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role/([\\w+=,.@-]{1,512}[/:])*([\\w+=,.@-]{1,64})$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.environmentAccountConnectionId, name: "environmentAccountConnectionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, max: 200)
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, min: 1)
            try self.validate(self.protonServiceRoleArn, name: "protonServiceRoleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):[a-zA-Z0-9-]+:[a-zA-Z0-9-]*:\\d{12}:([\\w+=,.@-]+[/:])*[\\w+=,.@-]+$")
            try self.provisioningRepository?.validate(name: "\(name).provisioningRepository")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
        }

        private enum CodingKeys: String, CodingKey {
            case codebuildRoleArn = "codebuildRoleArn"
            case componentRoleArn = "componentRoleArn"
            case deploymentType = "deploymentType"
            case description = "description"
            case environmentAccountConnectionId = "environmentAccountConnectionId"
            case name = "name"
            case protonServiceRoleArn = "protonServiceRoleArn"
            case provisioningRepository = "provisioningRepository"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
        }
    }

    public struct UpdateEnvironmentOutput: AWSDecodableShape {
        /// The environment detail data that's returned by Proton.
        public let environment: Environment

        public init(environment: Environment) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct UpdateEnvironmentTemplateInput: AWSEncodableShape {
        /// A description of the environment template update.
        public let description: String?
        /// The name of the environment template to update as displayed in the developer interface.
        public let displayName: String?
        /// The name of the environment template to update.
        public let name: String

        public init(description: String? = nil, displayName: String? = nil, name: String) {
            self.description = description
            self.displayName = displayName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case name = "name"
        }
    }

    public struct UpdateEnvironmentTemplateOutput: AWSDecodableShape {
        /// The environment template detail data that's returned by Proton.
        public let environmentTemplate: EnvironmentTemplate

        public init(environmentTemplate: EnvironmentTemplate) {
            self.environmentTemplate = environmentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplate = "environmentTemplate"
        }
    }

    public struct UpdateEnvironmentTemplateVersionInput: AWSEncodableShape {
        /// A description of environment template version to update.
        public let description: String?
        /// To update a major version of an environment template, include major Version.
        public let majorVersion: String
        /// To update a minor version of an environment template, include minorVersion.
        public let minorVersion: String
        /// The status of the environment template minor version to update.
        public let status: TemplateVersionStatus?
        /// The name of the environment template.
        public let templateName: String

        public init(description: String? = nil, majorVersion: String, minorVersion: String, status: TemplateVersionStatus? = nil, templateName: String) {
            self.description = description
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.status = status
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case status = "status"
            case templateName = "templateName"
        }
    }

    public struct UpdateEnvironmentTemplateVersionOutput: AWSDecodableShape {
        /// The environment template version detail data that's returned by Proton.
        public let environmentTemplateVersion: EnvironmentTemplateVersion

        public init(environmentTemplateVersion: EnvironmentTemplateVersion) {
            self.environmentTemplateVersion = environmentTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case environmentTemplateVersion = "environmentTemplateVersion"
        }
    }

    public struct UpdateServiceInput: AWSEncodableShape {
        /// The edited service description.
        public let description: String?
        /// The name of the service to edit.
        public let name: String
        /// Lists the service instances to add and the existing service instances to remain. Omit the existing service instances to delete from the list. Don't include edits to the existing service instances or pipeline. For more information, see Edit a service in the Proton User Guide.
        public let spec: String?

        public init(description: String? = nil, name: String, spec: String? = nil) {
            self.description = description
            self.name = name
            self.spec = spec
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case spec = "spec"
        }
    }

    public struct UpdateServiceInstanceInput: AWSEncodableShape {
        /// The client token of the service instance to update.
        public let clientToken: String?
        /// The deployment type. It defines the mode for updating a service instance, as follows:     NONE  In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated.     CURRENT_VERSION  In this mode, the service instance is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include major or minor version parameters when you use this deployment type.     MINOR_VERSION  In this mode, the service instance is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use.     MAJOR_VERSION  In this mode, the service instance is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can specify a different major version that's higher than the major version in use and a minor version.
        public let deploymentType: DeploymentUpdateType
        /// The name of the service instance to update.
        public let name: String
        /// The name of the service that the service instance belongs to.
        public let serviceName: String
        /// The formatted specification that defines the service instance update.
        public let spec: String?
        /// The major version of the service template to update.
        public let templateMajorVersion: String?
        /// The minor version of the service template to update.
        public let templateMinorVersion: String?

        public init(clientToken: String? = UpdateServiceInstanceInput.idempotencyToken(), deploymentType: DeploymentUpdateType, name: String, serviceName: String, spec: String? = nil, templateMajorVersion: String? = nil, templateMinorVersion: String? = nil) {
            self.clientToken = clientToken
            self.deploymentType = deploymentType
            self.name = name
            self.serviceName = serviceName
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case deploymentType = "deploymentType"
            case name = "name"
            case serviceName = "serviceName"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
        }
    }

    public struct UpdateServiceInstanceOutput: AWSDecodableShape {
        /// The service instance summary data that's returned by Proton.
        public let serviceInstance: ServiceInstance

        public init(serviceInstance: ServiceInstance) {
            self.serviceInstance = serviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstance = "serviceInstance"
        }
    }

    public struct UpdateServiceOutput: AWSDecodableShape {
        /// The service detail data that's returned by Proton.
        public let service: Service

        public init(service: Service) {
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case service = "service"
        }
    }

    public struct UpdateServicePipelineInput: AWSEncodableShape {
        /// The deployment type. There are four modes for updating a service pipeline. The deploymentType field defines the mode.     NONE  In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated.     CURRENT_VERSION  In this mode, the service pipeline is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include major or minor version parameters when you use this deployment-type.     MINOR_VERSION  In this mode, the service pipeline is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can specify a different minor version of the current major version in use.     MAJOR_VERSION  In this mode, the service pipeline is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can specify a different major version that's higher than the major version in use and a minor version.
        public let deploymentType: DeploymentUpdateType
        /// The name of the service to that the pipeline is associated with.
        public let serviceName: String
        /// The spec for the service pipeline to update.
        public let spec: String
        /// The major version of the service template that was used to create the service that the pipeline is associated with.
        public let templateMajorVersion: String?
        /// The minor version of the service template that was used to create the service that the pipeline is associated with.
        public let templateMinorVersion: String?

        public init(deploymentType: DeploymentUpdateType, serviceName: String, spec: String, templateMajorVersion: String? = nil, templateMinorVersion: String? = nil) {
            self.deploymentType = deploymentType
            self.serviceName = serviceName
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
            try self.validate(self.spec, name: "spec", parent: name, max: 51200)
            try self.validate(self.spec, name: "spec", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, max: 20)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, min: 1)
            try self.validate(self.templateMajorVersion, name: "templateMajorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, max: 20)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, min: 1)
            try self.validate(self.templateMinorVersion, name: "templateMinorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentType = "deploymentType"
            case serviceName = "serviceName"
            case spec = "spec"
            case templateMajorVersion = "templateMajorVersion"
            case templateMinorVersion = "templateMinorVersion"
        }
    }

    public struct UpdateServicePipelineOutput: AWSDecodableShape {
        /// The pipeline details that are returned by Proton.
        public let pipeline: ServicePipeline

        public init(pipeline: ServicePipeline) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "pipeline"
        }
    }

    public struct UpdateServiceSyncBlockerInput: AWSEncodableShape {
        /// The ID of the service sync blocker.
        public let id: String
        /// The reason the service sync blocker was resolved.
        public let resolvedReason: String

        public init(id: String, resolvedReason: String) {
            self.id = id
            self.resolvedReason = resolvedReason
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case resolvedReason = "resolvedReason"
        }
    }

    public struct UpdateServiceSyncBlockerOutput: AWSDecodableShape {
        /// The name of the service instance that you want to update the service sync blocker for.
        public let serviceInstanceName: String?
        /// The name of the service that you want to update the service sync blocker for.
        public let serviceName: String
        /// The detailed data on the service sync blocker that was updated.
        public let serviceSyncBlocker: SyncBlocker

        public init(serviceInstanceName: String? = nil, serviceName: String, serviceSyncBlocker: SyncBlocker) {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSyncBlocker = serviceSyncBlocker
        }

        private enum CodingKeys: String, CodingKey {
            case serviceInstanceName = "serviceInstanceName"
            case serviceName = "serviceName"
            case serviceSyncBlocker = "serviceSyncBlocker"
        }
    }

    public struct UpdateServiceSyncConfigInput: AWSEncodableShape {
        /// The name of the code repository branch where the Proton Ops file is found.
        public let branch: String
        /// The path to the Proton Ops file.
        public let filePath: String
        /// The name of the repository where the Proton Ops file is found.
        public let repositoryName: String
        /// The name of the repository provider where the Proton Ops file is found.
        public let repositoryProvider: RepositoryProvider
        /// The name of the service the Proton Ops file is for.
        public let serviceName: String

        public init(branch: String, filePath: String, repositoryName: String, repositoryProvider: RepositoryProvider, serviceName: String) {
            self.branch = branch
            self.filePath = filePath
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.filePath, name: "filePath", parent: name, max: 4096)
            try self.validate(self.filePath, name: "filePath", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 100)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case filePath = "filePath"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case serviceName = "serviceName"
        }
    }

    public struct UpdateServiceSyncConfigOutput: AWSDecodableShape {
        /// The detailed data of the Proton Ops file.
        public let serviceSyncConfig: ServiceSyncConfig?

        public init(serviceSyncConfig: ServiceSyncConfig? = nil) {
            self.serviceSyncConfig = serviceSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSyncConfig = "serviceSyncConfig"
        }
    }

    public struct UpdateServiceTemplateInput: AWSEncodableShape {
        /// A description of the service template update.
        public let description: String?
        /// The name of the service template to update that's displayed in the developer interface.
        public let displayName: String?
        /// The name of the service template to update.
        public let name: String

        public init(description: String? = nil, displayName: String? = nil, name: String) {
            self.description = description
            self.displayName = displayName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case name = "name"
        }
    }

    public struct UpdateServiceTemplateOutput: AWSDecodableShape {
        /// The service template detail data that's returned by Proton.
        public let serviceTemplate: ServiceTemplate

        public init(serviceTemplate: ServiceTemplate) {
            self.serviceTemplate = serviceTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplate = "serviceTemplate"
        }
    }

    public struct UpdateServiceTemplateVersionInput: AWSEncodableShape {
        /// An array of environment template objects that are compatible with this service template version. A service instance based on this service template version can run in environments based on compatible templates.
        public let compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplateInput]?
        /// A description of a service template version to update.
        public let description: String?
        /// To update a major version of a service template, include major Version.
        public let majorVersion: String
        /// To update a minor version of a service template, include minorVersion.
        public let minorVersion: String
        /// The status of the service template minor version to update.
        public let status: TemplateVersionStatus?
        /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version.  A change to supportedComponentSources doesn't impact existing component attachments to instances based on this template version. A change only affects later associations.  For more information about components, see Proton components in the Proton User Guide.
        public let supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]?
        /// The name of the service template.
        public let templateName: String

        public init(compatibleEnvironmentTemplates: [CompatibleEnvironmentTemplateInput]? = nil, description: String? = nil, majorVersion: String, minorVersion: String, status: TemplateVersionStatus? = nil, supportedComponentSources: [ServiceTemplateSupportedComponentSourceType]? = nil, templateName: String) {
            self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
            self.description = description
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.status = status
            self.supportedComponentSources = supportedComponentSources
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.compatibleEnvironmentTemplates?.forEach {
                try $0.validate(name: "\(name).compatibleEnvironmentTemplates[]")
            }
            try self.validate(self.compatibleEnvironmentTemplates, name: "compatibleEnvironmentTemplates", parent: name, max: 10)
            try self.validate(self.compatibleEnvironmentTemplates, name: "compatibleEnvironmentTemplates", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, max: 20)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, min: 1)
            try self.validate(self.majorVersion, name: "majorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, max: 20)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, min: 1)
            try self.validate(self.minorVersion, name: "minorVersion", parent: name, pattern: "^(0|([1-9]{1}\\d*))$")
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleEnvironmentTemplates = "compatibleEnvironmentTemplates"
            case description = "description"
            case majorVersion = "majorVersion"
            case minorVersion = "minorVersion"
            case status = "status"
            case supportedComponentSources = "supportedComponentSources"
            case templateName = "templateName"
        }
    }

    public struct UpdateServiceTemplateVersionOutput: AWSDecodableShape {
        /// The service template version detail data that's returned by Proton.
        public let serviceTemplateVersion: ServiceTemplateVersion

        public init(serviceTemplateVersion: ServiceTemplateVersion) {
            self.serviceTemplateVersion = serviceTemplateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case serviceTemplateVersion = "serviceTemplateVersion"
        }
    }

    public struct UpdateTemplateSyncConfigInput: AWSEncodableShape {
        /// The repository branch for your template.
        public let branch: String
        /// The repository name (for example, myrepos/myrepo).
        public let repositoryName: String
        /// The repository provider.
        public let repositoryProvider: RepositoryProvider
        /// A subdirectory path to your template bundle version. When included, limits the template bundle search to this repository directory.
        public let subdirectory: String?
        /// The synced template name.
        public let templateName: String
        /// The synced template type.
        public let templateType: TemplateType

        public init(branch: String, repositoryName: String, repositoryProvider: RepositoryProvider, subdirectory: String? = nil, templateName: String, templateType: TemplateType) {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.subdirectory = subdirectory
            self.templateName = templateName
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 200)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9_.-].*/[A-Za-z0-9_.-].*")
            try self.validate(self.subdirectory, name: "subdirectory", parent: name, max: 4096)
            try self.validate(self.subdirectory, name: "subdirectory", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, max: 100)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
            try self.validate(self.templateName, name: "templateName", parent: name, pattern: "^[0-9A-Za-z]+[0-9A-Za-z_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case repositoryName = "repositoryName"
            case repositoryProvider = "repositoryProvider"
            case subdirectory = "subdirectory"
            case templateName = "templateName"
            case templateType = "templateType"
        }
    }

    public struct UpdateTemplateSyncConfigOutput: AWSDecodableShape {
        /// The template sync configuration detail data that's returned by Proton.
        public let templateSyncConfig: TemplateSyncConfig?

        public init(templateSyncConfig: TemplateSyncConfig? = nil) {
            self.templateSyncConfig = templateSyncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case templateSyncConfig = "templateSyncConfig"
        }
    }

    public struct TemplateVersionSourceInput: AWSEncodableShape {
        /// An S3 source object that includes the template bundle S3 path and name for a template minor version.
        public let s3: S3ObjectSource?

        public init(s3: S3ObjectSource? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }
}

// MARK: - Errors

/// Error enum for Proton
public struct ProtonErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Proton
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// There isn't sufficient access for performing this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request couldn't be made due to a conflicting operation or resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request failed to register with the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource wasn't found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A quota was exceeded. For more information, see Proton Quotas in the Proton User Guide.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input is invalid or an out-of-range value was supplied for the input parameter.
    public static var validationException: Self { .init(.validationException) }
}

extension ProtonErrorType: Equatable {
    public static func == (lhs: ProtonErrorType, rhs: ProtonErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ProtonErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
