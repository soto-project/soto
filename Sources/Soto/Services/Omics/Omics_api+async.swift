//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.5.2) && canImport(_Concurrency)

import SotoCore

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    // MARK: Async API Calls

    /// Deletes one or more read sets.
    public func batchDeleteReadSet(_ input: BatchDeleteReadSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BatchDeleteReadSetResponse {
        return try await self.client.execute(operation: "BatchDeleteReadSet", path: "/sequencestore/{sequenceStoreId}/readset/batch/delete", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Cancels an annotation import job.
    public func cancelAnnotationImportJob(_ input: CancelAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CancelAnnotationImportResponse {
        return try await self.client.execute(operation: "CancelAnnotationImportJob", path: "/import/annotation/{jobId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Cancels a run.
    public func cancelRun(_ input: CancelRunRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "CancelRun", path: "/run/{id}/cancel", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Cancels a variant import job.
    public func cancelVariantImportJob(_ input: CancelVariantImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CancelVariantImportResponse {
        return try await self.client.execute(operation: "CancelVariantImportJob", path: "/import/variant/{jobId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Creates an annotation store.
    public func createAnnotationStore(_ input: CreateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateAnnotationStoreResponse {
        return try await self.client.execute(operation: "CreateAnnotationStore", path: "/annotationStore", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Creates a reference store.
    public func createReferenceStore(_ input: CreateReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateReferenceStoreResponse {
        return try await self.client.execute(operation: "CreateReferenceStore", path: "/referencestore", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Creates a run group.
    public func createRunGroup(_ input: CreateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateRunGroupResponse {
        return try await self.client.execute(operation: "CreateRunGroup", path: "/runGroup", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Creates a sequence store.
    public func createSequenceStore(_ input: CreateSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateSequenceStoreResponse {
        return try await self.client.execute(operation: "CreateSequenceStore", path: "/sequencestore", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Creates a variant store.
    public func createVariantStore(_ input: CreateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateVariantStoreResponse {
        return try await self.client.execute(operation: "CreateVariantStore", path: "/variantStore", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Creates a workflow.
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateWorkflowResponse {
        return try await self.client.execute(operation: "CreateWorkflow", path: "/workflow", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Deletes an annotation store.
    public func deleteAnnotationStore(_ input: DeleteAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteAnnotationStoreResponse {
        return try await self.client.execute(operation: "DeleteAnnotationStore", path: "/annotationStore/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Deletes a genome reference.
    public func deleteReference(_ input: DeleteReferenceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteReferenceResponse {
        return try await self.client.execute(operation: "DeleteReference", path: "/referencestore/{referenceStoreId}/reference/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Deletes a genome reference store.
    public func deleteReferenceStore(_ input: DeleteReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteReferenceStoreResponse {
        return try await self.client.execute(operation: "DeleteReferenceStore", path: "/referencestore/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Deletes a workflow run.
    public func deleteRun(_ input: DeleteRunRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteRun", path: "/run/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Deletes a workflow run group.
    public func deleteRunGroup(_ input: DeleteRunGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteRunGroup", path: "/runGroup/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Deletes a sequence store.
    public func deleteSequenceStore(_ input: DeleteSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteSequenceStoreResponse {
        return try await self.client.execute(operation: "DeleteSequenceStore", path: "/sequencestore/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Deletes a variant store.
    public func deleteVariantStore(_ input: DeleteVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteVariantStoreResponse {
        return try await self.client.execute(operation: "DeleteVariantStore", path: "/variantStore/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Deletes a workflow.
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteWorkflow", path: "/workflow/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Gets information about an annotation import job.
    public func getAnnotationImportJob(_ input: GetAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetAnnotationImportResponse {
        return try await self.client.execute(operation: "GetAnnotationImportJob", path: "/import/annotation/{jobId}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Gets information about an annotation store.
    public func getAnnotationStore(_ input: GetAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetAnnotationStoreResponse {
        return try await self.client.execute(operation: "GetAnnotationStore", path: "/annotationStore/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Gets a file from a read set.
    public func getReadSet(_ input: GetReadSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReadSetResponse {
        return try await self.client.execute(operation: "GetReadSet", path: "/sequencestore/{sequenceStoreId}/readset/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a read set activation job.
    public func getReadSetActivationJob(_ input: GetReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReadSetActivationJobResponse {
        return try await self.client.execute(operation: "GetReadSetActivationJob", path: "/sequencestore/{sequenceStoreId}/activationjob/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a read set export job.
    public func getReadSetExportJob(_ input: GetReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReadSetExportJobResponse {
        return try await self.client.execute(operation: "GetReadSetExportJob", path: "/sequencestore/{sequenceStoreId}/exportjob/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a read set import job.
    public func getReadSetImportJob(_ input: GetReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReadSetImportJobResponse {
        return try await self.client.execute(operation: "GetReadSetImportJob", path: "/sequencestore/{sequenceStoreId}/importjob/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets details about a read set.
    public func getReadSetMetadata(_ input: GetReadSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReadSetMetadataResponse {
        return try await self.client.execute(operation: "GetReadSetMetadata", path: "/sequencestore/{sequenceStoreId}/readset/{id}/metadata", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets a reference file.
    public func getReference(_ input: GetReferenceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReferenceResponse {
        return try await self.client.execute(operation: "GetReference", path: "/referencestore/{referenceStoreId}/reference/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a reference import job.
    public func getReferenceImportJob(_ input: GetReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReferenceImportJobResponse {
        return try await self.client.execute(operation: "GetReferenceImportJob", path: "/referencestore/{referenceStoreId}/importjob/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a genome reference's metadata.
    public func getReferenceMetadata(_ input: GetReferenceMetadataRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReferenceMetadataResponse {
        return try await self.client.execute(operation: "GetReferenceMetadata", path: "/referencestore/{referenceStoreId}/reference/{id}/metadata", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a reference store.
    public func getReferenceStore(_ input: GetReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetReferenceStoreResponse {
        return try await self.client.execute(operation: "GetReferenceStore", path: "/referencestore/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a workflow run.
    public func getRun(_ input: GetRunRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetRunResponse {
        return try await self.client.execute(operation: "GetRun", path: "/run/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Gets information about a workflow run group.
    public func getRunGroup(_ input: GetRunGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetRunGroupResponse {
        return try await self.client.execute(operation: "GetRunGroup", path: "/runGroup/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Gets information about a workflow run task.
    public func getRunTask(_ input: GetRunTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetRunTaskResponse {
        return try await self.client.execute(operation: "GetRunTask", path: "/run/{id}/task/{taskId}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Gets information about a sequence store.
    public func getSequenceStore(_ input: GetSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetSequenceStoreResponse {
        return try await self.client.execute(operation: "GetSequenceStore", path: "/sequencestore/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Gets information about a variant import job.
    public func getVariantImportJob(_ input: GetVariantImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetVariantImportResponse {
        return try await self.client.execute(operation: "GetVariantImportJob", path: "/import/variant/{jobId}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Gets information about a variant store.
    public func getVariantStore(_ input: GetVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetVariantStoreResponse {
        return try await self.client.execute(operation: "GetVariantStore", path: "/variantStore/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Gets information about a workflow.
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetWorkflowResponse {
        return try await self.client.execute(operation: "GetWorkflow", path: "/workflow/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of annotation import jobs.
    public func listAnnotationImportJobs(_ input: ListAnnotationImportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListAnnotationImportJobsResponse {
        return try await self.client.execute(operation: "ListAnnotationImportJobs", path: "/import/annotations", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of annotation stores.
    public func listAnnotationStores(_ input: ListAnnotationStoresRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListAnnotationStoresResponse {
        return try await self.client.execute(operation: "ListAnnotationStores", path: "/annotationStores", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of read set activation jobs.
    public func listReadSetActivationJobs(_ input: ListReadSetActivationJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReadSetActivationJobsResponse {
        return try await self.client.execute(operation: "ListReadSetActivationJobs", path: "/sequencestore/{sequenceStoreId}/activationjobs", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of read set export jobs.
    public func listReadSetExportJobs(_ input: ListReadSetExportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReadSetExportJobsResponse {
        return try await self.client.execute(operation: "ListReadSetExportJobs", path: "/sequencestore/{sequenceStoreId}/exportjobs", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of read set import jobs.
    public func listReadSetImportJobs(_ input: ListReadSetImportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReadSetImportJobsResponse {
        return try await self.client.execute(operation: "ListReadSetImportJobs", path: "/sequencestore/{sequenceStoreId}/importjobs", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of read sets.
    public func listReadSets(_ input: ListReadSetsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReadSetsResponse {
        return try await self.client.execute(operation: "ListReadSets", path: "/sequencestore/{sequenceStoreId}/readsets", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of reference import jobs.
    public func listReferenceImportJobs(_ input: ListReferenceImportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReferenceImportJobsResponse {
        return try await self.client.execute(operation: "ListReferenceImportJobs", path: "/referencestore/{referenceStoreId}/importjobs", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of reference stores.
    public func listReferenceStores(_ input: ListReferenceStoresRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReferenceStoresResponse {
        return try await self.client.execute(operation: "ListReferenceStores", path: "/referencestores", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of references.
    public func listReferences(_ input: ListReferencesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListReferencesResponse {
        return try await self.client.execute(operation: "ListReferences", path: "/referencestore/{referenceStoreId}/references", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of run groups.
    public func listRunGroups(_ input: ListRunGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListRunGroupsResponse {
        return try await self.client.execute(operation: "ListRunGroups", path: "/runGroup", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of tasks for a run.
    public func listRunTasks(_ input: ListRunTasksRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListRunTasksResponse {
        return try await self.client.execute(operation: "ListRunTasks", path: "/run/{id}/task", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of runs.
    public func listRuns(_ input: ListRunsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListRunsResponse {
        return try await self.client.execute(operation: "ListRuns", path: "/run", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of sequence stores.
    public func listSequenceStores(_ input: ListSequenceStoresRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListSequenceStoresResponse {
        return try await self.client.execute(operation: "ListSequenceStores", path: "/sequencestores", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of tags for a resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "tags-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of variant import jobs.
    public func listVariantImportJobs(_ input: ListVariantImportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListVariantImportJobsResponse {
        return try await self.client.execute(operation: "ListVariantImportJobs", path: "/import/variants", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of variant stores.
    public func listVariantStores(_ input: ListVariantStoresRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListVariantStoresResponse {
        return try await self.client.execute(operation: "ListVariantStores", path: "/variantStores", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Retrieves a list of workflows.
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListWorkflowsResponse {
        return try await self.client.execute(operation: "ListWorkflows", path: "/workflow", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Starts an annotation import job.
    public func startAnnotationImportJob(_ input: StartAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartAnnotationImportResponse {
        return try await self.client.execute(operation: "StartAnnotationImportJob", path: "/import/annotation", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Starts a read set activation job.
    public func startReadSetActivationJob(_ input: StartReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartReadSetActivationJobResponse {
        return try await self.client.execute(operation: "StartReadSetActivationJob", path: "/sequencestore/{sequenceStoreId}/activationjob", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Starts a read set export job.
    public func startReadSetExportJob(_ input: StartReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartReadSetExportJobResponse {
        return try await self.client.execute(operation: "StartReadSetExportJob", path: "/sequencestore/{sequenceStoreId}/exportjob", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Starts a read set import job.
    public func startReadSetImportJob(_ input: StartReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartReadSetImportJobResponse {
        return try await self.client.execute(operation: "StartReadSetImportJob", path: "/sequencestore/{sequenceStoreId}/importjob", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Starts a reference import job.
    public func startReferenceImportJob(_ input: StartReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartReferenceImportJobResponse {
        return try await self.client.execute(operation: "StartReferenceImportJob", path: "/referencestore/{referenceStoreId}/importjob", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "control-storage-", logger: logger, on: eventLoop)
    }

    /// Starts a run.
    public func startRun(_ input: StartRunRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartRunResponse {
        return try await self.client.execute(operation: "StartRun", path: "/run", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Starts a variant import job.
    public func startVariantImportJob(_ input: StartVariantImportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> StartVariantImportResponse {
        return try await self.client.execute(operation: "StartVariantImportJob", path: "/import/variant", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Tags a resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> TagResourceResponse {
        return try await self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "tags-", logger: logger, on: eventLoop)
    }

    /// Removes tags from a resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UntagResourceResponse {
        return try await self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, hostPrefix: "tags-", logger: logger, on: eventLoop)
    }

    /// Updates an annotation store.
    public func updateAnnotationStore(_ input: UpdateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateAnnotationStoreResponse {
        return try await self.client.execute(operation: "UpdateAnnotationStore", path: "/annotationStore/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Updates a run group.
    public func updateRunGroup(_ input: UpdateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "UpdateRunGroup", path: "/runGroup/{id}", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    /// Updates a variant store.
    public func updateVariantStore(_ input: UpdateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateVariantStoreResponse {
        return try await self.client.execute(operation: "UpdateVariantStore", path: "/variantStore/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "analytics-", logger: logger, on: eventLoop)
    }

    /// Updates a workflow.
    public func updateWorkflow(_ input: UpdateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "UpdateWorkflow", path: "/workflow/{id}", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "workflows-", logger: logger, on: eventLoop)
    }

    // MARK: Streaming Async API Calls

    /// Gets a file from a read set.
    public func getReadSetStreaming(_ input: GetReadSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil, _ stream: @escaping (ByteBuffer, EventLoop) -> EventLoopFuture<Void>) async throws -> GetReadSetResponse {
        return try await self.client.execute(operation: "GetReadSet", path: "/sequencestore/{sequenceStoreId}/readset/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "storage-", logger: logger, on: eventLoop, stream: stream)
    }

    /// Gets a reference file.
    public func getReferenceStreaming(_ input: GetReferenceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil, _ stream: @escaping (ByteBuffer, EventLoop) -> EventLoopFuture<Void>) async throws -> GetReferenceResponse {
        return try await self.client.execute(operation: "GetReference", path: "/referencestore/{referenceStoreId}/reference/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, hostPrefix: "storage-", logger: logger, on: eventLoop, stream: stream)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    ///  Retrieves a list of annotation import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listAnnotationImportJobsPaginator(
        _ input: ListAnnotationImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListAnnotationImportJobsRequest, ListAnnotationImportJobsResponse> {
        return .init(
            input: input,
            command: self.listAnnotationImportJobs,
            inputKey: \ListAnnotationImportJobsRequest.nextToken,
            outputKey: \ListAnnotationImportJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of annotation stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listAnnotationStoresPaginator(
        _ input: ListAnnotationStoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoresRequest, ListAnnotationStoresResponse> {
        return .init(
            input: input,
            command: self.listAnnotationStores,
            inputKey: \ListAnnotationStoresRequest.nextToken,
            outputKey: \ListAnnotationStoresResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of read set activation jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReadSetActivationJobsPaginator(
        _ input: ListReadSetActivationJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReadSetActivationJobsRequest, ListReadSetActivationJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetActivationJobs,
            inputKey: \ListReadSetActivationJobsRequest.nextToken,
            outputKey: \ListReadSetActivationJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of read set export jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReadSetExportJobsPaginator(
        _ input: ListReadSetExportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReadSetExportJobsRequest, ListReadSetExportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetExportJobs,
            inputKey: \ListReadSetExportJobsRequest.nextToken,
            outputKey: \ListReadSetExportJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of read set import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReadSetImportJobsPaginator(
        _ input: ListReadSetImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReadSetImportJobsRequest, ListReadSetImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetImportJobs,
            inputKey: \ListReadSetImportJobsRequest.nextToken,
            outputKey: \ListReadSetImportJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of read sets.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReadSetsPaginator(
        _ input: ListReadSetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReadSetsRequest, ListReadSetsResponse> {
        return .init(
            input: input,
            command: self.listReadSets,
            inputKey: \ListReadSetsRequest.nextToken,
            outputKey: \ListReadSetsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of reference import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReferenceImportJobsPaginator(
        _ input: ListReferenceImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReferenceImportJobsRequest, ListReferenceImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReferenceImportJobs,
            inputKey: \ListReferenceImportJobsRequest.nextToken,
            outputKey: \ListReferenceImportJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of reference stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReferenceStoresPaginator(
        _ input: ListReferenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReferenceStoresRequest, ListReferenceStoresResponse> {
        return .init(
            input: input,
            command: self.listReferenceStores,
            inputKey: \ListReferenceStoresRequest.nextToken,
            outputKey: \ListReferenceStoresResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of references.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listReferencesPaginator(
        _ input: ListReferencesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListReferencesRequest, ListReferencesResponse> {
        return .init(
            input: input,
            command: self.listReferences,
            inputKey: \ListReferencesRequest.nextToken,
            outputKey: \ListReferencesResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of run groups.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listRunGroupsPaginator(
        _ input: ListRunGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListRunGroupsRequest, ListRunGroupsResponse> {
        return .init(
            input: input,
            command: self.listRunGroups,
            inputKey: \ListRunGroupsRequest.startingToken,
            outputKey: \ListRunGroupsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of tasks for a run.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listRunTasksPaginator(
        _ input: ListRunTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListRunTasksRequest, ListRunTasksResponse> {
        return .init(
            input: input,
            command: self.listRunTasks,
            inputKey: \ListRunTasksRequest.startingToken,
            outputKey: \ListRunTasksResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of runs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listRunsPaginator(
        _ input: ListRunsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListRunsRequest, ListRunsResponse> {
        return .init(
            input: input,
            command: self.listRuns,
            inputKey: \ListRunsRequest.startingToken,
            outputKey: \ListRunsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of sequence stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listSequenceStoresPaginator(
        _ input: ListSequenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListSequenceStoresRequest, ListSequenceStoresResponse> {
        return .init(
            input: input,
            command: self.listSequenceStores,
            inputKey: \ListSequenceStoresRequest.nextToken,
            outputKey: \ListSequenceStoresResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of variant import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listVariantImportJobsPaginator(
        _ input: ListVariantImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListVariantImportJobsRequest, ListVariantImportJobsResponse> {
        return .init(
            input: input,
            command: self.listVariantImportJobs,
            inputKey: \ListVariantImportJobsRequest.nextToken,
            outputKey: \ListVariantImportJobsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of variant stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listVariantStoresPaginator(
        _ input: ListVariantStoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListVariantStoresRequest, ListVariantStoresResponse> {
        return .init(
            input: input,
            command: self.listVariantStores,
            inputKey: \ListVariantStoresRequest.nextToken,
            outputKey: \ListVariantStoresResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of workflows.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.startingToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    public func waitUntilAnnotationImportJobCreated(
        _ input: GetAnnotationImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilAnnotationStoreCreated(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilAnnotationStoreDeleted(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilReadSetActivationJobCompleted(
        _ input: GetReadSetActivationJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetActivationJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilReadSetExportJobCompleted(
        _ input: GetReadSetExportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetExportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilReadSetImportJobCompleted(
        _ input: GetReadSetImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilReferenceImportJobCompleted(
        _ input: GetReferenceImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReferenceImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilRunCompleted(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilRunRunning(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilTaskCompleted(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilTaskRunning(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilVariantImportJobCreated(
        _ input: GetVariantImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilVariantStoreCreated(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilVariantStoreDeleted(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }

    public func waitUntilWorkflowActive(
        _ input: GetWorkflowRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(3),
            maxDelayTime: .seconds(30),
            command: self.getWorkflow
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger, on: eventLoop)
    }
}

#endif // compiler(>=5.5.2) && canImport(_Concurrency)
