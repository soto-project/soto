//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS Omics service.
///
/// This is the AWS HealthOmics API Reference. For an introduction to the service, see What is AWS HealthOmics? in the AWS HealthOmics User Guide.
public struct Omics: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Omics client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Omics",
            serviceIdentifier: "omics",
            serviceProtocol: .restjson,
            apiVersion: "2022-11-28",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            variantEndpoints: Self.variantEndpoints,
            errorType: OmicsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "ap-southeast-1": "omics.ap-southeast-1.amazonaws.com",
        "eu-central-1": "omics.eu-central-1.amazonaws.com",
        "eu-west-1": "omics.eu-west-1.amazonaws.com",
        "eu-west-2": "omics.eu-west-2.amazonaws.com",
        "il-central-1": "omics.il-central-1.amazonaws.com",
        "us-east-1": "omics.us-east-1.amazonaws.com",
        "us-west-2": "omics.us-west-2.amazonaws.com"
    ]}


    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "omics-fips.us-east-1.amazonaws.com",
            "us-west-2": "omics-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    ///  Stops a multipart upload.
    @Sendable
    public func abortMultipartReadSetUpload(_ input: AbortMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AbortMultipartReadSetUploadResponse {
        return try await self.client.execute(
            operation: "AbortMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/abort", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Accepts a share for an analytics store.
    @Sendable
    public func acceptShare(_ input: AcceptShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AcceptShareResponse {
        return try await self.client.execute(
            operation: "AcceptShare", 
            path: "/share/{shareId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Deletes one or more read sets.
    @Sendable
    public func batchDeleteReadSet(_ input: BatchDeleteReadSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteReadSetResponse {
        return try await self.client.execute(
            operation: "BatchDeleteReadSet", 
            path: "/sequencestore/{sequenceStoreId}/readset/batch/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Cancels an annotation import job.
    @Sendable
    public func cancelAnnotationImportJob(_ input: CancelAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelAnnotationImportResponse {
        return try await self.client.execute(
            operation: "CancelAnnotationImportJob", 
            path: "/import/annotation/{jobId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Cancels a run.
    @Sendable
    public func cancelRun(_ input: CancelRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "CancelRun", 
            path: "/run/{id}/cancel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Cancels a variant import job.
    @Sendable
    public func cancelVariantImportJob(_ input: CancelVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelVariantImportResponse {
        return try await self.client.execute(
            operation: "CancelVariantImportJob", 
            path: "/import/variant/{jobId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    ///  Concludes a multipart upload once you have uploaded all the components.
    @Sendable
    public func completeMultipartReadSetUpload(_ input: CompleteMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CompleteMultipartReadSetUploadResponse {
        return try await self.client.execute(
            operation: "CompleteMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/complete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }

    /// Creates an annotation store.
    @Sendable
    public func createAnnotationStore(_ input: CreateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAnnotationStoreResponse {
        return try await self.client.execute(
            operation: "CreateAnnotationStore", 
            path: "/annotationStore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Creates a new version of an annotation store.
    @Sendable
    public func createAnnotationStoreVersion(_ input: CreateAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAnnotationStoreVersionResponse {
        return try await self.client.execute(
            operation: "CreateAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    ///  Begins a multipart read set upload.
    @Sendable
    public func createMultipartReadSetUpload(_ input: CreateMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMultipartReadSetUploadResponse {
        return try await self.client.execute(
            operation: "CreateMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Creates a reference store.
    @Sendable
    public func createReferenceStore(_ input: CreateReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReferenceStoreResponse {
        return try await self.client.execute(
            operation: "CreateReferenceStore", 
            path: "/referencestore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Creates a run group.
    @Sendable
    public func createRunGroup(_ input: CreateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRunGroupResponse {
        return try await self.client.execute(
            operation: "CreateRunGroup", 
            path: "/runGroup", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Creates a sequence store.
    @Sendable
    public func createSequenceStore(_ input: CreateSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSequenceStoreResponse {
        return try await self.client.execute(
            operation: "CreateSequenceStore", 
            path: "/sequencestore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    ///  Creates a share offer that can be accepted outside the account by a subscriber. The share is created by the owner and accepted by the principal subscriber.
    @Sendable
    public func createShare(_ input: CreateShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateShareResponse {
        return try await self.client.execute(
            operation: "CreateShare", 
            path: "/share", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Creates a variant store.
    @Sendable
    public func createVariantStore(_ input: CreateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVariantStoreResponse {
        return try await self.client.execute(
            operation: "CreateVariantStore", 
            path: "/variantStore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Creates a workflow.
    @Sendable
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkflowResponse {
        return try await self.client.execute(
            operation: "CreateWorkflow", 
            path: "/workflow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Deletes an annotation store.
    @Sendable
    public func deleteAnnotationStore(_ input: DeleteAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAnnotationStoreResponse {
        return try await self.client.execute(
            operation: "DeleteAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Deletes one or multiple versions of an annotation store.
    @Sendable
    public func deleteAnnotationStoreVersions(_ input: DeleteAnnotationStoreVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAnnotationStoreVersionsResponse {
        return try await self.client.execute(
            operation: "DeleteAnnotationStoreVersions", 
            path: "/annotationStore/{name}/versions/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Deletes a genome reference.
    @Sendable
    public func deleteReference(_ input: DeleteReferenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReferenceResponse {
        return try await self.client.execute(
            operation: "DeleteReference", 
            path: "/referencestore/{referenceStoreId}/reference/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Deletes a genome reference store.
    @Sendable
    public func deleteReferenceStore(_ input: DeleteReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReferenceStoreResponse {
        return try await self.client.execute(
            operation: "DeleteReferenceStore", 
            path: "/referencestore/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Deletes a workflow run.
    @Sendable
    public func deleteRun(_ input: DeleteRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteRun", 
            path: "/run/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Deletes a workflow run group.
    @Sendable
    public func deleteRunGroup(_ input: DeleteRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Deletes a sequence store.
    @Sendable
    public func deleteSequenceStore(_ input: DeleteSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSequenceStoreResponse {
        return try await self.client.execute(
            operation: "DeleteSequenceStore", 
            path: "/sequencestore/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    ///  Deletes a share of an analytics store.
    @Sendable
    public func deleteShare(_ input: DeleteShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteShareResponse {
        return try await self.client.execute(
            operation: "DeleteShare", 
            path: "/share/{shareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Deletes a variant store.
    @Sendable
    public func deleteVariantStore(_ input: DeleteVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVariantStoreResponse {
        return try await self.client.execute(
            operation: "DeleteVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Deletes a workflow.
    @Sendable
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Gets information about an annotation import job.
    @Sendable
    public func getAnnotationImportJob(_ input: GetAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationImportResponse {
        return try await self.client.execute(
            operation: "GetAnnotationImportJob", 
            path: "/import/annotation/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Gets information about an annotation store.
    @Sendable
    public func getAnnotationStore(_ input: GetAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationStoreResponse {
        return try await self.client.execute(
            operation: "GetAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Retrieves the metadata for an annotation store version.
    @Sendable
    public func getAnnotationStoreVersion(_ input: GetAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationStoreVersionResponse {
        return try await self.client.execute(
            operation: "GetAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version/{versionName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Gets a file from a read set.
    @Sendable
    public func getReadSet(_ input: GetReadSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetResponse {
        return try await self.client.execute(
            operation: "GetReadSet", 
            path: "/sequencestore/{sequenceStoreId}/readset/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }

    /// Gets information about a read set activation job.
    @Sendable
    public func getReadSetActivationJob(_ input: GetReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetActivationJobResponse {
        return try await self.client.execute(
            operation: "GetReadSetActivationJob", 
            path: "/sequencestore/{sequenceStoreId}/activationjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets information about a read set export job.
    @Sendable
    public func getReadSetExportJob(_ input: GetReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetExportJobResponse {
        return try await self.client.execute(
            operation: "GetReadSetExportJob", 
            path: "/sequencestore/{sequenceStoreId}/exportjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets information about a read set import job.
    @Sendable
    public func getReadSetImportJob(_ input: GetReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetImportJobResponse {
        return try await self.client.execute(
            operation: "GetReadSetImportJob", 
            path: "/sequencestore/{sequenceStoreId}/importjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets details about a read set.
    @Sendable
    public func getReadSetMetadata(_ input: GetReadSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetMetadataResponse {
        return try await self.client.execute(
            operation: "GetReadSetMetadata", 
            path: "/sequencestore/{sequenceStoreId}/readset/{id}/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets a reference file.
    @Sendable
    public func getReference(_ input: GetReferenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceResponse {
        return try await self.client.execute(
            operation: "GetReference", 
            path: "/referencestore/{referenceStoreId}/reference/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }

    /// Gets information about a reference import job.
    @Sendable
    public func getReferenceImportJob(_ input: GetReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceImportJobResponse {
        return try await self.client.execute(
            operation: "GetReferenceImportJob", 
            path: "/referencestore/{referenceStoreId}/importjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets information about a genome reference's metadata.
    @Sendable
    public func getReferenceMetadata(_ input: GetReferenceMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceMetadataResponse {
        return try await self.client.execute(
            operation: "GetReferenceMetadata", 
            path: "/referencestore/{referenceStoreId}/reference/{id}/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets information about a reference store.
    @Sendable
    public func getReferenceStore(_ input: GetReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceStoreResponse {
        return try await self.client.execute(
            operation: "GetReferenceStore", 
            path: "/referencestore/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Gets information about a workflow run.
    @Sendable
    public func getRun(_ input: GetRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunResponse {
        return try await self.client.execute(
            operation: "GetRun", 
            path: "/run/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Gets information about a workflow run group.
    @Sendable
    public func getRunGroup(_ input: GetRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunGroupResponse {
        return try await self.client.execute(
            operation: "GetRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Gets information about a workflow run task.
    @Sendable
    public func getRunTask(_ input: GetRunTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunTaskResponse {
        return try await self.client.execute(
            operation: "GetRunTask", 
            path: "/run/{id}/task/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Gets information about a sequence store.
    @Sendable
    public func getSequenceStore(_ input: GetSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSequenceStoreResponse {
        return try await self.client.execute(
            operation: "GetSequenceStore", 
            path: "/sequencestore/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    ///  Retrieves the metadata for a share.
    @Sendable
    public func getShare(_ input: GetShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetShareResponse {
        return try await self.client.execute(
            operation: "GetShare", 
            path: "/share/{shareId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Gets information about a variant import job.
    @Sendable
    public func getVariantImportJob(_ input: GetVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVariantImportResponse {
        return try await self.client.execute(
            operation: "GetVariantImportJob", 
            path: "/import/variant/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Gets information about a variant store.
    @Sendable
    public func getVariantStore(_ input: GetVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVariantStoreResponse {
        return try await self.client.execute(
            operation: "GetVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Gets information about a workflow.
    @Sendable
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowResponse {
        return try await self.client.execute(
            operation: "GetWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Retrieves a list of annotation import jobs.
    @Sendable
    public func listAnnotationImportJobs(_ input: ListAnnotationImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationImportJobsResponse {
        return try await self.client.execute(
            operation: "ListAnnotationImportJobs", 
            path: "/import/annotations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Lists the versions of an annotation store.
    @Sendable
    public func listAnnotationStoreVersions(_ input: ListAnnotationStoreVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationStoreVersionsResponse {
        return try await self.client.execute(
            operation: "ListAnnotationStoreVersions", 
            path: "/annotationStore/{name}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Retrieves a list of annotation stores.
    @Sendable
    public func listAnnotationStores(_ input: ListAnnotationStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationStoresResponse {
        return try await self.client.execute(
            operation: "ListAnnotationStores", 
            path: "/annotationStores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    ///  Lists multipart read set uploads and for in progress uploads. Once the upload is completed, a read set is created and the upload will no longer be returned in the respone.
    @Sendable
    public func listMultipartReadSetUploads(_ input: ListMultipartReadSetUploadsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMultipartReadSetUploadsResponse {
        return try await self.client.execute(
            operation: "ListMultipartReadSetUploads", 
            path: "/sequencestore/{sequenceStoreId}/uploads", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of read set activation jobs.
    @Sendable
    public func listReadSetActivationJobs(_ input: ListReadSetActivationJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetActivationJobsResponse {
        return try await self.client.execute(
            operation: "ListReadSetActivationJobs", 
            path: "/sequencestore/{sequenceStoreId}/activationjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of read set export jobs.
    @Sendable
    public func listReadSetExportJobs(_ input: ListReadSetExportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetExportJobsResponse {
        return try await self.client.execute(
            operation: "ListReadSetExportJobs", 
            path: "/sequencestore/{sequenceStoreId}/exportjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of read set import jobs.
    @Sendable
    public func listReadSetImportJobs(_ input: ListReadSetImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetImportJobsResponse {
        return try await self.client.execute(
            operation: "ListReadSetImportJobs", 
            path: "/sequencestore/{sequenceStoreId}/importjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    ///  This operation will list all parts in a requested multipart upload for a sequence store.
    @Sendable
    public func listReadSetUploadParts(_ input: ListReadSetUploadPartsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetUploadPartsResponse {
        return try await self.client.execute(
            operation: "ListReadSetUploadParts", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/parts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of read sets.
    @Sendable
    public func listReadSets(_ input: ListReadSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetsResponse {
        return try await self.client.execute(
            operation: "ListReadSets", 
            path: "/sequencestore/{sequenceStoreId}/readsets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of reference import jobs.
    @Sendable
    public func listReferenceImportJobs(_ input: ListReferenceImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferenceImportJobsResponse {
        return try await self.client.execute(
            operation: "ListReferenceImportJobs", 
            path: "/referencestore/{referenceStoreId}/importjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of reference stores.
    @Sendable
    public func listReferenceStores(_ input: ListReferenceStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferenceStoresResponse {
        return try await self.client.execute(
            operation: "ListReferenceStores", 
            path: "/referencestores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of references.
    @Sendable
    public func listReferences(_ input: ListReferencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferencesResponse {
        return try await self.client.execute(
            operation: "ListReferences", 
            path: "/referencestore/{referenceStoreId}/references", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Retrieves a list of run groups.
    @Sendable
    public func listRunGroups(_ input: ListRunGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunGroupsResponse {
        return try await self.client.execute(
            operation: "ListRunGroups", 
            path: "/runGroup", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Retrieves a list of tasks for a run.
    @Sendable
    public func listRunTasks(_ input: ListRunTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunTasksResponse {
        return try await self.client.execute(
            operation: "ListRunTasks", 
            path: "/run/{id}/task", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Retrieves a list of runs.
    @Sendable
    public func listRuns(_ input: ListRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunsResponse {
        return try await self.client.execute(
            operation: "ListRuns", 
            path: "/run", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Retrieves a list of sequence stores.
    @Sendable
    public func listSequenceStores(_ input: ListSequenceStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSequenceStoresResponse {
        return try await self.client.execute(
            operation: "ListSequenceStores", 
            path: "/sequencestores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    ///  Lists all shares associated with an account.
    @Sendable
    public func listShares(_ input: ListSharesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSharesResponse {
        return try await self.client.execute(
            operation: "ListShares", 
            path: "/shares", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Retrieves a list of tags for a resource.
    @Sendable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }

    /// Retrieves a list of variant import jobs.
    @Sendable
    public func listVariantImportJobs(_ input: ListVariantImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVariantImportJobsResponse {
        return try await self.client.execute(
            operation: "ListVariantImportJobs", 
            path: "/import/variants", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Retrieves a list of variant stores.
    @Sendable
    public func listVariantStores(_ input: ListVariantStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVariantStoresResponse {
        return try await self.client.execute(
            operation: "ListVariantStores", 
            path: "/variantStores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Retrieves a list of workflows.
    @Sendable
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowsResponse {
        return try await self.client.execute(
            operation: "ListWorkflows", 
            path: "/workflow", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Starts an annotation import job.
    @Sendable
    public func startAnnotationImportJob(_ input: StartAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartAnnotationImportResponse {
        return try await self.client.execute(
            operation: "StartAnnotationImportJob", 
            path: "/import/annotation", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Activates an archived read set. To reduce storage charges, Amazon Omics archives unused read sets after 30 days.
    @Sendable
    public func startReadSetActivationJob(_ input: StartReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetActivationJobResponse {
        return try await self.client.execute(
            operation: "StartReadSetActivationJob", 
            path: "/sequencestore/{sequenceStoreId}/activationjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Exports a read set to Amazon S3.
    @Sendable
    public func startReadSetExportJob(_ input: StartReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetExportJobResponse {
        return try await self.client.execute(
            operation: "StartReadSetExportJob", 
            path: "/sequencestore/{sequenceStoreId}/exportjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Starts a read set import job.
    @Sendable
    public func startReadSetImportJob(_ input: StartReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetImportJobResponse {
        return try await self.client.execute(
            operation: "StartReadSetImportJob", 
            path: "/sequencestore/{sequenceStoreId}/importjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Starts a reference import job.
    @Sendable
    public func startReferenceImportJob(_ input: StartReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReferenceImportJobResponse {
        return try await self.client.execute(
            operation: "StartReferenceImportJob", 
            path: "/referencestore/{referenceStoreId}/importjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }

    /// Starts a workflow run. To duplicate a run, specify the run's ID and a role ARN. The remaining parameters are copied from the previous run. The total number of runs in your account is subject to a quota per Region. To avoid needing to delete runs manually, you can set the retention mode to REMOVE. Runs with this setting are deleted automatically when the run quoata is exceeded.
    @Sendable
    public func startRun(_ input: StartRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartRunResponse {
        return try await self.client.execute(
            operation: "StartRun", 
            path: "/run", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Starts a variant import job.
    @Sendable
    public func startVariantImportJob(_ input: StartVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartVariantImportResponse {
        return try await self.client.execute(
            operation: "StartVariantImportJob", 
            path: "/import/variant", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Tags a resource.
    @Sendable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        return try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }

    /// Removes tags from a resource.
    @Sendable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        return try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }

    /// Updates an annotation store.
    @Sendable
    public func updateAnnotationStore(_ input: UpdateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnnotationStoreResponse {
        return try await self.client.execute(
            operation: "UpdateAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Updates the description of an annotation store version.
    @Sendable
    public func updateAnnotationStoreVersion(_ input: UpdateAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnnotationStoreVersionResponse {
        return try await self.client.execute(
            operation: "UpdateAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version/{versionName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Updates a run group.
    @Sendable
    public func updateRunGroup(_ input: UpdateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "UpdateRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    /// Updates a variant store.
    @Sendable
    public func updateVariantStore(_ input: UpdateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVariantStoreResponse {
        return try await self.client.execute(
            operation: "UpdateVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }

    /// Updates a workflow.
    @Sendable
    public func updateWorkflow(_ input: UpdateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "UpdateWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }

    ///  This operation uploads a specific part of a read set. If you upload a new part using a previously used part number, the previously uploaded part will be overwritten.
    @Sendable
    public func uploadReadSetPart(_ input: UploadReadSetPartRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UploadReadSetPartResponse {
        return try await self.client.execute(
            operation: "UploadReadSetPart", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/part", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }
}

extension Omics {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Omics, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    /// Retrieves a list of annotation import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAnnotationImportJobsPaginator(
        _ input: ListAnnotationImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationImportJobsRequest, ListAnnotationImportJobsResponse> {
        return .init(
            input: input,
            command: self.listAnnotationImportJobs,
            inputKey: \ListAnnotationImportJobsRequest.nextToken,
            outputKey: \ListAnnotationImportJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the versions of an annotation store.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAnnotationStoreVersionsPaginator(
        _ input: ListAnnotationStoreVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoreVersionsRequest, ListAnnotationStoreVersionsResponse> {
        return .init(
            input: input,
            command: self.listAnnotationStoreVersions,
            inputKey: \ListAnnotationStoreVersionsRequest.nextToken,
            outputKey: \ListAnnotationStoreVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of annotation stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAnnotationStoresPaginator(
        _ input: ListAnnotationStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoresRequest, ListAnnotationStoresResponse> {
        return .init(
            input: input,
            command: self.listAnnotationStores,
            inputKey: \ListAnnotationStoresRequest.nextToken,
            outputKey: \ListAnnotationStoresResponse.nextToken,
            logger: logger
        )
    }

    ///  Lists multipart read set uploads and for in progress uploads. Once the upload is completed, a read set is created and the upload will no longer be returned in the respone.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listMultipartReadSetUploadsPaginator(
        _ input: ListMultipartReadSetUploadsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMultipartReadSetUploadsRequest, ListMultipartReadSetUploadsResponse> {
        return .init(
            input: input,
            command: self.listMultipartReadSetUploads,
            inputKey: \ListMultipartReadSetUploadsRequest.nextToken,
            outputKey: \ListMultipartReadSetUploadsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of read set activation jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReadSetActivationJobsPaginator(
        _ input: ListReadSetActivationJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetActivationJobsRequest, ListReadSetActivationJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetActivationJobs,
            inputKey: \ListReadSetActivationJobsRequest.nextToken,
            outputKey: \ListReadSetActivationJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of read set export jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReadSetExportJobsPaginator(
        _ input: ListReadSetExportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetExportJobsRequest, ListReadSetExportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetExportJobs,
            inputKey: \ListReadSetExportJobsRequest.nextToken,
            outputKey: \ListReadSetExportJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of read set import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReadSetImportJobsPaginator(
        _ input: ListReadSetImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetImportJobsRequest, ListReadSetImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetImportJobs,
            inputKey: \ListReadSetImportJobsRequest.nextToken,
            outputKey: \ListReadSetImportJobsResponse.nextToken,
            logger: logger
        )
    }

    ///  This operation will list all parts in a requested multipart upload for a sequence store.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReadSetUploadPartsPaginator(
        _ input: ListReadSetUploadPartsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetUploadPartsRequest, ListReadSetUploadPartsResponse> {
        return .init(
            input: input,
            command: self.listReadSetUploadParts,
            inputKey: \ListReadSetUploadPartsRequest.nextToken,
            outputKey: \ListReadSetUploadPartsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of read sets.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReadSetsPaginator(
        _ input: ListReadSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetsRequest, ListReadSetsResponse> {
        return .init(
            input: input,
            command: self.listReadSets,
            inputKey: \ListReadSetsRequest.nextToken,
            outputKey: \ListReadSetsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of reference import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReferenceImportJobsPaginator(
        _ input: ListReferenceImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferenceImportJobsRequest, ListReferenceImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReferenceImportJobs,
            inputKey: \ListReferenceImportJobsRequest.nextToken,
            outputKey: \ListReferenceImportJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of reference stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReferenceStoresPaginator(
        _ input: ListReferenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferenceStoresRequest, ListReferenceStoresResponse> {
        return .init(
            input: input,
            command: self.listReferenceStores,
            inputKey: \ListReferenceStoresRequest.nextToken,
            outputKey: \ListReferenceStoresResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of references.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listReferencesPaginator(
        _ input: ListReferencesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferencesRequest, ListReferencesResponse> {
        return .init(
            input: input,
            command: self.listReferences,
            inputKey: \ListReferencesRequest.nextToken,
            outputKey: \ListReferencesResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of run groups.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listRunGroupsPaginator(
        _ input: ListRunGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunGroupsRequest, ListRunGroupsResponse> {
        return .init(
            input: input,
            command: self.listRunGroups,
            inputKey: \ListRunGroupsRequest.startingToken,
            outputKey: \ListRunGroupsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of tasks for a run.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listRunTasksPaginator(
        _ input: ListRunTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunTasksRequest, ListRunTasksResponse> {
        return .init(
            input: input,
            command: self.listRunTasks,
            inputKey: \ListRunTasksRequest.startingToken,
            outputKey: \ListRunTasksResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of runs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listRunsPaginator(
        _ input: ListRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunsRequest, ListRunsResponse> {
        return .init(
            input: input,
            command: self.listRuns,
            inputKey: \ListRunsRequest.startingToken,
            outputKey: \ListRunsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of sequence stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSequenceStoresPaginator(
        _ input: ListSequenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSequenceStoresRequest, ListSequenceStoresResponse> {
        return .init(
            input: input,
            command: self.listSequenceStores,
            inputKey: \ListSequenceStoresRequest.nextToken,
            outputKey: \ListSequenceStoresResponse.nextToken,
            logger: logger
        )
    }

    ///  Lists all shares associated with an account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSharesPaginator(
        _ input: ListSharesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSharesRequest, ListSharesResponse> {
        return .init(
            input: input,
            command: self.listShares,
            inputKey: \ListSharesRequest.nextToken,
            outputKey: \ListSharesResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of variant import jobs.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listVariantImportJobsPaginator(
        _ input: ListVariantImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVariantImportJobsRequest, ListVariantImportJobsResponse> {
        return .init(
            input: input,
            command: self.listVariantImportJobs,
            inputKey: \ListVariantImportJobsRequest.nextToken,
            outputKey: \ListVariantImportJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of variant stores.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listVariantStoresPaginator(
        _ input: ListVariantStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVariantStoresRequest, ListVariantStoresResponse> {
        return .init(
            input: input,
            command: self.listVariantStores,
            inputKey: \ListVariantStoresRequest.nextToken,
            outputKey: \ListVariantStoresResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of workflows.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.startingToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger
        )
    }
}

extension Omics.ListAnnotationImportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationImportJobsRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListAnnotationStoreVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationStoreVersionsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension Omics.ListAnnotationStoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationStoresRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListMultipartReadSetUploadsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListMultipartReadSetUploadsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetActivationJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetActivationJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetExportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetExportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetImportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetImportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetUploadPartsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetUploadPartsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            partSource: self.partSource,
            sequenceStoreId: self.sequenceStoreId,
            uploadId: self.uploadId
        )
    }
}

extension Omics.ListReadSetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReferenceImportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReferenceImportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            referenceStoreId: self.referenceStoreId
        )
    }
}

extension Omics.ListReferenceStoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReferenceStoresRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListReferencesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListReferencesRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            referenceStoreId: self.referenceStoreId
        )
    }
}

extension Omics.ListRunGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListRunGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            startingToken: token
        )
    }
}

extension Omics.ListRunTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListRunTasksRequest {
        return .init(
            id: self.id,
            maxResults: self.maxResults,
            startingToken: token,
            status: self.status
        )
    }
}

extension Omics.ListRunsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListRunsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            runGroupId: self.runGroupId,
            startingToken: token,
            status: self.status
        )
    }
}

extension Omics.ListSequenceStoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListSequenceStoresRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListSharesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListSharesRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            resourceOwner: self.resourceOwner
        )
    }
}

extension Omics.ListVariantImportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListVariantImportJobsRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListVariantStoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListVariantStoresRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListWorkflowsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Omics.ListWorkflowsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            startingToken: token,
            type: self.type
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    public func waitUntilAnnotationImportJobCreated(
        _ input: GetAnnotationImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilAnnotationStoreCreated(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilAnnotationStoreDeleted(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilAnnotationStoreVersionCreated(
        _ input: GetAnnotationStoreVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStoreVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilAnnotationStoreVersionDeleted(
        _ input: GetAnnotationStoreVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStoreVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReadSetActivationJobCompleted(
        _ input: GetReadSetActivationJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetActivationJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReadSetExportJobCompleted(
        _ input: GetReadSetExportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetExportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReadSetImportJobCompleted(
        _ input: GetReadSetImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReferenceImportJobCompleted(
        _ input: GetReferenceImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReferenceImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilRunCompleted(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilRunRunning(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilTaskCompleted(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilTaskRunning(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilVariantImportJobCreated(
        _ input: GetVariantImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilVariantStoreCreated(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilVariantStoreDeleted(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilWorkflowActive(
        _ input: GetWorkflowRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(3),
            maxDelayTime: .seconds(30),
            command: self.getWorkflow
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
}
