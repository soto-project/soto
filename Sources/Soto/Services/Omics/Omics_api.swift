//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Omics service.
///
/// This is the AWS HealthOmics API Reference. For an introduction to the service, see What is AWS HealthOmics? in the AWS HealthOmics User Guide.
public struct Omics: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Omics client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Omics",
            serviceIdentifier: "omics",
            serviceProtocol: .restjson,
            apiVersion: "2022-11-28",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            variantEndpoints: Self.variantEndpoints,
            errorType: OmicsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "ap-southeast-1": "omics.ap-southeast-1.amazonaws.com",
        "eu-central-1": "omics.eu-central-1.amazonaws.com",
        "eu-west-1": "omics.eu-west-1.amazonaws.com",
        "eu-west-2": "omics.eu-west-2.amazonaws.com",
        "il-central-1": "omics.il-central-1.amazonaws.com",
        "us-east-1": "omics.us-east-1.amazonaws.com",
        "us-west-2": "omics.us-west-2.amazonaws.com"
    ]}


    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "omics-fips.us-east-1.amazonaws.com",
            "us-west-2": "omics-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Stops a multipart upload.
    @Sendable
    @inlinable
    public func abortMultipartReadSetUpload(_ input: AbortMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AbortMultipartReadSetUploadResponse {
        try await self.client.execute(
            operation: "AbortMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/abort", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Stops a multipart upload.
    ///
    /// Parameters:
    ///   - sequenceStoreId: The sequence store ID for the store involved in the multipart upload.
    ///   - uploadId: The ID for the multipart upload.
    ///   - logger: Logger use during operation
    @inlinable
    public func abortMultipartReadSetUpload(
        sequenceStoreId: String,
        uploadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AbortMultipartReadSetUploadResponse {
        let input = AbortMultipartReadSetUploadRequest(
            sequenceStoreId: sequenceStoreId, 
            uploadId: uploadId
        )
        return try await self.abortMultipartReadSetUpload(input, logger: logger)
    }

    /// Accept a resource share request.
    @Sendable
    @inlinable
    public func acceptShare(_ input: AcceptShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AcceptShareResponse {
        try await self.client.execute(
            operation: "AcceptShare", 
            path: "/share/{shareId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Accept a resource share request.
    ///
    /// Parameters:
    ///   - shareId: The ID of the resource share.
    ///   - logger: Logger use during operation
    @inlinable
    public func acceptShare(
        shareId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AcceptShareResponse {
        let input = AcceptShareRequest(
            shareId: shareId
        )
        return try await self.acceptShare(input, logger: logger)
    }

    /// Deletes one or more read sets.
    @Sendable
    @inlinable
    public func batchDeleteReadSet(_ input: BatchDeleteReadSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteReadSetResponse {
        try await self.client.execute(
            operation: "BatchDeleteReadSet", 
            path: "/sequencestore/{sequenceStoreId}/readset/batch/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Deletes one or more read sets.
    ///
    /// Parameters:
    ///   - ids: The read sets' IDs.
    ///   - sequenceStoreId: The read sets' sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteReadSet(
        ids: [String],
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteReadSetResponse {
        let input = BatchDeleteReadSetRequest(
            ids: ids, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.batchDeleteReadSet(input, logger: logger)
    }

    /// Cancels an annotation import job.
    @Sendable
    @inlinable
    public func cancelAnnotationImportJob(_ input: CancelAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelAnnotationImportResponse {
        try await self.client.execute(
            operation: "CancelAnnotationImportJob", 
            path: "/import/annotation/{jobId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Cancels an annotation import job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelAnnotationImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelAnnotationImportResponse {
        let input = CancelAnnotationImportRequest(
            jobId: jobId
        )
        return try await self.cancelAnnotationImportJob(input, logger: logger)
    }

    /// Cancels a run.
    @Sendable
    @inlinable
    public func cancelRun(_ input: CancelRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CancelRun", 
            path: "/run/{id}/cancel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Cancels a run.
    ///
    /// Parameters:
    ///   - id: The run's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelRun(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CancelRunRequest(
            id: id
        )
        return try await self.cancelRun(input, logger: logger)
    }

    /// Cancels a variant import job.
    @Sendable
    @inlinable
    public func cancelVariantImportJob(_ input: CancelVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelVariantImportResponse {
        try await self.client.execute(
            operation: "CancelVariantImportJob", 
            path: "/import/variant/{jobId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Cancels a variant import job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelVariantImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelVariantImportResponse {
        let input = CancelVariantImportRequest(
            jobId: jobId
        )
        return try await self.cancelVariantImportJob(input, logger: logger)
    }

    /// Concludes a multipart upload once you have uploaded all the components.
    @Sendable
    @inlinable
    public func completeMultipartReadSetUpload(_ input: CompleteMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CompleteMultipartReadSetUploadResponse {
        try await self.client.execute(
            operation: "CompleteMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/complete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }
    /// Concludes a multipart upload once you have uploaded all the components.
    ///
    /// Parameters:
    ///   - parts: The individual uploads or parts of a multipart upload.
    ///   - sequenceStoreId: The sequence store ID for the store involved in the multipart upload.
    ///   - uploadId: The ID for the multipart upload.
    ///   - logger: Logger use during operation
    @inlinable
    public func completeMultipartReadSetUpload(
        parts: [CompleteReadSetUploadPartListItem],
        sequenceStoreId: String,
        uploadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CompleteMultipartReadSetUploadResponse {
        let input = CompleteMultipartReadSetUploadRequest(
            parts: parts, 
            sequenceStoreId: sequenceStoreId, 
            uploadId: uploadId
        )
        return try await self.completeMultipartReadSetUpload(input, logger: logger)
    }

    /// Creates an annotation store.
    @Sendable
    @inlinable
    public func createAnnotationStore(_ input: CreateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAnnotationStoreResponse {
        try await self.client.execute(
            operation: "CreateAnnotationStore", 
            path: "/annotationStore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Creates an annotation store.
    ///
    /// Parameters:
    ///   - description: A description for the store.
    ///   - name: A name for the store.
    ///   - reference: The genome reference for the store's annotations.
    ///   - sseConfig: Server-side encryption (SSE) settings for the store.
    ///   - storeFormat: The annotation file format of the store.
    ///   - storeOptions: File parsing options for the annotation store.
    ///   - tags: Tags for the store.
    ///   - versionName: The name given to an annotation store version to distinguish it from other versions.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAnnotationStore(
        description: String? = nil,
        name: String? = nil,
        reference: ReferenceItem? = nil,
        sseConfig: SseConfig? = nil,
        storeFormat: StoreFormat,
        storeOptions: StoreOptions? = nil,
        tags: [String: String]? = nil,
        versionName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAnnotationStoreResponse {
        let input = CreateAnnotationStoreRequest(
            description: description, 
            name: name, 
            reference: reference, 
            sseConfig: sseConfig, 
            storeFormat: storeFormat, 
            storeOptions: storeOptions, 
            tags: tags, 
            versionName: versionName
        )
        return try await self.createAnnotationStore(input, logger: logger)
    }

    /// Creates a new version of an annotation store.
    @Sendable
    @inlinable
    public func createAnnotationStoreVersion(_ input: CreateAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAnnotationStoreVersionResponse {
        try await self.client.execute(
            operation: "CreateAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Creates a new version of an annotation store.
    ///
    /// Parameters:
    ///   - description: The description of an annotation store version.
    ///   - name: The name of an annotation store version from which versions are being created.
    ///   - tags: Any tags added to annotation store version.
    ///   - versionName: The name given to an annotation store version to distinguish it from other versions.
    ///   - versionOptions: The options for an annotation store version.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAnnotationStoreVersion(
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        versionName: String,
        versionOptions: VersionOptions? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAnnotationStoreVersionResponse {
        let input = CreateAnnotationStoreVersionRequest(
            description: description, 
            name: name, 
            tags: tags, 
            versionName: versionName, 
            versionOptions: versionOptions
        )
        return try await self.createAnnotationStoreVersion(input, logger: logger)
    }

    /// Begins a multipart read set upload.
    @Sendable
    @inlinable
    public func createMultipartReadSetUpload(_ input: CreateMultipartReadSetUploadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMultipartReadSetUploadResponse {
        try await self.client.execute(
            operation: "CreateMultipartReadSetUpload", 
            path: "/sequencestore/{sequenceStoreId}/upload", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Begins a multipart read set upload.
    ///
    /// Parameters:
    ///   - clientToken: An idempotency token that can be used to avoid triggering multiple multipart uploads.
    ///   - description: The description of the read set.
    ///   - generatedFrom: Where the source originated.
    ///   - name: The name of the read set.
    ///   - referenceArn: The ARN of the reference.
    ///   - sampleId: The source's sample ID.
    ///   - sequenceStoreId: The sequence store ID for the store that is the destination of the multipart uploads.
    ///   - sourceFileType: The type of file being uploaded.
    ///   - subjectId: The source's subject ID.
    ///   - tags: Any tags to add to the read set.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMultipartReadSetUpload(
        clientToken: String? = nil,
        description: String? = nil,
        generatedFrom: String? = nil,
        name: String,
        referenceArn: String? = nil,
        sampleId: String,
        sequenceStoreId: String,
        sourceFileType: FileType,
        subjectId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMultipartReadSetUploadResponse {
        let input = CreateMultipartReadSetUploadRequest(
            clientToken: clientToken, 
            description: description, 
            generatedFrom: generatedFrom, 
            name: name, 
            referenceArn: referenceArn, 
            sampleId: sampleId, 
            sequenceStoreId: sequenceStoreId, 
            sourceFileType: sourceFileType, 
            subjectId: subjectId, 
            tags: tags
        )
        return try await self.createMultipartReadSetUpload(input, logger: logger)
    }

    /// Creates a reference store.
    @Sendable
    @inlinable
    public func createReferenceStore(_ input: CreateReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReferenceStoreResponse {
        try await self.client.execute(
            operation: "CreateReferenceStore", 
            path: "/referencestore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Creates a reference store.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that requests don't run multiple times, specify a unique token for each request.
    ///   - description: A description for the store.
    ///   - name: A name for the store.
    ///   - sseConfig: Server-side encryption (SSE) settings for the store.
    ///   - tags: Tags for the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReferenceStore(
        clientToken: String? = nil,
        description: String? = nil,
        name: String,
        sseConfig: SseConfig? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateReferenceStoreResponse {
        let input = CreateReferenceStoreRequest(
            clientToken: clientToken, 
            description: description, 
            name: name, 
            sseConfig: sseConfig, 
            tags: tags
        )
        return try await self.createReferenceStore(input, logger: logger)
    }

    /// You can create a run cache to save the task outputs from completed tasks in a run for a private workflow.  Subsequent runs use the task outputs from the cache, rather than computing the task outputs again. You specify an Amazon S3 location where HealthOmics saves the cached data. This data must be  immediately accessible (not in an archived state). For more information, see Creating a run cache in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func createRunCache(_ input: CreateRunCacheRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRunCacheResponse {
        try await self.client.execute(
            operation: "CreateRunCache", 
            path: "/runCache", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// You can create a run cache to save the task outputs from completed tasks in a run for a private workflow.  Subsequent runs use the task outputs from the cache, rather than computing the task outputs again. You specify an Amazon S3 location where HealthOmics saves the cached data. This data must be  immediately accessible (not in an archived state). For more information, see Creating a run cache in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - cacheBehavior: Default cache behavior for runs that use this cache. Supported values are:  CACHE_ON_FAILURE: Caches task outputs from completed tasks for runs that fail. This setting is  useful if you're debugging a workflow that fails after several tasks completed successfully. The subsequent run uses the cache outputs for previously-completed tasks if the task definition, inputs, and container in ECR are identical to the prior run.  CACHE_ALWAYS: Caches task outputs from completed tasks for all runs. This setting is useful in development mode, but do not use it in a production setting. If you don't specify a value, the default behavior is CACHE_ON_FAILURE. When you start a run that uses this cache, you can override the default cache behavior. For more information, see Run cache behavior in the AWS HealthOmics User Guide.
    ///   - cacheBucketOwnerId: The AWS account ID of the expected owner of the S3 bucket for the run cache. If not provided, your account ID is set as the owner of the bucket.
    ///   - cacheS3Location: Specify the S3 location for storing the cached task outputs. This data must be immediately accessible (not in an archived state).
    ///   - description: Enter a description of the run cache.
    ///   - name: Enter a user-friendly name for the run cache.
    ///   - requestId: A unique request token, to ensure idempotency. If you don't specify a token,  HealthOmics automatically generates a universally unique identifier (UUID) for the request.
    ///   - tags: Specify one or more tags to associate with this run cache.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRunCache(
        cacheBehavior: CacheBehavior? = nil,
        cacheBucketOwnerId: String? = nil,
        cacheS3Location: String,
        description: String? = nil,
        name: String? = nil,
        requestId: String = CreateRunCacheRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRunCacheResponse {
        let input = CreateRunCacheRequest(
            cacheBehavior: cacheBehavior, 
            cacheBucketOwnerId: cacheBucketOwnerId, 
            cacheS3Location: cacheS3Location, 
            description: description, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createRunCache(input, logger: logger)
    }

    /// You can optionally create a run group to limit the compute resources for the runs that you add to the group.
    @Sendable
    @inlinable
    public func createRunGroup(_ input: CreateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRunGroupResponse {
        try await self.client.execute(
            operation: "CreateRunGroup", 
            path: "/runGroup", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// You can optionally create a run group to limit the compute resources for the runs that you add to the group.
    ///
    /// Parameters:
    ///   - maxCpus: The maximum number of CPUs that can run concurrently across all active runs in the run group.
    ///   - maxDuration: The maximum time for each run (in minutes). If a run exceeds the maximum run time, the run fails automatically.
    ///   - maxGpus: The maximum number of GPUs that can run concurrently across all active runs in the run group.
    ///   - maxRuns: The maximum number of runs that can be running at the same time.
    ///   - name: A name for the group.
    ///   - requestId: To ensure that requests don't run multiple times, specify a unique ID for each request.
    ///   - tags: Tags for the group.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRunGroup(
        maxCpus: Int? = nil,
        maxDuration: Int? = nil,
        maxGpus: Int? = nil,
        maxRuns: Int? = nil,
        name: String? = nil,
        requestId: String = CreateRunGroupRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRunGroupResponse {
        let input = CreateRunGroupRequest(
            maxCpus: maxCpus, 
            maxDuration: maxDuration, 
            maxGpus: maxGpus, 
            maxRuns: maxRuns, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createRunGroup(input, logger: logger)
    }

    /// Creates a sequence store.
    @Sendable
    @inlinable
    public func createSequenceStore(_ input: CreateSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSequenceStoreResponse {
        try await self.client.execute(
            operation: "CreateSequenceStore", 
            path: "/sequencestore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Creates a sequence store.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that requests don't run multiple times, specify a unique token for each request.
    ///   - description: A description for the store.
    ///   - eTagAlgorithmFamily: The ETag algorithm family to use for ingested read sets.
    ///   - fallbackLocation: An S3 location that is used to store files that have failed a direct upload.
    ///   - name: A name for the store.
    ///   - propagatedSetLevelTags: The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
    ///   - s3AccessConfig: S3 access configuration parameters
    ///   - sseConfig: Server-side encryption (SSE) settings for the store.
    ///   - tags: Tags for the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSequenceStore(
        clientToken: String? = CreateSequenceStoreRequest.idempotencyToken(),
        description: String? = nil,
        eTagAlgorithmFamily: ETagAlgorithmFamily? = nil,
        fallbackLocation: String? = nil,
        name: String,
        propagatedSetLevelTags: [String]? = nil,
        s3AccessConfig: S3AccessConfig? = nil,
        sseConfig: SseConfig? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSequenceStoreResponse {
        let input = CreateSequenceStoreRequest(
            clientToken: clientToken, 
            description: description, 
            eTagAlgorithmFamily: eTagAlgorithmFamily, 
            fallbackLocation: fallbackLocation, 
            name: name, 
            propagatedSetLevelTags: propagatedSetLevelTags, 
            s3AccessConfig: s3AccessConfig, 
            sseConfig: sseConfig, 
            tags: tags
        )
        return try await self.createSequenceStore(input, logger: logger)
    }

    /// Creates a cross-account shared resource. The resource owner makes an offer to share the resource  with the principal subscriber (an AWS user with a different account than the resource owner). The following resources support cross-account sharing:   HealthOmics variant stores   HealthOmics annotation stores   Private workflows
    @Sendable
    @inlinable
    public func createShare(_ input: CreateShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateShareResponse {
        try await self.client.execute(
            operation: "CreateShare", 
            path: "/share", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Creates a cross-account shared resource. The resource owner makes an offer to share the resource  with the principal subscriber (an AWS user with a different account than the resource owner). The following resources support cross-account sharing:   HealthOmics variant stores   HealthOmics annotation stores   Private workflows
    ///
    /// Parameters:
    ///   - principalSubscriber: The principal subscriber is the account being offered shared access to the resource.
    ///   - resourceArn: The ARN of the resource to be shared.
    ///   - shareName: A name that the owner defines for the share.
    ///   - logger: Logger use during operation
    @inlinable
    public func createShare(
        principalSubscriber: String,
        resourceArn: String,
        shareName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateShareResponse {
        let input = CreateShareRequest(
            principalSubscriber: principalSubscriber, 
            resourceArn: resourceArn, 
            shareName: shareName
        )
        return try await self.createShare(input, logger: logger)
    }

    /// Creates a variant store.
    @Sendable
    @inlinable
    public func createVariantStore(_ input: CreateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVariantStoreResponse {
        try await self.client.execute(
            operation: "CreateVariantStore", 
            path: "/variantStore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Creates a variant store.
    ///
    /// Parameters:
    ///   - description: A description for the store.
    ///   - name: A name for the store.
    ///   - reference: The genome reference for the store's variants.
    ///   - sseConfig: Server-side encryption (SSE) settings for the store.
    ///   - tags: Tags for the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVariantStore(
        description: String? = nil,
        name: String? = nil,
        reference: ReferenceItem,
        sseConfig: SseConfig? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVariantStoreResponse {
        let input = CreateVariantStoreRequest(
            description: description, 
            name: name, 
            reference: reference, 
            sseConfig: sseConfig, 
            tags: tags
        )
        return try await self.createVariantStore(input, logger: logger)
    }

    /// Creates a workflow.
    @Sendable
    @inlinable
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkflowResponse {
        try await self.client.execute(
            operation: "CreateWorkflow", 
            path: "/workflow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Creates a workflow.
    ///
    /// Parameters:
    ///   - accelerators: The computational accelerator specified to run the workflow.
    ///   - definitionUri: The URI of a definition for the workflow.
    ///   - definitionZip: A ZIP archive for the workflow.
    ///   - description: A description for the workflow.
    ///   - engine: An engine for the workflow.
    ///   - main: The path of the main definition file for the workflow.
    ///   - name: A name for the workflow.
    ///   - parameterTemplate: A parameter template for the workflow.
    ///   - requestId: To ensure that requests don't run multiple times, specify a unique ID for each request.
    ///   - storageCapacity: The default storage capacity for the workflow runs, in gibibytes.
    ///   - tags: Tags for the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkflow(
        accelerators: Accelerators? = nil,
        definitionUri: String? = nil,
        definitionZip: AWSBase64Data? = nil,
        description: String? = nil,
        engine: WorkflowEngine? = nil,
        main: String? = nil,
        name: String? = nil,
        parameterTemplate: [String: WorkflowParameter]? = nil,
        requestId: String = CreateWorkflowRequest.idempotencyToken(),
        storageCapacity: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkflowResponse {
        let input = CreateWorkflowRequest(
            accelerators: accelerators, 
            definitionUri: definitionUri, 
            definitionZip: definitionZip, 
            description: description, 
            engine: engine, 
            main: main, 
            name: name, 
            parameterTemplate: parameterTemplate, 
            requestId: requestId, 
            storageCapacity: storageCapacity, 
            tags: tags
        )
        return try await self.createWorkflow(input, logger: logger)
    }

    /// Deletes an annotation store.
    @Sendable
    @inlinable
    public func deleteAnnotationStore(_ input: DeleteAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAnnotationStoreResponse {
        try await self.client.execute(
            operation: "DeleteAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Deletes an annotation store.
    ///
    /// Parameters:
    ///   - force: Whether to force deletion.
    ///   - name: The store's name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAnnotationStore(
        force: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAnnotationStoreResponse {
        let input = DeleteAnnotationStoreRequest(
            force: force, 
            name: name
        )
        return try await self.deleteAnnotationStore(input, logger: logger)
    }

    /// Deletes one or multiple versions of an annotation store.
    @Sendable
    @inlinable
    public func deleteAnnotationStoreVersions(_ input: DeleteAnnotationStoreVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAnnotationStoreVersionsResponse {
        try await self.client.execute(
            operation: "DeleteAnnotationStoreVersions", 
            path: "/annotationStore/{name}/versions/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Deletes one or multiple versions of an annotation store.
    ///
    /// Parameters:
    ///   - force: Forces the deletion of an annotation store version when imports are in-progress..
    ///   - name: The name of the annotation store from which versions are being deleted.
    ///   - versions: The versions of an annotation store to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAnnotationStoreVersions(
        force: Bool? = nil,
        name: String,
        versions: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAnnotationStoreVersionsResponse {
        let input = DeleteAnnotationStoreVersionsRequest(
            force: force, 
            name: name, 
            versions: versions
        )
        return try await self.deleteAnnotationStoreVersions(input, logger: logger)
    }

    /// Deletes a genome reference.
    @Sendable
    @inlinable
    public func deleteReference(_ input: DeleteReferenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReferenceResponse {
        try await self.client.execute(
            operation: "DeleteReference", 
            path: "/referencestore/{referenceStoreId}/reference/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Deletes a genome reference.
    ///
    /// Parameters:
    ///   - id: The reference's ID.
    ///   - referenceStoreId: The reference's store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReference(
        id: String,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReferenceResponse {
        let input = DeleteReferenceRequest(
            id: id, 
            referenceStoreId: referenceStoreId
        )
        return try await self.deleteReference(input, logger: logger)
    }

    /// Deletes a genome reference store.
    @Sendable
    @inlinable
    public func deleteReferenceStore(_ input: DeleteReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReferenceStoreResponse {
        try await self.client.execute(
            operation: "DeleteReferenceStore", 
            path: "/referencestore/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Deletes a genome reference store.
    ///
    /// Parameters:
    ///   - id: The store's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReferenceStore(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReferenceStoreResponse {
        let input = DeleteReferenceStoreRequest(
            id: id
        )
        return try await self.deleteReferenceStore(input, logger: logger)
    }

    /// Deletes a workflow run.
    @Sendable
    @inlinable
    public func deleteRun(_ input: DeleteRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRun", 
            path: "/run/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Deletes a workflow run.
    ///
    /// Parameters:
    ///   - id: The run's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRun(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRunRequest(
            id: id
        )
        return try await self.deleteRun(input, logger: logger)
    }

    /// Delete a run cache. This action removes the cache metadata stored in the service account,  but doesn't delete the data in Amazon S3.  You can access the cache data in Amazon S3, for inspection or to troubleshoot issues.  You can remove old cache data using standard S3 Delete operations.  For more information, see Deleting a run cache in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func deleteRunCache(_ input: DeleteRunCacheRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRunCache", 
            path: "/runCache/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Delete a run cache. This action removes the cache metadata stored in the service account,  but doesn't delete the data in Amazon S3.  You can access the cache data in Amazon S3, for inspection or to troubleshoot issues.  You can remove old cache data using standard S3 Delete operations.  For more information, see Deleting a run cache in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - id: Run cache identifier for the cache you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRunCache(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRunCacheRequest(
            id: id
        )
        return try await self.deleteRunCache(input, logger: logger)
    }

    /// Deletes a workflow run group.
    @Sendable
    @inlinable
    public func deleteRunGroup(_ input: DeleteRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Deletes a workflow run group.
    ///
    /// Parameters:
    ///   - id: The run group's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRunGroup(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRunGroupRequest(
            id: id
        )
        return try await self.deleteRunGroup(input, logger: logger)
    }

    /// Deletes an access policy for the specified store.
    @Sendable
    @inlinable
    public func deleteS3AccessPolicy(_ input: DeleteS3AccessPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteS3AccessPolicyResponse {
        try await self.client.execute(
            operation: "DeleteS3AccessPolicy", 
            path: "/s3accesspolicy/{s3AccessPointArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Deletes an access policy for the specified store.
    ///
    /// Parameters:
    ///   - s3AccessPointArn: The S3 access point ARN that has the access policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteS3AccessPolicy(
        s3AccessPointArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteS3AccessPolicyResponse {
        let input = DeleteS3AccessPolicyRequest(
            s3AccessPointArn: s3AccessPointArn
        )
        return try await self.deleteS3AccessPolicy(input, logger: logger)
    }

    /// Deletes a sequence store.
    @Sendable
    @inlinable
    public func deleteSequenceStore(_ input: DeleteSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSequenceStoreResponse {
        try await self.client.execute(
            operation: "DeleteSequenceStore", 
            path: "/sequencestore/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Deletes a sequence store.
    ///
    /// Parameters:
    ///   - id: The sequence store's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSequenceStore(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSequenceStoreResponse {
        let input = DeleteSequenceStoreRequest(
            id: id
        )
        return try await self.deleteSequenceStore(input, logger: logger)
    }

    /// Deletes a resource share. If you are the resource owner, the subscriber will no longer have  access to the shared resource. If you are the subscriber, this operation deletes your access to the share.
    @Sendable
    @inlinable
    public func deleteShare(_ input: DeleteShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteShareResponse {
        try await self.client.execute(
            operation: "DeleteShare", 
            path: "/share/{shareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Deletes a resource share. If you are the resource owner, the subscriber will no longer have  access to the shared resource. If you are the subscriber, this operation deletes your access to the share.
    ///
    /// Parameters:
    ///   - shareId: The ID for the resource share to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteShare(
        shareId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteShareResponse {
        let input = DeleteShareRequest(
            shareId: shareId
        )
        return try await self.deleteShare(input, logger: logger)
    }

    /// Deletes a variant store.
    @Sendable
    @inlinable
    public func deleteVariantStore(_ input: DeleteVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVariantStoreResponse {
        try await self.client.execute(
            operation: "DeleteVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Deletes a variant store.
    ///
    /// Parameters:
    ///   - force: Whether to force deletion.
    ///   - name: The store's name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVariantStore(
        force: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVariantStoreResponse {
        let input = DeleteVariantStoreRequest(
            force: force, 
            name: name
        )
        return try await self.deleteVariantStore(input, logger: logger)
    }

    /// Deletes a workflow.
    @Sendable
    @inlinable
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Deletes a workflow.
    ///
    /// Parameters:
    ///   - id: The workflow's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkflow(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteWorkflowRequest(
            id: id
        )
        return try await self.deleteWorkflow(input, logger: logger)
    }

    /// Gets information about an annotation import job.
    @Sendable
    @inlinable
    public func getAnnotationImportJob(_ input: GetAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationImportResponse {
        try await self.client.execute(
            operation: "GetAnnotationImportJob", 
            path: "/import/annotation/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Gets information about an annotation import job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnnotationImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnnotationImportResponse {
        let input = GetAnnotationImportRequest(
            jobId: jobId
        )
        return try await self.getAnnotationImportJob(input, logger: logger)
    }

    /// Gets information about an annotation store.
    @Sendable
    @inlinable
    public func getAnnotationStore(_ input: GetAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationStoreResponse {
        try await self.client.execute(
            operation: "GetAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Gets information about an annotation store.
    ///
    /// Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnnotationStore(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnnotationStoreResponse {
        let input = GetAnnotationStoreRequest(
            name: name
        )
        return try await self.getAnnotationStore(input, logger: logger)
    }

    /// Retrieves the metadata for an annotation store version.
    @Sendable
    @inlinable
    public func getAnnotationStoreVersion(_ input: GetAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnnotationStoreVersionResponse {
        try await self.client.execute(
            operation: "GetAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version/{versionName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves the metadata for an annotation store version.
    ///
    /// Parameters:
    ///   - name: The name given to an annotation store version to distinguish it from others.
    ///   - versionName: The name given to an annotation store version to distinguish it from others.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnnotationStoreVersion(
        name: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnnotationStoreVersionResponse {
        let input = GetAnnotationStoreVersionRequest(
            name: name, 
            versionName: versionName
        )
        return try await self.getAnnotationStoreVersion(input, logger: logger)
    }

    /// Gets a file from a read set.
    @Sendable
    @inlinable
    public func getReadSet(_ input: GetReadSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetResponse {
        try await self.client.execute(
            operation: "GetReadSet", 
            path: "/sequencestore/{sequenceStoreId}/readset/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }
    /// Gets a file from a read set.
    ///
    /// Parameters:
    ///   - file: The file to retrieve.
    ///   - id: The read set's ID.
    ///   - partNumber: The part number to retrieve.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReadSet(
        file: ReadSetFile? = nil,
        id: String,
        partNumber: Int,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReadSetResponse {
        let input = GetReadSetRequest(
            file: file, 
            id: id, 
            partNumber: partNumber, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.getReadSet(input, logger: logger)
    }

    /// Gets information about a read set activation job.
    @Sendable
    @inlinable
    public func getReadSetActivationJob(_ input: GetReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetActivationJobResponse {
        try await self.client.execute(
            operation: "GetReadSetActivationJob", 
            path: "/sequencestore/{sequenceStoreId}/activationjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a read set activation job.
    ///
    /// Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReadSetActivationJob(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReadSetActivationJobResponse {
        let input = GetReadSetActivationJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.getReadSetActivationJob(input, logger: logger)
    }

    /// Gets information about a read set export job.
    @Sendable
    @inlinable
    public func getReadSetExportJob(_ input: GetReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetExportJobResponse {
        try await self.client.execute(
            operation: "GetReadSetExportJob", 
            path: "/sequencestore/{sequenceStoreId}/exportjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a read set export job.
    ///
    /// Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReadSetExportJob(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReadSetExportJobResponse {
        let input = GetReadSetExportJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.getReadSetExportJob(input, logger: logger)
    }

    /// Gets information about a read set import job.
    @Sendable
    @inlinable
    public func getReadSetImportJob(_ input: GetReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetImportJobResponse {
        try await self.client.execute(
            operation: "GetReadSetImportJob", 
            path: "/sequencestore/{sequenceStoreId}/importjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a read set import job.
    ///
    /// Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReadSetImportJob(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReadSetImportJobResponse {
        let input = GetReadSetImportJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.getReadSetImportJob(input, logger: logger)
    }

    /// Gets details about a read set.
    @Sendable
    @inlinable
    public func getReadSetMetadata(_ input: GetReadSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReadSetMetadataResponse {
        try await self.client.execute(
            operation: "GetReadSetMetadata", 
            path: "/sequencestore/{sequenceStoreId}/readset/{id}/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets details about a read set.
    ///
    /// Parameters:
    ///   - id: The read set's ID.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReadSetMetadata(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReadSetMetadataResponse {
        let input = GetReadSetMetadataRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.getReadSetMetadata(input, logger: logger)
    }

    /// Gets a reference file.
    @Sendable
    @inlinable
    public func getReference(_ input: GetReferenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceResponse {
        try await self.client.execute(
            operation: "GetReference", 
            path: "/referencestore/{referenceStoreId}/reference/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }
    /// Gets a reference file.
    ///
    /// Parameters:
    ///   - file: The file to retrieve.
    ///   - id: The reference's ID.
    ///   - partNumber: The part number to retrieve.
    ///   - range: The range to retrieve.
    ///   - referenceStoreId: The reference's store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReference(
        file: ReferenceFile? = nil,
        id: String,
        partNumber: Int,
        range: String? = nil,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReferenceResponse {
        let input = GetReferenceRequest(
            file: file, 
            id: id, 
            partNumber: partNumber, 
            range: range, 
            referenceStoreId: referenceStoreId
        )
        return try await self.getReference(input, logger: logger)
    }

    /// Gets information about a reference import job.
    @Sendable
    @inlinable
    public func getReferenceImportJob(_ input: GetReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceImportJobResponse {
        try await self.client.execute(
            operation: "GetReferenceImportJob", 
            path: "/referencestore/{referenceStoreId}/importjob/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a reference import job.
    ///
    /// Parameters:
    ///   - id: The job's ID.
    ///   - referenceStoreId: The job's reference store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReferenceImportJob(
        id: String,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReferenceImportJobResponse {
        let input = GetReferenceImportJobRequest(
            id: id, 
            referenceStoreId: referenceStoreId
        )
        return try await self.getReferenceImportJob(input, logger: logger)
    }

    /// Gets information about a genome reference's metadata.
    @Sendable
    @inlinable
    public func getReferenceMetadata(_ input: GetReferenceMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceMetadataResponse {
        try await self.client.execute(
            operation: "GetReferenceMetadata", 
            path: "/referencestore/{referenceStoreId}/reference/{id}/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a genome reference's metadata.
    ///
    /// Parameters:
    ///   - id: The reference's ID.
    ///   - referenceStoreId: The reference's reference store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReferenceMetadata(
        id: String,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReferenceMetadataResponse {
        let input = GetReferenceMetadataRequest(
            id: id, 
            referenceStoreId: referenceStoreId
        )
        return try await self.getReferenceMetadata(input, logger: logger)
    }

    /// Gets information about a reference store.
    @Sendable
    @inlinable
    public func getReferenceStore(_ input: GetReferenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReferenceStoreResponse {
        try await self.client.execute(
            operation: "GetReferenceStore", 
            path: "/referencestore/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a reference store.
    ///
    /// Parameters:
    ///   - id: The store's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReferenceStore(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReferenceStoreResponse {
        let input = GetReferenceStoreRequest(
            id: id
        )
        return try await self.getReferenceStore(input, logger: logger)
    }

    /// Gets information about a workflow run. If a workflow is shared with you, you cannot export information about the run. HealthOmics stores a fixed number of runs that are available to the console and API. If  GetRun doesn't return the requested run, you can find run logs  for all runs in the CloudWatch logs. For more information about viewing the run logs, see CloudWatch logs  in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func getRun(_ input: GetRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunResponse {
        try await self.client.execute(
            operation: "GetRun", 
            path: "/run/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Gets information about a workflow run. If a workflow is shared with you, you cannot export information about the run. HealthOmics stores a fixed number of runs that are available to the console and API. If  GetRun doesn't return the requested run, you can find run logs  for all runs in the CloudWatch logs. For more information about viewing the run logs, see CloudWatch logs  in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - export: The run's export format.
    ///   - id: The run's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRun(
        export: [RunExport]? = nil,
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRunResponse {
        let input = GetRunRequest(
            export: export, 
            id: id
        )
        return try await self.getRun(input, logger: logger)
    }

    /// Retrieve the details for the specified run cache. For more information, see Call caching for HealthOmics runs in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func getRunCache(_ input: GetRunCacheRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunCacheResponse {
        try await self.client.execute(
            operation: "GetRunCache", 
            path: "/runCache/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieve the details for the specified run cache. For more information, see Call caching for HealthOmics runs in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - id: The identifier of the run cache to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRunCache(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRunCacheResponse {
        let input = GetRunCacheRequest(
            id: id
        )
        return try await self.getRunCache(input, logger: logger)
    }

    /// Gets information about a workflow run group.
    @Sendable
    @inlinable
    public func getRunGroup(_ input: GetRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunGroupResponse {
        try await self.client.execute(
            operation: "GetRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Gets information about a workflow run group.
    ///
    /// Parameters:
    ///   - id: The group's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRunGroup(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRunGroupResponse {
        let input = GetRunGroupRequest(
            id: id
        )
        return try await self.getRunGroup(input, logger: logger)
    }

    /// Gets information about a workflow run task.
    @Sendable
    @inlinable
    public func getRunTask(_ input: GetRunTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRunTaskResponse {
        try await self.client.execute(
            operation: "GetRunTask", 
            path: "/run/{id}/task/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Gets information about a workflow run task.
    ///
    /// Parameters:
    ///   - id: The workflow run ID.
    ///   - taskId: The task's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRunTask(
        id: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRunTaskResponse {
        let input = GetRunTaskRequest(
            id: id, 
            taskId: taskId
        )
        return try await self.getRunTask(input, logger: logger)
    }

    /// Retrieves details about an access policy on a given store.
    @Sendable
    @inlinable
    public func getS3AccessPolicy(_ input: GetS3AccessPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetS3AccessPolicyResponse {
        try await self.client.execute(
            operation: "GetS3AccessPolicy", 
            path: "/s3accesspolicy/{s3AccessPointArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves details about an access policy on a given store.
    ///
    /// Parameters:
    ///   - s3AccessPointArn: The S3 access point ARN that has the access policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func getS3AccessPolicy(
        s3AccessPointArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetS3AccessPolicyResponse {
        let input = GetS3AccessPolicyRequest(
            s3AccessPointArn: s3AccessPointArn
        )
        return try await self.getS3AccessPolicy(input, logger: logger)
    }

    /// Gets information about a sequence store.
    @Sendable
    @inlinable
    public func getSequenceStore(_ input: GetSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSequenceStoreResponse {
        try await self.client.execute(
            operation: "GetSequenceStore", 
            path: "/sequencestore/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Gets information about a sequence store.
    ///
    /// Parameters:
    ///   - id: The store's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSequenceStore(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSequenceStoreResponse {
        let input = GetSequenceStoreRequest(
            id: id
        )
        return try await self.getSequenceStore(input, logger: logger)
    }

    /// Retrieves the metadata for the specified resource share.
    @Sendable
    @inlinable
    public func getShare(_ input: GetShareRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetShareResponse {
        try await self.client.execute(
            operation: "GetShare", 
            path: "/share/{shareId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves the metadata for the specified resource share.
    ///
    /// Parameters:
    ///   - shareId: The ID of the share.
    ///   - logger: Logger use during operation
    @inlinable
    public func getShare(
        shareId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetShareResponse {
        let input = GetShareRequest(
            shareId: shareId
        )
        return try await self.getShare(input, logger: logger)
    }

    /// Gets information about a variant import job.
    @Sendable
    @inlinable
    public func getVariantImportJob(_ input: GetVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVariantImportResponse {
        try await self.client.execute(
            operation: "GetVariantImportJob", 
            path: "/import/variant/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Gets information about a variant import job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getVariantImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetVariantImportResponse {
        let input = GetVariantImportRequest(
            jobId: jobId
        )
        return try await self.getVariantImportJob(input, logger: logger)
    }

    /// Gets information about a variant store.
    @Sendable
    @inlinable
    public func getVariantStore(_ input: GetVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVariantStoreResponse {
        try await self.client.execute(
            operation: "GetVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Gets information about a variant store.
    ///
    /// Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getVariantStore(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetVariantStoreResponse {
        let input = GetVariantStoreRequest(
            name: name
        )
        return try await self.getVariantStore(input, logger: logger)
    }

    /// Gets information about a workflow. If a workflow is shared with you, you cannot export the workflow.
    @Sendable
    @inlinable
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowResponse {
        try await self.client.execute(
            operation: "GetWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Gets information about a workflow. If a workflow is shared with you, you cannot export the workflow.
    ///
    /// Parameters:
    ///   - export: The export format for the workflow.
    ///   - id: The workflow's ID.
    ///   - type: The workflow's type.
    ///   - workflowOwnerId: The ID of the workflow owner.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflow(
        export: [WorkflowExport]? = nil,
        id: String,
        type: WorkflowType? = nil,
        workflowOwnerId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowResponse {
        let input = GetWorkflowRequest(
            export: export, 
            id: id, 
            type: type, 
            workflowOwnerId: workflowOwnerId
        )
        return try await self.getWorkflow(input, logger: logger)
    }

    /// Retrieves a list of annotation import jobs.
    @Sendable
    @inlinable
    public func listAnnotationImportJobs(_ input: ListAnnotationImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationImportJobsResponse {
        try await self.client.execute(
            operation: "ListAnnotationImportJobs", 
            path: "/import/annotations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves a list of annotation import jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: IDs of annotation import jobs to retrieve.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - nextToken: Specifies the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnnotationImportJobs(
        filter: ListAnnotationImportJobsFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnnotationImportJobsResponse {
        let input = ListAnnotationImportJobsRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAnnotationImportJobs(input, logger: logger)
    }

    /// Lists the versions of an annotation store.
    @Sendable
    @inlinable
    public func listAnnotationStoreVersions(_ input: ListAnnotationStoreVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationStoreVersionsResponse {
        try await self.client.execute(
            operation: "ListAnnotationStoreVersions", 
            path: "/annotationStore/{name}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Lists the versions of an annotation store.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list of annotation store versions.
    ///   - maxResults: The maximum number of annotation store versions to return in one page of results.
    ///   - name: The name of an annotation store.
    ///   - nextToken: Specifies the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnnotationStoreVersions(
        filter: ListAnnotationStoreVersionsFilter? = nil,
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnnotationStoreVersionsResponse {
        let input = ListAnnotationStoreVersionsRequest(
            filter: filter, 
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listAnnotationStoreVersions(input, logger: logger)
    }

    /// Retrieves a list of annotation stores.
    @Sendable
    @inlinable
    public func listAnnotationStores(_ input: ListAnnotationStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnnotationStoresResponse {
        try await self.client.execute(
            operation: "ListAnnotationStores", 
            path: "/annotationStores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves a list of annotation stores.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: IDs of stores to list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnnotationStores(
        filter: ListAnnotationStoresFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnnotationStoresResponse {
        let input = ListAnnotationStoresRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAnnotationStores(input, logger: logger)
    }

    /// Lists multipart read set uploads and for in progress uploads.  Once the upload is completed, a read set is created and the upload will no longer be returned in the response.
    @Sendable
    @inlinable
    public func listMultipartReadSetUploads(_ input: ListMultipartReadSetUploadsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMultipartReadSetUploadsResponse {
        try await self.client.execute(
            operation: "ListMultipartReadSetUploads", 
            path: "/sequencestore/{sequenceStoreId}/uploads", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Lists multipart read set uploads and for in progress uploads.  Once the upload is completed, a read set is created and the upload will no longer be returned in the response.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of multipart uploads returned in a page.
    ///   - nextToken: Next token returned in the response of a previous ListMultipartReadSetUploads call.  Used to get the next page of results.
    ///   - sequenceStoreId: The Sequence Store ID used for the multipart uploads.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMultipartReadSetUploads(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMultipartReadSetUploadsResponse {
        let input = ListMultipartReadSetUploadsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.listMultipartReadSetUploads(input, logger: logger)
    }

    /// Retrieves a list of read set activation jobs.
    @Sendable
    @inlinable
    public func listReadSetActivationJobs(_ input: ListReadSetActivationJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetActivationJobsResponse {
        try await self.client.execute(
            operation: "ListReadSetActivationJobs", 
            path: "/sequencestore/{sequenceStoreId}/activationjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of read set activation jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of read set activation jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReadSetActivationJobs(
        filter: ActivateReadSetFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReadSetActivationJobsResponse {
        let input = ListReadSetActivationJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.listReadSetActivationJobs(input, logger: logger)
    }

    /// Retrieves a list of read set export jobs.
    @Sendable
    @inlinable
    public func listReadSetExportJobs(_ input: ListReadSetExportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetExportJobsResponse {
        try await self.client.execute(
            operation: "ListReadSetExportJobs", 
            path: "/sequencestore/{sequenceStoreId}/exportjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of read set export jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReadSetExportJobs(
        filter: ExportReadSetFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReadSetExportJobsResponse {
        let input = ListReadSetExportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.listReadSetExportJobs(input, logger: logger)
    }

    /// Retrieves a list of read set import jobs.
    @Sendable
    @inlinable
    public func listReadSetImportJobs(_ input: ListReadSetImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetImportJobsResponse {
        try await self.client.execute(
            operation: "ListReadSetImportJobs", 
            path: "/sequencestore/{sequenceStoreId}/importjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of read set import jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReadSetImportJobs(
        filter: ImportReadSetFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReadSetImportJobsResponse {
        let input = ListReadSetImportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.listReadSetImportJobs(input, logger: logger)
    }

    /// This operation will list all parts in a requested multipart upload for a sequence store.
    @Sendable
    @inlinable
    public func listReadSetUploadParts(_ input: ListReadSetUploadPartsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetUploadPartsResponse {
        try await self.client.execute(
            operation: "ListReadSetUploadParts", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/parts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// This operation will list all parts in a requested multipart upload for a sequence store.
    ///
    /// Parameters:
    ///   - filter: Attributes used to filter for a specific subset of read set part uploads.
    ///   - maxResults: The maximum number of read set upload parts returned in a page.
    ///   - nextToken: Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    ///   - partSource: The source file for the upload part.
    ///   - sequenceStoreId: The Sequence Store ID used for the multipart uploads.
    ///   - uploadId: The ID for the initiated multipart upload.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReadSetUploadParts(
        filter: ReadSetUploadPartListFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        partSource: ReadSetPartSource,
        sequenceStoreId: String,
        uploadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReadSetUploadPartsResponse {
        let input = ListReadSetUploadPartsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            partSource: partSource, 
            sequenceStoreId: sequenceStoreId, 
            uploadId: uploadId
        )
        return try await self.listReadSetUploadParts(input, logger: logger)
    }

    /// Retrieves a list of read sets.
    @Sendable
    @inlinable
    public func listReadSets(_ input: ListReadSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReadSetsResponse {
        try await self.client.execute(
            operation: "ListReadSets", 
            path: "/sequencestore/{sequenceStoreId}/readsets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of read sets.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of read sets to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReadSets(
        filter: ReadSetFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReadSetsResponse {
        let input = ListReadSetsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sequenceStoreId: sequenceStoreId
        )
        return try await self.listReadSets(input, logger: logger)
    }

    /// Retrieves a list of reference import jobs.
    @Sendable
    @inlinable
    public func listReferenceImportJobs(_ input: ListReferenceImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferenceImportJobsResponse {
        try await self.client.execute(
            operation: "ListReferenceImportJobs", 
            path: "/referencestore/{referenceStoreId}/importjobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of reference import jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - referenceStoreId: The job's reference store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReferenceImportJobs(
        filter: ImportReferenceFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReferenceImportJobsResponse {
        let input = ListReferenceImportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            referenceStoreId: referenceStoreId
        )
        return try await self.listReferenceImportJobs(input, logger: logger)
    }

    /// Retrieves a list of reference stores.
    @Sendable
    @inlinable
    public func listReferenceStores(_ input: ListReferenceStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferenceStoresResponse {
        try await self.client.execute(
            operation: "ListReferenceStores", 
            path: "/referencestores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of reference stores.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReferenceStores(
        filter: ReferenceStoreFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReferenceStoresResponse {
        let input = ListReferenceStoresRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listReferenceStores(input, logger: logger)
    }

    /// Retrieves a list of references.
    @Sendable
    @inlinable
    public func listReferences(_ input: ListReferencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReferencesResponse {
        try await self.client.execute(
            operation: "ListReferences", 
            path: "/referencestore/{referenceStoreId}/references", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of references.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of references to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - referenceStoreId: The references' reference store ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReferences(
        filter: ReferenceFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReferencesResponse {
        let input = ListReferencesRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            referenceStoreId: referenceStoreId
        )
        return try await self.listReferences(input, logger: logger)
    }

    /// Retrieves a list of your run caches.
    @Sendable
    @inlinable
    public func listRunCaches(_ input: ListRunCachesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunCachesResponse {
        try await self.client.execute(
            operation: "ListRunCaches", 
            path: "/runCache", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieves a list of your run caches.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - startingToken: Optional pagination token returned from a prior call to the ListRunCaches API operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRunCaches(
        maxResults: Int? = nil,
        startingToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRunCachesResponse {
        let input = ListRunCachesRequest(
            maxResults: maxResults, 
            startingToken: startingToken
        )
        return try await self.listRunCaches(input, logger: logger)
    }

    /// Retrieves a list of run groups.
    @Sendable
    @inlinable
    public func listRunGroups(_ input: ListRunGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunGroupsResponse {
        try await self.client.execute(
            operation: "ListRunGroups", 
            path: "/runGroup", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieves a list of run groups.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of run groups to return in one page of results.
    ///   - name: The run groups' name.
    ///   - startingToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRunGroups(
        maxResults: Int? = nil,
        name: String? = nil,
        startingToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRunGroupsResponse {
        let input = ListRunGroupsRequest(
            maxResults: maxResults, 
            name: name, 
            startingToken: startingToken
        )
        return try await self.listRunGroups(input, logger: logger)
    }

    /// Retrieves a list of tasks for a run.
    @Sendable
    @inlinable
    public func listRunTasks(_ input: ListRunTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunTasksResponse {
        try await self.client.execute(
            operation: "ListRunTasks", 
            path: "/run/{id}/task", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieves a list of tasks for a run.
    ///
    /// Parameters:
    ///   - id: The run's ID.
    ///   - maxResults: The maximum number of run tasks to return in one page of results.
    ///   - startingToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - status: Filter the list by status.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRunTasks(
        id: String,
        maxResults: Int? = nil,
        startingToken: String? = nil,
        status: TaskStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRunTasksResponse {
        let input = ListRunTasksRequest(
            id: id, 
            maxResults: maxResults, 
            startingToken: startingToken, 
            status: status
        )
        return try await self.listRunTasks(input, logger: logger)
    }

    /// Retrieves a list of runs. HealthOmics stores a fixed number of runs that are available to the console and API. If  the ListRuns response doesn't include specific runs that you expected, you can find run logs  for all runs in the CloudWatch logs. For more information about viewing the run logs, see CloudWatch logs  in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func listRuns(_ input: ListRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRunsResponse {
        try await self.client.execute(
            operation: "ListRuns", 
            path: "/run", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieves a list of runs. HealthOmics stores a fixed number of runs that are available to the console and API. If  the ListRuns response doesn't include specific runs that you expected, you can find run logs  for all runs in the CloudWatch logs. For more information about viewing the run logs, see CloudWatch logs  in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of runs to return in one page of results.
    ///   - name: Filter the list by run name.
    ///   - runGroupId: Filter the list by run group ID.
    ///   - startingToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - status: The status of a run.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRuns(
        maxResults: Int? = nil,
        name: String? = nil,
        runGroupId: String? = nil,
        startingToken: String? = nil,
        status: RunStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRunsResponse {
        let input = ListRunsRequest(
            maxResults: maxResults, 
            name: name, 
            runGroupId: runGroupId, 
            startingToken: startingToken, 
            status: status
        )
        return try await self.listRuns(input, logger: logger)
    }

    /// Retrieves a list of sequence stores.
    @Sendable
    @inlinable
    public func listSequenceStores(_ input: ListSequenceStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSequenceStoresResponse {
        try await self.client.execute(
            operation: "ListSequenceStores", 
            path: "/sequencestores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Retrieves a list of sequence stores.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSequenceStores(
        filter: SequenceStoreFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSequenceStoresResponse {
        let input = ListSequenceStoresRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSequenceStores(input, logger: logger)
    }

    /// Retrieves the resource shares associated with an account. Use the filter parameter to  retrieve a specific subset of the shares.
    @Sendable
    @inlinable
    public func listShares(_ input: ListSharesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSharesResponse {
        try await self.client.execute(
            operation: "ListShares", 
            path: "/shares", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves the resource shares associated with an account. Use the filter parameter to  retrieve a specific subset of the shares.
    ///
    /// Parameters:
    ///   - filter: Attributes that you use to filter for a specific subset of resource shares.
    ///   - maxResults: The maximum number of shares to return in one page of results.
    ///   - nextToken: Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    ///   - resourceOwner: The account that owns the resource shares.
    ///   - logger: Logger use during operation
    @inlinable
    public func listShares(
        filter: Filter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceOwner: ResourceOwner,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSharesResponse {
        let input = ListSharesRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceOwner: resourceOwner
        )
        return try await self.listShares(input, logger: logger)
    }

    /// Retrieves a list of tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }
    /// Retrieves a list of tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Retrieves a list of variant import jobs.
    @Sendable
    @inlinable
    public func listVariantImportJobs(_ input: ListVariantImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVariantImportJobsResponse {
        try await self.client.execute(
            operation: "ListVariantImportJobs", 
            path: "/import/variants", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves a list of variant import jobs.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: A list of job IDs.
    ///   - maxResults: The maximum number of import jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVariantImportJobs(
        filter: ListVariantImportJobsFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVariantImportJobsResponse {
        let input = ListVariantImportJobsRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listVariantImportJobs(input, logger: logger)
    }

    /// Retrieves a list of variant stores.
    @Sendable
    @inlinable
    public func listVariantStores(_ input: ListVariantStoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVariantStoresResponse {
        try await self.client.execute(
            operation: "ListVariantStores", 
            path: "/variantStores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Retrieves a list of variant stores.
    ///
    /// Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: A list of store IDs.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVariantStores(
        filter: ListVariantStoresFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVariantStoresResponse {
        let input = ListVariantStoresRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listVariantStores(input, logger: logger)
    }

    /// Retrieves a list of workflows.
    @Sendable
    @inlinable
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowsResponse {
        try await self.client.execute(
            operation: "ListWorkflows", 
            path: "/workflow", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Retrieves a list of workflows.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of workflows to return in one page of results.
    ///   - name: Filter the list by workflow name.
    ///   - startingToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - type: Filter the list by workflow type.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflows(
        maxResults: Int? = nil,
        name: String? = nil,
        startingToken: String? = nil,
        type: WorkflowType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowsResponse {
        let input = ListWorkflowsRequest(
            maxResults: maxResults, 
            name: name, 
            startingToken: startingToken, 
            type: type
        )
        return try await self.listWorkflows(input, logger: logger)
    }

    /// Adds an access policy to the specified store.
    @Sendable
    @inlinable
    public func putS3AccessPolicy(_ input: PutS3AccessPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutS3AccessPolicyResponse {
        try await self.client.execute(
            operation: "PutS3AccessPolicy", 
            path: "/s3accesspolicy/{s3AccessPointArn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Adds an access policy to the specified store.
    ///
    /// Parameters:
    ///   - s3AccessPointArn: The S3 access point ARN where you want to put the access policy.
    ///   - s3AccessPolicy: The resource policy that controls S3 access to the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func putS3AccessPolicy(
        s3AccessPointArn: String,
        s3AccessPolicy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutS3AccessPolicyResponse {
        let input = PutS3AccessPolicyRequest(
            s3AccessPointArn: s3AccessPointArn, 
            s3AccessPolicy: s3AccessPolicy
        )
        return try await self.putS3AccessPolicy(input, logger: logger)
    }

    /// Starts an annotation import job.
    @Sendable
    @inlinable
    public func startAnnotationImportJob(_ input: StartAnnotationImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartAnnotationImportResponse {
        try await self.client.execute(
            operation: "StartAnnotationImportJob", 
            path: "/import/annotation", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Starts an annotation import job.
    ///
    /// Parameters:
    ///   - annotationFields: The annotation schema generated by the parsed annotation data.
    ///   - destinationName: A destination annotation store for the job.
    ///   - formatOptions: Formatting options for the annotation file.
    ///   - items: Items to import.
    ///   - roleArn: A service role for the job.
    ///   - runLeftNormalization: The job's left normalization setting.
    ///   - versionName: The name of the annotation store version.
    ///   - logger: Logger use during operation
    @inlinable
    public func startAnnotationImportJob(
        annotationFields: [String: String]? = nil,
        destinationName: String,
        formatOptions: FormatOptions? = nil,
        items: [AnnotationImportItemSource],
        roleArn: String,
        runLeftNormalization: Bool? = nil,
        versionName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartAnnotationImportResponse {
        let input = StartAnnotationImportRequest(
            annotationFields: annotationFields, 
            destinationName: destinationName, 
            formatOptions: formatOptions, 
            items: items, 
            roleArn: roleArn, 
            runLeftNormalization: runLeftNormalization, 
            versionName: versionName
        )
        return try await self.startAnnotationImportJob(input, logger: logger)
    }

    /// Activates an archived read set. To reduce storage charges, Amazon Omics archives unused read sets after 30 days.
    @Sendable
    @inlinable
    public func startReadSetActivationJob(_ input: StartReadSetActivationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetActivationJobResponse {
        try await self.client.execute(
            operation: "StartReadSetActivationJob", 
            path: "/sequencestore/{sequenceStoreId}/activationjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Activates an archived read set. To reduce storage charges, Amazon Omics archives unused read sets after 30 days.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that jobs don't run multiple times, specify a unique token for each job.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - sources: The job's source files.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReadSetActivationJob(
        clientToken: String? = nil,
        sequenceStoreId: String,
        sources: [StartReadSetActivationJobSourceItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartReadSetActivationJobResponse {
        let input = StartReadSetActivationJobRequest(
            clientToken: clientToken, 
            sequenceStoreId: sequenceStoreId, 
            sources: sources
        )
        return try await self.startReadSetActivationJob(input, logger: logger)
    }

    /// Exports a read set to Amazon S3.
    @Sendable
    @inlinable
    public func startReadSetExportJob(_ input: StartReadSetExportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetExportJobResponse {
        try await self.client.execute(
            operation: "StartReadSetExportJob", 
            path: "/sequencestore/{sequenceStoreId}/exportjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Exports a read set to Amazon S3.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that jobs don't run multiple times, specify a unique token for each job.
    ///   - destination: A location for exported files in Amazon S3.
    ///   - roleArn: A service role for the job.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - sources: The job's source files.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReadSetExportJob(
        clientToken: String? = nil,
        destination: String,
        roleArn: String,
        sequenceStoreId: String,
        sources: [ExportReadSet],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartReadSetExportJobResponse {
        let input = StartReadSetExportJobRequest(
            clientToken: clientToken, 
            destination: destination, 
            roleArn: roleArn, 
            sequenceStoreId: sequenceStoreId, 
            sources: sources
        )
        return try await self.startReadSetExportJob(input, logger: logger)
    }

    /// Starts a read set import job.
    @Sendable
    @inlinable
    public func startReadSetImportJob(_ input: StartReadSetImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReadSetImportJobResponse {
        try await self.client.execute(
            operation: "StartReadSetImportJob", 
            path: "/sequencestore/{sequenceStoreId}/importjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Starts a read set import job.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that jobs don't run multiple times, specify a unique token for each job.
    ///   - roleArn: A service role for the job.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - sources: The job's source files.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReadSetImportJob(
        clientToken: String? = nil,
        roleArn: String,
        sequenceStoreId: String,
        sources: [StartReadSetImportJobSourceItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartReadSetImportJobResponse {
        let input = StartReadSetImportJobRequest(
            clientToken: clientToken, 
            roleArn: roleArn, 
            sequenceStoreId: sequenceStoreId, 
            sources: sources
        )
        return try await self.startReadSetImportJob(input, logger: logger)
    }

    /// Starts a reference import job.
    @Sendable
    @inlinable
    public func startReferenceImportJob(_ input: StartReferenceImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReferenceImportJobResponse {
        try await self.client.execute(
            operation: "StartReferenceImportJob", 
            path: "/referencestore/{referenceStoreId}/importjob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Starts a reference import job.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that jobs don't run multiple times, specify a unique token for each job.
    ///   - referenceStoreId: The job's reference store ID.
    ///   - roleArn: A service role for the job.
    ///   - sources: The job's source files.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReferenceImportJob(
        clientToken: String? = nil,
        referenceStoreId: String,
        roleArn: String,
        sources: [StartReferenceImportJobSourceItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartReferenceImportJobResponse {
        let input = StartReferenceImportJobRequest(
            clientToken: clientToken, 
            referenceStoreId: referenceStoreId, 
            roleArn: roleArn, 
            sources: sources
        )
        return try await self.startReferenceImportJob(input, logger: logger)
    }

    /// Starts a workflow run. To duplicate a run, specify the run's ID and a role ARN. The remaining parameters are copied from the previous run. StartRun will not support re-run for a workflow that is shared with you. HealthOmics stores a fixed number of runs that are available to the console and API. By default, HealthOmics doesn't any remove any runs. If HealthOmics reaches the maximum  number of runs, you must manually remove runs. To have older runs removed automatically, set the retention mode to REMOVE. By default, the run uses STATIC storage. For STATIC storage, set the storageCapacity field.  You can set the storage type to DYNAMIC. You do not set storageCapacity, because HealthOmics dynamically scales the storage up or down as required. For more information about static and dynamic storage, see Running workflows  in the AWS HealthOmics User Guide.
    @Sendable
    @inlinable
    public func startRun(_ input: StartRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartRunResponse {
        try await self.client.execute(
            operation: "StartRun", 
            path: "/run", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Starts a workflow run. To duplicate a run, specify the run's ID and a role ARN. The remaining parameters are copied from the previous run. StartRun will not support re-run for a workflow that is shared with you. HealthOmics stores a fixed number of runs that are available to the console and API. By default, HealthOmics doesn't any remove any runs. If HealthOmics reaches the maximum  number of runs, you must manually remove runs. To have older runs removed automatically, set the retention mode to REMOVE. By default, the run uses STATIC storage. For STATIC storage, set the storageCapacity field.  You can set the storage type to DYNAMIC. You do not set storageCapacity, because HealthOmics dynamically scales the storage up or down as required. For more information about static and dynamic storage, see Running workflows  in the AWS HealthOmics User Guide.
    ///
    /// Parameters:
    ///   - cacheBehavior: The cache behavior for the run. You specify this value if you want to override the default behavior for the cache. You had set the default value when you created the cache. For more information, see Run cache behavior in the AWS HealthOmics User Guide.
    ///   - cacheId: Identifier of the cache associated with this run. If you don't specify a cache ID, no task outputs are cached  for this run.
    ///   - logLevel: A log level for the run.
    ///   - name: A name for the run.
    ///   - outputUri: An output URI for the run.
    ///   - parameters: Parameters for the run.
    ///   - priority: A priority for the run.
    ///   - requestId: To ensure that requests don't run multiple times, specify a unique ID for each request.
    ///   - retentionMode: The retention mode for the run. The default value is RETAIN.  HealthOmics stores a fixed number of runs that are available to the console and API.  In the default mode (RETAIN), you need to remove runs manually when the number of run exceeds the maximum. If you set the retention mode to REMOVE, HealthOmics automatically  removes runs (that have mode set to REMOVE) when the number of run exceeds the maximum. All run logs are available in CloudWatch logs, if you need information about a run that is no longer available to the API. For more information about retention mode, see Specifying run retention mode  in the AWS HealthOmics User Guide.
    ///   - roleArn: A service role for the run.
    ///   - runGroupId: The run's group ID.
    ///   - runId: The ID of a run to duplicate.
    ///   - storageCapacity: A storage capacity for the run in gibibytes. This field is not required if the storage type is dynamic (the system ignores any value that you enter).
    ///   - storageType: The run's storage type. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, HealthOmics dynamically scales the storage up  or down, based on file system utilization.
    ///   - tags: Tags for the run.
    ///   - workflowId: The run's workflow ID.
    ///   - workflowOwnerId: The ID of the workflow owner.
    ///   - workflowType: The run's workflow type.
    ///   - logger: Logger use during operation
    @inlinable
    public func startRun(
        cacheBehavior: CacheBehavior? = nil,
        cacheId: String? = nil,
        logLevel: RunLogLevel? = nil,
        name: String? = nil,
        outputUri: String? = nil,
        parameters: String? = nil,
        priority: Int? = nil,
        requestId: String = StartRunRequest.idempotencyToken(),
        retentionMode: RunRetentionMode? = nil,
        roleArn: String,
        runGroupId: String? = nil,
        runId: String? = nil,
        storageCapacity: Int? = nil,
        storageType: StorageType? = nil,
        tags: [String: String]? = nil,
        workflowId: String? = nil,
        workflowOwnerId: String? = nil,
        workflowType: WorkflowType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartRunResponse {
        let input = StartRunRequest(
            cacheBehavior: cacheBehavior, 
            cacheId: cacheId, 
            logLevel: logLevel, 
            name: name, 
            outputUri: outputUri, 
            parameters: parameters, 
            priority: priority, 
            requestId: requestId, 
            retentionMode: retentionMode, 
            roleArn: roleArn, 
            runGroupId: runGroupId, 
            runId: runId, 
            storageCapacity: storageCapacity, 
            storageType: storageType, 
            tags: tags, 
            workflowId: workflowId, 
            workflowOwnerId: workflowOwnerId, 
            workflowType: workflowType
        )
        return try await self.startRun(input, logger: logger)
    }

    /// Starts a variant import job.
    @Sendable
    @inlinable
    public func startVariantImportJob(_ input: StartVariantImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartVariantImportResponse {
        try await self.client.execute(
            operation: "StartVariantImportJob", 
            path: "/import/variant", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Starts a variant import job.
    ///
    /// Parameters:
    ///   - annotationFields: The annotation schema generated by the parsed annotation data.
    ///   - destinationName: The destination variant store for the job.
    ///   - items: Items to import.
    ///   - roleArn: A service role for the job.
    ///   - runLeftNormalization: The job's left normalization setting.
    ///   - logger: Logger use during operation
    @inlinable
    public func startVariantImportJob(
        annotationFields: [String: String]? = nil,
        destinationName: String,
        items: [VariantImportItemSource],
        roleArn: String,
        runLeftNormalization: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartVariantImportResponse {
        let input = StartVariantImportRequest(
            annotationFields: annotationFields, 
            destinationName: destinationName, 
            items: items, 
            roleArn: roleArn, 
            runLeftNormalization: runLeftNormalization
        )
        return try await self.startVariantImportJob(input, logger: logger)
    }

    /// Tags a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }
    /// Tags a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - tags: Tags for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tags-", 
            logger: logger
        )
    }
    /// Removes tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - tagKeys: Keys of tags to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an annotation store.
    @Sendable
    @inlinable
    public func updateAnnotationStore(_ input: UpdateAnnotationStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnnotationStoreResponse {
        try await self.client.execute(
            operation: "UpdateAnnotationStore", 
            path: "/annotationStore/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Updates an annotation store.
    ///
    /// Parameters:
    ///   - description: A description for the store.
    ///   - name: A name for the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAnnotationStore(
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAnnotationStoreResponse {
        let input = UpdateAnnotationStoreRequest(
            description: description, 
            name: name
        )
        return try await self.updateAnnotationStore(input, logger: logger)
    }

    /// Updates the description of an annotation store version.
    @Sendable
    @inlinable
    public func updateAnnotationStoreVersion(_ input: UpdateAnnotationStoreVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnnotationStoreVersionResponse {
        try await self.client.execute(
            operation: "UpdateAnnotationStoreVersion", 
            path: "/annotationStore/{name}/version/{versionName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Updates the description of an annotation store version.
    ///
    /// Parameters:
    ///   - description: The description of an annotation store.
    ///   - name: The name of an annotation store.
    ///   - versionName: The name of an annotation store version.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAnnotationStoreVersion(
        description: String? = nil,
        name: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAnnotationStoreVersionResponse {
        let input = UpdateAnnotationStoreVersionRequest(
            description: description, 
            name: name, 
            versionName: versionName
        )
        return try await self.updateAnnotationStoreVersion(input, logger: logger)
    }

    /// Update a run cache.
    @Sendable
    @inlinable
    public func updateRunCache(_ input: UpdateRunCacheRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateRunCache", 
            path: "/runCache/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Update a run cache.
    ///
    /// Parameters:
    ///   - cacheBehavior: Update the default run cache behavior.
    ///   - description: Update the run cache description.
    ///   - id: The identifier of the run cache you want to update.
    ///   - name: Update the name of the run cache.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRunCache(
        cacheBehavior: CacheBehavior? = nil,
        description: String? = nil,
        id: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateRunCacheRequest(
            cacheBehavior: cacheBehavior, 
            description: description, 
            id: id, 
            name: name
        )
        return try await self.updateRunCache(input, logger: logger)
    }

    /// Updates a run group.
    @Sendable
    @inlinable
    public func updateRunGroup(_ input: UpdateRunGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateRunGroup", 
            path: "/runGroup/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Updates a run group.
    ///
    /// Parameters:
    ///   - id: The group's ID.
    ///   - maxCpus: The maximum number of CPUs to use.
    ///   - maxDuration: A maximum run time for the group in minutes.
    ///   - maxGpus: The maximum GPUs that can be used by a run group.
    ///   - maxRuns: The maximum number of concurrent runs for the group.
    ///   - name: A name for the group.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRunGroup(
        id: String,
        maxCpus: Int? = nil,
        maxDuration: Int? = nil,
        maxGpus: Int? = nil,
        maxRuns: Int? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateRunGroupRequest(
            id: id, 
            maxCpus: maxCpus, 
            maxDuration: maxDuration, 
            maxGpus: maxGpus, 
            maxRuns: maxRuns, 
            name: name
        )
        return try await self.updateRunGroup(input, logger: logger)
    }

    /// Update one or more parameters for the sequence store.
    @Sendable
    @inlinable
    public func updateSequenceStore(_ input: UpdateSequenceStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSequenceStoreResponse {
        try await self.client.execute(
            operation: "UpdateSequenceStore", 
            path: "/sequencestore/{id}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "control-storage-", 
            logger: logger
        )
    }
    /// Update one or more parameters for the sequence store.
    ///
    /// Parameters:
    ///   - clientToken: To ensure that requests don't run multiple times, specify a unique token for each request.
    ///   - description: A description for the sequence store.
    ///   - fallbackLocation: The S3 URI of a bucket and folder to store Read Sets that fail to upload.
    ///   - id: The ID of the sequence store.
    ///   - name: A name for the sequence store.
    ///   - propagatedSetLevelTags: The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
    ///   - s3AccessConfig: S3 access configuration parameters.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSequenceStore(
        clientToken: String? = UpdateSequenceStoreRequest.idempotencyToken(),
        description: String? = nil,
        fallbackLocation: String? = nil,
        id: String,
        name: String? = nil,
        propagatedSetLevelTags: [String]? = nil,
        s3AccessConfig: S3AccessConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSequenceStoreResponse {
        let input = UpdateSequenceStoreRequest(
            clientToken: clientToken, 
            description: description, 
            fallbackLocation: fallbackLocation, 
            id: id, 
            name: name, 
            propagatedSetLevelTags: propagatedSetLevelTags, 
            s3AccessConfig: s3AccessConfig
        )
        return try await self.updateSequenceStore(input, logger: logger)
    }

    /// Updates a variant store.
    @Sendable
    @inlinable
    public func updateVariantStore(_ input: UpdateVariantStoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVariantStoreResponse {
        try await self.client.execute(
            operation: "UpdateVariantStore", 
            path: "/variantStore/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "analytics-", 
            logger: logger
        )
    }
    /// Updates a variant store.
    ///
    /// Parameters:
    ///   - description: A description for the store.
    ///   - name: A name for the store.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVariantStore(
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVariantStoreResponse {
        let input = UpdateVariantStoreRequest(
            description: description, 
            name: name
        )
        return try await self.updateVariantStore(input, logger: logger)
    }

    /// Updates a workflow.
    @Sendable
    @inlinable
    public func updateWorkflow(_ input: UpdateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateWorkflow", 
            path: "/workflow/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "workflows-", 
            logger: logger
        )
    }
    /// Updates a workflow.
    ///
    /// Parameters:
    ///   - description: A description for the workflow.
    ///   - id: The workflow's ID.
    ///   - name: A name for the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkflow(
        description: String? = nil,
        id: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateWorkflowRequest(
            description: description, 
            id: id, 
            name: name
        )
        return try await self.updateWorkflow(input, logger: logger)
    }

    /// This operation uploads a specific part of a read set. If you upload a new part using a previously used part number,  the previously uploaded part will be overwritten.
    @Sendable
    @inlinable
    public func uploadReadSetPart(_ input: UploadReadSetPartRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UploadReadSetPartResponse {
        try await self.client.execute(
            operation: "UploadReadSetPart", 
            path: "/sequencestore/{sequenceStoreId}/upload/{uploadId}/part", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "storage-", 
            logger: logger
        )
    }
    /// This operation uploads a specific part of a read set. If you upload a new part using a previously used part number,  the previously uploaded part will be overwritten.
    ///
    /// Parameters:
    ///   - partNumber: The number of the part being uploaded.
    ///   - partSource: The source file for an upload part.
    ///   - payload: The read set data to upload for a part.
    ///   - sequenceStoreId: The Sequence Store ID used for the multipart upload.
    ///   - uploadId: The ID for the initiated multipart upload.
    ///   - logger: Logger use during operation
    @inlinable
    public func uploadReadSetPart(
        partNumber: Int,
        partSource: ReadSetPartSource,
        payload: AWSHTTPBody,
        sequenceStoreId: String,
        uploadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UploadReadSetPartResponse {
        let input = UploadReadSetPartRequest(
            partNumber: partNumber, 
            partSource: partSource, 
            payload: payload, 
            sequenceStoreId: sequenceStoreId, 
            uploadId: uploadId
        )
        return try await self.uploadReadSetPart(input, logger: logger)
    }
}

extension Omics {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Omics, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    /// Return PaginatorSequence for operation ``listAnnotationImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationImportJobsPaginator(
        _ input: ListAnnotationImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationImportJobsRequest, ListAnnotationImportJobsResponse> {
        return .init(
            input: input,
            command: self.listAnnotationImportJobs,
            inputKey: \ListAnnotationImportJobsRequest.nextToken,
            outputKey: \ListAnnotationImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAnnotationImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: IDs of annotation import jobs to retrieve.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationImportJobsPaginator(
        filter: ListAnnotationImportJobsFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAnnotationImportJobsRequest, ListAnnotationImportJobsResponse> {
        let input = ListAnnotationImportJobsRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults
        )
        return self.listAnnotationImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAnnotationStoreVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationStoreVersionsPaginator(
        _ input: ListAnnotationStoreVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoreVersionsRequest, ListAnnotationStoreVersionsResponse> {
        return .init(
            input: input,
            command: self.listAnnotationStoreVersions,
            inputKey: \ListAnnotationStoreVersionsRequest.nextToken,
            outputKey: \ListAnnotationStoreVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAnnotationStoreVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list of annotation store versions.
    ///   - maxResults: The maximum number of annotation store versions to return in one page of results.
    ///   - name: The name of an annotation store.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationStoreVersionsPaginator(
        filter: ListAnnotationStoreVersionsFilter? = nil,
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoreVersionsRequest, ListAnnotationStoreVersionsResponse> {
        let input = ListAnnotationStoreVersionsRequest(
            filter: filter, 
            maxResults: maxResults, 
            name: name
        )
        return self.listAnnotationStoreVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAnnotationStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationStoresPaginator(
        _ input: ListAnnotationStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoresRequest, ListAnnotationStoresResponse> {
        return .init(
            input: input,
            command: self.listAnnotationStores,
            inputKey: \ListAnnotationStoresRequest.nextToken,
            outputKey: \ListAnnotationStoresResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAnnotationStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: IDs of stores to list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnnotationStoresPaginator(
        filter: ListAnnotationStoresFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAnnotationStoresRequest, ListAnnotationStoresResponse> {
        let input = ListAnnotationStoresRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults
        )
        return self.listAnnotationStoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMultipartReadSetUploads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultipartReadSetUploadsPaginator(
        _ input: ListMultipartReadSetUploadsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMultipartReadSetUploadsRequest, ListMultipartReadSetUploadsResponse> {
        return .init(
            input: input,
            command: self.listMultipartReadSetUploads,
            inputKey: \ListMultipartReadSetUploadsRequest.nextToken,
            outputKey: \ListMultipartReadSetUploadsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMultipartReadSetUploads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of multipart uploads returned in a page.
    ///   - sequenceStoreId: The Sequence Store ID used for the multipart uploads.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultipartReadSetUploadsPaginator(
        maxResults: Int? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMultipartReadSetUploadsRequest, ListMultipartReadSetUploadsResponse> {
        let input = ListMultipartReadSetUploadsRequest(
            maxResults: maxResults, 
            sequenceStoreId: sequenceStoreId
        )
        return self.listMultipartReadSetUploadsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReadSetActivationJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetActivationJobsPaginator(
        _ input: ListReadSetActivationJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetActivationJobsRequest, ListReadSetActivationJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetActivationJobs,
            inputKey: \ListReadSetActivationJobsRequest.nextToken,
            outputKey: \ListReadSetActivationJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReadSetActivationJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of read set activation jobs to return in one page of results.
    ///   - sequenceStoreId: The read set's sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetActivationJobsPaginator(
        filter: ActivateReadSetFilter? = nil,
        maxResults: Int? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReadSetActivationJobsRequest, ListReadSetActivationJobsResponse> {
        let input = ListReadSetActivationJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sequenceStoreId: sequenceStoreId
        )
        return self.listReadSetActivationJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReadSetExportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetExportJobsPaginator(
        _ input: ListReadSetExportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetExportJobsRequest, ListReadSetExportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetExportJobs,
            inputKey: \ListReadSetExportJobsRequest.nextToken,
            outputKey: \ListReadSetExportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReadSetExportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetExportJobsPaginator(
        filter: ExportReadSetFilter? = nil,
        maxResults: Int? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReadSetExportJobsRequest, ListReadSetExportJobsResponse> {
        let input = ListReadSetExportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sequenceStoreId: sequenceStoreId
        )
        return self.listReadSetExportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReadSetImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetImportJobsPaginator(
        _ input: ListReadSetImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetImportJobsRequest, ListReadSetImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReadSetImportJobs,
            inputKey: \ListReadSetImportJobsRequest.nextToken,
            outputKey: \ListReadSetImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReadSetImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetImportJobsPaginator(
        filter: ImportReadSetFilter? = nil,
        maxResults: Int? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReadSetImportJobsRequest, ListReadSetImportJobsResponse> {
        let input = ListReadSetImportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sequenceStoreId: sequenceStoreId
        )
        return self.listReadSetImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReadSetUploadParts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetUploadPartsPaginator(
        _ input: ListReadSetUploadPartsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetUploadPartsRequest, ListReadSetUploadPartsResponse> {
        return .init(
            input: input,
            command: self.listReadSetUploadParts,
            inputKey: \ListReadSetUploadPartsRequest.nextToken,
            outputKey: \ListReadSetUploadPartsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReadSetUploadParts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: Attributes used to filter for a specific subset of read set part uploads.
    ///   - maxResults: The maximum number of read set upload parts returned in a page.
    ///   - partSource: The source file for the upload part.
    ///   - sequenceStoreId: The Sequence Store ID used for the multipart uploads.
    ///   - uploadId: The ID for the initiated multipart upload.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetUploadPartsPaginator(
        filter: ReadSetUploadPartListFilter? = nil,
        maxResults: Int? = nil,
        partSource: ReadSetPartSource,
        sequenceStoreId: String,
        uploadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReadSetUploadPartsRequest, ListReadSetUploadPartsResponse> {
        let input = ListReadSetUploadPartsRequest(
            filter: filter, 
            maxResults: maxResults, 
            partSource: partSource, 
            sequenceStoreId: sequenceStoreId, 
            uploadId: uploadId
        )
        return self.listReadSetUploadPartsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReadSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetsPaginator(
        _ input: ListReadSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReadSetsRequest, ListReadSetsResponse> {
        return .init(
            input: input,
            command: self.listReadSets,
            inputKey: \ListReadSetsRequest.nextToken,
            outputKey: \ListReadSetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReadSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of read sets to return in one page of results.
    ///   - sequenceStoreId: The jobs' sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReadSetsPaginator(
        filter: ReadSetFilter? = nil,
        maxResults: Int? = nil,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReadSetsRequest, ListReadSetsResponse> {
        let input = ListReadSetsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sequenceStoreId: sequenceStoreId
        )
        return self.listReadSetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReferenceImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferenceImportJobsPaginator(
        _ input: ListReferenceImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferenceImportJobsRequest, ListReferenceImportJobsResponse> {
        return .init(
            input: input,
            command: self.listReferenceImportJobs,
            inputKey: \ListReferenceImportJobsRequest.nextToken,
            outputKey: \ListReferenceImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReferenceImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of jobs to return in one page of results.
    ///   - referenceStoreId: The job's reference store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferenceImportJobsPaginator(
        filter: ImportReferenceFilter? = nil,
        maxResults: Int? = nil,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReferenceImportJobsRequest, ListReferenceImportJobsResponse> {
        let input = ListReferenceImportJobsRequest(
            filter: filter, 
            maxResults: maxResults, 
            referenceStoreId: referenceStoreId
        )
        return self.listReferenceImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReferenceStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferenceStoresPaginator(
        _ input: ListReferenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferenceStoresRequest, ListReferenceStoresResponse> {
        return .init(
            input: input,
            command: self.listReferenceStores,
            inputKey: \ListReferenceStoresRequest.nextToken,
            outputKey: \ListReferenceStoresResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReferenceStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferenceStoresPaginator(
        filter: ReferenceStoreFilter? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReferenceStoresRequest, ListReferenceStoresResponse> {
        let input = ListReferenceStoresRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listReferenceStoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReferences(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferencesPaginator(
        _ input: ListReferencesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReferencesRequest, ListReferencesResponse> {
        return .init(
            input: input,
            command: self.listReferences,
            inputKey: \ListReferencesRequest.nextToken,
            outputKey: \ListReferencesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReferences(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of references to return in one page of results.
    ///   - referenceStoreId: The references' reference store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReferencesPaginator(
        filter: ReferenceFilter? = nil,
        maxResults: Int? = nil,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReferencesRequest, ListReferencesResponse> {
        let input = ListReferencesRequest(
            filter: filter, 
            maxResults: maxResults, 
            referenceStoreId: referenceStoreId
        )
        return self.listReferencesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRunCaches(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunCachesPaginator(
        _ input: ListRunCachesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunCachesRequest, ListRunCachesResponse> {
        return .init(
            input: input,
            command: self.listRunCaches,
            inputKey: \ListRunCachesRequest.startingToken,
            outputKey: \ListRunCachesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRunCaches(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunCachesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRunCachesRequest, ListRunCachesResponse> {
        let input = ListRunCachesRequest(
            maxResults: maxResults
        )
        return self.listRunCachesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRunGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunGroupsPaginator(
        _ input: ListRunGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunGroupsRequest, ListRunGroupsResponse> {
        return .init(
            input: input,
            command: self.listRunGroups,
            inputKey: \ListRunGroupsRequest.startingToken,
            outputKey: \ListRunGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRunGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of run groups to return in one page of results.
    ///   - name: The run groups' name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunGroupsPaginator(
        maxResults: Int? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRunGroupsRequest, ListRunGroupsResponse> {
        let input = ListRunGroupsRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listRunGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRunTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunTasksPaginator(
        _ input: ListRunTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunTasksRequest, ListRunTasksResponse> {
        return .init(
            input: input,
            command: self.listRunTasks,
            inputKey: \ListRunTasksRequest.startingToken,
            outputKey: \ListRunTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRunTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The run's ID.
    ///   - maxResults: The maximum number of run tasks to return in one page of results.
    ///   - status: Filter the list by status.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunTasksPaginator(
        id: String,
        maxResults: Int? = nil,
        status: TaskStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRunTasksRequest, ListRunTasksResponse> {
        let input = ListRunTasksRequest(
            id: id, 
            maxResults: maxResults, 
            status: status
        )
        return self.listRunTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunsPaginator(
        _ input: ListRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRunsRequest, ListRunsResponse> {
        return .init(
            input: input,
            command: self.listRuns,
            inputKey: \ListRunsRequest.startingToken,
            outputKey: \ListRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of runs to return in one page of results.
    ///   - name: Filter the list by run name.
    ///   - runGroupId: Filter the list by run group ID.
    ///   - status: The status of a run.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRunsPaginator(
        maxResults: Int? = nil,
        name: String? = nil,
        runGroupId: String? = nil,
        status: RunStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRunsRequest, ListRunsResponse> {
        let input = ListRunsRequest(
            maxResults: maxResults, 
            name: name, 
            runGroupId: runGroupId, 
            status: status
        )
        return self.listRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSequenceStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSequenceStoresPaginator(
        _ input: ListSequenceStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSequenceStoresRequest, ListSequenceStoresResponse> {
        return .init(
            input: input,
            command: self.listSequenceStores,
            inputKey: \ListSequenceStoresRequest.nextToken,
            outputKey: \ListSequenceStoresResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSequenceStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSequenceStoresPaginator(
        filter: SequenceStoreFilter? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSequenceStoresRequest, ListSequenceStoresResponse> {
        let input = ListSequenceStoresRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listSequenceStoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSharesPaginator(
        _ input: ListSharesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSharesRequest, ListSharesResponse> {
        return .init(
            input: input,
            command: self.listShares,
            inputKey: \ListSharesRequest.nextToken,
            outputKey: \ListSharesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: Attributes that you use to filter for a specific subset of resource shares.
    ///   - maxResults: The maximum number of shares to return in one page of results.
    ///   - resourceOwner: The account that owns the resource shares.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSharesPaginator(
        filter: Filter? = nil,
        maxResults: Int? = nil,
        resourceOwner: ResourceOwner,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSharesRequest, ListSharesResponse> {
        let input = ListSharesRequest(
            filter: filter, 
            maxResults: maxResults, 
            resourceOwner: resourceOwner
        )
        return self.listSharesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVariantImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVariantImportJobsPaginator(
        _ input: ListVariantImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVariantImportJobsRequest, ListVariantImportJobsResponse> {
        return .init(
            input: input,
            command: self.listVariantImportJobs,
            inputKey: \ListVariantImportJobsRequest.nextToken,
            outputKey: \ListVariantImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVariantImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: A list of job IDs.
    ///   - maxResults: The maximum number of import jobs to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVariantImportJobsPaginator(
        filter: ListVariantImportJobsFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVariantImportJobsRequest, ListVariantImportJobsResponse> {
        let input = ListVariantImportJobsRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults
        )
        return self.listVariantImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVariantStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVariantStoresPaginator(
        _ input: ListVariantStoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVariantStoresRequest, ListVariantStoresResponse> {
        return .init(
            input: input,
            command: self.listVariantStores,
            inputKey: \ListVariantStoresRequest.nextToken,
            outputKey: \ListVariantStoresResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVariantStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A filter to apply to the list.
    ///   - ids: A list of store IDs.
    ///   - maxResults: The maximum number of stores to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVariantStoresPaginator(
        filter: ListVariantStoresFilter? = nil,
        ids: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVariantStoresRequest, ListVariantStoresResponse> {
        let input = ListVariantStoresRequest(
            filter: filter, 
            ids: ids, 
            maxResults: maxResults
        )
        return self.listVariantStoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.startingToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of workflows to return in one page of results.
    ///   - name: Filter the list by workflow name.
    ///   - type: Filter the list by workflow type.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        maxResults: Int? = nil,
        name: String? = nil,
        type: WorkflowType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        let input = ListWorkflowsRequest(
            maxResults: maxResults, 
            name: name, 
            type: type
        )
        return self.listWorkflowsPaginator(input, logger: logger)
    }
}

extension Omics.ListAnnotationImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationImportJobsRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListAnnotationStoreVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationStoreVersionsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension Omics.ListAnnotationStoresRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListAnnotationStoresRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListMultipartReadSetUploadsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListMultipartReadSetUploadsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetActivationJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetActivationJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetExportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetExportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetImportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReadSetUploadPartsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetUploadPartsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            partSource: self.partSource,
            sequenceStoreId: self.sequenceStoreId,
            uploadId: self.uploadId
        )
    }
}

extension Omics.ListReadSetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReadSetsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sequenceStoreId: self.sequenceStoreId
        )
    }
}

extension Omics.ListReferenceImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReferenceImportJobsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            referenceStoreId: self.referenceStoreId
        )
    }
}

extension Omics.ListReferenceStoresRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReferenceStoresRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListReferencesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListReferencesRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            referenceStoreId: self.referenceStoreId
        )
    }
}

extension Omics.ListRunCachesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListRunCachesRequest {
        return .init(
            maxResults: self.maxResults,
            startingToken: token
        )
    }
}

extension Omics.ListRunGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListRunGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            startingToken: token
        )
    }
}

extension Omics.ListRunTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListRunTasksRequest {
        return .init(
            id: self.id,
            maxResults: self.maxResults,
            startingToken: token,
            status: self.status
        )
    }
}

extension Omics.ListRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListRunsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            runGroupId: self.runGroupId,
            startingToken: token,
            status: self.status
        )
    }
}

extension Omics.ListSequenceStoresRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListSequenceStoresRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListSharesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListSharesRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            resourceOwner: self.resourceOwner
        )
    }
}

extension Omics.ListVariantImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListVariantImportJobsRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListVariantStoresRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListVariantStoresRequest {
        return .init(
            filter: self.filter,
            ids: self.ids,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Omics.ListWorkflowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Omics.ListWorkflowsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            startingToken: token,
            type: self.type
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Omics {
    /// Waiter for operation ``getAnnotationImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationImportJobCreated(
        _ input: GetAnnotationImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetAnnotationImportRequest, _>(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getAnnotationImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationImportJobCreated(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetAnnotationImportRequest(
            jobId: jobId
        )
        try await self.waitUntilAnnotationImportJobCreated(input, logger: logger)
    }

    /// Waiter for operation ``getAnnotationStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreCreated(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetAnnotationStoreRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getAnnotationStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreCreated(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetAnnotationStoreRequest(
            name: name
        )
        try await self.waitUntilAnnotationStoreCreated(input, logger: logger)
    }

    /// Waiter for operation ``getAnnotationStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreDeleted(
        _ input: GetAnnotationStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetAnnotationStoreRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getAnnotationStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreDeleted(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetAnnotationStoreRequest(
            name: name
        )
        try await self.waitUntilAnnotationStoreDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getAnnotationStoreVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreVersionCreated(
        _ input: GetAnnotationStoreVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetAnnotationStoreVersionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStoreVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getAnnotationStoreVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The name given to an annotation store version to distinguish it from others.
    ///   - versionName: The name given to an annotation store version to distinguish it from others.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreVersionCreated(
        name: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetAnnotationStoreVersionRequest(
            name: name, 
            versionName: versionName
        )
        try await self.waitUntilAnnotationStoreVersionCreated(input, logger: logger)
    }

    /// Waiter for operation ``getAnnotationStoreVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreVersionDeleted(
        _ input: GetAnnotationStoreVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetAnnotationStoreVersionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getAnnotationStoreVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getAnnotationStoreVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The name given to an annotation store version to distinguish it from others.
    ///   - versionName: The name given to an annotation store version to distinguish it from others.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilAnnotationStoreVersionDeleted(
        name: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetAnnotationStoreVersionRequest(
            name: name, 
            versionName: versionName
        )
        try await self.waitUntilAnnotationStoreVersionDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getReadSetActivationJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetActivationJobCompleted(
        _ input: GetReadSetActivationJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReadSetActivationJobRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetActivationJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReadSetActivationJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetActivationJobCompleted(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReadSetActivationJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        try await self.waitUntilReadSetActivationJobCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getReadSetExportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetExportJobCompleted(
        _ input: GetReadSetExportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReadSetExportJobRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetExportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReadSetExportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetExportJobCompleted(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReadSetExportJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        try await self.waitUntilReadSetExportJobCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getReadSetImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetImportJobCompleted(
        _ input: GetReadSetImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReadSetImportJobRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReadSetImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReadSetImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The job's ID.
    ///   - sequenceStoreId: The job's sequence store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReadSetImportJobCompleted(
        id: String,
        sequenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReadSetImportJobRequest(
            id: id, 
            sequenceStoreId: sequenceStoreId
        )
        try await self.waitUntilReadSetImportJobCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getReferenceImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReferenceImportJobCompleted(
        _ input: GetReferenceImportJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReferenceImportJobRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "COMPLETED_WITH_FAILURES")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getReferenceImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReferenceImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The job's ID.
    ///   - referenceStoreId: The job's reference store ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilReferenceImportJobCompleted(
        id: String,
        referenceStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReferenceImportJobRequest(
            id: id, 
            referenceStoreId: referenceStoreId
        )
        try await self.waitUntilReferenceImportJobCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getRun(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRunCompleted(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRunRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRun(_:logger:)``.
    ///
    /// - Parameters:
    ///   - export: The run's export format.
    ///   - id: The run's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRunCompleted(
        export: [RunExport]? = nil,
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRunRequest(
            export: export, 
            id: id
        )
        try await self.waitUntilRunCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getRun(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRunRunning(
        _ input: GetRunRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRunRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRun
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRun(_:logger:)``.
    ///
    /// - Parameters:
    ///   - export: The run's export format.
    ///   - id: The run's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilRunRunning(
        export: [RunExport]? = nil,
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRunRequest(
            export: export, 
            id: id
        )
        try await self.waitUntilRunRunning(input, logger: logger)
    }

    /// Waiter for operation ``getRunTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilTaskCompleted(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRunTaskRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STOPPING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRunTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The workflow run ID.
    ///   - taskId: The task's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilTaskCompleted(
        id: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRunTaskRequest(
            id: id, 
            taskId: taskId
        )
        try await self.waitUntilTaskCompleted(input, logger: logger)
    }

    /// Waiter for operation ``getRunTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilTaskRunning(
        _ input: GetRunTaskRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetRunTaskRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "PENDING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "STARTING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getRunTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getRunTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The workflow run ID.
    ///   - taskId: The task's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilTaskRunning(
        id: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetRunTaskRequest(
            id: id, 
            taskId: taskId
        )
        try await self.waitUntilTaskRunning(input, logger: logger)
    }

    /// Waiter for operation ``getVariantImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantImportJobCreated(
        _ input: GetVariantImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetVariantImportRequest, _>(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "SUBMITTED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "COMPLETED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantImportJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getVariantImportJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantImportJobCreated(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetVariantImportRequest(
            jobId: jobId
        )
        try await self.waitUntilVariantImportJobCreated(input, logger: logger)
    }

    /// Waiter for operation ``getVariantStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantStoreCreated(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetVariantStoreRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getVariantStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantStoreCreated(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetVariantStoreRequest(
            name: name
        )
        try await self.waitUntilVariantStoreCreated(input, logger: logger)
    }

    /// Waiter for operation ``getVariantStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantStoreDeleted(
        _ input: GetVariantStoreRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetVariantStoreRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "DELETED")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(600),
            command: self.getVariantStore
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getVariantStore(_:logger:)``.
    ///
    /// - Parameters:
    ///   - name: The store's name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilVariantStoreDeleted(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetVariantStoreRequest(
            name: name
        )
        try await self.waitUntilVariantStoreDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getWorkflow(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkflowActive(
        _ input: GetWorkflowRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetWorkflowRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(3),
            maxDelayTime: .seconds(30),
            command: self.getWorkflow
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getWorkflow(_:logger:)``.
    ///
    /// - Parameters:
    ///   - export: The export format for the workflow.
    ///   - id: The workflow's ID.
    ///   - type: The workflow's type.
    ///   - workflowOwnerId: The ID of the workflow owner.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkflowActive(
        export: [WorkflowExport]? = nil,
        id: String,
        type: WorkflowType? = nil,
        workflowOwnerId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetWorkflowRequest(
            export: export, 
            id: id, 
            type: type, 
            workflowOwnerId: workflowOwnerId
        )
        try await self.waitUntilWorkflowActive(input, logger: logger)
    }
}
