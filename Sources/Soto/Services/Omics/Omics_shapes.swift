//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Omics {
    // MARK: Enums

    public enum Accelerators: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gpu = "GPU"
        public var description: String { return self.rawValue }
    }

    public enum AnnotationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Contains contig and 1-base position
        case chrPos = "CHR_POS"
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt = "CHR_POS_REF_ALT"
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase = "CHR_START_END_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase = "CHR_START_END_REF_ALT_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase = "CHR_START_END_REF_ALT_ZERO_BASE"
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase = "CHR_START_END_ZERO_BASE"
        /// Generic text file. No genomic information
        case generic = "GENERIC"
        public var description: String { return self.rawValue }
    }

    public enum CreationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        case upload = "UPLOAD"
        public var description: String { return self.rawValue }
    }

    public enum ETagAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bamMd5Up = "BAM_MD5up"
        case cramMd5Up = "CRAM_MD5up"
        case fastqMd5Up = "FASTQ_MD5up"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// KMS
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bam = "BAM"
        case cram = "CRAM"
        case fastq = "FASTQ"
        case ubam = "UBAM"
        public var description: String { return self.rawValue }
    }

    public enum FormatToHeaderKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alt = "ALT"
        case chr = "CHR"
        case end = "END"
        case pos = "POS"
        case ref = "REF"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Job was cancelled
        case cancelled = "CANCELLED"
        /// The Job has completed
        case completed = "COMPLETED"
        /// The Job completed with failed runs
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        /// The Job failed
        case failed = "FAILED"
        /// The Job is executing
        case inProgress = "IN_PROGRESS"
        /// The Job has been submitted to run
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetFile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case index = "INDEX"
        case source1 = "SOURCE1"
        case source2 = "SOURCE2"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetPartSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source1 = "SOURCE1"
        case source2 = "SOURCE2"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case processingUpload = "PROCESSING_UPLOAD"
        case uploadFailed = "UPLOAD_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceFile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case index = "INDEX"
        case source = "SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceOwner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The resource owner is an account other than the caller
        case other = "OTHER"
        /// The resource owner is the calling account
        case _self = "SELF"
        public var description: String { return self.rawValue }
    }

    public enum RunExport: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum RunLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case error = "ERROR"
        case fatal = "FATAL"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum RunRetentionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case remove = "REMOVE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum RunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// BOOLEAN type
        case boolean = "BOOLEAN"
        /// DOUBLE type
        case double = "DOUBLE"
        /// FLOAT type
        case float = "FLOAT"
        /// INT type
        case int = "INT"
        /// LONG type
        case long = "LONG"
        /// STRING type
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ShareStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The share is activated
        case activating = "ACTIVATING"
        /// The share is active and can be used
        case active = "ACTIVE"
        /// The share has been deleted
        case deleted = "DELETED"
        /// The share is being deleted
        case deleting = "DELETING"
        /// The share has failed to activate or delete
        case failed = "FAILED"
        /// The share has been created but is not yet active
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum StoreFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// GFF3 Format
        case gff = "GFF"
        /// TSV Format
        case tsv = "TSV"
        /// VCF Format
        case vcf = "VCF"
        public var description: String { return self.rawValue }
    }

    public enum StoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Store is active
        case active = "ACTIVE"
        /// The Store is being created
        case creating = "CREATING"
        /// The Store is deleting
        case deleting = "DELETING"
        /// The Store creation failed
        case failed = "FAILED"
        /// The Store is updating
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum VersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Version is active
        case active = "ACTIVE"
        /// The Version is being created
        case creating = "CREATING"
        /// The Version is deleting
        case deleting = "DELETING"
        /// The Version creation failed
        case failed = "FAILED"
        /// The Version is updating
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cwl = "CWL"
        case nextflow = "NEXTFLOW"
        case wdl = "WDL"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowExport: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case ready2run = "READY2RUN"
        public var description: String { return self.rawValue }
    }

    public enum FormatOptions: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Options for a TSV file.
        case tsvOptions(TsvOptions)
        /// Options for a VCF file.
        case vcfOptions(VcfOptions)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .tsvOptions:
                let value = try container.decode(TsvOptions.self, forKey: .tsvOptions)
                self = .tsvOptions(value)
            case .vcfOptions:
                let value = try container.decode(VcfOptions.self, forKey: .vcfOptions)
                self = .vcfOptions(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .tsvOptions(let value):
                try container.encode(value, forKey: .tsvOptions)
            case .vcfOptions(let value):
                try container.encode(value, forKey: .vcfOptions)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .tsvOptions(let value):
                try value.validate(name: "\(name).tsvOptions")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tsvOptions = "tsvOptions"
            case vcfOptions = "vcfOptions"
        }
    }

    // MARK: Shapes

    public struct AbortMultipartReadSetUploadRequest: AWSEncodableShape {
        ///  The sequence store ID for the store involved in the multipart upload.
        public let sequenceStoreId: String
        ///  The ID for the multipart upload.
        public let uploadId: String

        public init(sequenceStoreId: String, uploadId: String) {
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AbortMultipartReadSetUploadResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptShareRequest: AWSEncodableShape {
        /// The ID for a share offer for analytics store data.
        public let shareId: String

        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptShareResponse: AWSDecodableShape {
        /// The status of an analytics store share.
        public let status: ShareStatus?

        public init(status: ShareStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ActivateReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The filter's status.
        public let status: ReadSetActivationJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetActivationJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ActivateReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct ActivateReadSetSourceItem: AWSDecodableShape {
        /// The source's read set ID.
        public let readSetId: String
        /// The source's status.
        public let status: ReadSetActivationJobItemStatus
        /// The source's status message.
        public let statusMessage: String?

        public init(readSetId: String, status: ReadSetActivationJobItemStatus, statusMessage: String? = nil) {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct AnnotationImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String

        public init(jobStatus: JobStatus, source: String) {
            self.jobStatus = jobStatus
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "jobStatus"
            case source = "source"
        }
    }

    public struct AnnotationImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct AnnotationImportJobItem: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of the annotation store version.
        public let versionName: String

        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date, versionName: String) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct AnnotationStoreItem: AWSDecodableShape {
        /// The store's creation time.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's file format.
        public let storeFormat: StoreFormat
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeFormat = "storeFormat"
            case storeSizeBytes = "storeSizeBytes"
            case updateTime = "updateTime"
        }
    }

    public struct AnnotationStoreVersionItem: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// A name given to an annotation store version to distinguish it from others.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The status of an annotation store version.
        public let statusMessage: String
        /// The store ID for an annotation store version.
        public let storeId: String
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The Arn for an annotation store version.
        public let versionArn: String
        /// The name of an annotation store version.
        public let versionName: String
        /// The size of an annotation store version in Bytes.
        public let versionSizeBytes: Int64

        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, statusMessage: String, storeId: String, updateTime: Date, versionArn: String, versionName: String, versionSizeBytes: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionSizeBytes = versionSizeBytes
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeId = "storeId"
            case updateTime = "updateTime"
            case versionArn = "versionArn"
            case versionName = "versionName"
            case versionSizeBytes = "versionSizeBytes"
        }
    }

    public struct BatchDeleteReadSetRequest: AWSEncodableShape {
        /// The read sets' IDs.
        public let ids: [String]
        /// The read sets' sequence store ID.
        public let sequenceStoreId: String

        public init(ids: [String], sequenceStoreId: String) {
            self.ids = ids
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.ids, forKey: .ids)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 10)
                try validate($0, name: "ids[]", parent: name, pattern: "^[0-9]+$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
        }
    }

    public struct BatchDeleteReadSetResponse: AWSDecodableShape {
        /// Errors returned by individual delete operations.
        public let errors: [ReadSetBatchError]?

        public init(errors: [ReadSetBatchError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct CancelAnnotationImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelAnnotationImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelRunRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CompleteMultipartReadSetUploadRequest: AWSEncodableShape {
        ///  The individual uploads or parts of a multipart upload.
        public let parts: [CompleteReadSetUploadPartListItem]
        ///  The sequence store ID for the store involved in the multipart upload.
        public let sequenceStoreId: String
        ///  The ID for the multipart upload.
        public let uploadId: String

        public init(parts: [CompleteReadSetUploadPartListItem], sequenceStoreId: String, uploadId: String) {
            self.parts = parts
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.parts, forKey: .parts)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parts = "parts"
        }
    }

    public struct CompleteMultipartReadSetUploadResponse: AWSDecodableShape {
        ///  The read set ID created for an uploaded read set.
        public let readSetId: String

        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct CompleteReadSetUploadPartListItem: AWSEncodableShape {
        ///  A unique identifier used to confirm that parts are being added to the correct upload.
        public let checksum: String
        ///  A number identifying the part in a read set upload.
        public let partNumber: Int
        ///  The source file of the part being uploaded.
        public let partSource: ReadSetPartSource

        public init(checksum: String, partNumber: Int, partSource: ReadSetPartSource) {
            self.checksum = checksum
            self.partNumber = partNumber
            self.partSource = partSource
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
            case partNumber = "partNumber"
            case partSource = "partSource"
        }
    }

    public struct CreateAnnotationStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's annotations.
        public let reference: ReferenceItem?
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat
        /// File parsing options for the annotation store.
        public let storeOptions: StoreOptions?
        /// Tags for the store.
        public let tags: [String: String]?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String?

        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem? = nil, sseConfig: SseConfig? = nil, storeFormat: StoreFormat, storeOptions: StoreOptions? = nil, tags: [String: String]? = nil, versionName: String? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.tags = tags
            self.versionName = versionName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.reference?.validate(name: "\(name).reference")
            try self.storeOptions?.validate(name: "\(name).storeOptions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case tags = "tags"
            case versionName = "versionName"
        }
    }

    public struct CreateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference. Required for all stores except TSV format with generic annotations.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// The store's file parsing options.
        public let storeOptions: StoreOptions?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String

        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, versionName: String) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case versionName = "versionName"
        }
    }

    public struct CreateAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The description of an annotation store version.
        public let description: String?
        /// The name of an annotation store version from which versions are being created.
        public let name: String
        /// Any tags added to annotation store version.
        public let tags: [String: String]?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?

        public init(description: String? = nil, name: String, tags: [String: String]? = nil, versionName: String, versionOptions: VersionOptions? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
            self.versionName = versionName
            self.versionOptions = versionOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.versionName, forKey: .versionName)
            try container.encodeIfPresent(self.versionOptions, forKey: .versionOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.versionOptions?.validate(name: "\(name).versionOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case tags = "tags"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
        }
    }

    public struct CreateAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for the creation of an annotation store version.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// A generated ID for the annotation store
        public let id: String
        /// The name given to an annotation store version to distinguish it from other versions.
        public let name: String
        /// The status of a annotation store version.
        public let status: VersionStatus
        /// The ID for the annotation store from which new versions are being created.
        public let storeId: String
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?

        public init(creationTime: Date, id: String, name: String, status: VersionStatus, storeId: String, versionName: String, versionOptions: VersionOptions? = nil) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.status = status
            self.storeId = storeId
            self.versionName = versionName
            self.versionOptions = versionOptions
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case status = "status"
            case storeId = "storeId"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
        }
    }

    public struct CreateMultipartReadSetUploadRequest: AWSEncodableShape {
        ///  An idempotency token that can be used to avoid triggering multiple multipart uploads.
        public let clientToken: String?
        ///  The description of the read set.
        public let description: String?
        ///  Where the source originated.
        public let generatedFrom: String?
        ///  The name of the read set.
        public let name: String
        ///  The ARN of the reference.
        public let referenceArn: String?
        ///  The source's sample ID.
        public let sampleId: String
        ///  The sequence store ID for the store that is the destination of the multipart uploads.
        public let sequenceStoreId: String
        ///  The type of file being uploaded.
        public let sourceFileType: FileType
        ///  The source's subject ID.
        public let subjectId: String
        ///  Any tags to add to the read set.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, generatedFrom: String? = nil, name: String, referenceArn: String? = nil, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.generatedFrom, forKey: .generatedFrom)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.referenceArn, forKey: .referenceArn)
            try container.encode(self.sampleId, forKey: .sampleId)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sourceFileType, forKey: .sourceFileType)
            try container.encode(self.subjectId, forKey: .subjectId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct CreateMultipartReadSetUploadResponse: AWSDecodableShape {
        ///  The creation time of the multipart upload.
        public let creationTime: Date
        ///  The description of the read set.
        public let description: String?
        ///  The source of the read set.
        public let generatedFrom: String?
        ///  The name of the read set.
        public let name: String?
        ///  The read set source's reference ARN.
        public let referenceArn: String
        ///  The source's sample ID.
        public let sampleId: String
        ///  The sequence store ID for the store that the read set will be created in.
        public let sequenceStoreId: String
        ///  The file type of the read set source.
        public let sourceFileType: FileType
        ///  The source's subject ID.
        public let subjectId: String
        ///  The tags to add to the read set.
        public let tags: [String: String]?
        ///  he ID for the initiated multipart upload.
        public let uploadId: String

        public init(creationTime: Date, description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil, uploadId: String) {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceStoreId = "sequenceStoreId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
            case uploadId = "uploadId"
        }
    }

    public struct CreateReferenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, name: String, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct CreateRunGroupRequest: AWSEncodableShape {
        /// The maximum number of CPUs to use in the group.
        public let maxCpus: Int?
        /// A maximum run time for the group in minutes.
        public let maxDuration: Int?
        ///  The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// Tags for the group.
        public let tags: [String: String]?

        public init(maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil, requestId: String = CreateRunGroupRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
            self.requestId = requestId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
            case requestId = "requestId"
            case tags = "tags"
        }
    }

    public struct CreateRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// The group's ID.
        public let id: String?
        /// Tags for the run group.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateSequenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        ///  An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// A name for the store.
        public let name: String
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, fallbackLocation: String? = nil, name: String, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.name = name
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.fallbackLocation, name: "fallbackLocation", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case fallbackLocation = "fallbackLocation"
            case name = "name"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        ///  An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct CreateShareRequest: AWSEncodableShape {
        ///  The principal subscriber is the account being given access to the analytics store data through the share offer.
        public let principalSubscriber: String
        ///  The resource ARN for the analytics store to be shared.
        public let resourceArn: String
        ///  A name given to the share.
        public let shareName: String?

        public init(principalSubscriber: String, resourceArn: String, shareName: String? = nil) {
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.shareName = shareName
        }

        public func validate(name: String) throws {
            try self.validate(self.shareName, name: "shareName", parent: name, max: 256)
            try self.validate(self.shareName, name: "shareName", parent: name, min: 1)
            try self.validate(self.shareName, name: "shareName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case principalSubscriber = "principalSubscriber"
            case resourceArn = "resourceArn"
            case shareName = "shareName"
        }
    }

    public struct CreateShareResponse: AWSDecodableShape {
        ///  An ID generated for the share.
        public let shareId: String?
        ///  A name given to the share.
        public let shareName: String?
        ///  The status of a share.
        public let status: ShareStatus?

        public init(shareId: String? = nil, shareName: String? = nil, status: ShareStatus? = nil) {
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case shareId = "shareId"
            case shareName = "shareName"
            case status = "status"
        }
    }

    public struct CreateVariantStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's variants.
        public let reference: ReferenceItem
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.reference.validate(name: "\(name).reference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus

        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
        }
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        ///  The computational accelerator specified to run the workflow.
        public let accelerators: Accelerators?
        /// The URI of a definition for the workflow.
        public let definitionUri: String?
        /// A ZIP archive for the workflow.
        public let definitionZip: AWSBase64Data?
        /// A description for the workflow.
        public let description: String?
        /// An engine for the workflow.
        public let engine: WorkflowEngine?
        /// The path of the main definition file for the workflow.
        public let main: String?
        /// A name for the workflow.
        public let name: String?
        /// A parameter template for the workflow.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// A storage capacity for the workflow in gibibytes.
        public let storageCapacity: Int?
        /// Tags for the workflow.
        public let tags: [String: String]?

        public init(accelerators: Accelerators? = nil, definitionUri: String? = nil, definitionZip: AWSBase64Data? = nil, description: String? = nil, engine: WorkflowEngine? = nil, main: String? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, requestId: String = CreateWorkflowRequest.idempotencyToken(), storageCapacity: Int? = nil, tags: [String: String]? = nil) {
            self.accelerators = accelerators
            self.definitionUri = definitionUri
            self.definitionZip = definitionZip
            self.description = description
            self.engine = engine
            self.main = main
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.requestId = requestId
            self.storageCapacity = storageCapacity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, max: 256)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, min: 1)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.main, name: "main", parent: name, max: 128)
            try self.validate(self.main, name: "main", parent: name, min: 1)
            try self.validate(self.main, name: "main", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.parameterTemplate?.forEach {
                try validate($0.key, name: "parameterTemplate.key", parent: name, max: 128)
                try validate($0.key, name: "parameterTemplate.key", parent: name, min: 1)
                try validate($0.key, name: "parameterTemplate.key", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
                try $0.value.validate(name: "\(name).parameterTemplate[\"\($0.key)\"]")
            }
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, max: 1000)
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case definitionUri = "definitionUri"
            case definitionZip = "definitionZip"
            case description = "description"
            case engine = "engine"
            case main = "main"
            case name = "name"
            case parameterTemplate = "parameterTemplate"
            case requestId = "requestId"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// The workflow's ID.
        public let id: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, status: WorkflowStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DeleteAnnotationStoreRequest: AWSEncodableShape {
        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnnotationStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteAnnotationStoreVersionsRequest: AWSEncodableShape {
        /// Forces the deletion of an annotation store version when imports are in-progress..
        public let force: Bool?
        /// The name of the annotation store from which versions are being deleted.
        public let name: String
        /// The versions of an annotation store to be deleted.
        public let versions: [String]

        public init(force: Bool? = nil, name: String, versions: [String]) {
            self.force = force
            self.name = name
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
            try container.encode(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 3)
                try validate($0, name: "versions[]", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 10)
            try self.validate(self.versions, name: "versions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case versions = "versions"
        }
    }

    public struct DeleteAnnotationStoreVersionsResponse: AWSDecodableShape {
        /// Any errors that occur when attempting to delete an annotation store version.
        public let errors: [VersionDeleteError]?

        public init(errors: [VersionDeleteError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct DeleteReferenceRequest: AWSEncodableShape {
        /// The reference's ID.
        public let id: String
        /// The reference's store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReferenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRunGroupRequest: AWSEncodableShape {
        /// The run group's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRunRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSequenceStoreRequest: AWSEncodableShape {
        /// The sequence store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSequenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteShareRequest: AWSEncodableShape {
        ///  The ID for the share request to be deleted.
        public let shareId: String

        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteShareResponse: AWSDecodableShape {
        ///  The status of the share being deleted.
        public let status: ShareStatus?

        public init(status: ShareStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteVariantStoreRequest: AWSEncodableShape {
        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVariantStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// The workflow's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ETag: AWSDecodableShape {
        ///  The algorithm used to calculate the read sets ETag(s).
        public let algorithm: ETagAlgorithm?
        ///  The ETag hash calculated on Source1 of the read set.
        public let source1: String?
        ///  The ETag hash calculated on Source2 of the read set.
        public let source2: String?

        public init(algorithm: ETagAlgorithm? = nil, source1: String? = nil, source2: String? = nil) {
            self.algorithm = algorithm
            self.source1 = source1
            self.source2 = source2
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct ExportReadSet: AWSEncodableShape {
        /// The set's ID.
        public let readSetId: String

        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct ExportReadSetDetail: AWSDecodableShape {
        /// The set's ID.
        public let id: String
        /// The set's status.
        public let status: ReadSetExportJobItemStatus
        /// The set's status message.
        public let statusMessage: String?

        public init(id: String, status: ReadSetExportJobItemStatus, statusMessage: String? = nil) {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct ExportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetExportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetExportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ExportReadSetJobDetail: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct FileInformation: AWSDecodableShape {
        /// The file's content length.
        public let contentLength: Int64?
        /// The file's part size.
        public let partSize: Int64?
        /// The file's total parts.
        public let totalParts: Int?

        public init(contentLength: Int64? = nil, partSize: Int64? = nil, totalParts: Int? = nil) {
            self.contentLength = contentLength
            self.partSize = partSize
            self.totalParts = totalParts
        }

        private enum CodingKeys: String, CodingKey {
            case contentLength = "contentLength"
            case partSize = "partSize"
            case totalParts = "totalParts"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The Amazon Resource Number (Arn) for an analytics store.
        public let resourceArns: [String]?
        /// The status of an annotation store version.
        public let status: [ShareStatus]?

        public init(resourceArns: [String]? = nil, status: [ShareStatus]? = nil) {
            self.resourceArns = resourceArns
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 10)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArns = "resourceArns"
            case status = "status"
        }
    }

    public struct GetAnnotationImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationImportResponse: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @CustomCoding<ISO8601DateCoder>
        public var completionTime: Date
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        public let formatOptions: FormatOptions
        /// The job's ID.
        public let id: String
        /// The job's imported items.
        public let items: [AnnotationImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of the annotation store version.
        public let versionName: String

        public init(annotationFields: [String: String]? = nil, completionTime: Date, creationTime: Date, destinationName: String, formatOptions: FormatOptions, id: String, items: [AnnotationImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date, versionName: String) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case formatOptions = "formatOptions"
            case id = "id"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct GetAnnotationStoreRequest: AWSEncodableShape {
        /// The store's name.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// An integer indicating how many versions of an annotation store exist.
        public let numVersions: Int
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// A status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's annotation file format.
        public let storeFormat: StoreFormat?
        /// The store's parsing options.
        public let storeOptions: StoreOptions?
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, numVersions: Int, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.numVersions = numVersions
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case numVersions = "numVersions"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case storeSizeBytes = "storeSizeBytes"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The name given to an annotation store version to distinguish it from others.
        public let name: String
        /// The name given to an annotation store version to distinguish it from others.
        public let versionName: String

        public init(name: String, versionName: String) {
            self.name = name
            self.versionName = versionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.versionName, key: "versionName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description for an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// The name of the annotation store.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The status of an annotation store version.
        public let statusMessage: String
        /// The store ID for annotation store version.
        public let storeId: String
        /// Any tags associated with an annotation store version.
        public let tags: [String: String]
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The Arn for the annotation store.
        public let versionArn: String
        /// The name given to an annotation store version to distinguish it from others.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?
        /// The size of the annotation store version in Bytes.
        public let versionSizeBytes: Int64

        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, statusMessage: String, storeId: String, tags: [String: String], updateTime: Date, versionArn: String, versionName: String, versionOptions: VersionOptions? = nil, versionSizeBytes: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.tags = tags
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionOptions = versionOptions
            self.versionSizeBytes = versionSizeBytes
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeId = "storeId"
            case tags = "tags"
            case updateTime = "updateTime"
            case versionArn = "versionArn"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
            case versionSizeBytes = "versionSizeBytes"
        }
    }

    public struct GetReadSetActivationJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ActivateReadSetSourceItem]?
        /// The job's status.
        public let status: ReadSetActivationJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, sources: [ActivateReadSetSourceItem]? = nil, status: ReadSetActivationJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetExportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetExportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's read sets.
        public let readSets: [ExportReadSetDetail]?
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, readSets: [ExportReadSetDetail]? = nil, sequenceStoreId: String, status: ReadSetExportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.readSets = readSets
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case readSets = "readSets"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetImportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ImportReadSetSourceItem]
        /// The job's status.
        public let status: ReadSetImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, sources: [ImportReadSetSourceItem], status: ReadSetImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetMetadataRequest: AWSEncodableShape {
        /// The read set's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetMetadataResponse: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// When the read set was created.
        public let creationTime: Date
        ///  The creation type of the read set.
        public let creationType: CreationType?
        /// The read set's description.
        public let description: String?
        ///  The entity tag (ETag) is a hash of the object meant to represent its semantic content.
        public let etag: ETag?
        /// The read set's files.
        public let files: ReadSetFiles?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        /// The read set's sequence information.
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        ///  The status message for a read set. It provides more detail as to why the read set has a status.
        public let statusMessage: String?
        /// The read set's subject ID.
        public let subjectId: String?

        public init(arn: String, creationTime: Date, creationType: CreationType? = nil, description: String? = nil, etag: ETag? = nil, files: ReadSetFiles? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, statusMessage: String? = nil, subjectId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.files = files
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case creationType = "creationType"
            case description = "description"
            case etag = "etag"
            case files = "files"
            case fileType = "fileType"
            case id = "id"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceInformation = "sequenceInformation"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
        }
    }

    public struct GetReadSetRequest: AWSEncodableShape {
        /// The file to retrieve.
        public let file: ReadSetFile?
        /// The read set's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(file: ReadSetFile? = nil, id: String, partNumber: Int, sequenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.file, key: "file")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The read set file payload.
        public let payload: AWSHTTPBody

        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceImportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's source files.
        public let sources: [ImportReferenceSourceItem]
        /// The job's status.
        public let status: ReferenceImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, sources: [ImportReferenceSourceItem], status: ReferenceImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReferenceMetadataRequest: AWSEncodableShape {
        /// The reference's ID.
        public let id: String
        /// The reference's reference store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceMetadataResponse: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's description.
        public let description: String?
        /// The reference's files.
        public let files: ReferenceFiles?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's reference store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        public init(arn: String, creationTime: Date, description: String? = nil, files: ReferenceFiles? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.files = files
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case files = "files"
            case id = "id"
            case md5 = "md5"
            case name = "name"
            case referenceStoreId = "referenceStoreId"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct GetReferenceRequest: AWSEncodableShape {
        /// The file to retrieve.
        public let file: ReferenceFile?
        /// The reference's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The range to retrieve.
        public let range: String?
        /// The reference's store ID.
        public let referenceStoreId: String

        public init(file: ReferenceFile? = nil, id: String, partNumber: Int, range: String? = nil, referenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.range = range
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.file, key: "file")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodeHeader(self.range, key: "Range")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.range, name: "range", parent: name, max: 127)
            try self.validate(self.range, name: "range", parent: name, min: 1)
            try self.validate(self.range, name: "range", parent: name, pattern: "^[\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The reference file payload.
        public let payload: AWSHTTPBody

        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct GetRunGroupRequest: AWSEncodableShape {
        /// The group's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum number of CPUs to use.
        public let maxCpus: Int?
        /// The group's maximum run time in minutes.
        public let maxDuration: Int?
        ///  The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?
        /// The group's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetRunRequest: AWSEncodableShape {
        /// The run's export format.
        public let export: [RunExport]?
        /// The run's ID.
        public let id: String

        public init(export: [RunExport]? = nil, id: String) {
            self.export = export
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.export, key: "export")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunResponse: AWSDecodableShape {
        ///  The computational accelerator used to run the workflow.
        public let accelerators: Accelerators?
        /// The run's ARN.
        public let arn: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's definition.
        public let definition: String?
        /// The run's digest.
        public let digest: String?
        ///  The reason a run has failed.
        public let failureReason: String?
        /// The run's ID.
        public let id: String?
        /// The run's log level.
        public let logLevel: RunLogLevel?
        ///  The location of the run log.
        public let logLocation: RunLogLocation?
        /// The run's name.
        public let name: String?
        /// The run's output URI.
        public let outputUri: String?
        /// The run's parameters.
        public let parameters: String?
        /// The run's priority.
        public let priority: Int?
        /// The run's resource digests.
        public let resourceDigests: [String: String]?
        /// The run's retention mode.
        public let retentionMode: RunRetentionMode?
        /// The run's service role ARN.
        public let roleArn: String?
        /// The run's group ID.
        public let runGroupId: String?
        /// The run's ID.
        public let runId: String?
        ///  The destination for workflow outputs.
        public let runOutputUri: String?
        /// Who started the run.
        public let startedBy: String?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// The run's status message.
        public let statusMessage: String?
        /// The run's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity in gigabytes.
        public let storageCapacity: Int?
        /// The run's tags.
        public let tags: [String: String]?
        ///  The universally unique identifier for a run.
        public let uuid: String?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The run's workflow type.
        public let workflowType: WorkflowType?

        public init(accelerators: Accelerators? = nil, arn: String? = nil, creationTime: Date? = nil, definition: String? = nil, digest: String? = nil, failureReason: String? = nil, id: String? = nil, logLevel: RunLogLevel? = nil, logLocation: RunLogLocation? = nil, name: String? = nil, outputUri: String? = nil, parameters: String? = nil, priority: Int? = nil, resourceDigests: [String: String]? = nil, retentionMode: RunRetentionMode? = nil, roleArn: String? = nil, runGroupId: String? = nil, runId: String? = nil, runOutputUri: String? = nil, startedBy: String? = nil, startTime: Date? = nil, status: RunStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, uuid: String? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.accelerators = accelerators
            self.arn = arn
            self.creationTime = creationTime
            self.definition = definition
            self.digest = digest
            self.failureReason = failureReason
            self.id = id
            self.logLevel = logLevel
            self.logLocation = logLocation
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.resourceDigests = resourceDigests
            self.retentionMode = retentionMode
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.runOutputUri = runOutputUri
            self.startedBy = startedBy
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.uuid = uuid
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case arn = "arn"
            case creationTime = "creationTime"
            case definition = "definition"
            case digest = "digest"
            case failureReason = "failureReason"
            case id = "id"
            case logLevel = "logLevel"
            case logLocation = "logLocation"
            case name = "name"
            case outputUri = "outputUri"
            case parameters = "parameters"
            case priority = "priority"
            case resourceDigests = "resourceDigests"
            case retentionMode = "retentionMode"
            case roleArn = "roleArn"
            case runGroupId = "runGroupId"
            case runId = "runId"
            case runOutputUri = "runOutputUri"
            case startedBy = "startedBy"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case stopTime = "stopTime"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
            case uuid = "uuid"
            case workflowId = "workflowId"
            case workflowType = "workflowType"
        }
    }

    public struct GetRunTaskRequest: AWSEncodableShape {
        /// The workflow run ID.
        public let id: String
        /// The task's ID.
        public let taskId: String

        public init(id: String, taskId: String) {
            self.id = id
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.taskId, name: "taskId", parent: name, max: 18)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunTaskResponse: AWSDecodableShape {
        /// The task's CPU usage.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        ///  The reason a task has failed.
        public let failureReason: String?
        ///  The number of Graphics Processing Units (GPU) specified in the task.
        public let gpus: Int?
        ///  The instance type for a task.
        public let instanceType: String?
        /// The task's log stream.
        public let logStream: String?
        /// The task's memory use in gigabytes.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// The task's start time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// The task's status message.
        public let statusMessage: String?
        /// The task's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        public init(cpus: Int? = nil, creationTime: Date? = nil, failureReason: String? = nil, gpus: Int? = nil, instanceType: String? = nil, logStream: String? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cpus = cpus
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.gpus = gpus
            self.instanceType = instanceType
            self.logStream = logStream
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cpus = "cpus"
            case creationTime = "creationTime"
            case failureReason = "failureReason"
            case gpus = "gpus"
            case instanceType = "instanceType"
            case logStream = "logStream"
            case memory = "memory"
            case name = "name"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case stopTime = "stopTime"
            case taskId = "taskId"
        }
    }

    public struct GetSequenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        ///  An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct GetShareRequest: AWSEncodableShape {
        ///  The generated ID for a share.
        public let shareId: String

        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetShareResponse: AWSDecodableShape {
        ///  An analytic store share details object. contains status, resourceArn, ownerId, etc.
        public let share: ShareDetails?

        public init(share: ShareDetails? = nil) {
            self.share = share
        }

        private enum CodingKeys: String, CodingKey {
            case share = "share"
        }
    }

    public struct GetVariantImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantImportResponse: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's items.
        public let items: [VariantImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, items: [VariantImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct GetVariantStoreRequest: AWSEncodableShape {
        /// The store's name.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeSizeBytes = "storeSizeBytes"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// The export format for the workflow.
        public let export: [WorkflowExport]?
        /// The workflow's ID.
        public let id: String
        /// The workflow's type.
        public let type: WorkflowType?

        public init(export: [WorkflowExport]? = nil, id: String, type: WorkflowType? = nil) {
            self.export = export
            self.id = id
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.export, key: "export")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        ///  The computational accelerator specified to run the workflow.
        public let accelerators: Accelerators?
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's definition.
        public let definition: String?
        /// The workflow's description.
        public let description: String?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's engine.
        public let engine: WorkflowEngine?
        /// The workflow's ID.
        public let id: String?
        /// The path of the main definition file for the workflow.
        public let main: String?
        ///  Gets metadata for workflow.
        public let metadata: [String: String]?
        /// The workflow's name.
        public let name: String?
        /// The workflow's parameter template.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's status message.
        public let statusMessage: String?
        /// The workflow's storage capacity in gigabytes.
        public let storageCapacity: Int?
        /// The workflow's tags.
        public let tags: [String: String]?
        /// The workflow's type.
        public let type: WorkflowType?

        public init(accelerators: Accelerators? = nil, arn: String? = nil, creationTime: Date? = nil, definition: String? = nil, description: String? = nil, digest: String? = nil, engine: WorkflowEngine? = nil, id: String? = nil, main: String? = nil, metadata: [String: String]? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, status: WorkflowStatus? = nil, statusMessage: String? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, type: WorkflowType? = nil) {
            self.accelerators = accelerators
            self.arn = arn
            self.creationTime = creationTime
            self.definition = definition
            self.description = description
            self.digest = digest
            self.engine = engine
            self.id = id
            self.main = main
            self.metadata = metadata
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.status = status
            self.statusMessage = statusMessage
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case arn = "arn"
            case creationTime = "creationTime"
            case definition = "definition"
            case description = "description"
            case digest = "digest"
            case engine = "engine"
            case id = "id"
            case main = "main"
            case metadata = "metadata"
            case name = "name"
            case parameterTemplate = "parameterTemplate"
            case status = "status"
            case statusMessage = "statusMessage"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ImportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetImportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ImportReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct ImportReadSetSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's genome reference ARN.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's status.
        public let status: ReadSetImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, status: ReadSetImportJobItemStatus, statusMessage: String? = nil, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFiles = "sourceFiles"
            case sourceFileType = "sourceFileType"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct ImportReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReferenceImportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReferenceImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ImportReferenceJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct ImportReferenceSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String?
        /// The source file's location in Amazon S3.
        public let sourceFile: String?
        /// The source's status.
        public let status: ReferenceImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, sourceFile: String? = nil, status: ReferenceImportJobItemStatus, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case sourceFile = "sourceFile"
            case status = "status"
            case statusMessage = "statusMessage"
            case tags = "tags"
        }
    }

    public struct ListAnnotationImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case storeName = "storeName"
        }
    }

    public struct ListAnnotationImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListAnnotationImportJobsFilter?
        /// IDs of annotation import jobs to retrieve.
        public let ids: [String]?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListAnnotationImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListAnnotationImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let annotationImportJobs: [AnnotationImportJobItem]?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(annotationImportJobs: [AnnotationImportJobItem]? = nil, nextToken: String? = nil) {
            self.annotationImportJobs = annotationImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationImportJobs = "annotationImportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnnotationStoreVersionsFilter: AWSEncodableShape {
        /// The status of an annotation store version.
        public let status: VersionStatus?

        public init(status: VersionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListAnnotationStoreVersionsRequest: AWSEncodableShape {
        /// A filter to apply to the list of annotation store versions.
        public let filter: ListAnnotationStoreVersionsFilter?
        /// The maximum number of annotation store versions to return in one page of results.
        public let maxResults: Int?
        /// The name of an annotation store.
        public let name: String
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListAnnotationStoreVersionsFilter? = nil, maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListAnnotationStoreVersionsResponse: AWSDecodableShape {
        /// Lists all versions of an annotation store.
        public let annotationStoreVersions: [AnnotationStoreVersionItem]?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(annotationStoreVersions: [AnnotationStoreVersionItem]? = nil, nextToken: String? = nil) {
            self.annotationStoreVersions = annotationStoreVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationStoreVersions = "annotationStoreVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnnotationStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListAnnotationStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListAnnotationStoresFilter?
        /// IDs of stores to list.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListAnnotationStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListAnnotationStoresResponse: AWSDecodableShape {
        /// A list of stores.
        public let annotationStores: [AnnotationStoreItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(annotationStores: [AnnotationStoreItem]? = nil, nextToken: String? = nil) {
            self.annotationStores = annotationStores
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationStores = "annotationStores"
            case nextToken = "nextToken"
        }
    }

    public struct ListMultipartReadSetUploadsRequest: AWSEncodableShape {
        ///  The maximum number of multipart uploads returned in a page.
        public let maxResults: Int?
        ///  Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
        public let nextToken: String?
        ///  The Sequence Store ID used for the multipart uploads.
        public let sequenceStoreId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMultipartReadSetUploadsResponse: AWSDecodableShape {
        ///  Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
        public let nextToken: String?
        ///  An array of multipart uploads.
        public let uploads: [MultipartReadSetUploadListItem]?

        public init(nextToken: String? = nil, uploads: [MultipartReadSetUploadListItem]? = nil) {
            self.nextToken = nextToken
            self.uploads = uploads
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case uploads = "uploads"
        }
    }

    public struct ListReadSetActivationJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ActivateReadSetFilter?
        /// The maximum number of read set activation jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ActivateReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetActivationJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let activationJobs: [ActivateReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(activationJobs: [ActivateReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.activationJobs = activationJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case activationJobs = "activationJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetExportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ExportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ExportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetExportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let exportJobs: [ExportReadSetJobDetail]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(exportJobs: [ExportReadSetJobDetail]? = nil, nextToken: String? = nil) {
            self.exportJobs = exportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobs = "exportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ImportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ImportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let importJobs: [ImportReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(importJobs: [ImportReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs = "importJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetUploadPartsRequest: AWSEncodableShape {
        ///  Attributes used to filter for a specific subset of read set part uploads.
        public let filter: ReadSetUploadPartListFilter?
        ///  The maximum number of read set upload parts returned in a page.
        public let maxResults: Int?
        ///  Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
        public let nextToken: String?
        ///  The source file for the upload part.
        public let partSource: ReadSetPartSource
        ///  The Sequence Store ID used for the multipart uploads.
        public let sequenceStoreId: String
        ///  The ID for the initiated multipart upload.
        public let uploadId: String

        public init(filter: ReadSetUploadPartListFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, partSource: ReadSetPartSource, sequenceStoreId: String, uploadId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.partSource = partSource
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.partSource, forKey: .partSource)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case partSource = "partSource"
        }
    }

    public struct ListReadSetUploadPartsResponse: AWSDecodableShape {
        ///  Next token returned in the response of a previous ListReadSetUploadParts call. Used to get the next page of results.
        public let nextToken: String?
        ///  An array of upload parts.
        public let parts: [ReadSetUploadPartListItem]?

        public init(nextToken: String? = nil, parts: [ReadSetUploadPartListItem]? = nil) {
            self.nextToken = nextToken
            self.parts = parts
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case parts = "parts"
        }
    }

    public struct ListReadSetsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReadSetFilter?
        /// The maximum number of read sets to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of read sets.
        public let readSets: [ReadSetListItem]

        public init(nextToken: String? = nil, readSets: [ReadSetListItem]) {
            self.nextToken = nextToken
            self.readSets = readSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readSets = "readSets"
        }
    }

    public struct ListReferenceImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ImportReferenceFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String

        public init(filter: ImportReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferenceImportJobsResponse: AWSDecodableShape {
        /// A lis of jobs.
        public let importJobs: [ImportReferenceJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(importJobs: [ImportReferenceJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs = "importJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReferenceStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReferenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ReferenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of reference stores.
        public let referenceStores: [ReferenceStoreDetail]

        public init(nextToken: String? = nil, referenceStores: [ReferenceStoreDetail]) {
            self.nextToken = nextToken
            self.referenceStores = referenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case referenceStores = "referenceStores"
        }
    }

    public struct ListReferencesRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReferenceFilter?
        /// The maximum number of references to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The references' reference store ID.
        public let referenceStoreId: String

        public init(filter: ReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferencesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of references.
        public let references: [ReferenceListItem]

        public init(nextToken: String? = nil, references: [ReferenceListItem]) {
            self.nextToken = nextToken
            self.references = references
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case references = "references"
        }
    }

    public struct ListRunGroupsRequest: AWSEncodableShape {
        /// The maximum number of run groups to return in one page of results.
        public let maxResults: Int?
        /// The run groups' name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.startingToken, key: "startingToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunGroupsResponse: AWSDecodableShape {
        /// A list of groups.
        public let items: [RunGroupListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [RunGroupListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRunTasksRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String
        /// The maximum number of run tasks to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// Filter the list by status.
        public let status: TaskStatus?

        public init(id: String, maxResults: Int? = nil, startingToken: String? = nil, status: TaskStatus? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.startingToken = startingToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunTasksResponse: AWSDecodableShape {
        /// A list of tasks.
        public let items: [TaskListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [TaskListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRunsRequest: AWSEncodableShape {
        /// The maximum number of runs to return in one page of results.
        public let maxResults: Int?
        /// Filter the list by run name.
        public let name: String?
        /// Filter the list by run group ID.
        public let runGroupId: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        ///  The status of a run.
        public let status: RunStatus?

        public init(maxResults: Int? = nil, name: String? = nil, runGroupId: String? = nil, startingToken: String? = nil, status: RunStatus? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.runGroupId = runGroupId
            self.startingToken = startingToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.runGroupId, key: "runGroupId")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunsResponse: AWSDecodableShape {
        /// A list of runs.
        public let items: [RunListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [RunListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSequenceStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: SequenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: SequenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListSequenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of sequence stores.
        public let sequenceStores: [SequenceStoreDetail]

        public init(nextToken: String? = nil, sequenceStores: [SequenceStoreDetail]) {
            self.nextToken = nextToken
            self.sequenceStores = sequenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sequenceStores = "sequenceStores"
        }
    }

    public struct ListSharesRequest: AWSEncodableShape {
        ///  Attributes used to filter for a specific subset of shares.
        public let filter: Filter?
        ///  The maximum number of shares to return in one page of results.
        public let maxResults: Int?
        ///  Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
        public let nextToken: String?
        ///  The account that owns the analytics store shared.
        public let resourceOwner: ResourceOwner

        public init(filter: Filter? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceOwner: ResourceOwner) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceOwner = resourceOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.resourceOwner, forKey: .resourceOwner)
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListSharesResponse: AWSDecodableShape {
        /// Next token returned in the response of a previous ListSharesResponse call. Used to get the next page of results.
        public let nextToken: String?
        ///  The shares available and their meta details.
        public let shares: [ShareDetails]

        public init(nextToken: String? = nil, shares: [ShareDetails]) {
            self.nextToken = nextToken
            self.shares = shares
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case shares = "shares"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVariantImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case storeName = "storeName"
        }
    }

    public struct ListVariantImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListVariantImportJobsFilter?
        /// A list of job IDs.
        public let ids: [String]?
        /// The maximum number of import jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListVariantImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListVariantImportJobsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of jobs.
        public let variantImportJobs: [VariantImportJobItem]?

        public init(nextToken: String? = nil, variantImportJobs: [VariantImportJobItem]? = nil) {
            self.nextToken = nextToken
            self.variantImportJobs = variantImportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case variantImportJobs = "variantImportJobs"
        }
    }

    public struct ListVariantStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListVariantStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListVariantStoresFilter?
        /// A list of store IDs.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListVariantStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListVariantStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of variant stores.
        public let variantStores: [VariantStoreItem]?

        public init(nextToken: String? = nil, variantStores: [VariantStoreItem]? = nil) {
            self.nextToken = nextToken
            self.variantStores = variantStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case variantStores = "variantStores"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The maximum number of workflows to return in one page of results.
        public let maxResults: Int?
        /// The workflows' name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// The workflows' type.
        public let type: WorkflowType?

        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil, type: WorkflowType? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// The workflows' items.
        public let items: [WorkflowListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [WorkflowListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct MultipartReadSetUploadListItem: AWSDecodableShape {
        ///  The time stamp for when a direct upload was created.
        public let creationTime: Date
        ///  The description of a read set.
        public let description: String?
        ///  The source of an uploaded part.
        public let generatedFrom: String
        ///  The name of a read set.
        public let name: String?
        ///  The source's reference ARN.
        public let referenceArn: String
        ///  The read set source's sample ID.
        public let sampleId: String
        ///  The sequence store ID used for the multipart upload.
        public let sequenceStoreId: String
        ///  The type of file the read set originated from.
        public let sourceFileType: FileType
        ///  The read set source's subject ID.
        public let subjectId: String
        ///  Any tags you wish to add to a read set.
        public let tags: [String: String]?
        ///  The ID for the initiated multipart upload.
        public let uploadId: String

        public init(creationTime: Date, description: String? = nil, generatedFrom: String, name: String? = nil, referenceArn: String, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil, uploadId: String) {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceStoreId = "sequenceStoreId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
            case uploadId = "uploadId"
        }
    }

    public struct ReadOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's comment character.
        public let comment: String?
        /// The file's encoding.
        public let encoding: String?
        /// A character for escaping quotes in the file.
        public let escape: String?
        /// Whether quotes need to be escaped in the file.
        public let escapeQuotes: Bool?
        /// Whether the file has a header row.
        public let header: Bool?
        /// A line separator for the file.
        public let lineSep: String?
        /// The file's quote character.
        public let quote: String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public let quoteAll: Bool?
        /// The file's field separator.
        public let sep: String?

        public init(comment: String? = nil, encoding: String? = nil, escape: String? = nil, escapeQuotes: Bool? = nil, header: Bool? = nil, lineSep: String? = nil, quote: String? = nil, quoteAll: Bool? = nil, sep: String? = nil) {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.encoding, name: "encoding", parent: name, max: 20)
            try self.validate(self.encoding, name: "encoding", parent: name, min: 1)
            try self.validate(self.escape, name: "escape", parent: name, max: 1)
            try self.validate(self.escape, name: "escape", parent: name, min: 1)
            try self.validate(self.lineSep, name: "lineSep", parent: name, max: 20)
            try self.validate(self.lineSep, name: "lineSep", parent: name, min: 1)
            try self.validate(self.quote, name: "quote", parent: name, max: 1)
            try self.validate(self.quote, name: "quote", parent: name, min: 1)
            try self.validate(self.sep, name: "sep", parent: name, max: 20)
            try self.validate(self.sep, name: "sep", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case encoding = "encoding"
            case escape = "escape"
            case escapeQuotes = "escapeQuotes"
            case header = "header"
            case lineSep = "lineSep"
            case quote = "quote"
            case quoteAll = "quoteAll"
            case sep = "sep"
        }
    }

    public struct ReadSetBatchError: AWSDecodableShape {
        /// The error's code.
        public let code: String
        /// The error's ID.
        public let id: String
        /// The error's message.
        public let message: String

        public init(code: String, id: String, message: String) {
            self.code = code
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case id = "id"
            case message = "message"
        }
    }

    public struct ReadSetFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The location of the first file in Amazon S3.
        public let source1: FileInformation?
        /// The location of the second file in Amazon S3.
        public let source2: FileInformation?

        public init(index: FileInformation? = nil, source1: FileInformation? = nil, source2: FileInformation? = nil) {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct ReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        ///  The creation type of the read set.
        public let creationType: CreationType?
        ///  Where the source originated.
        public let generatedFrom: String?
        /// A name to filter on.
        public let name: String?
        /// A genome reference ARN to filter on.
        public let referenceArn: String?
        ///  The read set source's sample ID.
        public let sampleId: String?
        /// A status to filter on.
        public let status: ReadSetStatus?
        ///  The read set source's subject ID.
        public let subjectId: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, creationType: CreationType? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, status: ReadSetStatus? = nil, subjectId: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.creationType = creationType
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.status = status
            self.subjectId = subjectId
        }

        public func validate(name: String) throws {
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^$|^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case creationType = "creationType"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case status = "status"
            case subjectId = "subjectId"
        }
    }

    public struct ReadSetListItem: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// When the read set was created.
        public let creationTime: Date
        ///  The creation type of the read set.
        public let creationType: CreationType?
        /// The read set's description.
        public let description: String?
        ///  The entity tag (ETag) is a hash of the object representing  its semantic content.
        public let etag: ETag?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        ///  The status for a read set. It provides more detail as to why the read set has a status.
        public let statusMessage: String?
        /// The read set's subject ID.
        public let subjectId: String?

        public init(arn: String, creationTime: Date, creationType: CreationType? = nil, description: String? = nil, etag: ETag? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, statusMessage: String? = nil, subjectId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case creationType = "creationType"
            case description = "description"
            case etag = "etag"
            case fileType = "fileType"
            case id = "id"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceInformation = "sequenceInformation"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
        }
    }

    public struct ReadSetUploadPartListFilter: AWSEncodableShape {
        ///  Filters for read set uploads after a specified time.
        public let createdAfter: Date?
        ///  Filters for read set part uploads before a specified time.
        public let createdBefore: Date?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
        }
    }

    public struct ReadSetUploadPartListItem: AWSDecodableShape {
        ///  A unique identifier used to confirm that parts are being added to the correct upload.
        public let checksum: String
        ///  The time stamp for when a direct upload was created.
        public let creationTime: Date?
        ///  The time stamp for the most recent update to an uploaded part.
        public let lastUpdatedTime: Date?
        ///  The number identifying the part in an upload.
        public let partNumber: Int
        ///  The size of the the part in an upload.
        public let partSize: Int64
        ///  The origin of the part being direct uploaded.
        public let partSource: ReadSetPartSource

        public init(checksum: String, creationTime: Date? = nil, lastUpdatedTime: Date? = nil, partNumber: Int, partSize: Int64, partSource: ReadSetPartSource) {
            self.checksum = checksum
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.partNumber = partNumber
            self.partSize = partSize
            self.partSource = partSource
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
            case creationTime = "creationTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case partNumber = "partNumber"
            case partSize = "partSize"
            case partSource = "partSource"
        }
    }

    public struct ReferenceFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The source file's location in Amazon S3.
        public let source: FileInformation?

        public init(index: FileInformation? = nil, source: FileInformation? = nil) {
            self.index = index
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case source = "source"
        }
    }

    public struct ReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// An MD5 checksum to filter on.
        public let md5: String?
        /// A name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, md5: String? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.md5, name: "md5", parent: name, max: 255)
            try self.validate(self.md5, name: "md5", parent: name, min: 1)
            try self.validate(self.md5, name: "md5", parent: name, pattern: "^[\\p{L}||\\p{N}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case md5 = "md5"
            case name = "name"
        }
    }

    public struct ReferenceListItem: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's description.
        public let description: String?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case md5 = "md5"
            case name = "name"
            case referenceStoreId = "referenceStoreId"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct ReferenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct ReferenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case name = "name"
        }
    }

    public struct RunGroupListItem: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum CPU count setting.
        public let maxCpus: Int?
        /// The group's maximum duration setting in minutes.
        public let maxDuration: Int?
        ///  The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The group's maximum concurrent run setting.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
        }
    }

    public struct RunListItem: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's ID.
        public let id: String?
        /// The run's name.
        public let name: String?
        /// The run's priority.
        public let priority: Int?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// When the run stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity.
        public let storageCapacity: Int?
        /// The run's workflow ID.
        public let workflowId: String?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, name: String? = nil, priority: Int? = nil, startTime: Date? = nil, status: RunStatus? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, workflowId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case startTime = "startTime"
            case status = "status"
            case stopTime = "stopTime"
            case storageCapacity = "storageCapacity"
            case workflowId = "workflowId"
        }
    }

    public struct RunLogLocation: AWSDecodableShape {
        ///  The log stream ARN for the engine log.
        public let engineLogStream: String?
        ///  The log stream ARN for the run log.
        public let runLogStream: String?

        public init(engineLogStream: String? = nil, runLogStream: String? = nil) {
            self.engineLogStream = engineLogStream
            self.runLogStream = runLogStream
        }

        private enum CodingKeys: String, CodingKey {
            case engineLogStream = "engineLogStream"
            case runLogStream = "runLogStream"
        }
    }

    public struct SequenceInformation: AWSDecodableShape {
        /// The sequence's alignment setting.
        public let alignment: String?
        /// Where the sequence originated.
        public let generatedFrom: String?
        /// The sequence's total base count.
        public let totalBaseCount: Int64?
        /// The sequence's total read count.
        public let totalReadCount: Int64?

        public init(alignment: String? = nil, generatedFrom: String? = nil, totalBaseCount: Int64? = nil, totalReadCount: Int64? = nil) {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }

        private enum CodingKeys: String, CodingKey {
            case alignment = "alignment"
            case generatedFrom = "generatedFrom"
            case totalBaseCount = "totalBaseCount"
            case totalReadCount = "totalReadCount"
        }
    }

    public struct SequenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        ///  An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct SequenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case name = "name"
        }
    }

    public struct ShareDetails: AWSDecodableShape {
        ///  The timestamp for when the share was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        ///  The account ID for the data owner. The owner creates the share offer.
        public let ownerId: String?
        ///  The principal subscriber is the account the analytics store data is being shared with.
        public let principalSubscriber: String?
        ///  The resource Arn of the analytics store being shared.
        public let resourceArn: String?
        ///  The ID for a share offer for an analytics store .
        public let shareId: String?
        ///  The name of the share.
        public let shareName: String?
        ///  The status of a share.
        public let status: ShareStatus?
        ///  The status message for a share. It provides more details on the status of the share.
        public let statusMessage: String?
        ///  The timestamp of the share update.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updateTime: Date?

        public init(creationTime: Date? = nil, ownerId: String? = nil, principalSubscriber: String? = nil, resourceArn: String? = nil, shareId: String? = nil, shareName: String? = nil, status: ShareStatus? = nil, statusMessage: String? = nil, updateTime: Date? = nil) {
            self.creationTime = creationTime
            self.ownerId = ownerId
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case ownerId = "ownerId"
            case principalSubscriber = "principalSubscriber"
            case resourceArn = "resourceArn"
            case shareId = "shareId"
            case shareName = "shareName"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct SourceFiles: AWSEncodableShape & AWSDecodableShape {
        /// The location of the first file in Amazon S3.
        public let source1: String
        /// The location of the second file in Amazon S3.
        public let source2: String?

        public init(source1: String, source2: String? = nil) {
            self.source1 = source1
            self.source2 = source2
        }

        public func validate(name: String) throws {
            try self.validate(self.source1, name: "source1", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.validate(self.source2, name: "source2", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct SseConfig: AWSEncodableShape & AWSDecodableShape {
        /// An encryption key ARN.
        public let keyArn: String?
        /// The encryption type.
        public let type: EncryptionType

        public init(keyArn: String? = nil, type: EncryptionType) {
            self.keyArn = keyArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "keyArn"
            case type = "type"
        }
    }

    public struct StartAnnotationImportRequest: AWSEncodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// A destination annotation store for the job.
        public let destinationName: String
        /// Formatting options for the annotation file.
        public let formatOptions: FormatOptions?
        /// Items to import.
        public let items: [AnnotationImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The name of the annotation store version.
        public let versionName: String?

        public init(annotationFields: [String: String]? = nil, destinationName: String, formatOptions: FormatOptions? = nil, items: [AnnotationImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil, versionName: String? = nil) {
            self.annotationFields = annotationFields
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.versionName = versionName
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case destinationName = "destinationName"
            case formatOptions = "formatOptions"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case versionName = "versionName"
        }
    }

    public struct StartAnnotationImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct StartReadSetActivationJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [StartReadSetActivationJobSourceItem]

        public init(clientToken: String? = nil, sequenceStoreId: String, sources: [StartReadSetActivationJobSourceItem]) {
            self.clientToken = clientToken
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case sources = "sources"
        }
    }

    public struct StartReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        public init(creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetActivationJobSourceItem: AWSEncodableShape {
        /// The source's read set ID.
        public let readSetId: String

        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct StartReadSetExportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A location for exported files in Amazon S3.
        public let destination: String
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ExportReadSet]

        public init(clientToken: String? = nil, destination: String, roleArn: String, sequenceStoreId: String, sources: [ExportReadSet]) {
            self.clientToken = clientToken
            self.destination = destination
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.destination, forKey: .destination)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destination = "destination"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReadSetExportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's output location.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        public init(creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetImportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [StartReadSetImportJobSourceItem]

        public init(clientToken: String? = nil, roleArn: String, sequenceStoreId: String, sources: [StartReadSetImportJobSourceItem]) {
            self.clientToken = clientToken
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReadSetImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        public init(creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's reference ARN.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.sourceFiles.validate(name: "\(name).sourceFiles")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFiles = "sourceFiles"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct StartReferenceImportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// A service role for the job.
        public let roleArn: String
        /// The job's source files.
        public let sources: [StartReferenceImportJobSourceItem]

        public init(clientToken: String? = nil, referenceStoreId: String, roleArn: String, sources: [StartReferenceImportJobSourceItem]) {
            self.clientToken = clientToken
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReferenceImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        public init(creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct StartReferenceImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String
        /// The source file's location in Amazon S3.
        public let sourceFile: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, sourceFile: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sourceFile, name: "sourceFile", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case sourceFile = "sourceFile"
            case tags = "tags"
        }
    }

    public struct StartRunRequest: AWSEncodableShape {
        /// A log level for the run.
        public let logLevel: RunLogLevel?
        /// A name for the run.
        public let name: String?
        /// An output URI for the run.
        public let outputUri: String?
        /// Parameters for the run.
        public let parameters: String?
        /// A priority for the run.
        public let priority: Int?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// The retention mode for the run.
        public let retentionMode: RunRetentionMode?
        /// A service role for the run.
        public let roleArn: String
        /// The run's group ID.
        public let runGroupId: String?
        /// The ID of a run to duplicate.
        public let runId: String?
        /// A storage capacity for the run in gigabytes.
        public let storageCapacity: Int?
        /// Tags for the run.
        public let tags: [String: String]?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The run's workflow type.
        public let workflowType: WorkflowType?

        public init(logLevel: RunLogLevel? = nil, name: String? = nil, outputUri: String? = nil, parameters: String? = nil, priority: Int? = nil, requestId: String = StartRunRequest.idempotencyToken(), retentionMode: RunRetentionMode? = nil, roleArn: String, runGroupId: String? = nil, runId: String? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.logLevel = logLevel
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.requestId = requestId
            self.retentionMode = retentionMode
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.outputUri, name: "outputUri", parent: name, max: 750)
            try self.validate(self.outputUri, name: "outputUri", parent: name, min: 1)
            try self.validate(self.outputUri, name: "outputUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 128)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.runId, name: "runId", parent: name, max: 18)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.workflowId, name: "workflowId", parent: name, max: 18)
            try self.validate(self.workflowId, name: "workflowId", parent: name, min: 1)
            try self.validate(self.workflowId, name: "workflowId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "logLevel"
            case name = "name"
            case outputUri = "outputUri"
            case parameters = "parameters"
            case priority = "priority"
            case requestId = "requestId"
            case retentionMode = "retentionMode"
            case roleArn = "roleArn"
            case runGroupId = "runGroupId"
            case runId = "runId"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
            case workflowId = "workflowId"
            case workflowType = "workflowType"
        }
    }

    public struct StartRunResponse: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// The run's ID.
        public let id: String?
        ///  The destination for workflow outputs.
        public let runOutputUri: String?
        /// The run's status.
        public let status: RunStatus?
        /// The run's tags.
        public let tags: [String: String]?
        ///  The universally unique identifier for a run.
        public let uuid: String?

        public init(arn: String? = nil, id: String? = nil, runOutputUri: String? = nil, status: RunStatus? = nil, tags: [String: String]? = nil, uuid: String? = nil) {
            self.arn = arn
            self.id = id
            self.runOutputUri = runOutputUri
            self.status = status
            self.tags = tags
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case runOutputUri = "runOutputUri"
            case status = "status"
            case tags = "tags"
            case uuid = "uuid"
        }
    }

    public struct StartVariantImportRequest: AWSEncodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// The destination variant store for the job.
        public let destinationName: String
        /// Items to import.
        public let items: [VariantImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?

        public init(annotationFields: [String: String]? = nil, destinationName: String, items: [VariantImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil) {
            self.annotationFields = annotationFields
            self.destinationName = destinationName
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case destinationName = "destinationName"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
        }
    }

    public struct StartVariantImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Tags for the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskListItem: AWSDecodableShape {
        /// The task's CPU count.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        ///  The number of Graphics Processing Units (GPU) specified for the task.
        public let gpus: Int?
        ///  The instance type for a task.
        public let instanceType: String?
        /// The task's memory use in gigabyes.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// When the task started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// When the task stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        public init(cpus: Int? = nil, creationTime: Date? = nil, gpus: Int? = nil, instanceType: String? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cpus = cpus
            self.creationTime = creationTime
            self.gpus = gpus
            self.instanceType = instanceType
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cpus = "cpus"
            case creationTime = "creationTime"
            case gpus = "gpus"
            case instanceType = "instanceType"
            case memory = "memory"
            case name = "name"
            case startTime = "startTime"
            case status = "status"
            case stopTime = "stopTime"
            case taskId = "taskId"
        }
    }

    public struct TsvOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's read options.
        public let readOptions: ReadOptions?

        public init(readOptions: ReadOptions? = nil) {
            self.readOptions = readOptions
        }

        public func validate(name: String) throws {
            try self.readOptions?.validate(name: "\(name).readOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case readOptions = "readOptions"
        }
    }

    public struct TsvStoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// The store's annotation type.
        public let annotationType: AnnotationType?
        /// The store's header key to column name mapping.
        public let formatToHeader: [FormatToHeaderKey: String]?
        /// The store's schema.
        public let schema: [[String: SchemaValueType]]?

        public init(annotationType: AnnotationType? = nil, formatToHeader: [FormatToHeaderKey: String]? = nil, schema: [[String: SchemaValueType]]? = nil) {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.schema?.forEach {
                try validate($0, name: "schema[]", parent: name, max: 1)
                try validate($0, name: "schema[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case annotationType = "annotationType"
            case formatToHeader = "formatToHeader"
            case schema = "schema"
        }
    }

    public struct TsvVersionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The store version's annotation type.
        public let annotationType: AnnotationType?
        /// The annotation store version's header key to column name mapping.
        public let formatToHeader: [FormatToHeaderKey: String]?
        /// The TSV schema for an annotation store version.
        public let schema: [[String: SchemaValueType]]?

        public init(annotationType: AnnotationType? = nil, formatToHeader: [FormatToHeaderKey: String]? = nil, schema: [[String: SchemaValueType]]? = nil) {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.schema?.forEach {
                try validate($0, name: "schema[]", parent: name, max: 1)
                try validate($0, name: "schema[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case annotationType = "annotationType"
            case formatToHeader = "formatToHeader"
            case schema = "schema"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Keys of tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnnotationStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// Parsing options for the store.
        public let storeOptions: StoreOptions?
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The description of an annotation store.
        public let description: String?
        /// The name of an annotation store.
        public let name: String
        /// The name of an annotation store version.
        public let versionName: String

        public init(description: String? = nil, name: String, versionName: String) {
            self.description = description
            self.name = name
            self.versionName = versionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.versionName, key: "versionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// The name of an annotation store.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The annotation store ID.
        public let storeId: String
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of an annotation store version.
        public let versionName: String

        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, storeId: String, updateTime: Date, versionName: String) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case storeId = "storeId"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct UpdateRunGroupRequest: AWSEncodableShape {
        /// The group's ID.
        public let id: String
        /// The maximum number of CPUs to use.
        public let maxCpus: Int?
        /// A maximum run time for the group in minutes.
        public let maxDuration: Int?
        ///  The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?

        public init(id: String, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.maxCpus, forKey: .maxCpus)
            try container.encodeIfPresent(self.maxDuration, forKey: .maxDuration)
            try container.encodeIfPresent(self.maxGpus, forKey: .maxGpus)
            try container.encodeIfPresent(self.maxRuns, forKey: .maxRuns)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
        }
    }

    public struct UpdateVariantStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        /// A description for the workflow.
        public let description: String?
        /// The workflow's ID.
        public let id: String
        /// A name for the workflow.
        public let name: String?

        public init(description: String? = nil, id: String, name: String? = nil) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UploadReadSetPartRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        ///  The number of the part being uploaded.
        public let partNumber: Int
        ///  The source file for an upload part.
        public let partSource: ReadSetPartSource
        ///  The read set data to upload for a part.
        public let payload: AWSHTTPBody
        ///  The Sequence Store ID used for the multipart upload.
        public let sequenceStoreId: String
        ///  The ID for the initiated multipart upload.
        public let uploadId: String

        public init(partNumber: Int, partSource: ReadSetPartSource, payload: AWSHTTPBody, sequenceStoreId: String, uploadId: String) {
            self.partNumber = partNumber
            self.partSource = partSource
            self.payload = payload
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodeQuery(self.partSource, key: "partSource")
            try container.encode(self.payload)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UploadReadSetPartResponse: AWSDecodableShape {
        ///  An identifier used to confirm that parts are being added to the intended upload.
        public let checksum: String

        public init(checksum: String) {
            self.checksum = checksum
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
        }
    }

    public struct VariantImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String
        ///  A message that provides additional context about a job
        public let statusMessage: String?

        public init(jobStatus: JobStatus, source: String, statusMessage: String? = nil) {
            self.jobStatus = jobStatus
            self.source = source
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "jobStatus"
            case source = "source"
            case statusMessage = "statusMessage"
        }
    }

    public struct VariantImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct VariantImportJobItem: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct VariantStoreItem: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeSizeBytes = "storeSizeBytes"
            case updateTime = "updateTime"
        }
    }

    public struct VcfOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's ignore filter field setting.
        public let ignoreFilterField: Bool?
        /// The file's ignore qual field setting.
        public let ignoreQualField: Bool?

        public init(ignoreFilterField: Bool? = nil, ignoreQualField: Bool? = nil) {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }

        private enum CodingKeys: String, CodingKey {
            case ignoreFilterField = "ignoreFilterField"
            case ignoreQualField = "ignoreQualField"
        }
    }

    public struct VersionDeleteError: AWSDecodableShape {
        /// The message explaining the error in annotation store deletion.
        public let message: String
        /// The name given to an annotation store version.
        public let versionName: String

        public init(message: String, versionName: String) {
            self.message = message
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case versionName = "versionName"
        }
    }

    public struct WorkflowListItem: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's ID.
        public let id: String?
        ///  Any metadata available for workflow. The information listed may vary depending on the workflow, and there may also be no metadata to return.
        public let metadata: [String: String]?
        /// The workflow's name.
        public let name: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's type.
        public let type: WorkflowType?

        public init(arn: String? = nil, creationTime: Date? = nil, digest: String? = nil, id: String? = nil, metadata: [String: String]? = nil, name: String? = nil, status: WorkflowStatus? = nil, type: WorkflowType? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case digest = "digest"
            case id = "id"
            case metadata = "metadata"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct WorkflowParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter's description.
        public let description: String?
        /// Whether the parameter is optional.
        public let optional: Bool?

        public init(description: String? = nil, optional: Bool? = nil) {
            self.description = description
            self.optional = optional
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case optional = "optional"
        }
    }

    public struct ReferenceItem: AWSEncodableShape & AWSDecodableShape {
        /// The reference's ARN.
        public let referenceArn: String?

        public init(referenceArn: String? = nil) {
            self.referenceArn = referenceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case referenceArn = "referenceArn"
        }
    }

    public struct StoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// File settings for a TSV store.
        public let tsvStoreOptions: TsvStoreOptions?

        public init(tsvStoreOptions: TsvStoreOptions? = nil) {
            self.tsvStoreOptions = tsvStoreOptions
        }

        public func validate(name: String) throws {
            try self.tsvStoreOptions?.validate(name: "\(name).tsvStoreOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case tsvStoreOptions = "tsvStoreOptions"
        }
    }

    public struct VersionOptions: AWSEncodableShape & AWSDecodableShape {
        /// File settings for a version of a TSV store.
        public let tsvVersionOptions: TsvVersionOptions?

        public init(tsvVersionOptions: TsvVersionOptions? = nil) {
            self.tsvVersionOptions = tsvVersionOptions
        }

        public func validate(name: String) throws {
            try self.tsvVersionOptions?.validate(name: "\(name).tsvVersionOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case tsvVersionOptions = "tsvVersionOptions"
        }
    }
}

// MARK: - Errors

/// Error enum for Omics
public struct OmicsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case notSupportedOperationException = "NotSupportedOperationException"
        case rangeNotSatisfiableException = "RangeNotSatisfiableException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Omics
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request cannot be applied to the target resource in its current state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred. Try the request again.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The operation is not supported by Amazon Omics, or the API does not exist.
    public static var notSupportedOperationException: Self { .init(.notSupportedOperationException) }
    /// The ranges specified in the request are not valid.
    public static var rangeNotSatisfiableException: Self { .init(.rangeNotSatisfiableException) }
    /// The request timed out.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The target resource was not found in the current Region.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension OmicsErrorType: Equatable {
    public static func == (lhs: OmicsErrorType, rhs: OmicsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OmicsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
