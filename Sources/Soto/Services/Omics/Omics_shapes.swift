//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Omics {
    // MARK: Enums

    public enum Accelerators: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gpu = "GPU"
        public var description: String { return self.rawValue }
    }

    public enum AnnotationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Contains contig and 1-base position
        case chrPos = "CHR_POS"
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt = "CHR_POS_REF_ALT"
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase = "CHR_START_END_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase = "CHR_START_END_REF_ALT_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase = "CHR_START_END_REF_ALT_ZERO_BASE"
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase = "CHR_START_END_ZERO_BASE"
        /// Generic text file. No genomic information
        case generic = "GENERIC"
        public var description: String { return self.rawValue }
    }

    public enum CacheBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cacheAlways = "CACHE_ALWAYS"
        case cacheOnFailure = "CACHE_ON_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum CreationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        case upload = "UPLOAD"
        public var description: String { return self.rawValue }
    }

    public enum ETagAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bamMd5Up = "BAM_MD5up"
        case bamSha256Up = "BAM_SHA256up"
        case bamSha512Up = "BAM_SHA512up"
        case cramMd5Up = "CRAM_MD5up"
        case cramSha256Up = "CRAM_SHA256up"
        case cramSha512Up = "CRAM_SHA512up"
        case fastqMd5Up = "FASTQ_MD5up"
        case fastqSha256Up = "FASTQ_SHA256up"
        case fastqSha512Up = "FASTQ_SHA512up"
        public var description: String { return self.rawValue }
    }

    public enum ETagAlgorithmFamily: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case md5up = "MD5up"
        case sha256up = "SHA256up"
        case sha512up = "SHA512up"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// KMS
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bam = "BAM"
        case cram = "CRAM"
        case fastq = "FASTQ"
        case ubam = "UBAM"
        public var description: String { return self.rawValue }
    }

    public enum FormatToHeaderKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alt = "ALT"
        case chr = "CHR"
        case end = "END"
        case pos = "POS"
        case ref = "REF"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Job was cancelled
        case cancelled = "CANCELLED"
        /// The Job has completed
        case completed = "COMPLETED"
        /// The Job completed with failed runs
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        /// The Job failed
        case failed = "FAILED"
        /// The Job is executing
        case inProgress = "IN_PROGRESS"
        /// The Job has been submitted to run
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetFile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case index = "INDEX"
        case source1 = "SOURCE1"
        case source2 = "SOURCE2"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetPartSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source1 = "SOURCE1"
        case source2 = "SOURCE2"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case processingUpload = "PROCESSING_UPLOAD"
        case uploadFailed = "UPLOAD_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceCreationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceFile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case index = "INDEX"
        case source = "SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceOwner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The resource owner is an account other than the caller
        case other = "OTHER"
        /// The resource owner is the calling account
        case _self = "SELF"
        public var description: String { return self.rawValue }
    }

    public enum RunCacheStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum RunExport: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum RunLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case error = "ERROR"
        case fatal = "FATAL"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum RunRetentionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case remove = "REMOVE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum RunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// BOOLEAN type
        case boolean = "BOOLEAN"
        /// DOUBLE type
        case double = "DOUBLE"
        /// FLOAT type
        case float = "FLOAT"
        /// INT type
        case int = "INT"
        /// LONG type
        case long = "LONG"
        /// STRING type
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum SequenceStoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ShareResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The share is on an annotation store
        case annotationStore = "ANNOTATION_STORE"
        /// The share is on a variant store
        case variantStore = "VARIANT_STORE"
        /// The share is on a workflow
        case workflow = "WORKFLOW"
        public var description: String { return self.rawValue }
    }

    public enum ShareStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The share is activated
        case activating = "ACTIVATING"
        /// The share is active and can be used
        case active = "ACTIVE"
        /// The share has been deleted
        case deleted = "DELETED"
        /// The share is being deleted
        case deleting = "DELETING"
        /// The share has failed to activate or delete
        case failed = "FAILED"
        /// The share has been created but is not yet active
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dynamic = "DYNAMIC"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public enum StoreFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// GFF3 Format
        case gff = "GFF"
        /// TSV Format
        case tsv = "TSV"
        /// VCF Format
        case vcf = "VCF"
        public var description: String { return self.rawValue }
    }

    public enum StoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Store is active
        case active = "ACTIVE"
        /// The Store is being created
        case creating = "CREATING"
        /// The Store is deleting
        case deleting = "DELETING"
        /// The Store creation failed
        case failed = "FAILED"
        /// The Store is updating
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum StoreType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case referenceStore = "REFERENCE_STORE"
        case sequenceStore = "SEQUENCE_STORE"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum VersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The Version is active
        case active = "ACTIVE"
        /// The Version is being created
        case creating = "CREATING"
        /// The Version is deleting
        case deleting = "DELETING"
        /// The Version creation failed
        case failed = "FAILED"
        /// The Version is updating
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cwl = "CWL"
        case nextflow = "NEXTFLOW"
        case wdl = "WDL"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowExport: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case ready2run = "READY2RUN"
        public var description: String { return self.rawValue }
    }

    public enum FormatOptions: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Options for a TSV file.
        case tsvOptions(TsvOptions)
        /// Options for a VCF file.
        case vcfOptions(VcfOptions)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .tsvOptions:
                let value = try container.decode(TsvOptions.self, forKey: .tsvOptions)
                self = .tsvOptions(value)
            case .vcfOptions:
                let value = try container.decode(VcfOptions.self, forKey: .vcfOptions)
                self = .vcfOptions(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .tsvOptions(let value):
                try container.encode(value, forKey: .tsvOptions)
            case .vcfOptions(let value):
                try container.encode(value, forKey: .vcfOptions)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .tsvOptions(let value):
                try value.validate(name: "\(name).tsvOptions")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tsvOptions = "tsvOptions"
            case vcfOptions = "vcfOptions"
        }
    }

    // MARK: Shapes

    public struct AbortMultipartReadSetUploadRequest: AWSEncodableShape {
        /// The sequence store ID for the store involved in the multipart upload.
        public let sequenceStoreId: String
        /// The ID for the multipart upload.
        public let uploadId: String

        @inlinable
        public init(sequenceStoreId: String, uploadId: String) {
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AbortMultipartReadSetUploadResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptShareRequest: AWSEncodableShape {
        /// The ID of the resource share.
        public let shareId: String

        @inlinable
        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptShareResponse: AWSDecodableShape {
        /// The status of the resource share.
        public let status: ShareStatus?

        @inlinable
        public init(status: ShareStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ActivateReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The filter's status.
        public let status: ReadSetActivationJobStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetActivationJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ActivateReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct ActivateReadSetSourceItem: AWSDecodableShape {
        /// The source's read set ID.
        public let readSetId: String
        /// The source's status.
        public let status: ReadSetActivationJobItemStatus
        /// The source's status message.
        public let statusMessage: String?

        @inlinable
        public init(readSetId: String, status: ReadSetActivationJobItemStatus, statusMessage: String? = nil) {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct AnnotationImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String

        @inlinable
        public init(jobStatus: JobStatus, source: String) {
            self.jobStatus = jobStatus
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "jobStatus"
            case source = "source"
        }
    }

    public struct AnnotationImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        @inlinable
        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct AnnotationImportJobItem: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of the annotation store version.
        public let versionName: String

        @inlinable
        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date, versionName: String) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct AnnotationStoreItem: AWSDecodableShape {
        /// The store's creation time.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's file format.
        public let storeFormat: StoreFormat
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeFormat = "storeFormat"
            case storeSizeBytes = "storeSizeBytes"
            case updateTime = "updateTime"
        }
    }

    public struct AnnotationStoreVersionItem: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// A name given to an annotation store version to distinguish it from others.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The status of an annotation store version.
        public let statusMessage: String
        /// The store ID for an annotation store version.
        public let storeId: String
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The Arn for an annotation store version.
        public let versionArn: String
        /// The name of an annotation store version.
        public let versionName: String
        /// The size of an annotation store version in Bytes.
        public let versionSizeBytes: Int64

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, statusMessage: String, storeId: String, updateTime: Date, versionArn: String, versionName: String, versionSizeBytes: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionSizeBytes = versionSizeBytes
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeId = "storeId"
            case updateTime = "updateTime"
            case versionArn = "versionArn"
            case versionName = "versionName"
            case versionSizeBytes = "versionSizeBytes"
        }
    }

    public struct BatchDeleteReadSetRequest: AWSEncodableShape {
        /// The read sets' IDs.
        public let ids: [String]
        /// The read sets' sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(ids: [String], sequenceStoreId: String) {
            self.ids = ids
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.ids, forKey: .ids)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 10)
                try validate($0, name: "ids[]", parent: name, pattern: "^[0-9]+$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
        }
    }

    public struct BatchDeleteReadSetResponse: AWSDecodableShape {
        /// Errors returned by individual delete operations.
        public let errors: [ReadSetBatchError]?

        @inlinable
        public init(errors: [ReadSetBatchError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct CancelAnnotationImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelAnnotationImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelRunRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CompleteMultipartReadSetUploadRequest: AWSEncodableShape {
        /// The individual uploads or parts of a multipart upload.
        public let parts: [CompleteReadSetUploadPartListItem]
        /// The sequence store ID for the store involved in the multipart upload.
        public let sequenceStoreId: String
        /// The ID for the multipart upload.
        public let uploadId: String

        @inlinable
        public init(parts: [CompleteReadSetUploadPartListItem], sequenceStoreId: String, uploadId: String) {
            self.parts = parts
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.parts, forKey: .parts)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parts = "parts"
        }
    }

    public struct CompleteMultipartReadSetUploadResponse: AWSDecodableShape {
        /// The read set ID created for an uploaded read set.
        public let readSetId: String

        @inlinable
        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct CompleteReadSetUploadPartListItem: AWSEncodableShape {
        ///  A unique identifier used to confirm that parts are being added to the correct upload.
        public let checksum: String
        ///  A number identifying the part in a read set upload.
        public let partNumber: Int
        ///  The source file of the part being uploaded.
        public let partSource: ReadSetPartSource

        @inlinable
        public init(checksum: String, partNumber: Int, partSource: ReadSetPartSource) {
            self.checksum = checksum
            self.partNumber = partNumber
            self.partSource = partSource
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
            case partNumber = "partNumber"
            case partSource = "partSource"
        }
    }

    public struct CreateAnnotationStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's annotations.
        public let reference: ReferenceItem?
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat
        /// File parsing options for the annotation store.
        public let storeOptions: StoreOptions?
        /// Tags for the store.
        public let tags: [String: String]?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String?

        @inlinable
        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem? = nil, sseConfig: SseConfig? = nil, storeFormat: StoreFormat, storeOptions: StoreOptions? = nil, tags: [String: String]? = nil, versionName: String? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.tags = tags
            self.versionName = versionName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.reference?.validate(name: "\(name).reference")
            try self.storeOptions?.validate(name: "\(name).storeOptions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case tags = "tags"
            case versionName = "versionName"
        }
    }

    public struct CreateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference. Required for all stores except TSV format with generic annotations.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// The store's file parsing options.
        public let storeOptions: StoreOptions?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String

        @inlinable
        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, versionName: String) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case versionName = "versionName"
        }
    }

    public struct CreateAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The description of an annotation store version.
        public let description: String?
        /// The name of an annotation store version from which versions are being created.
        public let name: String
        /// Any tags added to annotation store version.
        public let tags: [String: String]?
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?

        @inlinable
        public init(description: String? = nil, name: String, tags: [String: String]? = nil, versionName: String, versionOptions: VersionOptions? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
            self.versionName = versionName
            self.versionOptions = versionOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.versionName, forKey: .versionName)
            try container.encodeIfPresent(self.versionOptions, forKey: .versionOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.versionOptions?.validate(name: "\(name).versionOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case tags = "tags"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
        }
    }

    public struct CreateAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for the creation of an annotation store version.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// A generated ID for the annotation store
        public let id: String
        /// The name given to an annotation store version to distinguish it from other versions.
        public let name: String
        /// The status of a annotation store version.
        public let status: VersionStatus
        /// The ID for the annotation store from which new versions are being created.
        public let storeId: String
        /// The name given to an annotation store version to distinguish it from other versions.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?

        @inlinable
        public init(creationTime: Date, id: String, name: String, status: VersionStatus, storeId: String, versionName: String, versionOptions: VersionOptions? = nil) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.status = status
            self.storeId = storeId
            self.versionName = versionName
            self.versionOptions = versionOptions
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case status = "status"
            case storeId = "storeId"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
        }
    }

    public struct CreateMultipartReadSetUploadRequest: AWSEncodableShape {
        /// An idempotency token that can be used to avoid triggering multiple multipart uploads.
        public let clientToken: String?
        /// The description of the read set.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The name of the read set.
        public let name: String
        /// The ARN of the reference.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The sequence store ID for the store that is the destination of the multipart uploads.
        public let sequenceStoreId: String
        /// The type of file being uploaded.
        public let sourceFileType: FileType
        /// The source's subject ID.
        public let subjectId: String
        /// Any tags to add to the read set.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, description: String? = nil, generatedFrom: String? = nil, name: String, referenceArn: String? = nil, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.generatedFrom, forKey: .generatedFrom)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.referenceArn, forKey: .referenceArn)
            try container.encode(self.sampleId, forKey: .sampleId)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sourceFileType, forKey: .sourceFileType)
            try container.encode(self.subjectId, forKey: .subjectId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct CreateMultipartReadSetUploadResponse: AWSDecodableShape {
        /// The creation time of the multipart upload.
        public let creationTime: Date
        /// The description of the read set.
        public let description: String?
        /// The source of the read set.
        public let generatedFrom: String?
        /// The name of the read set.
        public let name: String?
        /// The read set source's reference ARN.
        public let referenceArn: String
        /// The source's sample ID.
        public let sampleId: String
        /// The sequence store ID for the store that the read set will be created in.
        public let sequenceStoreId: String
        /// The file type of the read set source.
        public let sourceFileType: FileType
        /// The source's subject ID.
        public let subjectId: String
        /// The tags to add to the read set.
        public let tags: [String: String]?
        /// The ID for the initiated multipart upload.
        public let uploadId: String

        @inlinable
        public init(creationTime: Date, description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil, uploadId: String) {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceStoreId = "sequenceStoreId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
            case uploadId = "uploadId"
        }
    }

    public struct CreateReferenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, description: String? = nil, name: String, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct CreateRunCacheRequest: AWSEncodableShape {
        /// Default cache behavior for runs that use this cache. Supported values are:  CACHE_ON_FAILURE: Caches task outputs from completed tasks for runs that fail. This setting is  useful if you're debugging a workflow that fails after several tasks completed successfully. The subsequent run uses the cache outputs for previously-completed tasks if the task definition, inputs, and container in ECR are identical to the prior run.  CACHE_ALWAYS: Caches task outputs from completed tasks for all runs. This setting is useful in development mode, but do not use it in a production setting. If you don't specify a value, the default behavior is CACHE_ON_FAILURE. When you start a run that uses this cache, you can override the default cache behavior. For more information, see Run cache behavior in the AWS HealthOmics User Guide.
        public let cacheBehavior: CacheBehavior?
        /// The AWS account ID of the expected owner of the S3 bucket for the run cache. If not provided, your account ID is set as the owner of the bucket.
        public let cacheBucketOwnerId: String?
        /// Specify the S3 location for storing the cached task outputs. This data must be immediately accessible (not in an archived state).
        public let cacheS3Location: String
        /// Enter a description of the run cache.
        public let description: String?
        /// Enter a user-friendly name for the run cache.
        public let name: String?
        /// A unique request token, to ensure idempotency. If you don't specify a token,  HealthOmics automatically generates a universally unique identifier (UUID) for the request.
        public let requestId: String
        /// Specify one or more tags to associate with this run cache.
        public let tags: [String: String]?

        @inlinable
        public init(cacheBehavior: CacheBehavior? = nil, cacheBucketOwnerId: String? = nil, cacheS3Location: String, description: String? = nil, name: String? = nil, requestId: String = CreateRunCacheRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.cacheBehavior = cacheBehavior
            self.cacheBucketOwnerId = cacheBucketOwnerId
            self.cacheS3Location = cacheS3Location
            self.description = description
            self.name = name
            self.requestId = requestId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheBucketOwnerId, name: "cacheBucketOwnerId", parent: name, max: 12)
            try self.validate(self.cacheBucketOwnerId, name: "cacheBucketOwnerId", parent: name, min: 12)
            try self.validate(self.cacheBucketOwnerId, name: "cacheBucketOwnerId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.cacheS3Location, name: "cacheS3Location", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])(/(.{0,1024}))?$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cacheBehavior = "cacheBehavior"
            case cacheBucketOwnerId = "cacheBucketOwnerId"
            case cacheS3Location = "cacheS3Location"
            case description = "description"
            case name = "name"
            case requestId = "requestId"
            case tags = "tags"
        }
    }

    public struct CreateRunCacheResponse: AWSDecodableShape {
        /// Unique resource identifier for the run cache.
        public let arn: String?
        /// Identifier for the run cache.
        public let id: String?
        /// Run cache status.
        public let status: RunCacheStatus?
        /// The tags associated with this run cache.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: RunCacheStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateRunGroupRequest: AWSEncodableShape {
        /// The maximum number of CPUs that can run concurrently across all active runs in the run group.
        public let maxCpus: Int?
        /// The maximum time for each run (in minutes). If a run exceeds the maximum run time, the run fails automatically.
        public let maxDuration: Int?
        /// The maximum number of GPUs that can run concurrently across all active runs in the run group.
        public let maxGpus: Int?
        /// The maximum number of runs that can be running at the same time.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// Tags for the group.
        public let tags: [String: String]?

        @inlinable
        public init(maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil, requestId: String = CreateRunGroupRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
            self.requestId = requestId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
            case requestId = "requestId"
            case tags = "tags"
        }
    }

    public struct CreateRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// The group's ID.
        public let id: String?
        /// Tags for the run group.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateSequenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        /// The ETag algorithm family to use for ingested read sets.
        public let eTagAlgorithmFamily: ETagAlgorithmFamily?
        /// An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// A name for the store.
        public let name: String
        /// The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
        public let propagatedSetLevelTags: [String]?
        /// S3 access configuration parameters
        public let s3AccessConfig: S3AccessConfig?
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateSequenceStoreRequest.idempotencyToken(), description: String? = nil, eTagAlgorithmFamily: ETagAlgorithmFamily? = nil, fallbackLocation: String? = nil, name: String, propagatedSetLevelTags: [String]? = nil, s3AccessConfig: S3AccessConfig? = nil, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.name = name
            self.propagatedSetLevelTags = propagatedSetLevelTags
            self.s3AccessConfig = s3AccessConfig
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.fallbackLocation, name: "fallbackLocation", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.propagatedSetLevelTags?.forEach {
                try validate($0, name: "propagatedSetLevelTags[]", parent: name, max: 128)
                try validate($0, name: "propagatedSetLevelTags[]", parent: name, min: 1)
            }
            try self.validate(self.propagatedSetLevelTags, name: "propagatedSetLevelTags", parent: name, max: 50)
            try self.s3AccessConfig?.validate(name: "\(name).s3AccessConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case eTagAlgorithmFamily = "eTagAlgorithmFamily"
            case fallbackLocation = "fallbackLocation"
            case name = "name"
            case propagatedSetLevelTags = "propagatedSetLevelTags"
            case s3AccessConfig = "s3AccessConfig"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The algorithm family of the ETag.
        public let eTagAlgorithmFamily: ETagAlgorithmFamily?
        /// An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
        public let propagatedSetLevelTags: [String]?
        public let s3Access: SequenceStoreS3Access?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?
        /// The status of the sequence store.
        public let status: SequenceStoreStatus?
        /// The status message of the sequence store.
        public let statusMessage: String?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, eTagAlgorithmFamily: ETagAlgorithmFamily? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, propagatedSetLevelTags: [String]? = nil, s3Access: SequenceStoreS3Access? = nil, sseConfig: SseConfig? = nil, status: SequenceStoreStatus? = nil, statusMessage: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.propagatedSetLevelTags = propagatedSetLevelTags
            self.s3Access = s3Access
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case eTagAlgorithmFamily = "eTagAlgorithmFamily"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case propagatedSetLevelTags = "propagatedSetLevelTags"
            case s3Access = "s3Access"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct CreateShareRequest: AWSEncodableShape {
        /// The principal subscriber is the account being offered shared access to the resource.
        public let principalSubscriber: String
        /// The ARN of the resource to be shared.
        public let resourceArn: String
        /// A name that the owner defines for the share.
        public let shareName: String?

        @inlinable
        public init(principalSubscriber: String, resourceArn: String, shareName: String? = nil) {
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.shareName = shareName
        }

        public func validate(name: String) throws {
            try self.validate(self.shareName, name: "shareName", parent: name, max: 256)
            try self.validate(self.shareName, name: "shareName", parent: name, min: 1)
            try self.validate(self.shareName, name: "shareName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case principalSubscriber = "principalSubscriber"
            case resourceArn = "resourceArn"
            case shareName = "shareName"
        }
    }

    public struct CreateShareResponse: AWSDecodableShape {
        /// The ID that HealthOmics generates for the share.
        public let shareId: String?
        /// The name of the share.
        public let shareName: String?
        /// The status of the share.
        public let status: ShareStatus?

        @inlinable
        public init(shareId: String? = nil, shareName: String? = nil, status: ShareStatus? = nil) {
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case shareId = "shareId"
            case shareName = "shareName"
            case status = "status"
        }
    }

    public struct CreateVariantStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's variants.
        public let reference: ReferenceItem
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.reference.validate(name: "\(name).reference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case tags = "tags"
        }
    }

    public struct CreateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus

        @inlinable
        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
        }
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// The computational accelerator specified to run the workflow.
        public let accelerators: Accelerators?
        /// The URI of a definition for the workflow.
        public let definitionUri: String?
        /// A ZIP archive for the workflow.
        public let definitionZip: AWSBase64Data?
        /// A description for the workflow.
        public let description: String?
        /// An engine for the workflow.
        public let engine: WorkflowEngine?
        /// The path of the main definition file for the workflow.
        public let main: String?
        /// A name for the workflow.
        public let name: String?
        /// A parameter template for the workflow.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// The default storage capacity for the workflow runs, in gibibytes.
        public let storageCapacity: Int?
        /// Tags for the workflow.
        public let tags: [String: String]?

        @inlinable
        public init(accelerators: Accelerators? = nil, definitionUri: String? = nil, definitionZip: AWSBase64Data? = nil, description: String? = nil, engine: WorkflowEngine? = nil, main: String? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, requestId: String = CreateWorkflowRequest.idempotencyToken(), storageCapacity: Int? = nil, tags: [String: String]? = nil) {
            self.accelerators = accelerators
            self.definitionUri = definitionUri
            self.definitionZip = definitionZip
            self.description = description
            self.engine = engine
            self.main = main
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.requestId = requestId
            self.storageCapacity = storageCapacity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, max: 256)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, min: 1)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.main, name: "main", parent: name, max: 128)
            try self.validate(self.main, name: "main", parent: name, min: 1)
            try self.validate(self.main, name: "main", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.parameterTemplate?.forEach {
                try validate($0.key, name: "parameterTemplate.key", parent: name, max: 128)
                try validate($0.key, name: "parameterTemplate.key", parent: name, min: 1)
                try validate($0.key, name: "parameterTemplate.key", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
                try $0.value.validate(name: "\(name).parameterTemplate[\"\($0.key)\"]")
            }
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, max: 1000)
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case definitionUri = "definitionUri"
            case definitionZip = "definitionZip"
            case description = "description"
            case engine = "engine"
            case main = "main"
            case name = "name"
            case parameterTemplate = "parameterTemplate"
            case requestId = "requestId"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// The workflow's ID.
        public let id: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's tags.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: WorkflowStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DeleteAnnotationStoreRequest: AWSEncodableShape {
        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        @inlinable
        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnnotationStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        @inlinable
        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteAnnotationStoreVersionsRequest: AWSEncodableShape {
        /// Forces the deletion of an annotation store version when imports are in-progress..
        public let force: Bool?
        /// The name of the annotation store from which versions are being deleted.
        public let name: String
        /// The versions of an annotation store to be deleted.
        public let versions: [String]

        @inlinable
        public init(force: Bool? = nil, name: String, versions: [String]) {
            self.force = force
            self.name = name
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
            try container.encode(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 3)
                try validate($0, name: "versions[]", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 10)
            try self.validate(self.versions, name: "versions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case versions = "versions"
        }
    }

    public struct DeleteAnnotationStoreVersionsResponse: AWSDecodableShape {
        /// Any errors that occur when attempting to delete an annotation store version.
        public let errors: [VersionDeleteError]?

        @inlinable
        public init(errors: [VersionDeleteError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct DeleteReferenceRequest: AWSEncodableShape {
        /// The reference's ID.
        public let id: String
        /// The reference's store ID.
        public let referenceStoreId: String

        @inlinable
        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReferenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRunCacheRequest: AWSEncodableShape {
        /// Run cache identifier for the cache you want to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRunGroupRequest: AWSEncodableShape {
        /// The run group's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRunRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteS3AccessPolicyRequest: AWSEncodableShape {
        /// The S3 access point ARN that has the access policy.
        public let s3AccessPointArn: String

        @inlinable
        public init(s3AccessPointArn: String) {
            self.s3AccessPointArn = s3AccessPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.s3AccessPointArn, key: "s3AccessPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, max: 1024)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, min: 1)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, pattern: "^arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteS3AccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSequenceStoreRequest: AWSEncodableShape {
        /// The sequence store's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSequenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteShareRequest: AWSEncodableShape {
        /// The ID for the resource share to be deleted.
        public let shareId: String

        @inlinable
        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteShareResponse: AWSDecodableShape {
        /// The status of the share being deleted.
        public let status: ShareStatus?

        @inlinable
        public init(status: ShareStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteVariantStoreRequest: AWSEncodableShape {
        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        @inlinable
        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVariantStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        @inlinable
        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// The workflow's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ETag: AWSDecodableShape {
        /// The algorithm used to calculate the read sets ETag(s).
        public let algorithm: ETagAlgorithm?
        /// The ETag hash calculated on Source1 of the read set.
        public let source1: String?
        /// The ETag hash calculated on Source2 of the read set.
        public let source2: String?

        @inlinable
        public init(algorithm: ETagAlgorithm? = nil, source1: String? = nil, source2: String? = nil) {
            self.algorithm = algorithm
            self.source1 = source1
            self.source2 = source2
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct ExportReadSet: AWSEncodableShape {
        /// The set's ID.
        public let readSetId: String

        @inlinable
        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct ExportReadSetDetail: AWSDecodableShape {
        /// The set's ID.
        public let id: String
        /// The set's status.
        public let status: ReadSetExportJobItemStatus
        /// The set's status message.
        public let statusMessage: String?

        @inlinable
        public init(id: String, status: ReadSetExportJobItemStatus, statusMessage: String? = nil) {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct ExportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetExportJobStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetExportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ExportReadSetJobDetail: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct FileInformation: AWSDecodableShape {
        /// The file's content length.
        public let contentLength: Int64?
        /// The file's part size.
        public let partSize: Int64?
        /// The S3 URI metadata of a sequence store.
        public let s3Access: ReadSetS3Access?
        /// The file's total parts.
        public let totalParts: Int?

        @inlinable
        public init(contentLength: Int64? = nil, partSize: Int64? = nil, s3Access: ReadSetS3Access? = nil, totalParts: Int? = nil) {
            self.contentLength = contentLength
            self.partSize = partSize
            self.s3Access = s3Access
            self.totalParts = totalParts
        }

        private enum CodingKeys: String, CodingKey {
            case contentLength = "contentLength"
            case partSize = "partSize"
            case s3Access = "s3Access"
            case totalParts = "totalParts"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// Filter based on the Amazon Resource Number (ARN) of the resource. You can specify up to 10 values.
        public let resourceArns: [String]?
        /// Filter based on the resource status. You can specify up to 10 values.
        public let status: [ShareStatus]?
        /// The type of resources to be filtered. You can specify one or more of the resource types.
        public let type: [ShareResourceType]?

        @inlinable
        public init(resourceArns: [String]? = nil, status: [ShareStatus]? = nil, type: [ShareResourceType]? = nil) {
            self.resourceArns = resourceArns
            self.status = status
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 10)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
            try self.validate(self.status, name: "status", parent: name, max: 10)
            try self.validate(self.status, name: "status", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, max: 10)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArns = "resourceArns"
            case status = "status"
            case type = "type"
        }
    }

    public struct GetAnnotationImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationImportResponse: AWSDecodableShape {
        /// The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @CustomCoding<ISO8601DateCoder>
        public var completionTime: Date
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        public let formatOptions: FormatOptions
        /// The job's ID.
        public let id: String
        /// The job's imported items.
        public let items: [AnnotationImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of the annotation store version.
        public let versionName: String

        @inlinable
        public init(annotationFields: [String: String]? = nil, completionTime: Date, creationTime: Date, destinationName: String, formatOptions: FormatOptions, id: String, items: [AnnotationImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date, versionName: String) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case formatOptions = "formatOptions"
            case id = "id"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct GetAnnotationStoreRequest: AWSEncodableShape {
        /// The store's name.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// An integer indicating how many versions of an annotation store exist.
        public let numVersions: Int
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// A status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's annotation file format.
        public let storeFormat: StoreFormat?
        /// The store's parsing options.
        public let storeOptions: StoreOptions?
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, numVersions: Int, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.numVersions = numVersions
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case numVersions = "numVersions"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case storeSizeBytes = "storeSizeBytes"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The name given to an annotation store version to distinguish it from others.
        public let name: String
        /// The name given to an annotation store version to distinguish it from others.
        public let versionName: String

        @inlinable
        public init(name: String, versionName: String) {
            self.name = name
            self.versionName = versionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.versionName, key: "versionName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description for an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// The name of the annotation store.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The status of an annotation store version.
        public let statusMessage: String
        /// The store ID for annotation store version.
        public let storeId: String
        /// Any tags associated with an annotation store version.
        public let tags: [String: String]
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The Arn for the annotation store.
        public let versionArn: String
        /// The name given to an annotation store version to distinguish it from others.
        public let versionName: String
        /// The options for an annotation store version.
        public let versionOptions: VersionOptions?
        /// The size of the annotation store version in Bytes.
        public let versionSizeBytes: Int64

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, statusMessage: String, storeId: String, tags: [String: String], updateTime: Date, versionArn: String, versionName: String, versionOptions: VersionOptions? = nil, versionSizeBytes: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.tags = tags
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionOptions = versionOptions
            self.versionSizeBytes = versionSizeBytes
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeId = "storeId"
            case tags = "tags"
            case updateTime = "updateTime"
            case versionArn = "versionArn"
            case versionName = "versionName"
            case versionOptions = "versionOptions"
            case versionSizeBytes = "versionSizeBytes"
        }
    }

    public struct GetReadSetActivationJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ActivateReadSetSourceItem]?
        /// The job's status.
        public let status: ReadSetActivationJobStatus
        /// The job's status message.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, sources: [ActivateReadSetSourceItem]? = nil, status: ReadSetActivationJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetExportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetExportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's read sets.
        public let readSets: [ExportReadSetDetail]?
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, readSets: [ExportReadSetDetail]? = nil, sequenceStoreId: String, status: ReadSetExportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.readSets = readSets
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case readSets = "readSets"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetImportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ImportReadSetSourceItem]
        /// The job's status.
        public let status: ReadSetImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, sources: [ImportReadSetSourceItem], status: ReadSetImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReadSetMetadataRequest: AWSEncodableShape {
        /// The read set's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetMetadataResponse: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// The read set's creation job ID.
        public let creationJobId: String?
        /// When the read set was created.
        public let creationTime: Date
        ///  The creation type of the read set.
        public let creationType: CreationType?
        /// The read set's description.
        public let description: String?
        /// The entity tag (ETag) is a hash of the object meant to represent its semantic content.
        public let etag: ETag?
        /// The read set's files.
        public let files: ReadSetFiles?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        /// The read set's sequence information.
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        /// The status message for a read set. It provides more detail as to why the read set has a status.
        public let statusMessage: String?
        /// The read set's subject ID.
        public let subjectId: String?

        @inlinable
        public init(arn: String, creationJobId: String? = nil, creationTime: Date, creationType: CreationType? = nil, description: String? = nil, etag: ETag? = nil, files: ReadSetFiles? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, statusMessage: String? = nil, subjectId: String? = nil) {
            self.arn = arn
            self.creationJobId = creationJobId
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.files = files
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationJobId = "creationJobId"
            case creationTime = "creationTime"
            case creationType = "creationType"
            case description = "description"
            case etag = "etag"
            case files = "files"
            case fileType = "fileType"
            case id = "id"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceInformation = "sequenceInformation"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
        }
    }

    public struct GetReadSetRequest: AWSEncodableShape {
        /// The file to retrieve.
        public let file: ReadSetFile?
        /// The read set's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(file: ReadSetFile? = nil, id: String, partNumber: Int, sequenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.file, key: "file")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The read set file payload.
        public let payload: AWSHTTPBody

        @inlinable
        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceImportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String

        @inlinable
        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's source files.
        public let sources: [ImportReferenceSourceItem]
        /// The job's status.
        public let status: ReferenceImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, sources: [ImportReferenceSourceItem], status: ReferenceImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case sources = "sources"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetReferenceMetadataRequest: AWSEncodableShape {
        /// The reference's ID.
        public let id: String
        /// The reference's reference store ID.
        public let referenceStoreId: String

        @inlinable
        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceMetadataResponse: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// The reference's creation job ID.
        public let creationJobId: String?
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's creation type.
        public let creationType: ReferenceCreationType?
        /// The reference's description.
        public let description: String?
        /// The reference's files.
        public let files: ReferenceFiles?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's reference store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, creationJobId: String? = nil, creationTime: Date, creationType: ReferenceCreationType? = nil, description: String? = nil, files: ReferenceFiles? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationJobId = creationJobId
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.files = files
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationJobId = "creationJobId"
            case creationTime = "creationTime"
            case creationType = "creationType"
            case description = "description"
            case files = "files"
            case id = "id"
            case md5 = "md5"
            case name = "name"
            case referenceStoreId = "referenceStoreId"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct GetReferenceRequest: AWSEncodableShape {
        /// The file to retrieve.
        public let file: ReferenceFile?
        /// The reference's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The range to retrieve.
        public let range: String?
        /// The reference's store ID.
        public let referenceStoreId: String

        @inlinable
        public init(file: ReferenceFile? = nil, id: String, partNumber: Int, range: String? = nil, referenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.range = range
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.file, key: "file")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodeHeader(self.range, key: "Range")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.range, name: "range", parent: name, max: 127)
            try self.validate(self.range, name: "range", parent: name, min: 1)
            try self.validate(self.range, name: "range", parent: name, pattern: "^[\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The reference file payload.
        public let payload: AWSHTTPBody

        @inlinable
        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct GetRunCacheRequest: AWSEncodableShape {
        /// The identifier of the run cache to retrieve.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunCacheResponse: AWSDecodableShape {
        /// Unique resource identifier for the run cache.
        public let arn: String?
        /// The default cache behavior for runs using this cache.
        public let cacheBehavior: CacheBehavior?
        /// The identifier of the bucket owner.
        public let cacheBucketOwnerId: String?
        /// The S3 URI where the cache data is stored.
        public let cacheS3Uri: String?
        /// Creation time of the run cache (an ISO 8601 formatted string).
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run cache description.
        public let description: String?
        /// The run cache ID.
        public let id: String?
        /// The run cache name.
        public let name: String?
        /// The run cache status.
        public let status: RunCacheStatus?
        /// The tags associated with the run cache.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, cacheBehavior: CacheBehavior? = nil, cacheBucketOwnerId: String? = nil, cacheS3Uri: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: RunCacheStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cacheBehavior = cacheBehavior
            self.cacheBucketOwnerId = cacheBucketOwnerId
            self.cacheS3Uri = cacheS3Uri
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cacheBehavior = "cacheBehavior"
            case cacheBucketOwnerId = "cacheBucketOwnerId"
            case cacheS3Uri = "cacheS3Uri"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetRunGroupRequest: AWSEncodableShape {
        /// The group's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum number of CPUs to use.
        public let maxCpus: Int?
        /// The group's maximum run time in minutes.
        public let maxDuration: Int?
        /// The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?
        /// The group's tags.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetRunRequest: AWSEncodableShape {
        /// The run's export format.
        public let export: [RunExport]?
        /// The run's ID.
        public let id: String

        @inlinable
        public init(export: [RunExport]? = nil, id: String) {
            self.export = export
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.export, key: "export")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunResponse: AWSDecodableShape {
        /// The computational accelerator used to run the workflow.
        public let accelerators: Accelerators?
        /// The run's ARN.
        public let arn: String?
        /// The run cache behavior for the run.
        public let cacheBehavior: CacheBehavior?
        /// The run cache associated with the run.
        public let cacheId: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's definition.
        public let definition: String?
        /// The run's digest.
        public let digest: String?
        /// The workflow engine version.
        public let engineVersion: String?
        /// The reason a run has failed.
        public let failureReason: String?
        /// The run's ID.
        public let id: String?
        /// The run's log level.
        public let logLevel: RunLogLevel?
        /// The location of the run log.
        public let logLocation: RunLogLocation?
        /// The run's name.
        public let name: String?
        /// The run's output URI.
        public let outputUri: String?
        /// The run's parameters.
        public let parameters: AWSDocument?
        /// The run's priority.
        public let priority: Int?
        /// The run's resource digests.
        public let resourceDigests: [String: String]?
        /// The run's retention mode.
        public let retentionMode: RunRetentionMode?
        /// The run's service role ARN.
        public let roleArn: String?
        /// The run's group ID.
        public let runGroupId: String?
        /// The run's ID.
        public let runId: String?
        /// The destination for workflow outputs.
        public let runOutputUri: String?
        /// Who started the run.
        public let startedBy: String?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// The run's status message.
        public let statusMessage: String?
        /// The run's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity in gibibytes. For dynamic storage,  after the run has completed, this value is the maximum amount of storage used during the run.
        public let storageCapacity: Int?
        /// The run's storage type.
        public let storageType: StorageType?
        /// The run's tags.
        public let tags: [String: String]?
        /// The universally unique identifier for a run.
        public let uuid: String?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The ID of the workflow owner.
        public let workflowOwnerId: String?
        /// The run's workflow type.
        public let workflowType: WorkflowType?

        @inlinable
        public init(accelerators: Accelerators? = nil, arn: String? = nil, cacheBehavior: CacheBehavior? = nil, cacheId: String? = nil, creationTime: Date? = nil, definition: String? = nil, digest: String? = nil, engineVersion: String? = nil, failureReason: String? = nil, id: String? = nil, logLevel: RunLogLevel? = nil, logLocation: RunLogLocation? = nil, name: String? = nil, outputUri: String? = nil, parameters: AWSDocument? = nil, priority: Int? = nil, resourceDigests: [String: String]? = nil, retentionMode: RunRetentionMode? = nil, roleArn: String? = nil, runGroupId: String? = nil, runId: String? = nil, runOutputUri: String? = nil, startedBy: String? = nil, startTime: Date? = nil, status: RunStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, storageType: StorageType? = nil, tags: [String: String]? = nil, uuid: String? = nil, workflowId: String? = nil, workflowOwnerId: String? = nil, workflowType: WorkflowType? = nil) {
            self.accelerators = accelerators
            self.arn = arn
            self.cacheBehavior = cacheBehavior
            self.cacheId = cacheId
            self.creationTime = creationTime
            self.definition = definition
            self.digest = digest
            self.engineVersion = engineVersion
            self.failureReason = failureReason
            self.id = id
            self.logLevel = logLevel
            self.logLocation = logLocation
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.resourceDigests = resourceDigests
            self.retentionMode = retentionMode
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.runOutputUri = runOutputUri
            self.startedBy = startedBy
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.storageType = storageType
            self.tags = tags
            self.uuid = uuid
            self.workflowId = workflowId
            self.workflowOwnerId = workflowOwnerId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case arn = "arn"
            case cacheBehavior = "cacheBehavior"
            case cacheId = "cacheId"
            case creationTime = "creationTime"
            case definition = "definition"
            case digest = "digest"
            case engineVersion = "engineVersion"
            case failureReason = "failureReason"
            case id = "id"
            case logLevel = "logLevel"
            case logLocation = "logLocation"
            case name = "name"
            case outputUri = "outputUri"
            case parameters = "parameters"
            case priority = "priority"
            case resourceDigests = "resourceDigests"
            case retentionMode = "retentionMode"
            case roleArn = "roleArn"
            case runGroupId = "runGroupId"
            case runId = "runId"
            case runOutputUri = "runOutputUri"
            case startedBy = "startedBy"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case stopTime = "stopTime"
            case storageCapacity = "storageCapacity"
            case storageType = "storageType"
            case tags = "tags"
            case uuid = "uuid"
            case workflowId = "workflowId"
            case workflowOwnerId = "workflowOwnerId"
            case workflowType = "workflowType"
        }
    }

    public struct GetRunTaskRequest: AWSEncodableShape {
        /// The workflow run ID.
        public let id: String
        /// The task's ID.
        public let taskId: String

        @inlinable
        public init(id: String, taskId: String) {
            self.id = id
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.taskId, name: "taskId", parent: name, max: 18)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunTaskResponse: AWSDecodableShape {
        /// Set to true if AWS HealthOmics found a matching entry in the run cache for this task.
        public let cacheHit: Bool?
        /// The S3 URI of the cache location.
        public let cacheS3Uri: String?
        /// The task's CPU usage.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The reason a task has failed.
        public let failureReason: String?
        /// The number of Graphics Processing Units (GPU) specified in the task.
        public let gpus: Int?
        /// The instance type for a task.
        public let instanceType: String?
        /// The task's log stream.
        public let logStream: String?
        /// The task's memory use in gigabytes.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// The task's start time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// The task's status message.
        public let statusMessage: String?
        /// The task's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        @inlinable
        public init(cacheHit: Bool? = nil, cacheS3Uri: String? = nil, cpus: Int? = nil, creationTime: Date? = nil, failureReason: String? = nil, gpus: Int? = nil, instanceType: String? = nil, logStream: String? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cacheHit = cacheHit
            self.cacheS3Uri = cacheS3Uri
            self.cpus = cpus
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.gpus = gpus
            self.instanceType = instanceType
            self.logStream = logStream
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cacheHit = "cacheHit"
            case cacheS3Uri = "cacheS3Uri"
            case cpus = "cpus"
            case creationTime = "creationTime"
            case failureReason = "failureReason"
            case gpus = "gpus"
            case instanceType = "instanceType"
            case logStream = "logStream"
            case memory = "memory"
            case name = "name"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case stopTime = "stopTime"
            case taskId = "taskId"
        }
    }

    public struct GetS3AccessPolicyRequest: AWSEncodableShape {
        /// The S3 access point ARN that has the access policy.
        public let s3AccessPointArn: String

        @inlinable
        public init(s3AccessPointArn: String) {
            self.s3AccessPointArn = s3AccessPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.s3AccessPointArn, key: "s3AccessPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, max: 1024)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, min: 1)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, pattern: "^arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetS3AccessPolicyResponse: AWSDecodableShape {
        /// The S3 access point ARN that has the access policy.
        public let s3AccessPointArn: String?
        /// The current resource policy that controls S3 access on the store.
        public let s3AccessPolicy: String
        /// The AWS-generated Sequence Store or Reference Store ID.
        public let storeId: String?
        /// The type of store associated with the access point.
        public let storeType: StoreType?
        /// The time when the policy was last updated.
        public let updateTime: Date?

        @inlinable
        public init(s3AccessPointArn: String? = nil, s3AccessPolicy: String, storeId: String? = nil, storeType: StoreType? = nil, updateTime: Date? = nil) {
            self.s3AccessPointArn = s3AccessPointArn
            self.s3AccessPolicy = s3AccessPolicy
            self.storeId = storeId
            self.storeType = storeType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case s3AccessPointArn = "s3AccessPointArn"
            case s3AccessPolicy = "s3AccessPolicy"
            case storeId = "storeId"
            case storeType = "storeType"
            case updateTime = "updateTime"
        }
    }

    public struct GetSequenceStoreRequest: AWSEncodableShape {
        /// The store's ID.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The algorithm family of the ETag.
        public let eTagAlgorithmFamily: ETagAlgorithmFamily?
        /// An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
        public let propagatedSetLevelTags: [String]?
        /// The S3 metadata of a sequence store, including the ARN and S3 URI of the S3 bucket.
        public let s3Access: SequenceStoreS3Access?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?
        /// The status of the sequence store.
        public let status: SequenceStoreStatus?
        /// The status message of the sequence store.
        public let statusMessage: String?
        /// The last-updated time of the sequence store.
        public let updateTime: Date?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, eTagAlgorithmFamily: ETagAlgorithmFamily? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, propagatedSetLevelTags: [String]? = nil, s3Access: SequenceStoreS3Access? = nil, sseConfig: SseConfig? = nil, status: SequenceStoreStatus? = nil, statusMessage: String? = nil, updateTime: Date? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.propagatedSetLevelTags = propagatedSetLevelTags
            self.s3Access = s3Access
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case eTagAlgorithmFamily = "eTagAlgorithmFamily"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case propagatedSetLevelTags = "propagatedSetLevelTags"
            case s3Access = "s3Access"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct GetShareRequest: AWSEncodableShape {
        /// The ID of the share.
        public let shareId: String

        @inlinable
        public init(shareId: String) {
            self.shareId = shareId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.shareId, key: "shareId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetShareResponse: AWSDecodableShape {
        /// A resource share details object. The object includes the status, the resourceArn, and ownerId.
        public let share: ShareDetails?

        @inlinable
        public init(share: ShareDetails? = nil) {
            self.share = share
        }

        private enum CodingKeys: String, CodingKey {
            case share = "share"
        }
    }

    public struct GetVariantImportRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantImportResponse: AWSDecodableShape {
        /// The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's items.
        public let items: [VariantImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, items: [VariantImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct GetVariantStoreRequest: AWSEncodableShape {
        /// The store's name.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeSizeBytes = "storeSizeBytes"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// The export format for the workflow.
        public let export: [WorkflowExport]?
        /// The workflow's ID.
        public let id: String
        /// The workflow's type.
        public let type: WorkflowType?
        /// The ID of the workflow owner.
        public let workflowOwnerId: String?

        @inlinable
        public init(export: [WorkflowExport]? = nil, id: String, type: WorkflowType? = nil, workflowOwnerId: String? = nil) {
            self.export = export
            self.id = id
            self.type = type
            self.workflowOwnerId = workflowOwnerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.export, key: "export")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.type, key: "type")
            request.encodeQuery(self.workflowOwnerId, key: "workflowOwnerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.workflowOwnerId, name: "workflowOwnerId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The computational accelerator specified to run the workflow.
        public let accelerators: Accelerators?
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's definition.
        public let definition: String?
        /// The workflow's description.
        public let description: String?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's engine.
        public let engine: WorkflowEngine?
        /// The workflow's ID.
        public let id: String?
        /// The path of the main definition file for the workflow.
        public let main: String?
        /// Gets metadata for workflow.
        public let metadata: [String: String]?
        /// The workflow's name.
        public let name: String?
        /// The workflow's parameter template.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's status message.
        public let statusMessage: String?
        /// The workflow's default run storage capacity in gibibytes.
        public let storageCapacity: Int?
        /// The workflow's tags.
        public let tags: [String: String]?
        /// The workflow's type.
        public let type: WorkflowType?

        @inlinable
        public init(accelerators: Accelerators? = nil, arn: String? = nil, creationTime: Date? = nil, definition: String? = nil, description: String? = nil, digest: String? = nil, engine: WorkflowEngine? = nil, id: String? = nil, main: String? = nil, metadata: [String: String]? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, status: WorkflowStatus? = nil, statusMessage: String? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, type: WorkflowType? = nil) {
            self.accelerators = accelerators
            self.arn = arn
            self.creationTime = creationTime
            self.definition = definition
            self.description = description
            self.digest = digest
            self.engine = engine
            self.id = id
            self.main = main
            self.metadata = metadata
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.status = status
            self.statusMessage = statusMessage
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "accelerators"
            case arn = "arn"
            case creationTime = "creationTime"
            case definition = "definition"
            case description = "description"
            case digest = "digest"
            case engine = "engine"
            case id = "id"
            case main = "main"
            case metadata = "metadata"
            case name = "name"
            case parameterTemplate = "parameterTemplate"
            case status = "status"
            case statusMessage = "statusMessage"
            case storageCapacity = "storageCapacity"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ImportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetImportJobStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ImportReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct ImportReadSetSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's read set ID.
        public let readSetId: String?
        /// The source's genome reference ARN.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's status.
        public let status: ReadSetImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, readSetId: String? = nil, referenceArn: String? = nil, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, status: ReadSetImportJobItemStatus, statusMessage: String? = nil, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.readSetId = readSetId
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case readSetId = "readSetId"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFiles = "sourceFiles"
            case sourceFileType = "sourceFileType"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct ImportReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReferenceImportJobStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReferenceImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case status = "status"
        }
    }

    public struct ImportReferenceJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct ImportReferenceSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String?
        /// The source's reference ID.
        public let referenceId: String?
        /// The source file's location in Amazon S3.
        public let sourceFile: String?
        /// The source's status.
        public let status: ReferenceImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's tags.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, name: String? = nil, referenceId: String? = nil, sourceFile: String? = nil, status: ReferenceImportJobItemStatus, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.referenceId = referenceId
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case referenceId = "referenceId"
            case sourceFile = "sourceFile"
            case status = "status"
            case statusMessage = "statusMessage"
            case tags = "tags"
        }
    }

    public struct ListAnnotationImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        @inlinable
        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case storeName = "storeName"
        }
    }

    public struct ListAnnotationImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListAnnotationImportJobsFilter?
        /// IDs of annotation import jobs to retrieve.
        public let ids: [String]?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListAnnotationImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListAnnotationImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let annotationImportJobs: [AnnotationImportJobItem]?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(annotationImportJobs: [AnnotationImportJobItem]? = nil, nextToken: String? = nil) {
            self.annotationImportJobs = annotationImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationImportJobs = "annotationImportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnnotationStoreVersionsFilter: AWSEncodableShape {
        /// The status of an annotation store version.
        public let status: VersionStatus?

        @inlinable
        public init(status: VersionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListAnnotationStoreVersionsRequest: AWSEncodableShape {
        /// A filter to apply to the list of annotation store versions.
        public let filter: ListAnnotationStoreVersionsFilter?
        /// The maximum number of annotation store versions to return in one page of results.
        public let maxResults: Int?
        /// The name of an annotation store.
        public let name: String
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListAnnotationStoreVersionsFilter? = nil, maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListAnnotationStoreVersionsResponse: AWSDecodableShape {
        /// Lists all versions of an annotation store.
        public let annotationStoreVersions: [AnnotationStoreVersionItem]?
        /// Specifies the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(annotationStoreVersions: [AnnotationStoreVersionItem]? = nil, nextToken: String? = nil) {
            self.annotationStoreVersions = annotationStoreVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationStoreVersions = "annotationStoreVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnnotationStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        @inlinable
        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListAnnotationStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListAnnotationStoresFilter?
        /// IDs of stores to list.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListAnnotationStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListAnnotationStoresResponse: AWSDecodableShape {
        /// A list of stores.
        public let annotationStores: [AnnotationStoreItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(annotationStores: [AnnotationStoreItem]? = nil, nextToken: String? = nil) {
            self.annotationStores = annotationStores
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationStores = "annotationStores"
            case nextToken = "nextToken"
        }
    }

    public struct ListMultipartReadSetUploadsRequest: AWSEncodableShape {
        /// The maximum number of multipart uploads returned in a page.
        public let maxResults: Int?
        /// Next token returned in the response of a previous ListMultipartReadSetUploads call.  Used to get the next page of results.
        public let nextToken: String?
        /// The Sequence Store ID used for the multipart uploads.
        public let sequenceStoreId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMultipartReadSetUploadsResponse: AWSDecodableShape {
        /// Next token returned in the response of a previous ListMultipartReadSetUploads call.  Used to get the next page of results.
        public let nextToken: String?
        /// An array of multipart uploads.
        public let uploads: [MultipartReadSetUploadListItem]?

        @inlinable
        public init(nextToken: String? = nil, uploads: [MultipartReadSetUploadListItem]? = nil) {
            self.nextToken = nextToken
            self.uploads = uploads
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case uploads = "uploads"
        }
    }

    public struct ListReadSetActivationJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ActivateReadSetFilter?
        /// The maximum number of read set activation jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(filter: ActivateReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetActivationJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let activationJobs: [ActivateReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(activationJobs: [ActivateReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.activationJobs = activationJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case activationJobs = "activationJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetExportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ExportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(filter: ExportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetExportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let exportJobs: [ExportReadSetJobDetail]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(exportJobs: [ExportReadSetJobDetail]? = nil, nextToken: String? = nil) {
            self.exportJobs = exportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobs = "exportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ImportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(filter: ImportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let importJobs: [ImportReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(importJobs: [ImportReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs = "importJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadSetUploadPartsRequest: AWSEncodableShape {
        /// Attributes used to filter for a specific subset of read set part uploads.
        public let filter: ReadSetUploadPartListFilter?
        /// The maximum number of read set upload parts returned in a page.
        public let maxResults: Int?
        /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
        public let nextToken: String?
        /// The source file for the upload part.
        public let partSource: ReadSetPartSource
        /// The Sequence Store ID used for the multipart uploads.
        public let sequenceStoreId: String
        /// The ID for the initiated multipart upload.
        public let uploadId: String

        @inlinable
        public init(filter: ReadSetUploadPartListFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, partSource: ReadSetPartSource, sequenceStoreId: String, uploadId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.partSource = partSource
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.partSource, forKey: .partSource)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case partSource = "partSource"
        }
    }

    public struct ListReadSetUploadPartsResponse: AWSDecodableShape {
        /// Next token returned in the response of a previous ListReadSetUploadParts call. Used to get the next page of results.
        public let nextToken: String?
        /// An array of upload parts.
        public let parts: [ReadSetUploadPartListItem]?

        @inlinable
        public init(nextToken: String? = nil, parts: [ReadSetUploadPartListItem]? = nil) {
            self.nextToken = nextToken
            self.parts = parts
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case parts = "parts"
        }
    }

    public struct ListReadSetsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReadSetFilter?
        /// The maximum number of read sets to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        @inlinable
        public init(filter: ReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReadSetsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of read sets.
        public let readSets: [ReadSetListItem]

        @inlinable
        public init(nextToken: String? = nil, readSets: [ReadSetListItem]) {
            self.nextToken = nextToken
            self.readSets = readSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readSets = "readSets"
        }
    }

    public struct ListReferenceImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ImportReferenceFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String

        @inlinable
        public init(filter: ImportReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferenceImportJobsResponse: AWSDecodableShape {
        /// A lis of jobs.
        public let importJobs: [ImportReferenceJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(importJobs: [ImportReferenceJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs = "importJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListReferenceStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReferenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ReferenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of reference stores.
        public let referenceStores: [ReferenceStoreDetail]

        @inlinable
        public init(nextToken: String? = nil, referenceStores: [ReferenceStoreDetail]) {
            self.nextToken = nextToken
            self.referenceStores = referenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case referenceStores = "referenceStores"
        }
    }

    public struct ListReferencesRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ReferenceFilter?
        /// The maximum number of references to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The references' reference store ID.
        public let referenceStoreId: String

        @inlinable
        public init(filter: ReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListReferencesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of references.
        public let references: [ReferenceListItem]

        @inlinable
        public init(nextToken: String? = nil, references: [ReferenceListItem]) {
            self.nextToken = nextToken
            self.references = references
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case references = "references"
        }
    }

    public struct ListRunCachesRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Optional pagination token returned from a prior call to the ListRunCaches API operation.
        public let startingToken: String?

        @inlinable
        public init(maxResults: Int? = nil, startingToken: String? = nil) {
            self.maxResults = maxResults
            self.startingToken = startingToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.startingToken, key: "startingToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunCachesResponse: AWSDecodableShape {
        /// Details about each run cache in the response.
        public let items: [RunCacheListItem]?
        /// Pagination token to retrieve additional run caches. If the response does not have a  nextTokenvalue, you have reached to the end of the list.
        public let nextToken: String?

        @inlinable
        public init(items: [RunCacheListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRunGroupsRequest: AWSEncodableShape {
        /// The maximum number of run groups to return in one page of results.
        public let maxResults: Int?
        /// The run groups' name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.startingToken, key: "startingToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunGroupsResponse: AWSDecodableShape {
        /// A list of groups.
        public let items: [RunGroupListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(items: [RunGroupListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRunTasksRequest: AWSEncodableShape {
        /// The run's ID.
        public let id: String
        /// The maximum number of run tasks to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// Filter the list by status.
        public let status: TaskStatus?

        @inlinable
        public init(id: String, maxResults: Int? = nil, startingToken: String? = nil, status: TaskStatus? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.startingToken = startingToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunTasksResponse: AWSDecodableShape {
        /// A list of tasks.
        public let items: [TaskListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(items: [TaskListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRunsRequest: AWSEncodableShape {
        /// The maximum number of runs to return in one page of results.
        public let maxResults: Int?
        /// Filter the list by run name.
        public let name: String?
        /// Filter the list by run group ID.
        public let runGroupId: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// The status of a run.
        public let status: RunStatus?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, runGroupId: String? = nil, startingToken: String? = nil, status: RunStatus? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.runGroupId = runGroupId
            self.startingToken = startingToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.runGroupId, key: "runGroupId")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunsResponse: AWSDecodableShape {
        /// A list of runs.
        public let items: [RunListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(items: [RunListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSequenceStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: SequenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: SequenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct ListSequenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of sequence stores.
        public let sequenceStores: [SequenceStoreDetail]

        @inlinable
        public init(nextToken: String? = nil, sequenceStores: [SequenceStoreDetail]) {
            self.nextToken = nextToken
            self.sequenceStores = sequenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sequenceStores = "sequenceStores"
        }
    }

    public struct ListSharesRequest: AWSEncodableShape {
        /// Attributes that you use to filter for a specific subset of resource shares.
        public let filter: Filter?
        /// The maximum number of shares to return in one page of results.
        public let maxResults: Int?
        /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
        public let nextToken: String?
        /// The account that owns the resource shares.
        public let resourceOwner: ResourceOwner

        @inlinable
        public init(filter: Filter? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceOwner: ResourceOwner) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceOwner = resourceOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.resourceOwner, forKey: .resourceOwner)
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListSharesResponse: AWSDecodableShape {
        /// Next token returned in the response of a previous ListSharesResponse call. Used to get the next page of results.
        public let nextToken: String?
        /// The shares available and their metadata details.
        public let shares: [ShareDetails]

        @inlinable
        public init(nextToken: String? = nil, shares: [ShareDetails]) {
            self.nextToken = nextToken
            self.shares = shares
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case shares = "shares"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVariantImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        @inlinable
        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case storeName = "storeName"
        }
    }

    public struct ListVariantImportJobsRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListVariantImportJobsFilter?
        /// A list of job IDs.
        public let ids: [String]?
        /// The maximum number of import jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListVariantImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListVariantImportJobsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of jobs.
        public let variantImportJobs: [VariantImportJobItem]?

        @inlinable
        public init(nextToken: String? = nil, variantImportJobs: [VariantImportJobItem]? = nil) {
            self.nextToken = nextToken
            self.variantImportJobs = variantImportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case variantImportJobs = "variantImportJobs"
        }
    }

    public struct ListVariantStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        @inlinable
        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListVariantStoresRequest: AWSEncodableShape {
        /// A filter to apply to the list.
        public let filter: ListVariantStoresFilter?
        /// A list of store IDs.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListVariantStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.ids, forKey: .ids)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ids = "ids"
        }
    }

    public struct ListVariantStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of variant stores.
        public let variantStores: [VariantStoreItem]?

        @inlinable
        public init(nextToken: String? = nil, variantStores: [VariantStoreItem]? = nil) {
            self.nextToken = nextToken
            self.variantStores = variantStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case variantStores = "variantStores"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The maximum number of workflows to return in one page of results.
        public let maxResults: Int?
        /// Filter the list by workflow name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// Filter the list by workflow type.
        public let type: WorkflowType?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil, type: WorkflowType? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.startingToken, key: "startingToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// A list of workflow items.
        public let items: [WorkflowListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(items: [WorkflowListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct MultipartReadSetUploadListItem: AWSDecodableShape {
        ///  The time stamp for when a direct upload was created.
        public let creationTime: Date
        ///  The description of a read set.
        public let description: String?
        ///  The source of an uploaded part.
        public let generatedFrom: String
        ///  The name of a read set.
        public let name: String?
        ///  The source's reference ARN.
        public let referenceArn: String
        ///  The read set source's sample ID.
        public let sampleId: String
        ///  The sequence store ID used for the multipart upload.
        public let sequenceStoreId: String
        ///  The type of file the read set originated from.
        public let sourceFileType: FileType
        ///  The read set source's subject ID.
        public let subjectId: String
        ///  Any tags you wish to add to a read set.
        public let tags: [String: String]?
        ///  The ID for the initiated multipart upload.
        public let uploadId: String

        @inlinable
        public init(creationTime: Date, description: String? = nil, generatedFrom: String, name: String? = nil, referenceArn: String, sampleId: String, sequenceStoreId: String, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil, uploadId: String) {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceStoreId = "sequenceStoreId"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
            case uploadId = "uploadId"
        }
    }

    public struct PutS3AccessPolicyRequest: AWSEncodableShape {
        /// The S3 access point ARN where you want to put the access policy.
        public let s3AccessPointArn: String
        /// The resource policy that controls S3 access to the store.
        public let s3AccessPolicy: String

        @inlinable
        public init(s3AccessPointArn: String, s3AccessPolicy: String) {
            self.s3AccessPointArn = s3AccessPointArn
            self.s3AccessPolicy = s3AccessPolicy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.s3AccessPointArn, key: "s3AccessPointArn")
            try container.encode(self.s3AccessPolicy, forKey: .s3AccessPolicy)
        }

        public func validate(name: String) throws {
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, max: 1024)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, min: 1)
            try self.validate(self.s3AccessPointArn, name: "s3AccessPointArn", parent: name, pattern: "^arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*$")
            try self.validate(self.s3AccessPolicy, name: "s3AccessPolicy", parent: name, max: 100000)
            try self.validate(self.s3AccessPolicy, name: "s3AccessPolicy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3AccessPolicy = "s3AccessPolicy"
        }
    }

    public struct PutS3AccessPolicyResponse: AWSDecodableShape {
        /// The S3 access point ARN that now has the access policy.
        public let s3AccessPointArn: String?
        /// The AWS-generated Sequence Store or Reference Store ID.
        public let storeId: String?
        /// The type of store associated with the access point.
        public let storeType: StoreType?

        @inlinable
        public init(s3AccessPointArn: String? = nil, storeId: String? = nil, storeType: StoreType? = nil) {
            self.s3AccessPointArn = s3AccessPointArn
            self.storeId = storeId
            self.storeType = storeType
        }

        private enum CodingKeys: String, CodingKey {
            case s3AccessPointArn = "s3AccessPointArn"
            case storeId = "storeId"
            case storeType = "storeType"
        }
    }

    public struct ReadOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's comment character.
        public let comment: String?
        /// The file's encoding.
        public let encoding: String?
        /// A character for escaping quotes in the file.
        public let escape: String?
        /// Whether quotes need to be escaped in the file.
        public let escapeQuotes: Bool?
        /// Whether the file has a header row.
        public let header: Bool?
        /// A line separator for the file.
        public let lineSep: String?
        /// The file's quote character.
        public let quote: String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public let quoteAll: Bool?
        /// The file's field separator.
        public let sep: String?

        @inlinable
        public init(comment: String? = nil, encoding: String? = nil, escape: String? = nil, escapeQuotes: Bool? = nil, header: Bool? = nil, lineSep: String? = nil, quote: String? = nil, quoteAll: Bool? = nil, sep: String? = nil) {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.encoding, name: "encoding", parent: name, max: 20)
            try self.validate(self.encoding, name: "encoding", parent: name, min: 1)
            try self.validate(self.escape, name: "escape", parent: name, max: 1)
            try self.validate(self.escape, name: "escape", parent: name, min: 1)
            try self.validate(self.lineSep, name: "lineSep", parent: name, max: 20)
            try self.validate(self.lineSep, name: "lineSep", parent: name, min: 1)
            try self.validate(self.quote, name: "quote", parent: name, max: 1)
            try self.validate(self.quote, name: "quote", parent: name, min: 1)
            try self.validate(self.sep, name: "sep", parent: name, max: 20)
            try self.validate(self.sep, name: "sep", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case encoding = "encoding"
            case escape = "escape"
            case escapeQuotes = "escapeQuotes"
            case header = "header"
            case lineSep = "lineSep"
            case quote = "quote"
            case quoteAll = "quoteAll"
            case sep = "sep"
        }
    }

    public struct ReadSetBatchError: AWSDecodableShape {
        /// The error's code.
        public let code: String
        /// The error's ID.
        public let id: String
        /// The error's message.
        public let message: String

        @inlinable
        public init(code: String, id: String, message: String) {
            self.code = code
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case id = "id"
            case message = "message"
        }
    }

    public struct ReadSetFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The location of the first file in Amazon S3.
        public let source1: FileInformation?
        /// The location of the second file in Amazon S3.
        public let source2: FileInformation?

        @inlinable
        public init(index: FileInformation? = nil, source1: FileInformation? = nil, source2: FileInformation? = nil) {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct ReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        ///  The creation type of the read set.
        public let creationType: CreationType?
        ///  Where the source originated.
        public let generatedFrom: String?
        /// A name to filter on.
        public let name: String?
        /// A genome reference ARN to filter on.
        public let referenceArn: String?
        ///  The read set source's sample ID.
        public let sampleId: String?
        /// A status to filter on.
        public let status: ReadSetStatus?
        ///  The read set source's subject ID.
        public let subjectId: String?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, creationType: CreationType? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, status: ReadSetStatus? = nil, subjectId: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.creationType = creationType
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.status = status
            self.subjectId = subjectId
        }

        public func validate(name: String) throws {
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^$|^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case creationType = "creationType"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case status = "status"
            case subjectId = "subjectId"
        }
    }

    public struct ReadSetListItem: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// When the read set was created.
        public let creationTime: Date
        ///  The creation type of the read set.
        public let creationType: CreationType?
        /// The read set's description.
        public let description: String?
        /// The entity tag (ETag) is a hash of the object representing its semantic content.
        public let etag: ETag?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        ///  The status for a read set. It provides more detail as to why the read set has a status.
        public let statusMessage: String?
        /// The read set's subject ID.
        public let subjectId: String?

        @inlinable
        public init(arn: String, creationTime: Date, creationType: CreationType? = nil, description: String? = nil, etag: ETag? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, statusMessage: String? = nil, subjectId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case creationType = "creationType"
            case description = "description"
            case etag = "etag"
            case fileType = "fileType"
            case id = "id"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sequenceInformation = "sequenceInformation"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
            case statusMessage = "statusMessage"
            case subjectId = "subjectId"
        }
    }

    public struct ReadSetS3Access: AWSDecodableShape {
        /// The S3 URI for each read set file.
        public let s3Uri: String?

        @inlinable
        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ReadSetUploadPartListFilter: AWSEncodableShape {
        ///  Filters for read set uploads after a specified time.
        public let createdAfter: Date?
        ///  Filters for read set part uploads before a specified time.
        public let createdBefore: Date?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
        }
    }

    public struct ReadSetUploadPartListItem: AWSDecodableShape {
        ///  A unique identifier used to confirm that parts are being added to the correct upload.
        public let checksum: String
        ///  The time stamp for when a direct upload was created.
        public let creationTime: Date?
        ///  The time stamp for the most recent update to an uploaded part.
        public let lastUpdatedTime: Date?
        ///  The number identifying the part in an upload.
        public let partNumber: Int
        ///  The size of the the part in an upload.
        public let partSize: Int64
        ///  The origin of the part being direct uploaded.
        public let partSource: ReadSetPartSource

        @inlinable
        public init(checksum: String, creationTime: Date? = nil, lastUpdatedTime: Date? = nil, partNumber: Int, partSize: Int64, partSource: ReadSetPartSource) {
            self.checksum = checksum
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.partNumber = partNumber
            self.partSize = partSize
            self.partSource = partSource
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
            case creationTime = "creationTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case partNumber = "partNumber"
            case partSize = "partSize"
            case partSource = "partSource"
        }
    }

    public struct ReferenceFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The source file's location in Amazon S3.
        public let source: FileInformation?

        @inlinable
        public init(index: FileInformation? = nil, source: FileInformation? = nil) {
            self.index = index
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case source = "source"
        }
    }

    public struct ReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// An MD5 checksum to filter on.
        public let md5: String?
        /// A name to filter on.
        public let name: String?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, md5: String? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.md5, name: "md5", parent: name, max: 255)
            try self.validate(self.md5, name: "md5", parent: name, min: 1)
            try self.validate(self.md5, name: "md5", parent: name, pattern: "^[\\p{L}||\\p{N}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case md5 = "md5"
            case name = "name"
        }
    }

    public struct ReferenceListItem: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's description.
        public let description: String?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case md5 = "md5"
            case name = "name"
            case referenceStoreId = "referenceStoreId"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct ReferenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
        }
    }

    public struct ReferenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The name to filter on.
        public let name: String?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case name = "name"
        }
    }

    public struct RunCacheListItem: AWSDecodableShape {
        /// Unique resource identifier for the run cache.
        public let arn: String?
        /// Default cache behavior for the run cache.
        public let cacheBehavior: CacheBehavior?
        /// The S3 uri for the run cache data.
        public let cacheS3Uri: String?
        /// The time that this run cache was created (an ISO 8601 formatted string).
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The identifier for this run cache.
        public let id: String?
        /// The name of the run cache.
        public let name: String?
        /// The run cache status.
        public let status: RunCacheStatus?

        @inlinable
        public init(arn: String? = nil, cacheBehavior: CacheBehavior? = nil, cacheS3Uri: String? = nil, creationTime: Date? = nil, id: String? = nil, name: String? = nil, status: RunCacheStatus? = nil) {
            self.arn = arn
            self.cacheBehavior = cacheBehavior
            self.cacheS3Uri = cacheS3Uri
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cacheBehavior = "cacheBehavior"
            case cacheS3Uri = "cacheS3Uri"
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct RunGroupListItem: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum CPU count setting.
        public let maxCpus: Int?
        /// The group's maximum duration setting in minutes.
        public let maxDuration: Int?
        ///  The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The group's maximum concurrent run setting.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
        }
    }

    public struct RunListItem: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's ID.
        public let id: String?
        /// The run's name.
        public let name: String?
        /// The run's priority.
        public let priority: Int?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// When the run stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity in gibibytes. For dynamic storage,  after the run has completed, this value is the maximum amount of storage used during the run.
        public let storageCapacity: Int?
        /// The run's storage type.
        public let storageType: StorageType?
        /// The run's workflow ID.
        public let workflowId: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, name: String? = nil, priority: Int? = nil, startTime: Date? = nil, status: RunStatus? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, storageType: StorageType? = nil, workflowId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.storageType = storageType
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case startTime = "startTime"
            case status = "status"
            case stopTime = "stopTime"
            case storageCapacity = "storageCapacity"
            case storageType = "storageType"
            case workflowId = "workflowId"
        }
    }

    public struct RunLogLocation: AWSDecodableShape {
        /// The log stream ARN for the engine log.
        public let engineLogStream: String?
        /// The log stream ARN for the run log.
        public let runLogStream: String?

        @inlinable
        public init(engineLogStream: String? = nil, runLogStream: String? = nil) {
            self.engineLogStream = engineLogStream
            self.runLogStream = runLogStream
        }

        private enum CodingKeys: String, CodingKey {
            case engineLogStream = "engineLogStream"
            case runLogStream = "runLogStream"
        }
    }

    public struct S3AccessConfig: AWSEncodableShape {
        /// Location of the access logs.
        public let accessLogLocation: String?

        @inlinable
        public init(accessLogLocation: String? = nil) {
            self.accessLogLocation = accessLogLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogLocation, name: "accessLogLocation", parent: name, pattern: "^$|^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,800})/)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogLocation = "accessLogLocation"
        }
    }

    public struct SequenceInformation: AWSDecodableShape {
        /// The sequence's alignment setting.
        public let alignment: String?
        /// Where the sequence originated.
        public let generatedFrom: String?
        /// The sequence's total base count.
        public let totalBaseCount: Int64?
        /// The sequence's total read count.
        public let totalReadCount: Int64?

        @inlinable
        public init(alignment: String? = nil, generatedFrom: String? = nil, totalBaseCount: Int64? = nil, totalReadCount: Int64? = nil) {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }

        private enum CodingKeys: String, CodingKey {
            case alignment = "alignment"
            case generatedFrom = "generatedFrom"
            case totalBaseCount = "totalBaseCount"
            case totalReadCount = "totalReadCount"
        }
    }

    public struct SequenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The algorithm family of the ETag.
        public let eTagAlgorithmFamily: ETagAlgorithmFamily?
        ///  An S3 location that is used to store files that have failed a direct upload.
        public let fallbackLocation: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?
        /// Status of the sequence store.
        public let status: SequenceStoreStatus?
        /// The status message of the sequence store.
        public let statusMessage: String?
        /// The last-updated time of the Sequence Store.
        public let updateTime: Date?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, eTagAlgorithmFamily: ETagAlgorithmFamily? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil, status: SequenceStoreStatus? = nil, statusMessage: String? = nil, updateTime: Date? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case eTagAlgorithmFamily = "eTagAlgorithmFamily"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct SequenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A name to filter on.
        public let name: String?
        /// Filter results based on status.
        public let status: SequenceStoreStatus?
        /// Filter results based on stores updated after the specified time.
        public let updatedAfter: Date?
        /// Filter results based on stores updated before the specified time.
        public let updatedBefore: Date?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil, status: SequenceStoreStatus? = nil, updatedAfter: Date? = nil, updatedBefore: Date? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
            self.status = status
            self.updatedAfter = updatedAfter
            self.updatedBefore = updatedBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "createdAfter"
            case createdBefore = "createdBefore"
            case name = "name"
            case status = "status"
            case updatedAfter = "updatedAfter"
            case updatedBefore = "updatedBefore"
        }
    }

    public struct SequenceStoreS3Access: AWSDecodableShape {
        /// Location of the access logs.
        public let accessLogLocation: String?
        /// This is ARN of the access point associated with the S3 bucket storing read sets.
        public let s3AccessPointArn: String?
        /// The S3 URI of the sequence store.
        public let s3Uri: String?

        @inlinable
        public init(accessLogLocation: String? = nil, s3AccessPointArn: String? = nil, s3Uri: String? = nil) {
            self.accessLogLocation = accessLogLocation
            self.s3AccessPointArn = s3AccessPointArn
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogLocation = "accessLogLocation"
            case s3AccessPointArn = "s3AccessPointArn"
            case s3Uri = "s3Uri"
        }
    }

    public struct ShareDetails: AWSDecodableShape {
        /// The timestamp of when the resource share was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The account ID for the data owner. The owner creates the resource share.
        public let ownerId: String?
        /// The principal subscriber is the account that is sharing the resource.
        public let principalSubscriber: String?
        /// The Arn of the shared resource.
        public let resourceArn: String?
        /// The ID of the shared resource.
        public let resourceId: String?
        /// The ID of the resource share.
        public let shareId: String?
        /// The name of the resource share.
        public let shareName: String?
        /// The status of the share.
        public let status: ShareStatus?
        /// The status message for a resource share. It provides additional details about the share status.
        public let statusMessage: String?
        /// The timestamp of the resource share update.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updateTime: Date?

        @inlinable
        public init(creationTime: Date? = nil, ownerId: String? = nil, principalSubscriber: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, shareId: String? = nil, shareName: String? = nil, status: ShareStatus? = nil, statusMessage: String? = nil, updateTime: Date? = nil) {
            self.creationTime = creationTime
            self.ownerId = ownerId
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case ownerId = "ownerId"
            case principalSubscriber = "principalSubscriber"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case shareId = "shareId"
            case shareName = "shareName"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct SourceFiles: AWSEncodableShape & AWSDecodableShape {
        /// The location of the first file in Amazon S3.
        public let source1: String
        /// The location of the second file in Amazon S3.
        public let source2: String?

        @inlinable
        public init(source1: String, source2: String? = nil) {
            self.source1 = source1
            self.source2 = source2
        }

        public func validate(name: String) throws {
            try self.validate(self.source1, name: "source1", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.validate(self.source2, name: "source2", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source1 = "source1"
            case source2 = "source2"
        }
    }

    public struct SseConfig: AWSEncodableShape & AWSDecodableShape {
        /// An encryption key ARN.
        public let keyArn: String?
        /// The encryption type.
        public let type: EncryptionType

        @inlinable
        public init(keyArn: String? = nil, type: EncryptionType) {
            self.keyArn = keyArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "keyArn"
            case type = "type"
        }
    }

    public struct StartAnnotationImportRequest: AWSEncodableShape {
        /// The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// A destination annotation store for the job.
        public let destinationName: String
        /// Formatting options for the annotation file.
        public let formatOptions: FormatOptions?
        /// Items to import.
        public let items: [AnnotationImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The name of the annotation store version.
        public let versionName: String?

        @inlinable
        public init(annotationFields: [String: String]? = nil, destinationName: String, formatOptions: FormatOptions? = nil, items: [AnnotationImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil, versionName: String? = nil) {
            self.annotationFields = annotationFields
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.versionName = versionName
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 3)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case destinationName = "destinationName"
            case formatOptions = "formatOptions"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case versionName = "versionName"
        }
    }

    public struct StartAnnotationImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct StartReadSetActivationJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [StartReadSetActivationJobSourceItem]

        @inlinable
        public init(clientToken: String? = nil, sequenceStoreId: String, sources: [StartReadSetActivationJobSourceItem]) {
            self.clientToken = clientToken
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case sources = "sources"
        }
    }

    public struct StartReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        @inlinable
        public init(creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetActivationJobSourceItem: AWSEncodableShape {
        /// The source's read set ID.
        public let readSetId: String

        @inlinable
        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId = "readSetId"
        }
    }

    public struct StartReadSetExportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A location for exported files in Amazon S3.
        public let destination: String
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [ExportReadSet]

        @inlinable
        public init(clientToken: String? = nil, destination: String, roleArn: String, sequenceStoreId: String, sources: [ExportReadSet]) {
            self.clientToken = clientToken
            self.destination = destination
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.destination, forKey: .destination)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destination = "destination"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReadSetExportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's output location.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        @inlinable
        public init(creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case destination = "destination"
            case id = "id"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetImportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's source files.
        public let sources: [StartReadSetImportJobSourceItem]

        @inlinable
        public init(clientToken: String? = nil, roleArn: String, sequenceStoreId: String, sources: [StartReadSetImportJobSourceItem]) {
            self.clientToken = clientToken
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReadSetImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        @inlinable
        public init(creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case sequenceStoreId = "sequenceStoreId"
            case status = "status"
        }
    }

    public struct StartReadSetImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's reference ARN.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.sourceFiles.validate(name: "\(name).sourceFiles")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generatedFrom = "generatedFrom"
            case name = "name"
            case referenceArn = "referenceArn"
            case sampleId = "sampleId"
            case sourceFiles = "sourceFiles"
            case sourceFileType = "sourceFileType"
            case subjectId = "subjectId"
            case tags = "tags"
        }
    }

    public struct StartReferenceImportJobRequest: AWSEncodableShape {
        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// A service role for the job.
        public let roleArn: String
        /// The job's source files.
        public let sources: [StartReferenceImportJobSourceItem]

        @inlinable
        public init(clientToken: String? = nil, referenceStoreId: String, roleArn: String, sources: [StartReferenceImportJobSourceItem]) {
            self.clientToken = clientToken
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.referenceStoreId, key: "referenceStoreId")
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.sources, forKey: .sources)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case roleArn = "roleArn"
            case sources = "sources"
        }
    }

    public struct StartReferenceImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        @inlinable
        public init(creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case id = "id"
            case referenceStoreId = "referenceStoreId"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct StartReferenceImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String
        /// The source file's location in Amazon S3.
        public let sourceFile: String
        /// The source's tags.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, name: String, sourceFile: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sourceFile, name: "sourceFile", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case sourceFile = "sourceFile"
            case tags = "tags"
        }
    }

    public struct StartRunRequest: AWSEncodableShape {
        /// The cache behavior for the run. You specify this value if you want to override the default behavior for the cache. You had set the default value when you created the cache. For more information, see Run cache behavior in the AWS HealthOmics User Guide.
        public let cacheBehavior: CacheBehavior?
        /// Identifier of the cache associated with this run. If you don't specify a cache ID, no task outputs are cached  for this run.
        public let cacheId: String?
        /// A log level for the run.
        public let logLevel: RunLogLevel?
        /// A name for the run.
        public let name: String?
        /// An output URI for the run.
        public let outputUri: String?
        /// Parameters for the run.
        public let parameters: AWSDocument?
        /// A priority for the run.
        public let priority: Int?
        /// To ensure that requests don't run multiple times, specify a unique ID for each request.
        public let requestId: String
        /// The retention mode for the run. The default value is RETAIN.  HealthOmics stores a fixed number of runs that are available to the console and API.  In the default mode (RETAIN), you need to remove runs manually when the number of run exceeds the maximum. If you set the retention mode to REMOVE, HealthOmics automatically  removes runs (that have mode set to REMOVE) when the number of run exceeds the maximum. All run logs are available in CloudWatch logs, if you need information about a run that is no longer available to the API. For more information about retention mode, see Specifying run retention mode  in the AWS HealthOmics User Guide.
        public let retentionMode: RunRetentionMode?
        /// A service role for the run.
        public let roleArn: String
        /// The run's group ID.
        public let runGroupId: String?
        /// The ID of a run to duplicate.
        public let runId: String?
        /// A storage capacity for the run in gibibytes. This field is not required if the storage type is dynamic (the system ignores any value that you enter).
        public let storageCapacity: Int?
        /// The run's storage type. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, HealthOmics dynamically scales the storage up  or down, based on file system utilization.
        public let storageType: StorageType?
        /// Tags for the run.
        public let tags: [String: String]?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The ID of the workflow owner.
        public let workflowOwnerId: String?
        /// The run's workflow type.
        public let workflowType: WorkflowType?

        @inlinable
        public init(cacheBehavior: CacheBehavior? = nil, cacheId: String? = nil, logLevel: RunLogLevel? = nil, name: String? = nil, outputUri: String? = nil, parameters: AWSDocument? = nil, priority: Int? = nil, requestId: String = StartRunRequest.idempotencyToken(), retentionMode: RunRetentionMode? = nil, roleArn: String, runGroupId: String? = nil, runId: String? = nil, storageCapacity: Int? = nil, storageType: StorageType? = nil, tags: [String: String]? = nil, workflowId: String? = nil, workflowOwnerId: String? = nil, workflowType: WorkflowType? = nil) {
            self.cacheBehavior = cacheBehavior
            self.cacheId = cacheId
            self.logLevel = logLevel
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.requestId = requestId
            self.retentionMode = retentionMode
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.storageCapacity = storageCapacity
            self.storageType = storageType
            self.tags = tags
            self.workflowId = workflowId
            self.workflowOwnerId = workflowOwnerId
            self.workflowType = workflowType
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheId, name: "cacheId", parent: name, max: 18)
            try self.validate(self.cacheId, name: "cacheId", parent: name, min: 1)
            try self.validate(self.cacheId, name: "cacheId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.outputUri, name: "outputUri", parent: name, max: 750)
            try self.validate(self.outputUri, name: "outputUri", parent: name, min: 1)
            try self.validate(self.outputUri, name: "outputUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 128)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.runId, name: "runId", parent: name, max: 18)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.workflowId, name: "workflowId", parent: name, max: 18)
            try self.validate(self.workflowId, name: "workflowId", parent: name, min: 1)
            try self.validate(self.workflowId, name: "workflowId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.workflowOwnerId, name: "workflowOwnerId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheBehavior = "cacheBehavior"
            case cacheId = "cacheId"
            case logLevel = "logLevel"
            case name = "name"
            case outputUri = "outputUri"
            case parameters = "parameters"
            case priority = "priority"
            case requestId = "requestId"
            case retentionMode = "retentionMode"
            case roleArn = "roleArn"
            case runGroupId = "runGroupId"
            case runId = "runId"
            case storageCapacity = "storageCapacity"
            case storageType = "storageType"
            case tags = "tags"
            case workflowId = "workflowId"
            case workflowOwnerId = "workflowOwnerId"
            case workflowType = "workflowType"
        }
    }

    public struct StartRunResponse: AWSDecodableShape {
        /// Unique resource identifier for the run.
        public let arn: String?
        /// The run's ID.
        public let id: String?
        /// The destination for workflow outputs.
        public let runOutputUri: String?
        /// The run's status.
        public let status: RunStatus?
        /// The run's tags.
        public let tags: [String: String]?
        /// The universally unique identifier for a run.
        public let uuid: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, runOutputUri: String? = nil, status: RunStatus? = nil, tags: [String: String]? = nil, uuid: String? = nil) {
            self.arn = arn
            self.id = id
            self.runOutputUri = runOutputUri
            self.status = status
            self.tags = tags
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case runOutputUri = "runOutputUri"
            case status = "status"
            case tags = "tags"
            case uuid = "uuid"
        }
    }

    public struct StartVariantImportRequest: AWSEncodableShape {
        /// The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// The destination variant store for the job.
        public let destinationName: String
        /// Items to import.
        public let items: [VariantImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?

        @inlinable
        public init(annotationFields: [String: String]? = nil, destinationName: String, items: [VariantImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil) {
            self.annotationFields = annotationFields
            self.destinationName = destinationName
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case destinationName = "destinationName"
            case items = "items"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
        }
    }

    public struct StartVariantImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Tags for the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskListItem: AWSDecodableShape {
        /// Set to true if AWS HealthOmics found a matching entry in the run cache for this task.
        public let cacheHit: Bool?
        /// The S3 URI of the cache location.
        public let cacheS3Uri: String?
        /// The task's CPU count.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        ///  The number of Graphics Processing Units (GPU) specified for the task.
        public let gpus: Int?
        ///  The instance type for a task.
        public let instanceType: String?
        /// The task's memory use in gigabyes.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// When the task started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// When the task stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        @inlinable
        public init(cacheHit: Bool? = nil, cacheS3Uri: String? = nil, cpus: Int? = nil, creationTime: Date? = nil, gpus: Int? = nil, instanceType: String? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cacheHit = cacheHit
            self.cacheS3Uri = cacheS3Uri
            self.cpus = cpus
            self.creationTime = creationTime
            self.gpus = gpus
            self.instanceType = instanceType
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cacheHit = "cacheHit"
            case cacheS3Uri = "cacheS3Uri"
            case cpus = "cpus"
            case creationTime = "creationTime"
            case gpus = "gpus"
            case instanceType = "instanceType"
            case memory = "memory"
            case name = "name"
            case startTime = "startTime"
            case status = "status"
            case stopTime = "stopTime"
            case taskId = "taskId"
        }
    }

    public struct TsvOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's read options.
        public let readOptions: ReadOptions?

        @inlinable
        public init(readOptions: ReadOptions? = nil) {
            self.readOptions = readOptions
        }

        public func validate(name: String) throws {
            try self.readOptions?.validate(name: "\(name).readOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case readOptions = "readOptions"
        }
    }

    public struct TsvStoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// The store's annotation type.
        public let annotationType: AnnotationType?
        /// The store's header key to column name mapping.
        public let formatToHeader: [FormatToHeaderKey: String]?
        /// The store's schema.
        public let schema: [[String: SchemaValueType]]?

        @inlinable
        public init(annotationType: AnnotationType? = nil, formatToHeader: [FormatToHeaderKey: String]? = nil, schema: [[String: SchemaValueType]]? = nil) {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.schema?.forEach {
                try validate($0, name: "schema[]", parent: name, max: 1)
                try validate($0, name: "schema[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case annotationType = "annotationType"
            case formatToHeader = "formatToHeader"
            case schema = "schema"
        }
    }

    public struct TsvVersionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The store version's annotation type.
        public let annotationType: AnnotationType?
        /// The annotation store version's header key to column name mapping.
        public let formatToHeader: [FormatToHeaderKey: String]?
        /// The TSV schema for an annotation store version.
        public let schema: [[String: SchemaValueType]]?

        @inlinable
        public init(annotationType: AnnotationType? = nil, formatToHeader: [FormatToHeaderKey: String]? = nil, schema: [[String: SchemaValueType]]? = nil) {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.schema?.forEach {
                try validate($0, name: "schema[]", parent: name, max: 1)
                try validate($0, name: "schema[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case annotationType = "annotationType"
            case formatToHeader = "formatToHeader"
            case schema = "schema"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Keys of tags to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnnotationStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        @inlinable
        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// Parsing options for the store.
        public let storeOptions: StoreOptions?
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case storeFormat = "storeFormat"
            case storeOptions = "storeOptions"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateAnnotationStoreVersionRequest: AWSEncodableShape {
        /// The description of an annotation store.
        public let description: String?
        /// The name of an annotation store.
        public let name: String
        /// The name of an annotation store version.
        public let versionName: String

        @inlinable
        public init(description: String? = nil, name: String, versionName: String) {
            self.description = description
            self.name = name
            self.versionName = versionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.versionName, key: "versionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnnotationStoreVersionResponse: AWSDecodableShape {
        /// The time stamp for when an annotation store version was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of an annotation store version.
        public let description: String
        /// The annotation store version ID.
        public let id: String
        /// The name of an annotation store.
        public let name: String
        /// The status of an annotation store version.
        public let status: VersionStatus
        /// The annotation store ID.
        public let storeId: String
        /// The time stamp for when an annotation store version was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date
        /// The name of an annotation store version.
        public let versionName: String

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, status: VersionStatus, storeId: String, updateTime: Date, versionName: String) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case storeId = "storeId"
            case updateTime = "updateTime"
            case versionName = "versionName"
        }
    }

    public struct UpdateRunCacheRequest: AWSEncodableShape {
        /// Update the default run cache behavior.
        public let cacheBehavior: CacheBehavior?
        /// Update the run cache description.
        public let description: String?
        /// The identifier of the run cache you want to update.
        public let id: String
        /// Update the name of the run cache.
        public let name: String?

        @inlinable
        public init(cacheBehavior: CacheBehavior? = nil, description: String? = nil, id: String, name: String? = nil) {
            self.cacheBehavior = cacheBehavior
            self.description = description
            self.id = id
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.cacheBehavior, forKey: .cacheBehavior)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheBehavior = "cacheBehavior"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateRunGroupRequest: AWSEncodableShape {
        /// The group's ID.
        public let id: String
        /// The maximum number of CPUs to use.
        public let maxCpus: Int?
        /// A maximum run time for the group in minutes.
        public let maxDuration: Int?
        /// The maximum GPUs that can be used by a run group.
        public let maxGpus: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?

        @inlinable
        public init(id: String, maxCpus: Int? = nil, maxDuration: Int? = nil, maxGpus: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.maxCpus, forKey: .maxCpus)
            try container.encodeIfPresent(self.maxDuration, forKey: .maxDuration)
            try container.encodeIfPresent(self.maxGpus, forKey: .maxGpus)
            try container.encodeIfPresent(self.maxRuns, forKey: .maxRuns)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus = "maxCpus"
            case maxDuration = "maxDuration"
            case maxGpus = "maxGpus"
            case maxRuns = "maxRuns"
            case name = "name"
        }
    }

    public struct UpdateSequenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the sequence store.
        public let description: String?
        /// The S3 URI of a bucket and folder to store Read Sets that fail to upload.
        public let fallbackLocation: String?
        /// The ID of the sequence store.
        public let id: String
        /// A name for the sequence store.
        public let name: String?
        /// The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
        public let propagatedSetLevelTags: [String]?
        /// S3 access configuration parameters.
        public let s3AccessConfig: S3AccessConfig?

        @inlinable
        public init(clientToken: String? = UpdateSequenceStoreRequest.idempotencyToken(), description: String? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, propagatedSetLevelTags: [String]? = nil, s3AccessConfig: S3AccessConfig? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.propagatedSetLevelTags = propagatedSetLevelTags
            self.s3AccessConfig = s3AccessConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.fallbackLocation, forKey: .fallbackLocation)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.propagatedSetLevelTags, forKey: .propagatedSetLevelTags)
            try container.encodeIfPresent(self.s3AccessConfig, forKey: .s3AccessConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.fallbackLocation, name: "fallbackLocation", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.propagatedSetLevelTags?.forEach {
                try validate($0, name: "propagatedSetLevelTags[]", parent: name, max: 128)
                try validate($0, name: "propagatedSetLevelTags[]", parent: name, min: 1)
            }
            try self.validate(self.propagatedSetLevelTags, name: "propagatedSetLevelTags", parent: name, max: 50)
            try self.s3AccessConfig?.validate(name: "\(name).s3AccessConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case fallbackLocation = "fallbackLocation"
            case name = "name"
            case propagatedSetLevelTags = "propagatedSetLevelTags"
            case s3AccessConfig = "s3AccessConfig"
        }
    }

    public struct UpdateSequenceStoreResponse: AWSDecodableShape {
        /// The ARN of the sequence store.
        public let arn: String
        /// The time when the store was created.
        public let creationTime: Date
        /// Description of the sequence store.
        public let description: String?
        /// The ETag algorithm family to use on ingested read sets.
        public let eTagAlgorithmFamily: ETagAlgorithmFamily?
        /// The S3 URI of a bucket and folder to store Read Sets that fail to upload.
        public let fallbackLocation: String?
        /// The ID of the sequence store.
        public let id: String
        /// The name of the sequence store.
        public let name: String?
        /// The tags keys to propagate to the S3 objects associated with read sets in the sequence store.
        public let propagatedSetLevelTags: [String]?
        public let s3Access: SequenceStoreS3Access?
        public let sseConfig: SseConfig?
        /// The status of the sequence store.
        public let status: SequenceStoreStatus?
        /// The status message of the sequence store.
        public let statusMessage: String?
        /// The last-updated time of the Sequence Store.
        public let updateTime: Date?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, eTagAlgorithmFamily: ETagAlgorithmFamily? = nil, fallbackLocation: String? = nil, id: String, name: String? = nil, propagatedSetLevelTags: [String]? = nil, s3Access: SequenceStoreS3Access? = nil, sseConfig: SseConfig? = nil, status: SequenceStoreStatus? = nil, statusMessage: String? = nil, updateTime: Date? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.propagatedSetLevelTags = propagatedSetLevelTags
            self.s3Access = s3Access
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case eTagAlgorithmFamily = "eTagAlgorithmFamily"
            case fallbackLocation = "fallbackLocation"
            case id = "id"
            case name = "name"
            case propagatedSetLevelTags = "propagatedSetLevelTags"
            case s3Access = "s3Access"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateVariantStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        @inlinable
        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        /// A description for the workflow.
        public let description: String?
        /// The workflow's ID.
        public let id: String
        /// A name for the workflow.
        public let name: String?

        @inlinable
        public init(description: String? = nil, id: String, name: String? = nil) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UploadReadSetPartRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The number of the part being uploaded.
        public let partNumber: Int
        /// The source file for an upload part.
        public let partSource: ReadSetPartSource
        /// The read set data to upload for a part.
        public let payload: AWSHTTPBody
        /// The Sequence Store ID used for the multipart upload.
        public let sequenceStoreId: String
        /// The ID for the initiated multipart upload.
        public let uploadId: String

        @inlinable
        public init(partNumber: Int, partSource: ReadSetPartSource, payload: AWSHTTPBody, sequenceStoreId: String, uploadId: String) {
            self.partNumber = partNumber
            self.partSource = partSource
            self.payload = payload
            self.sequenceStoreId = sequenceStoreId
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeQuery(self.partNumber, key: "partNumber")
            request.encodeQuery(self.partSource, key: "partSource")
            try container.encode(self.payload)
            request.encodePath(self.sequenceStoreId, key: "sequenceStoreId")
            request.encodePath(self.uploadId, key: "uploadId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 36)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UploadReadSetPartResponse: AWSDecodableShape {
        /// An identifier used to confirm that parts are being added to the intended upload.
        public let checksum: String

        @inlinable
        public init(checksum: String) {
            self.checksum = checksum
        }

        private enum CodingKeys: String, CodingKey {
            case checksum = "checksum"
        }
    }

    public struct VariantImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String
        ///  A message that provides additional context about a job
        public let statusMessage: String?

        @inlinable
        public init(jobStatus: JobStatus, source: String, statusMessage: String? = nil) {
            self.jobStatus = jobStatus
            self.source = source
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "jobStatus"
            case source = "source"
            case statusMessage = "statusMessage"
        }
    }

    public struct VariantImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        @inlinable
        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct VariantImportJobItem: AWSDecodableShape {
        ///  The annotation schema generated by the parsed annotation data.
        public let annotationFields: [String: String]?
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(annotationFields: [String: String]? = nil, completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date) {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotationFields = "annotationFields"
            case completionTime = "completionTime"
            case creationTime = "creationTime"
            case destinationName = "destinationName"
            case id = "id"
            case roleArn = "roleArn"
            case runLeftNormalization = "runLeftNormalization"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct VariantStoreItem: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case reference = "reference"
            case sseConfig = "sseConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case storeArn = "storeArn"
            case storeSizeBytes = "storeSizeBytes"
            case updateTime = "updateTime"
        }
    }

    public struct VcfOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's ignore filter field setting.
        public let ignoreFilterField: Bool?
        /// The file's ignore qual field setting.
        public let ignoreQualField: Bool?

        @inlinable
        public init(ignoreFilterField: Bool? = nil, ignoreQualField: Bool? = nil) {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }

        private enum CodingKeys: String, CodingKey {
            case ignoreFilterField = "ignoreFilterField"
            case ignoreQualField = "ignoreQualField"
        }
    }

    public struct VersionDeleteError: AWSDecodableShape {
        /// The message explaining the error in annotation store deletion.
        public let message: String
        /// The name given to an annotation store version.
        public let versionName: String

        @inlinable
        public init(message: String, versionName: String) {
            self.message = message
            self.versionName = versionName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case versionName = "versionName"
        }
    }

    public struct WorkflowListItem: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's ID.
        public let id: String?
        ///  Any metadata available for workflow. The information listed may vary depending on the workflow, and there may also be no metadata to return.
        public let metadata: [String: String]?
        /// The workflow's name.
        public let name: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's type.
        public let type: WorkflowType?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, digest: String? = nil, id: String? = nil, metadata: [String: String]? = nil, name: String? = nil, status: WorkflowStatus? = nil, type: WorkflowType? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case digest = "digest"
            case id = "id"
            case metadata = "metadata"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct WorkflowParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter's description.
        public let description: String?
        /// Whether the parameter is optional.
        public let optional: Bool?

        @inlinable
        public init(description: String? = nil, optional: Bool? = nil) {
            self.description = description
            self.optional = optional
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case optional = "optional"
        }
    }

    public struct ReferenceItem: AWSEncodableShape & AWSDecodableShape {
        /// The reference's ARN.
        public let referenceArn: String?

        @inlinable
        public init(referenceArn: String? = nil) {
            self.referenceArn = referenceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case referenceArn = "referenceArn"
        }
    }

    public struct StoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// File settings for a TSV store.
        public let tsvStoreOptions: TsvStoreOptions?

        @inlinable
        public init(tsvStoreOptions: TsvStoreOptions? = nil) {
            self.tsvStoreOptions = tsvStoreOptions
        }

        public func validate(name: String) throws {
            try self.tsvStoreOptions?.validate(name: "\(name).tsvStoreOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case tsvStoreOptions = "tsvStoreOptions"
        }
    }

    public struct VersionOptions: AWSEncodableShape & AWSDecodableShape {
        /// File settings for a version of a TSV store.
        public let tsvVersionOptions: TsvVersionOptions?

        @inlinable
        public init(tsvVersionOptions: TsvVersionOptions? = nil) {
            self.tsvVersionOptions = tsvVersionOptions
        }

        public func validate(name: String) throws {
            try self.tsvVersionOptions?.validate(name: "\(name).tsvVersionOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case tsvVersionOptions = "tsvVersionOptions"
        }
    }
}

// MARK: - Errors

/// Error enum for Omics
public struct OmicsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case notSupportedOperationException = "NotSupportedOperationException"
        case rangeNotSatisfiableException = "RangeNotSatisfiableException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Omics
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request cannot be applied to the target resource in its current state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred. Try the request again.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The operation is not supported by Amazon Omics, or the API does not exist.
    public static var notSupportedOperationException: Self { .init(.notSupportedOperationException) }
    /// The ranges specified in the request are not valid.
    public static var rangeNotSatisfiableException: Self { .init(.rangeNotSatisfiableException) }
    /// The request timed out.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The target resource was not found in the current Region.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension OmicsErrorType: Equatable {
    public static func == (lhs: OmicsErrorType, rhs: OmicsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OmicsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
