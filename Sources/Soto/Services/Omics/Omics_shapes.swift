//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Omics {
    // MARK: Enums

    public enum AnnotationType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Contains contig and 1-base position
        case chrPos = "CHR_POS"
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt = "CHR_POS_REF_ALT"
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase = "CHR_START_END_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase = "CHR_START_END_REF_ALT_ONE_BASE"
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase = "CHR_START_END_REF_ALT_ZERO_BASE"
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase = "CHR_START_END_ZERO_BASE"
        /// Generic text file. No genomic information
        case generic = "GENERIC"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// KMS
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bam = "BAM"
        case cram = "CRAM"
        case fastq = "FASTQ"
        public var description: String { return self.rawValue }
    }

    public enum FormatToHeaderKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case alt = "ALT"
        case chr = "CHR"
        case end = "END"
        case pos = "POS"
        case ref = "REF"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        /// The Job was cancelled
        case cancelled = "CANCELLED"
        /// The Job has completed
        case completed = "COMPLETED"
        /// The Job failed
        case failed = "FAILED"
        /// The Job is executing
        case inProgress = "IN_PROGRESS"
        /// The Job has been submitted to run
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobItemStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetActivationJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobItemStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetExportJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetFile: String, CustomStringConvertible, Codable, _SotoSendable {
        case index = "INDEX"
        case source1 = "SOURCE1"
        case source2 = "SOURCE2"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobItemStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetImportJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReadSetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceFile: String, CustomStringConvertible, Codable, _SotoSendable {
        case index = "INDEX"
        case source = "SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobItemStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case finished = "FINISHED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceImportJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum RunExport: String, CustomStringConvertible, Codable, _SotoSendable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum RunLogLevel: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case error = "ERROR"
        case fatal = "FATAL"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum RunStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaValueType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// BOOLEAN type
        case boolean = "BOOLEAN"
        /// DOUBLE type
        case double = "DOUBLE"
        /// FLOAT type
        case float = "FLOAT"
        /// INT type
        case int = "INT"
        /// LONG type
        case long = "LONG"
        /// STRING type
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum StoreFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        /// GFF3 Format
        case gff = "GFF"
        /// TSV Format
        case tsv = "TSV"
        /// VCF Format
        case vcf = "VCF"
        public var description: String { return self.rawValue }
    }

    public enum StoreStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        /// The Store is active
        case active = "ACTIVE"
        /// The Store is being created
        case creating = "CREATING"
        /// The Store is deleting
        case deleting = "DELETING"
        /// The Store creation failed
        case failed = "FAILED"
        /// The Store is updating
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowEngine: String, CustomStringConvertible, Codable, _SotoSendable {
        case nextflow = "NEXTFLOW"
        case wdl = "WDL"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowExport: String, CustomStringConvertible, Codable, _SotoSendable {
        case definition = "DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public enum FormatOptions: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// Options for a TSV file.
        case tsvOptions(TsvOptions)
        /// Options for a VCF file.
        case vcfOptions(VcfOptions)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .tsvOptions:
                let value = try container.decode(TsvOptions.self, forKey: .tsvOptions)
                self = .tsvOptions(value)
            case .vcfOptions:
                let value = try container.decode(VcfOptions.self, forKey: .vcfOptions)
                self = .vcfOptions(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .tsvOptions(let value):
                try container.encode(value, forKey: .tsvOptions)
            case .vcfOptions(let value):
                try container.encode(value, forKey: .vcfOptions)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .tsvOptions(let value):
                try value.validate(name: "\(name).tsvOptions")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tsvOptions
            case vcfOptions
        }
    }

    // MARK: Shapes

    public struct ActivateReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The filter's status.
        public let status: ReadSetActivationJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetActivationJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case status
        }
    }

    public struct ActivateReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case sequenceStoreId
            case status
        }
    }

    public struct ActivateReadSetSourceItem: AWSDecodableShape {
        /// The source's read set ID.
        public let readSetId: String
        /// The source's status.
        public let status: ReadSetActivationJobItemStatus
        /// The source's status message.
        public let statusMessage: String?

        public init(readSetId: String, status: ReadSetActivationJobItemStatus, statusMessage: String? = nil) {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId
            case status
            case statusMessage
        }
    }

    public struct AnnotationImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String

        public init(jobStatus: JobStatus, source: String) {
            self.jobStatus = jobStatus
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus
            case source
        }
    }

    public struct AnnotationImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source
        }
    }

    public struct AnnotationImportJobItem: AWSDecodableShape {
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destinationName
            case id
            case roleArn
            case runLeftNormalization
            case status
            case updateTime
        }
    }

    public struct AnnotationStoreItem: AWSDecodableShape {
        /// The store's creation time.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's file format.
        public let storeFormat: StoreFormat
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case sseConfig
            case status
            case statusMessage
            case storeArn
            case storeFormat
            case storeSizeBytes
            case updateTime
        }
    }

    public struct BatchDeleteReadSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The read sets' IDs.
        public let ids: [String]
        /// The read sets' sequence store ID.
        public let sequenceStoreId: String

        public init(ids: [String], sequenceStoreId: String) {
            self.ids = ids
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 10)
                try validate($0, name: "ids[]", parent: name, pattern: "^[0-9]+$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ids
        }
    }

    public struct BatchDeleteReadSetResponse: AWSDecodableShape {
        /// Errors returned by individual delete operations.
        public let errors: [ReadSetBatchError]?

        public init(errors: [ReadSetBatchError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct CancelAnnotationImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId"))
        ]

        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelAnnotationImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The run's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId"))
        ]

        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelVariantImportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateAnnotationStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's annotations.
        public let reference: ReferenceItem?
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat
        /// File parsing options for the annotation store.
        public let storeOptions: StoreOptions?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem? = nil, sseConfig: SseConfig? = nil, storeFormat: StoreFormat, storeOptions: StoreOptions? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.reference?.validate(name: "\(name).reference")
            try self.storeOptions?.validate(name: "\(name).storeOptions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case reference
            case sseConfig
            case storeFormat
            case storeOptions
            case tags
        }
    }

    public struct CreateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// The store's file parsing options.
        public let storeOptions: StoreOptions?

        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case id
            case name
            case reference
            case status
            case storeFormat
            case storeOptions
        }
    }

    public struct CreateReferenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, name: String, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case sseConfig
            case tags
        }
    }

    public struct CreateReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct CreateRunGroupRequest: AWSEncodableShape {
        /// The maximum number of CPUs to use in the group.
        public let maxCpus: Int?
        /// A max duration for the group.
        public let maxDuration: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?
        /// A request ID for the group.
        public let requestId: String
        /// Tags for the group.
        public let tags: [String: String]?

        public init(maxCpus: Int? = nil, maxDuration: Int? = nil, maxRuns: Int? = nil, name: String? = nil, requestId: String = CreateRunGroupRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxRuns = maxRuns
            self.name = name
            self.requestId = requestId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus
            case maxDuration
            case maxRuns
            case name
            case requestId
            case tags
        }
    }

    public struct CreateRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// The group's ID.
        public let id: String?
        /// Tags for the run group.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
            case tags
        }
    }

    public struct CreateSequenceStoreRequest: AWSEncodableShape {
        /// To ensure that requests don't run multiple times, specify a unique token for each request.
        public let clientToken: String?
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, name: String, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case sseConfig
            case tags
        }
    }

    public struct CreateSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's SSE settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct CreateVariantStoreRequest: AWSEncodableShape {
        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String?
        /// The genome reference for the store's variants.
        public let reference: ReferenceItem
        /// Server-side encryption (SSE) settings for the store.
        public let sseConfig: SseConfig?
        /// Tags for the store.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, reference: ReferenceItem, sseConfig: SseConfig? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.reference.validate(name: "\(name).reference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case reference
            case sseConfig
            case tags
        }
    }

    public struct CreateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem?
        /// The store's status.
        public let status: StoreStatus

        public init(creationTime: Date, id: String, name: String, reference: ReferenceItem? = nil, status: StoreStatus) {
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case id
            case name
            case reference
            case status
        }
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// The URI of a definition for the workflow.
        public let definitionUri: String?
        /// A ZIP archive for the workflow.
        public let definitionZip: AWSBase64Data?
        /// A description for the workflow.
        public let description: String?
        /// An engine for the workflow.
        public let engine: WorkflowEngine?
        /// The path of the main definition file for the workflow.
        public let main: String?
        /// A name for the workflow.
        public let name: String?
        /// A parameter template for the workflow.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// A request ID for the workflow.
        public let requestId: String
        /// A storage capacity for the workflow.
        public let storageCapacity: Int?
        /// Tags for the workflow.
        public let tags: [String: String]?

        public init(definitionUri: String? = nil, definitionZip: AWSBase64Data? = nil, description: String? = nil, engine: WorkflowEngine? = nil, main: String? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, requestId: String = CreateWorkflowRequest.idempotencyToken(), storageCapacity: Int? = nil, tags: [String: String]? = nil) {
            self.definitionUri = definitionUri
            self.definitionZip = definitionZip
            self.description = description
            self.engine = engine
            self.main = main
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.requestId = requestId
            self.storageCapacity = storageCapacity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, max: 256)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, min: 1)
            try self.validate(self.definitionUri, name: "definitionUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.main, name: "main", parent: name, max: 128)
            try self.validate(self.main, name: "main", parent: name, min: 1)
            try self.validate(self.main, name: "main", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.parameterTemplate?.forEach {
                try validate($0.key, name: "parameterTemplate.key", parent: name, max: 128)
                try validate($0.key, name: "parameterTemplate.key", parent: name, min: 1)
                try validate($0.key, name: "parameterTemplate.key", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
                try $0.value.validate(name: "\(name).parameterTemplate[\"\($0.key)\"]")
            }
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, max: 1000)
            try self.validate(self.parameterTemplate, name: "parameterTemplate", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definitionUri
            case definitionZip
            case description
            case engine
            case main
            case name
            case parameterTemplate
            case requestId
            case storageCapacity
            case tags
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// The workflow's ID.
        public let id: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, status: WorkflowStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
            case status
            case tags
        }
    }

    public struct DeleteAnnotationStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "force", location: .querystring("force")),
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnnotationStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct DeleteReferenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// The reference's ID.
        public let id: String
        /// The reference's store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReferenceStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReferenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRunGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The run group's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The run's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSequenceStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The sequence store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSequenceStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVariantStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "force", location: .querystring("force")),
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// Whether to force deletion.
        public let force: Bool?
        /// The store's name.
        public let name: String

        public init(force: Bool? = nil, name: String) {
            self.force = force
            self.name = name
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVariantStoreResponse: AWSDecodableShape {
        /// The store's status.
        public let status: StoreStatus

        public init(status: StoreStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The workflow's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportReadSet: AWSEncodableShape {
        /// The set's ID.
        public let readSetId: String

        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId
        }
    }

    public struct ExportReadSetDetail: AWSDecodableShape {
        /// The set's ID.
        public let id: String
        /// The set's status.
        public let status: ReadSetExportJobItemStatus
        /// The set's status message.
        public let statusMessage: String?

        public init(id: String, status: ReadSetExportJobItemStatus, statusMessage: String? = nil) {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case status
            case statusMessage
        }
    }

    public struct ExportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetExportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetExportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case status
        }
    }

    public struct ExportReadSetJobDetail: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destination
            case id
            case sequenceStoreId
            case status
        }
    }

    public struct FileInformation: AWSDecodableShape {
        /// The file's content length.
        public let contentLength: Int64?
        /// The file's part size.
        public let partSize: Int64?
        /// The file's total parts.
        public let totalParts: Int?

        public init(contentLength: Int64? = nil, partSize: Int64? = nil, totalParts: Int? = nil) {
            self.contentLength = contentLength
            self.partSize = partSize
            self.totalParts = totalParts
        }

        private enum CodingKeys: String, CodingKey {
            case contentLength
            case partSize
            case totalParts
        }
    }

    public struct GetAnnotationImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId"))
        ]

        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationImportResponse: AWSDecodableShape {
        /// When the job completed.
        @CustomCoding<ISO8601DateCoder>
        public var completionTime: Date
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination annotation store.
        public let destinationName: String
        public let formatOptions: FormatOptions
        /// The job's ID.
        public let id: String
        /// The job's imported items.
        public let items: [AnnotationImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(completionTime: Date, creationTime: Date, destinationName: String, formatOptions: FormatOptions, id: String, items: [AnnotationImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destinationName
            case formatOptions
            case id
            case items
            case roleArn
            case runLeftNormalization
            case status
            case statusMessage
            case updateTime
        }
    }

    public struct GetAnnotationStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// The store's name.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// A status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's annotation file format.
        public let storeFormat: StoreFormat?
        /// The store's parsing options.
        public let storeOptions: StoreOptions?
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case sseConfig
            case status
            case statusMessage
            case storeArn
            case storeFormat
            case storeOptions
            case storeSizeBytes
            case tags
            case updateTime
        }
    }

    public struct GetReadSetActivationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's sources.
        public let sources: [ActivateReadSetSourceItem]?
        /// The job's status.
        public let status: ReadSetActivationJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, sequenceStoreId: String, sources: [ActivateReadSetSourceItem]? = nil, status: ReadSetActivationJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case sequenceStoreId
            case sources
            case status
            case statusMessage
        }
    }

    public struct GetReadSetExportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetExportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's destination in Amazon S3.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The job's read sets.
        public let readSets: [ExportReadSetDetail]?
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, destination: String, id: String, readSets: [ExportReadSetDetail]? = nil, sequenceStoreId: String, status: ReadSetExportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.readSets = readSets
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destination
            case id
            case readSets
            case sequenceStoreId
            case status
            case statusMessage
        }
    }

    public struct GetReadSetImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The job's ID.
        public let id: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's sources.
        public let sources: [ImportReadSetSourceItem]
        /// The job's status.
        public let status: ReadSetImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, sources: [ImportReadSetSourceItem], status: ReadSetImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case roleArn
            case sequenceStoreId
            case sources
            case status
            case statusMessage
        }
    }

    public struct GetReadSetMetadataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The read set's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(id: String, sequenceStoreId: String) {
            self.id = id
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetMetadataResponse: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// When the read set was created.
        public let creationTime: Date
        /// The read set's description.
        public let description: String?
        /// The read set's files.
        public let files: ReadSetFiles?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        /// The read set's sequence information.
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        /// The read set's subject ID.
        public let subjectId: String?

        public init(arn: String, creationTime: Date, description: String? = nil, files: ReadSetFiles? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, subjectId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.files = files
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case files
            case fileType
            case id
            case name
            case referenceArn
            case sampleId
            case sequenceInformation
            case sequenceStoreId
            case status
            case subjectId
        }
    }

    public struct GetReadSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "file", location: .querystring("file")),
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "partNumber", location: .querystring("partNumber")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// The file to retrieve.
        public let file: ReadSetFile?
        /// The read set's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(file: ReadSetFile? = nil, id: String, partNumber: Int, sequenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadSetResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "payload"
        public static let _options: AWSShapeOptions = [.rawPayload, .allowStreaming]

        /// The read set file payload.
        public let payload: AWSPayload?

        public init(payload: AWSPayload? = nil) {
            self.payload = payload
        }

        private enum CodingKeys: String, CodingKey {
            case payload
        }
    }

    public struct GetReferenceImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceImportJobResponse: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sources.
        public let sources: [ImportReferenceSourceItem]
        /// The job's status.
        public let status: ReferenceImportJobStatus
        /// The job's status message.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, sources: [ImportReferenceSourceItem], status: ReferenceImportJobStatus, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case referenceStoreId
            case roleArn
            case sources
            case status
            case statusMessage
        }
    }

    public struct GetReferenceMetadataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// The reference's ID.
        public let id: String
        /// The reference's reference store ID.
        public let referenceStoreId: String

        public init(id: String, referenceStoreId: String) {
            self.id = id
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceMetadataResponse: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's description.
        public let description: String?
        /// The reference's files.
        public let files: ReferenceFiles?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's reference store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        public init(arn: String, creationTime: Date, description: String? = nil, files: ReferenceFiles? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.files = files
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case files
            case id
            case md5
            case name
            case referenceStoreId
            case status
            case updateTime
        }
    }

    public struct GetReferenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "file", location: .querystring("file")),
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "partNumber", location: .querystring("partNumber")),
            AWSMemberEncoding(label: "range", location: .header("Range")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// The file to retrieve.
        public let file: ReferenceFile?
        /// The reference's ID.
        public let id: String
        /// The part number to retrieve.
        public let partNumber: Int
        /// The range to retrieve.
        public let range: String?
        /// The reference's store ID.
        public let referenceStoreId: String

        public init(file: ReferenceFile? = nil, id: String, partNumber: Int, range: String? = nil, referenceStoreId: String) {
            self.file = file
            self.id = id
            self.partNumber = partNumber
            self.range = range
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.range, name: "range", parent: name, max: 127)
            try self.validate(self.range, name: "range", parent: name, min: 1)
            try self.validate(self.range, name: "range", parent: name, pattern: "^[\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "payload"
        public static let _options: AWSShapeOptions = [.rawPayload, .allowStreaming]

        /// The reference file payload.
        public let payload: AWSPayload?

        public init(payload: AWSPayload? = nil) {
            self.payload = payload
        }

        private enum CodingKeys: String, CodingKey {
            case payload
        }
    }

    public struct GetReferenceStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReferenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct GetRunGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The group's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunGroupResponse: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum number of CPUs to use.
        public let maxCpus: Int?
        /// The group's maximum run duration.
        public let maxDuration: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?
        /// The group's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxRuns: Int? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxRuns = maxRuns
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case id
            case maxCpus
            case maxDuration
            case maxRuns
            case name
            case tags
        }
    }

    public struct GetRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "export", location: .querystring("export")),
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The run's export format.
        public let export: [RunExport]?
        /// The run's ID.
        public let id: String

        public init(export: [RunExport]? = nil, id: String) {
            self.export = export
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunResponse: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's definition.
        public let definition: String?
        /// The run's digest.
        public let digest: String?
        /// The run's ID.
        public let id: String?
        /// The run's log level.
        public let logLevel: RunLogLevel?
        /// The run's name.
        public let name: String?
        /// The run's output URI.
        public let outputUri: String?
        /// The run's parameters.
        public let parameters: String?
        /// The run's priority.
        public let priority: Int?
        /// The run's resource digests.
        public let resourceDigests: [String: String]?
        /// The run's service role ARN.
        public let roleArn: String?
        /// The run's group ID.
        public let runGroupId: String?
        /// The run's ID.
        public let runId: String?
        /// Who started the run.
        public let startedBy: String?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// The run's status message.
        public let statusMessage: String?
        /// The run's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity.
        public let storageCapacity: Int?
        /// The run's tags.
        public let tags: [String: String]?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The run's workflow type.
        public let workflowType: WorkflowType?

        public init(arn: String? = nil, creationTime: Date? = nil, definition: String? = nil, digest: String? = nil, id: String? = nil, logLevel: RunLogLevel? = nil, name: String? = nil, outputUri: String? = nil, parameters: String? = nil, priority: Int? = nil, resourceDigests: [String: String]? = nil, roleArn: String? = nil, runGroupId: String? = nil, runId: String? = nil, startedBy: String? = nil, startTime: Date? = nil, status: RunStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.definition = definition
            self.digest = digest
            self.id = id
            self.logLevel = logLevel
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.resourceDigests = resourceDigests
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.startedBy = startedBy
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case definition
            case digest
            case id
            case logLevel
            case name
            case outputUri
            case parameters
            case priority
            case resourceDigests
            case roleArn
            case runGroupId
            case runId
            case startedBy
            case startTime
            case status
            case statusMessage
            case stopTime
            case storageCapacity
            case tags
            case workflowId
            case workflowType
        }
    }

    public struct GetRunTaskRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "taskId", location: .uri("taskId"))
        ]

        /// The task's ID.
        public let id: String
        /// The task's ID.
        public let taskId: String

        public init(id: String, taskId: String) {
            self.id = id
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.taskId, name: "taskId", parent: name, max: 18)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRunTaskResponse: AWSDecodableShape {
        /// The task's CPU usage.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The task's log stream.
        public let logStream: String?
        /// The task's memory setting.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// The task's start time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// The task's status message.
        public let statusMessage: String?
        /// The task's stop time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        public init(cpus: Int? = nil, creationTime: Date? = nil, logStream: String? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, statusMessage: String? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cpus = cpus
            self.creationTime = creationTime
            self.logStream = logStream
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cpus
            case creationTime
            case logStream
            case memory
            case name
            case startTime
            case status
            case statusMessage
            case stopTime
            case taskId
        }
    }

    public struct GetSequenceStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The store's ID.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 10)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSequenceStoreResponse: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct GetVariantImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId"))
        ]

        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantImportResponse: AWSDecodableShape {
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's items.
        public let items: [VariantImportItemDetail]
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool
        /// The job's status.
        public let status: JobStatus
        /// The job's status message.
        public let statusMessage: String
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, items: [VariantImportItemDetail], roleArn: String, runLeftNormalization: Bool, status: JobStatus, statusMessage: String, updateTime: Date) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destinationName
            case id
            case items
            case roleArn
            case runLeftNormalization
            case status
            case statusMessage
            case updateTime
        }
    }

    public struct GetVariantStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// The store's name.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// The store's tags.
        public let tags: [String: String]
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, tags: [String: String], updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case sseConfig
            case status
            case statusMessage
            case storeArn
            case storeSizeBytes
            case tags
            case updateTime
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "export", location: .querystring("export")),
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The export format for the workflow.
        public let export: [WorkflowExport]?
        /// The workflow's ID.
        public let id: String
        /// The workflow's type.
        public let type: WorkflowType?

        public init(export: [WorkflowExport]? = nil, id: String, type: WorkflowType? = nil) {
            self.export = export
            self.id = id
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.export, name: "export", parent: name, max: 32)
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's definition.
        public let definition: String?
        /// The workflow's description.
        public let description: String?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's engine.
        public let engine: WorkflowEngine?
        /// The workflow's ID.
        public let id: String?
        /// The path of the main definition file for the workflow.
        public let main: String?
        /// The workflow's name.
        public let name: String?
        /// The workflow's parameter template.
        public let parameterTemplate: [String: WorkflowParameter]?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's status message.
        public let statusMessage: String?
        /// The workflow's storage capacity.
        public let storageCapacity: Int?
        /// The workflow's tags.
        public let tags: [String: String]?
        /// The workflow's type.
        public let type: WorkflowType?

        public init(arn: String? = nil, creationTime: Date? = nil, definition: String? = nil, description: String? = nil, digest: String? = nil, engine: WorkflowEngine? = nil, id: String? = nil, main: String? = nil, name: String? = nil, parameterTemplate: [String: WorkflowParameter]? = nil, status: WorkflowStatus? = nil, statusMessage: String? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, type: WorkflowType? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.definition = definition
            self.description = description
            self.digest = digest
            self.engine = engine
            self.id = id
            self.main = main
            self.name = name
            self.parameterTemplate = parameterTemplate
            self.status = status
            self.statusMessage = statusMessage
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case definition
            case description
            case digest
            case engine
            case id
            case main
            case name
            case parameterTemplate
            case status
            case statusMessage
            case storageCapacity
            case tags
            case type
        }
    }

    public struct ImportReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReadSetImportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReadSetImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case status
        }
    }

    public struct ImportReadSetJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case roleArn
            case sequenceStoreId
            case status
        }
    }

    public struct ImportReadSetSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's genome reference ARN.
        public let referenceArn: String?
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's status.
        public let status: ReadSetImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String? = nil, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, status: ReadSetImportJobItemStatus, statusMessage: String? = nil, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case generatedFrom
            case name
            case referenceArn
            case sampleId
            case sourceFiles
            case sourceFileType
            case status
            case statusMessage
            case subjectId
            case tags
        }
    }

    public struct ImportReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A status to filter on.
        public let status: ReferenceImportJobStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, status: ReferenceImportJobStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case status
        }
    }

    public struct ImportReferenceJobItem: AWSDecodableShape {
        /// When the job completed.
        public let completionTime: Date?
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case id
            case referenceStoreId
            case roleArn
            case status
        }
    }

    public struct ImportReferenceSourceItem: AWSDecodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String?
        /// The source file's location in Amazon S3.
        public let sourceFile: String?
        /// The source's status.
        public let status: ReferenceImportJobItemStatus
        /// The source's status message.
        public let statusMessage: String?
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, sourceFile: String? = nil, status: ReferenceImportJobItemStatus, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case sourceFile
            case status
            case statusMessage
            case tags
        }
    }

    public struct ListAnnotationImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case storeName
        }
    }

    public struct ListAnnotationImportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: ListAnnotationImportJobsFilter?
        /// IDs of annotation import jobs to retrieve.
        public let ids: [String]?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListAnnotationImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case ids
        }
    }

    public struct ListAnnotationImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let annotationImportJobs: [AnnotationImportJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(annotationImportJobs: [AnnotationImportJobItem]? = nil, nextToken: String? = nil) {
            self.annotationImportJobs = annotationImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationImportJobs
            case nextToken
        }
    }

    public struct ListAnnotationStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct ListAnnotationStoresRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: ListAnnotationStoresFilter?
        /// IDs of stores to list.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListAnnotationStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case ids
        }
    }

    public struct ListAnnotationStoresResponse: AWSDecodableShape {
        /// A list of stores.
        public let annotationStores: [AnnotationStoreItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(annotationStores: [AnnotationStoreItem]? = nil, nextToken: String? = nil) {
            self.annotationStores = annotationStores
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotationStores
            case nextToken
        }
    }

    public struct ListReadSetActivationJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ActivateReadSetFilter?
        /// The maximum number of read set activation jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ActivateReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReadSetActivationJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let activationJobs: [ActivateReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(activationJobs: [ActivateReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.activationJobs = activationJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case activationJobs
            case nextToken
        }
    }

    public struct ListReadSetExportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ExportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ExportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReadSetExportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let exportJobs: [ExportReadSetJobDetail]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(exportJobs: [ExportReadSetJobDetail]? = nil, nextToken: String? = nil) {
            self.exportJobs = exportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobs
            case nextToken
        }
    }

    public struct ListReadSetImportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ImportReadSetFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ImportReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReadSetImportJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let importJobs: [ImportReadSetJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(importJobs: [ImportReadSetJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs
            case nextToken
        }
    }

    public struct ListReadSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ReadSetFilter?
        /// The maximum number of read sets to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The jobs' sequence store ID.
        public let sequenceStoreId: String

        public init(filter: ReadSetFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, sequenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sequenceStoreId = sequenceStoreId
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReadSetsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of read sets.
        public let readSets: [ReadSetListItem]

        public init(nextToken: String? = nil, readSets: [ReadSetListItem]) {
            self.nextToken = nextToken
            self.readSets = readSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case readSets
        }
    }

    public struct ListReferenceImportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ImportReferenceFilter?
        /// The maximum number of jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String

        public init(filter: ImportReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReferenceImportJobsResponse: AWSDecodableShape {
        /// A lis of jobs.
        public let importJobs: [ImportReferenceJobItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(importJobs: [ImportReferenceJobItem]? = nil, nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs
            case nextToken
        }
    }

    public struct ListReferenceStoresRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: ReferenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ReferenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReferenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of reference stores.
        public let referenceStores: [ReferenceStoreDetail]

        public init(nextToken: String? = nil, referenceStores: [ReferenceStoreDetail]) {
            self.nextToken = nextToken
            self.referenceStores = referenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case referenceStores
        }
    }

    public struct ListReferencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// A filter to apply to the list.
        public let filter: ReferenceFilter?
        /// The maximum number of references to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The references' reference store ID.
        public let referenceStoreId: String

        public init(filter: ReferenceFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, referenceStoreId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.referenceStoreId = referenceStoreId
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListReferencesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of references.
        public let references: [ReferenceListItem]

        public init(nextToken: String? = nil, references: [ReferenceListItem]) {
            self.nextToken = nextToken
            self.references = references
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case references
        }
    }

    public struct ListRunGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring("name")),
            AWSMemberEncoding(label: "startingToken", location: .querystring("startingToken"))
        ]

        /// The maximum number of run groups to return in one page of results.
        public let maxResults: Int?
        /// The run groups' name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunGroupsResponse: AWSDecodableShape {
        /// A list of groups.
        public let items: [RunGroupListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [RunGroupListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListRunTasksRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "startingToken", location: .querystring("startingToken")),
            AWSMemberEncoding(label: "status", location: .querystring("status"))
        ]

        /// The run's ID.
        public let id: String
        /// The maximum number of run tasks to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// Filter the list by status.
        public let status: TaskStatus?

        public init(id: String, maxResults: Int? = nil, startingToken: String? = nil, status: TaskStatus? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.startingToken = startingToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunTasksResponse: AWSDecodableShape {
        /// A list of tasks.
        public let items: [TaskListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [TaskListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListRunsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring("name")),
            AWSMemberEncoding(label: "runGroupId", location: .querystring("runGroupId")),
            AWSMemberEncoding(label: "startingToken", location: .querystring("startingToken"))
        ]

        /// The maximum number of runs to return in one page of results.
        public let maxResults: Int?
        /// Filter the list by run name.
        public let name: String?
        /// Filter the list by run group ID.
        public let runGroupId: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, runGroupId: String? = nil, startingToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.runGroupId = runGroupId
            self.startingToken = startingToken
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRunsResponse: AWSDecodableShape {
        /// A list of runs.
        public let items: [RunListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [RunListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListSequenceStoresRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: SequenceStoreFilter?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: SequenceStoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 6144)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct ListSequenceStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of sequence stores.
        public let sequenceStores: [SequenceStoreDetail]

        public init(nextToken: String? = nil, sequenceStores: [SequenceStoreDetail]) {
            self.nextToken = nextToken
            self.sequenceStores = sequenceStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sequenceStores
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The resource's ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListVariantImportJobsFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: JobStatus?
        /// A store name to filter on.
        public let storeName: String?

        public init(status: JobStatus? = nil, storeName: String? = nil) {
            self.status = status
            self.storeName = storeName
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case storeName
        }
    }

    public struct ListVariantImportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: ListVariantImportJobsFilter?
        /// A list of job IDs.
        public let ids: [String]?
        /// The maximum number of import jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListVariantImportJobsFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case ids
        }
    }

    public struct ListVariantImportJobsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of jobs.
        public let variantImportJobs: [VariantImportJobItem]?

        public init(nextToken: String? = nil, variantImportJobs: [VariantImportJobItem]? = nil) {
            self.nextToken = nextToken
            self.variantImportJobs = variantImportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case variantImportJobs
        }
    }

    public struct ListVariantStoresFilter: AWSEncodableShape {
        /// A status to filter on.
        public let status: StoreStatus?

        public init(status: StoreStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct ListVariantStoresRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A filter to apply to the list.
        public let filter: ListVariantStoresFilter?
        /// A list of store IDs.
        public let ids: [String]?
        /// The maximum number of stores to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(filter: ListVariantStoresFilter? = nil, ids: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.ids = ids
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 50)
                try validate($0, name: "ids[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case ids
        }
    }

    public struct ListVariantStoresResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of variant stores.
        public let variantStores: [VariantStoreItem]?

        public init(nextToken: String? = nil, variantStores: [VariantStoreItem]? = nil) {
            self.nextToken = nextToken
            self.variantStores = variantStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case variantStores
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring("name")),
            AWSMemberEncoding(label: "startingToken", location: .querystring("startingToken")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The maximum number of workflows to return in one page of results.
        public let maxResults: Int?
        /// The workflows' name.
        public let name: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let startingToken: String?
        /// The workflows' type.
        public let type: WorkflowType?

        public init(maxResults: Int? = nil, name: String? = nil, startingToken: String? = nil, type: WorkflowType? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.startingToken = startingToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.startingToken, name: "startingToken", parent: name, max: 128)
            try self.validate(self.startingToken, name: "startingToken", parent: name, min: 1)
            try self.validate(self.startingToken, name: "startingToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// The workflows' items.
        public let items: [WorkflowListItem]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(items: [WorkflowListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ReadOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's comment character.
        public let comment: String?
        /// The file's encoding.
        public let encoding: String?
        /// A character for escaping quotes in the file.
        public let escape: String?
        /// Whether quotes need to be escaped in the file.
        public let escapeQuotes: Bool?
        /// Whether the file has a header row.
        public let header: Bool?
        /// A line separator for the file.
        public let lineSep: String?
        /// The file's quote character.
        public let quote: String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public let quoteAll: Bool?
        /// The file's field separator.
        public let sep: String?

        public init(comment: String? = nil, encoding: String? = nil, escape: String? = nil, escapeQuotes: Bool? = nil, header: Bool? = nil, lineSep: String? = nil, quote: String? = nil, quoteAll: Bool? = nil, sep: String? = nil) {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.encoding, name: "encoding", parent: name, max: 20)
            try self.validate(self.encoding, name: "encoding", parent: name, min: 1)
            try self.validate(self.escape, name: "escape", parent: name, max: 1)
            try self.validate(self.escape, name: "escape", parent: name, min: 1)
            try self.validate(self.lineSep, name: "lineSep", parent: name, max: 20)
            try self.validate(self.lineSep, name: "lineSep", parent: name, min: 1)
            try self.validate(self.quote, name: "quote", parent: name, max: 1)
            try self.validate(self.quote, name: "quote", parent: name, min: 1)
            try self.validate(self.sep, name: "sep", parent: name, max: 20)
            try self.validate(self.sep, name: "sep", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case encoding
            case escape
            case escapeQuotes
            case header
            case lineSep
            case quote
            case quoteAll
            case sep
        }
    }

    public struct ReadSetBatchError: AWSDecodableShape {
        /// The error's code.
        public let code: String
        /// The error's ID.
        public let id: String
        /// The error's message.
        public let message: String

        public init(code: String, id: String, message: String) {
            self.code = code
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case id
            case message
        }
    }

    public struct ReadSetFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The location of the first file in Amazon S3.
        public let source1: FileInformation?
        /// The location of the second file in Amazon S3.
        public let source2: FileInformation?

        public init(index: FileInformation? = nil, source1: FileInformation? = nil, source2: FileInformation? = nil) {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }

        private enum CodingKeys: String, CodingKey {
            case index
            case source1
            case source2
        }
    }

    public struct ReadSetFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A name to filter on.
        public let name: String?
        /// A genome reference ARN to filter on.
        public let referenceArn: String?
        /// A status to filter on.
        public let status: ReadSetStatus?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil, referenceArn: String? = nil, status: ReadSetStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
            self.referenceArn = referenceArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case name
            case referenceArn
            case status
        }
    }

    public struct ReadSetListItem: AWSDecodableShape {
        /// The read set's ARN.
        public let arn: String
        /// When the read set was created.
        public let creationTime: Date
        /// The read set's description.
        public let description: String?
        /// The read set's file type.
        public let fileType: FileType
        /// The read set's ID.
        public let id: String
        /// The read set's name.
        public let name: String?
        /// The read set's genome reference ARN.
        public let referenceArn: String?
        /// The read set's sample ID.
        public let sampleId: String?
        public let sequenceInformation: SequenceInformation?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The read set's status.
        public let status: ReadSetStatus
        /// The read set's subject ID.
        public let subjectId: String?

        public init(arn: String, creationTime: Date, description: String? = nil, fileType: FileType, id: String, name: String? = nil, referenceArn: String? = nil, sampleId: String? = nil, sequenceInformation: SequenceInformation? = nil, sequenceStoreId: String, status: ReadSetStatus, subjectId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.subjectId = subjectId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case fileType
            case id
            case name
            case referenceArn
            case sampleId
            case sequenceInformation
            case sequenceStoreId
            case status
            case subjectId
        }
    }

    public struct ReferenceFiles: AWSDecodableShape {
        /// The files' index.
        public let index: FileInformation?
        /// The source file's location in Amazon S3.
        public let source: FileInformation?

        public init(index: FileInformation? = nil, source: FileInformation? = nil) {
            self.index = index
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case index
            case source
        }
    }

    public struct ReferenceFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// An MD5 checksum to filter on.
        public let md5: String?
        /// A name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, md5: String? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.md5, name: "md5", parent: name, max: 255)
            try self.validate(self.md5, name: "md5", parent: name, min: 1)
            try self.validate(self.md5, name: "md5", parent: name, pattern: "^[\\p{L}||\\p{N}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case md5
            case name
        }
    }

    public struct ReferenceListItem: AWSDecodableShape {
        /// The reference's ARN.
        public let arn: String
        /// When the reference was created.
        public let creationTime: Date
        /// The reference's description.
        public let description: String?
        /// The reference's ID.
        public let id: String
        /// The reference's MD5 checksum.
        public let md5: String
        /// The reference's name.
        public let name: String?
        /// The reference's store ID.
        public let referenceStoreId: String
        /// The reference's status.
        public let status: ReferenceStatus?
        /// When the reference was updated.
        public let updateTime: Date

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, md5: String, name: String? = nil, referenceStoreId: String, status: ReferenceStatus? = nil, updateTime: Date) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case md5
            case name
            case referenceStoreId
            case status
            case updateTime
        }
    }

    public struct ReferenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct ReferenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// The name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case name
        }
    }

    public struct RunGroupListItem: AWSDecodableShape {
        /// The group's ARN.
        public let arn: String?
        /// When the group was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The group's ID.
        public let id: String?
        /// The group's maximum CPU count setting.
        public let maxCpus: Int?
        /// The group's maximum duration setting.
        public let maxDuration: Int?
        /// The group's maximum concurrent run setting.
        public let maxRuns: Int?
        /// The group's name.
        public let name: String?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, maxCpus: Int? = nil, maxDuration: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxRuns = maxRuns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case id
            case maxCpus
            case maxDuration
            case maxRuns
            case name
        }
    }

    public struct RunListItem: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// When the run was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The run's ID.
        public let id: String?
        /// The run's name.
        public let name: String?
        /// The run's priority.
        public let priority: Int?
        /// When the run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The run's status.
        public let status: RunStatus?
        /// When the run stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The run's storage capacity.
        public let storageCapacity: Int?
        /// The run's workflow ID.
        public let workflowId: String?

        public init(arn: String? = nil, creationTime: Date? = nil, id: String? = nil, name: String? = nil, priority: Int? = nil, startTime: Date? = nil, status: RunStatus? = nil, stopTime: Date? = nil, storageCapacity: Int? = nil, workflowId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case id
            case name
            case priority
            case startTime
            case status
            case stopTime
            case storageCapacity
            case workflowId
        }
    }

    public struct SequenceInformation: AWSDecodableShape {
        /// The sequence's alignment setting.
        public let alignment: String?
        /// Where the sequence originated.
        public let generatedFrom: String?
        /// The sequence's total base count.
        public let totalBaseCount: Int64?
        /// The sequence's total read count.
        public let totalReadCount: Int64?

        public init(alignment: String? = nil, generatedFrom: String? = nil, totalBaseCount: Int64? = nil, totalReadCount: Int64? = nil) {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }

        private enum CodingKeys: String, CodingKey {
            case alignment
            case generatedFrom
            case totalBaseCount
            case totalReadCount
        }
    }

    public struct SequenceStoreDetail: AWSDecodableShape {
        /// The store's ARN.
        public let arn: String
        /// When the store was created.
        public let creationTime: Date
        /// The store's description.
        public let description: String?
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String?
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig?

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, name: String? = nil, sseConfig: SseConfig? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case id
            case name
            case sseConfig
        }
    }

    public struct SequenceStoreFilter: AWSEncodableShape {
        /// The filter's start date.
        public let createdAfter: Date?
        /// The filter's end date.
        public let createdBefore: Date?
        /// A name to filter on.
        public let name: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, name: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter
            case createdBefore
            case name
        }
    }

    public struct SourceFiles: AWSEncodableShape & AWSDecodableShape {
        /// The location of the first file in Amazon S3.
        public let source1: String
        /// The location of the second file in Amazon S3.
        public let source2: String?

        public init(source1: String, source2: String? = nil) {
            self.source1 = source1
            self.source2 = source2
        }

        public func validate(name: String) throws {
            try self.validate(self.source1, name: "source1", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.validate(self.source2, name: "source2", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source1
            case source2
        }
    }

    public struct SseConfig: AWSEncodableShape & AWSDecodableShape {
        /// An encryption key ARN.
        public let keyArn: String?
        /// The encryption type.
        public let type: EncryptionType

        public init(keyArn: String? = nil, type: EncryptionType) {
            self.keyArn = keyArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case type
        }
    }

    public struct StartAnnotationImportRequest: AWSEncodableShape {
        /// A destination annotation store for the job.
        public let destinationName: String
        /// Formatting options for the annotation file.
        public let formatOptions: FormatOptions?
        /// Items to import.
        public let items: [AnnotationImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?

        public init(destinationName: String, formatOptions: FormatOptions? = nil, items: [AnnotationImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil) {
            self.destinationName = destinationName
            self.formatOptions = formatOptions
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, max: 1)
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName
            case formatOptions
            case items
            case roleArn
            case runLeftNormalization
        }
    }

    public struct StartAnnotationImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct StartReadSetActivationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's sources.
        public let sources: [StartReadSetActivationJobSourceItem]

        public init(clientToken: String? = nil, sequenceStoreId: String, sources: [StartReadSetActivationJobSourceItem]) {
            self.clientToken = clientToken
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case sources
        }
    }

    public struct StartReadSetActivationJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetActivationJobStatus

        public init(creationTime: Date, id: String, sequenceStoreId: String, status: ReadSetActivationJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case id
            case sequenceStoreId
            case status
        }
    }

    public struct StartReadSetActivationJobSourceItem: AWSEncodableShape {
        /// The source's read set ID.
        public let readSetId: String

        public init(readSetId: String) {
            self.readSetId = readSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.readSetId, name: "readSetId", parent: name, max: 36)
            try self.validate(self.readSetId, name: "readSetId", parent: name, min: 10)
            try self.validate(self.readSetId, name: "readSetId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case readSetId
        }
    }

    public struct StartReadSetExportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A location for exported files in Amazon S3.
        public let destination: String
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// Sources for the job.
        public let sources: [ExportReadSet]

        public init(clientToken: String? = nil, destination: String, roleArn: String, sequenceStoreId: String, sources: [ExportReadSet]) {
            self.clientToken = clientToken
            self.destination = destination
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/?((.{1,1024})/)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case destination
            case roleArn
            case sources
        }
    }

    public struct StartReadSetExportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's output location.
        public let destination: String
        /// The job's ID.
        public let id: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetExportJobStatus

        public init(creationTime: Date, destination: String, id: String, sequenceStoreId: String, status: ReadSetExportJobStatus) {
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case destination
            case id
            case sequenceStoreId
            case status
        }
    }

    public struct StartReadSetImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sequenceStoreId", location: .uri("sequenceStoreId"))
        ]

        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// A service role for the job.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// Source files to import.
        public let sources: [StartReadSetImportJobSourceItem]

        public init(clientToken: String? = nil, roleArn: String, sequenceStoreId: String, sources: [StartReadSetImportJobSourceItem]) {
            self.clientToken = clientToken
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, max: 36)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, min: 10)
            try self.validate(self.sequenceStoreId, name: "sequenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case roleArn
            case sources
        }
    }

    public struct StartReadSetImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The read set's sequence store ID.
        public let sequenceStoreId: String
        /// The job's status.
        public let status: ReadSetImportJobStatus

        public init(creationTime: Date, id: String, roleArn: String, sequenceStoreId: String, status: ReadSetImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case id
            case roleArn
            case sequenceStoreId
            case status
        }
    }

    public struct StartReadSetImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// Where the source originated.
        public let generatedFrom: String?
        /// The source's name.
        public let name: String?
        /// The source's reference ARN.
        public let referenceArn: String
        /// The source's sample ID.
        public let sampleId: String
        /// The source files' location in Amazon S3.
        public let sourceFiles: SourceFiles
        /// The source's file type.
        public let sourceFileType: FileType
        /// The source's subject ID.
        public let subjectId: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, generatedFrom: String? = nil, name: String? = nil, referenceArn: String, sampleId: String, sourceFiles: SourceFiles, sourceFileType: FileType, subjectId: String, tags: [String: String]? = nil) {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFiles = sourceFiles
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, max: 127)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, min: 1)
            try self.validate(self.generatedFrom, name: "generatedFrom", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.sampleId, name: "sampleId", parent: name, max: 127)
            try self.validate(self.sampleId, name: "sampleId", parent: name, min: 1)
            try self.validate(self.sampleId, name: "sampleId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.sourceFiles.validate(name: "\(name).sourceFiles")
            try self.validate(self.subjectId, name: "subjectId", parent: name, max: 127)
            try self.validate(self.subjectId, name: "subjectId", parent: name, min: 1)
            try self.validate(self.subjectId, name: "subjectId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case generatedFrom
            case name
            case referenceArn
            case sampleId
            case sourceFiles
            case sourceFileType
            case subjectId
            case tags
        }
    }

    public struct StartReferenceImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "referenceStoreId", location: .uri("referenceStoreId"))
        ]

        /// To ensure that jobs don't run multiple times, specify a unique token for each job.
        public let clientToken: String?
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// A service role for the job.
        public let roleArn: String
        /// Sources for the job.
        public let sources: [StartReferenceImportJobSourceItem]

        public init(clientToken: String? = nil, referenceStoreId: String, roleArn: String, sources: [StartReferenceImportJobSourceItem]) {
            self.clientToken = clientToken
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 127)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, max: 36)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, min: 10)
            try self.validate(self.referenceStoreId, name: "referenceStoreId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case roleArn
            case sources
        }
    }

    public struct StartReferenceImportJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let creationTime: Date
        /// The job's ID.
        public let id: String
        /// The job's reference store ID.
        public let referenceStoreId: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's status.
        public let status: ReferenceImportJobStatus

        public init(creationTime: Date, id: String, referenceStoreId: String, roleArn: String, status: ReferenceImportJobStatus) {
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case id
            case referenceStoreId
            case roleArn
            case status
        }
    }

    public struct StartReferenceImportJobSourceItem: AWSEncodableShape {
        /// The source's description.
        public let description: String?
        /// The source's name.
        public let name: String
        /// The source file's location in Amazon S3.
        public let sourceFile: String
        /// The source's tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, sourceFile: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.sourceFile, name: "sourceFile", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case sourceFile
            case tags
        }
    }

    public struct StartRunRequest: AWSEncodableShape {
        /// A log level for the run.
        public let logLevel: RunLogLevel?
        /// A name for the run.
        public let name: String?
        /// An output URI for the run.
        public let outputUri: String?
        /// Parameters for the run.
        public let parameters: String?
        /// A priority for the run.
        public let priority: Int?
        /// A request ID for the run.
        public let requestId: String
        /// A service role for the run.
        public let roleArn: String
        /// The run's group ID.
        public let runGroupId: String?
        /// The run's ID.
        public let runId: String?
        /// A storage capacity for the run.
        public let storageCapacity: Int?
        /// Tags for the run.
        public let tags: [String: String]?
        /// The run's workflow ID.
        public let workflowId: String?
        /// The run's workflows type.
        public let workflowType: WorkflowType?

        public init(logLevel: RunLogLevel? = nil, name: String? = nil, outputUri: String? = nil, parameters: String? = nil, priority: Int? = nil, requestId: String = StartRunRequest.idempotencyToken(), roleArn: String, runGroupId: String? = nil, runId: String? = nil, storageCapacity: Int? = nil, tags: [String: String]? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.logLevel = logLevel
            self.name = name
            self.outputUri = outputUri
            self.parameters = parameters
            self.priority = priority
            self.requestId = requestId
            self.roleArn = roleArn
            self.runGroupId = runGroupId
            self.runId = runId
            self.storageCapacity = storageCapacity
            self.tags = tags
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.outputUri, name: "outputUri", parent: name, max: 128)
            try self.validate(self.outputUri, name: "outputUri", parent: name, min: 1)
            try self.validate(self.outputUri, name: "outputUri", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.requestId, name: "requestId", parent: name, max: 128)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 128)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.+$")
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, max: 18)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, min: 1)
            try self.validate(self.runGroupId, name: "runGroupId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.runId, name: "runId", parent: name, max: 18)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.workflowId, name: "workflowId", parent: name, max: 18)
            try self.validate(self.workflowId, name: "workflowId", parent: name, min: 1)
            try self.validate(self.workflowId, name: "workflowId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel
            case name
            case outputUri
            case parameters
            case priority
            case requestId
            case roleArn
            case runGroupId
            case runId
            case storageCapacity
            case tags
            case workflowId
            case workflowType
        }
    }

    public struct StartRunResponse: AWSDecodableShape {
        /// The run's ARN.
        public let arn: String?
        /// The run's ID.
        public let id: String?
        /// The run's status.
        public let status: RunStatus?
        /// The run's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, status: RunStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
            case status
            case tags
        }
    }

    public struct StartVariantImportRequest: AWSEncodableShape {
        /// The destination variant store for the job.
        public let destinationName: String
        /// Items to import.
        public let items: [VariantImportItemSource]
        /// A service role for the job.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?

        public init(destinationName: String, items: [VariantImportItemSource], roleArn: String, runLeftNormalization: Bool? = nil) {
            self.destinationName = destinationName
            self.items = items
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 255)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 3)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^([a-z]){1}([a-z0-9_]){2,254}$")
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, max: 1)
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([^:\n]*):([^:\n]*):([^:\n]*):([0-9]{12}):([^:\n]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName
            case items
            case roleArn
            case runLeftNormalization
        }
    }

    public struct StartVariantImportResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The resource's ARN.
        public let resourceArn: String
        /// Tags for the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskListItem: AWSDecodableShape {
        /// The task's CPU count.
        public let cpus: Int?
        /// When the task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The task's memory.
        public let memory: Int?
        /// The task's name.
        public let name: String?
        /// When the task started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The task's status.
        public let status: TaskStatus?
        /// When the task stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The task's ID.
        public let taskId: String?

        public init(cpus: Int? = nil, creationTime: Date? = nil, memory: Int? = nil, name: String? = nil, startTime: Date? = nil, status: TaskStatus? = nil, stopTime: Date? = nil, taskId: String? = nil) {
            self.cpus = cpus
            self.creationTime = creationTime
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case cpus
            case creationTime
            case memory
            case name
            case startTime
            case status
            case stopTime
            case taskId
        }
    }

    public struct TsvOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's read options.
        public let readOptions: ReadOptions?

        public init(readOptions: ReadOptions? = nil) {
            self.readOptions = readOptions
        }

        public func validate(name: String) throws {
            try self.readOptions?.validate(name: "\(name).readOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case readOptions
        }
    }

    public struct TsvStoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// The store's annotation type.
        public let annotationType: AnnotationType?
        /// The store's header key to column name mapping.
        public let formatToHeader: [FormatToHeaderKey: String]?
        /// The store's schema.
        public let schema: [[String: SchemaValueType]]?

        public init(annotationType: AnnotationType? = nil, formatToHeader: [FormatToHeaderKey: String]? = nil, schema: [[String: SchemaValueType]]? = nil) {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.schema?.forEach {
                try validate($0, name: "schema[]", parent: name, max: 1)
                try validate($0, name: "schema[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case annotationType
            case formatToHeader
            case schema
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The resource's ARN.
        public let resourceArn: String
        /// Keys of tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnnotationStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description
        }
    }

    public struct UpdateAnnotationStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// The annotation file format of the store.
        public let storeFormat: StoreFormat?
        /// Parsing options for the store.
        public let storeOptions: StoreOptions?
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, storeFormat: StoreFormat? = nil, storeOptions: StoreOptions? = nil, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.storeFormat = storeFormat
            self.storeOptions = storeOptions
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case status
            case storeFormat
            case storeOptions
            case updateTime
        }
    }

    public struct UpdateRunGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// The group's ID.
        public let id: String
        /// The maximum number of CPUs to use.
        public let maxCpus: Int?
        /// The maximum amount of time to run.
        public let maxDuration: Int?
        /// The maximum number of concurrent runs for the group.
        public let maxRuns: Int?
        /// A name for the group.
        public let name: String?

        public init(id: String, maxCpus: Int? = nil, maxDuration: Int? = nil, maxRuns: Int? = nil, name: String? = nil) {
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxRuns = maxRuns
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxCpus
            case maxDuration
            case maxRuns
            case name
        }
    }

    public struct UpdateVariantStoreRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name"))
        ]

        /// A description for the store.
        public let description: String?
        /// A name for the store.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description
        }
    }

    public struct UpdateVariantStoreResponse: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's status.
        public let status: StoreStatus
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, status: StoreStatus, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case status
            case updateTime
        }
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        /// A description for the workflow.
        public let description: String?
        /// The workflow's ID.
        public let id: String
        /// A name for the workflow.
        public let name: String?

        public init(description: String? = nil, id: String, name: String? = nil) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
            try self.validate(self.id, name: "id", parent: name, max: 18)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
        }
    }

    public struct VariantImportItemDetail: AWSDecodableShape {
        /// The item's job status.
        public let jobStatus: JobStatus
        /// The source file's location in Amazon S3.
        public let source: String

        public init(jobStatus: JobStatus, source: String) {
            self.jobStatus = jobStatus
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus
            case source
        }
    }

    public struct VariantImportItemSource: AWSEncodableShape {
        /// The source file's location in Amazon S3.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, pattern: "^s3://([a-z0-9][a-z0-9-.]{1,61}[a-z0-9])/(.{1,1024})$")
        }

        private enum CodingKeys: String, CodingKey {
            case source
        }
    }

    public struct VariantImportJobItem: AWSDecodableShape {
        /// When the job completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// When the job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The job's destination variant store.
        public let destinationName: String
        /// The job's ID.
        public let id: String
        /// The job's service role ARN.
        public let roleArn: String
        /// The job's left normalization setting.
        public let runLeftNormalization: Bool?
        /// The job's status.
        public let status: JobStatus
        /// When the job was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(completionTime: Date? = nil, creationTime: Date, destinationName: String, id: String, roleArn: String, runLeftNormalization: Bool? = nil, status: JobStatus, updateTime: Date) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case creationTime
            case destinationName
            case id
            case roleArn
            case runLeftNormalization
            case status
            case updateTime
        }
    }

    public struct VariantStoreItem: AWSDecodableShape {
        /// When the store was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The store's description.
        public let description: String
        /// The store's ID.
        public let id: String
        /// The store's name.
        public let name: String
        /// The store's genome reference.
        public let reference: ReferenceItem
        /// The store's server-side encryption (SSE) settings.
        public let sseConfig: SseConfig
        /// The store's status.
        public let status: StoreStatus
        /// The store's status message.
        public let statusMessage: String
        /// The store's ARN.
        public let storeArn: String
        /// The store's size in bytes.
        public let storeSizeBytes: Int64
        /// When the store was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(creationTime: Date, description: String, id: String, name: String, reference: ReferenceItem, sseConfig: SseConfig, status: StoreStatus, statusMessage: String, storeArn: String, storeSizeBytes: Int64, updateTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case id
            case name
            case reference
            case sseConfig
            case status
            case statusMessage
            case storeArn
            case storeSizeBytes
            case updateTime
        }
    }

    public struct VcfOptions: AWSEncodableShape & AWSDecodableShape {
        /// The file's ignore filter field setting.
        public let ignoreFilterField: Bool?
        /// The file's ignore qual field setting.
        public let ignoreQualField: Bool?

        public init(ignoreFilterField: Bool? = nil, ignoreQualField: Bool? = nil) {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }

        private enum CodingKeys: String, CodingKey {
            case ignoreFilterField
            case ignoreQualField
        }
    }

    public struct WorkflowListItem: AWSDecodableShape {
        /// The workflow's ARN.
        public let arn: String?
        /// When the workflow was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The workflow's digest.
        public let digest: String?
        /// The workflow's ID.
        public let id: String?
        /// The workflow's name.
        public let name: String?
        /// The workflow's status.
        public let status: WorkflowStatus?
        /// The workflow's type.
        public let type: WorkflowType?

        public init(arn: String? = nil, creationTime: Date? = nil, digest: String? = nil, id: String? = nil, name: String? = nil, status: WorkflowStatus? = nil, type: WorkflowType? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case digest
            case id
            case name
            case status
            case type
        }
    }

    public struct WorkflowParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter's description.
        public let description: String?
        /// Whether the parameter is optional.
        public let optional: Bool?

        public init(description: String? = nil, optional: Bool? = nil) {
            self.description = description
            self.optional = optional
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}||\\p{M}||\\p{Z}||\\p{S}||\\p{N}||\\p{P}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case optional
        }
    }

    public struct ReferenceItem: AWSEncodableShape & AWSDecodableShape {
        /// The reference's ARN.
        public let referenceArn: String?

        public init(referenceArn: String? = nil) {
            self.referenceArn = referenceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, max: 127)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, min: 1)
            try self.validate(self.referenceArn, name: "referenceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case referenceArn
        }
    }

    public struct StoreOptions: AWSEncodableShape & AWSDecodableShape {
        /// File settings for a TSV store.
        public let tsvStoreOptions: TsvStoreOptions?

        public init(tsvStoreOptions: TsvStoreOptions? = nil) {
            self.tsvStoreOptions = tsvStoreOptions
        }

        public func validate(name: String) throws {
            try self.tsvStoreOptions?.validate(name: "\(name).tsvStoreOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case tsvStoreOptions
        }
    }
}

// MARK: - Errors

/// Error enum for Omics
public struct OmicsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case rangeNotSatisfiableException = "RangeNotSatisfiableException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Omics
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request cannot be applied to the target resource in its current state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred. Try the request again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The ranges specified in the request are not valid.
    public static var rangeNotSatisfiableException: Self { .init(.rangeNotSatisfiableException) }
    /// The request timed out.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The target resource was not found in the current Region.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension OmicsErrorType: Equatable {
    public static func == (lhs: OmicsErrorType, rhs: OmicsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OmicsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
