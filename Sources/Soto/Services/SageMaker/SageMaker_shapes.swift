//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension SageMaker {
    // MARK: Enums

    public enum ActionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case unknown = "Unknown"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum AppImageConfigSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AppInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC512Xlarge = "ml.c5.12xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC524Xlarge = "ml.c5.24xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5Large = "ml.c5.large"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlG512Xlarge = "ml.g5.12xlarge"
        case mlG516Xlarge = "ml.g5.16xlarge"
        case mlG524Xlarge = "ml.g5.24xlarge"
        case mlG52Xlarge = "ml.g5.2xlarge"
        case mlG548Xlarge = "ml.g5.48xlarge"
        case mlG54Xlarge = "ml.g5.4xlarge"
        case mlG58Xlarge = "ml.g5.8xlarge"
        case mlG5Xlarge = "ml.g5.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM516Xlarge = "ml.m5.16xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM58Xlarge = "ml.m5.8xlarge"
        case mlM5D12Xlarge = "ml.m5d.12xlarge"
        case mlM5D16Xlarge = "ml.m5d.16xlarge"
        case mlM5D24Xlarge = "ml.m5d.24xlarge"
        case mlM5D2Xlarge = "ml.m5d.2xlarge"
        case mlM5D4Xlarge = "ml.m5d.4xlarge"
        case mlM5D8Xlarge = "ml.m5d.8xlarge"
        case mlM5DLarge = "ml.m5d.large"
        case mlM5DXlarge = "ml.m5d.xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP3Dn24Xlarge = "ml.p3dn.24xlarge"
        case mlR512Xlarge = "ml.r5.12xlarge"
        case mlR516Xlarge = "ml.r5.16xlarge"
        case mlR524Xlarge = "ml.r5.24xlarge"
        case mlR52Xlarge = "ml.r5.2xlarge"
        case mlR54Xlarge = "ml.r5.4xlarge"
        case mlR58Xlarge = "ml.r5.8xlarge"
        case mlR5Large = "ml.r5.large"
        case mlR5Xlarge = "ml.r5.xlarge"
        case mlT32Xlarge = "ml.t3.2xlarge"
        case mlT3Large = "ml.t3.large"
        case mlT3Medium = "ml.t3.medium"
        case mlT3Micro = "ml.t3.micro"
        case mlT3Small = "ml.t3.small"
        case mlT3Xlarge = "ml.t3.xlarge"
        case system
        public var description: String { return self.rawValue }
    }

    public enum AppNetworkAccessType: String, CustomStringConvertible, Codable, _SotoSendable {
        case publicInternetOnly = "PublicInternetOnly"
        case vpcOnly = "VpcOnly"
        public var description: String { return self.rawValue }
    }

    public enum AppSecurityGroupManagement: String, CustomStringConvertible, Codable, _SotoSendable {
        case customer = "Customer"
        case service = "Service"
        public var description: String { return self.rawValue }
    }

    public enum AppSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleted = "Deleted"
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum AppType: String, CustomStringConvertible, Codable, _SotoSendable {
        case jupyterServer = "JupyterServer"
        case kernelGateway = "KernelGateway"
        case rSessionGateway = "RSessionGateway"
        case rStudioServerPro = "RStudioServerPro"
        case tensorBoard = "TensorBoard"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactSourceIdType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "Custom"
        case md5Hash = "MD5Hash"
        case s3Etag = "S3ETag"
        case s3Version = "S3Version"
        public var description: String { return self.rawValue }
    }

    public enum AssemblyType: String, CustomStringConvertible, Codable, _SotoSendable {
        case line = "Line"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum AssociationEdgeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case associatedWith = "AssociatedWith"
        case contributedTo = "ContributedTo"
        case derivedFrom = "DerivedFrom"
        case produced = "Produced"
        public var description: String { return self.rawValue }
    }

    public enum AthenaResultCompressionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gzip = "GZIP"
        case snappy = "SNAPPY"
        case zlib = "ZLIB"
        public var description: String { return self.rawValue }
    }

    public enum AthenaResultFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case avro = "AVRO"
        case json = "JSON"
        case orc = "ORC"
        case parquet = "PARQUET"
        case textfile = "TEXTFILE"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLChannelType: String, CustomStringConvertible, Codable, _SotoSendable {
        case training
        case validation
        public var description: String { return self.rawValue }
    }

    public enum AutoMLJobObjectiveType: String, CustomStringConvertible, Codable, _SotoSendable {
        case maximize = "Maximize"
        case minimize = "Minimize"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLJobSecondaryStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case analyzingData = "AnalyzingData"
        case candidateDefinitionsGenerated = "CandidateDefinitionsGenerated"
        case completed = "Completed"
        case deployingModel = "DeployingModel"
        case explainabilityError = "ExplainabilityError"
        case failed = "Failed"
        case featureEngineering = "FeatureEngineering"
        case generatingExplainabilityReport = "GeneratingExplainabilityReport"
        case generatingModelInsightsReport = "GeneratingModelInsightsReport"
        case maxAutoMlJobRuntimeReached = "MaxAutoMLJobRuntimeReached"
        case maxCandidatesReached = "MaxCandidatesReached"
        case modelDeploymentError = "ModelDeploymentError"
        case modelInsightsError = "ModelInsightsError"
        case modelTuning = "ModelTuning"
        case starting = "Starting"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLMetricEnum: String, CustomStringConvertible, Codable, _SotoSendable {
        case accuracy = "Accuracy"
        case auc = "AUC"
        case balancedAccuracy = "BalancedAccuracy"
        case f1 = "F1"
        case f1Macro = "F1macro"
        case mae = "MAE"
        case mse = "MSE"
        case precision = "Precision"
        case precisionMacro = "PrecisionMacro"
        case r2 = "R2"
        case recall = "Recall"
        case recallMacro = "RecallMacro"
        case rmse = "RMSE"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLMetricExtendedEnum: String, CustomStringConvertible, Codable, _SotoSendable {
        case accuracy = "Accuracy"
        case auc = "AUC"
        case balancedAccuracy = "BalancedAccuracy"
        case f1 = "F1"
        case f1Macro = "F1macro"
        case inferenceLatency = "InferenceLatency"
        case logLoss = "LogLoss"
        case mae = "MAE"
        case mse = "MSE"
        case precision = "Precision"
        case precisionMacro = "PrecisionMacro"
        case r2 = "R2"
        case recall = "Recall"
        case recallMacro = "RecallMacro"
        case rmse = "RMSE"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case ensembling = "ENSEMBLING"
        case hyperparameterTuning = "HYPERPARAMETER_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLS3DataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case manifestFile = "ManifestFile"
        case s3Prefix = "S3Prefix"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum AwsManagedHumanLoopRequestSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case rekognitionDetectModerationLabelsImageV3 = "AWS/Rekognition/DetectModerationLabels/Image/V3"
        case textractAnalyzeDocumentFormsV1 = "AWS/Textract/AnalyzeDocument/Forms/V1"
        public var description: String { return self.rawValue }
    }

    public enum BatchStrategy: String, CustomStringConvertible, Codable, _SotoSendable {
        case multiRecord = "MultiRecord"
        case singleRecord = "SingleRecord"
        public var description: String { return self.rawValue }
    }

    public enum BooleanOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case and = "And"
        case or = "Or"
        public var description: String { return self.rawValue }
    }

    public enum CandidateSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case finalObjectiveMetricValue = "FinalObjectiveMetricValue"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum CandidateStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum CandidateStepType: String, CustomStringConvertible, Codable, _SotoSendable {
        case processing = "AWS::SageMaker::ProcessingJob"
        case training = "AWS::SageMaker::TrainingJob"
        case transform = "AWS::SageMaker::TransformJob"
        public var description: String { return self.rawValue }
    }

    public enum CapacitySizeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case capacityPercent = "CAPACITY_PERCENT"
        case instanceCount = "INSTANCE_COUNT"
        public var description: String { return self.rawValue }
    }

    public enum CaptureMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case input = "Input"
        case output = "Output"
        public var description: String { return self.rawValue }
    }

    public enum CaptureStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case started = "Started"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public enum ClarifyFeatureType: String, CustomStringConvertible, Codable, _SotoSendable {
        case categorical
        case numerical
        case text
        public var description: String { return self.rawValue }
    }

    public enum ClarifyTextGranularity: String, CustomStringConvertible, Codable, _SotoSendable {
        case paragraph
        case sentence
        case token
        public var description: String { return self.rawValue }
    }

    public enum ClarifyTextLanguage: String, CustomStringConvertible, Codable, _SotoSendable {
        case afrikaans = "af"
        case albanian = "sq"
        case arabic = "ar"
        case armenian = "hy"
        case basque = "eu"
        case bengali = "bn"
        case bulgarian = "bg"
        case catalan = "ca"
        case chinese = "zh"
        case croatian = "hr"
        case czech = "cs"
        case danish = "da"
        case dutch = "nl"
        case english = "en"
        case estonian = "et"
        case finnish = "fi"
        case french = "fr"
        case german = "de"
        case greek = "el"
        case gujarati = "gu"
        case hebrew = "he"
        case hindi = "hi"
        case hungarian = "hu"
        case icelandic = "is"
        case indonesian = "id"
        case irish = "ga"
        case italian = "it"
        case kannada = "kn"
        case kyrgyz = "ky"
        case latvian = "lv"
        case ligurian = "lij"
        case lithuanian = "lt"
        case luxembourgish = "lb"
        case macedonian = "mk"
        case malayalam = "ml"
        case marathi = "mr"
        case multiLanguage = "xx"
        case nepali = "ne"
        case norwegianBokmal = "nb"
        case persian = "fa"
        case polish = "pl"
        case portuguese = "pt"
        case romanian = "ro"
        case russian = "ru"
        case sanskrit = "sa"
        case serbian = "sr"
        case setswana = "tn"
        case sinhala = "si"
        case slovak = "sk"
        case slovenian = "sl"
        case spanish = "es"
        case swedish = "sv"
        case tagalog = "tl"
        case tamil = "ta"
        case tatar = "tt"
        case telugu = "te"
        case turkish = "tr"
        case ukrainian = "uk"
        case urdu = "ur"
        case yoruba = "yo"
        public var description: String { return self.rawValue }
    }

    public enum CodeRepositorySortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum CodeRepositorySortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum CompilationJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inprogress = "INPROGRESS"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum CompressionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gzip = "Gzip"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum ConditionOutcome: String, CustomStringConvertible, Codable, _SotoSendable {
        case `false` = "False"
        case `true` = "True"
        public var description: String { return self.rawValue }
    }

    public enum ContainerMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case multiModel = "MultiModel"
        case singleModel = "SingleModel"
        public var description: String { return self.rawValue }
    }

    public enum ContentClassifier: String, CustomStringConvertible, Codable, _SotoSendable {
        case freeOfAdultContent = "FreeOfAdultContent"
        case freeOfPersonallyIdentifiableInformation = "FreeOfPersonallyIdentifiableInformation"
        public var description: String { return self.rawValue }
    }

    public enum DataDistributionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case fullyreplicated = "FullyReplicated"
        case shardedbys3key = "ShardedByS3Key"
        public var description: String { return self.rawValue }
    }

    public enum DetailedAlgorithmStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case notStarted = "NotStarted"
        public var description: String { return self.rawValue }
    }

    public enum DetailedModelPackageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case notStarted = "NotStarted"
        public var description: String { return self.rawValue }
    }

    public enum DeviceDeploymentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deployed = "DEPLOYED"
        case failed = "FAILED"
        case inProgress = "INPROGRESS"
        case readyToDeploy = "READYTODEPLOY"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum DeviceSubsetType: String, CustomStringConvertible, Codable, _SotoSendable {
        case nameContains = "NAMECONTAINS"
        case percentage = "PERCENTAGE"
        case selection = "SELECTION"
        public var description: String { return self.rawValue }
    }

    public enum DirectInternetAccess: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum Direction: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascendants = "Ascendants"
        case both = "Both"
        case descendants = "Descendants"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleteFailed = "Delete_Failed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case pending = "Pending"
        case updateFailed = "Update_Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum EdgePackagingJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "INPROGRESS"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum EdgePresetDeploymentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum EdgePresetDeploymentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case greengrassV2Component = "GreengrassV2Component"
        public var description: String { return self.rawValue }
    }

    public enum EndpointConfigSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum EndpointSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case outOfService = "OutOfService"
        case rollingBack = "RollingBack"
        case systemUpdating = "SystemUpdating"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionRoleIdentityConfig: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case userProfileName = "USER_PROFILE_NAME"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case completedWithViolations = "CompletedWithViolations"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum FailureHandlingPolicy: String, CustomStringConvertible, Codable, _SotoSendable {
        case doNothing = "DO_NOTHING"
        case rollbackOnFailure = "ROLLBACK_ON_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum FeatureGroupSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case featureGroupStatus = "FeatureGroupStatus"
        case name = "Name"
        case offlineStoreStatus = "OfflineStoreStatus"
        public var description: String { return self.rawValue }
    }

    public enum FeatureGroupSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum FeatureGroupStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CreateFailed"
        case created = "Created"
        case creating = "Creating"
        case deleteFailed = "DeleteFailed"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public enum FeatureStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum FeatureType: String, CustomStringConvertible, Codable, _SotoSendable {
        case fractional = "Fractional"
        case integral = "Integral"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum FileSystemAccessMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case ro
        case rw
        public var description: String { return self.rawValue }
    }

    public enum FileSystemType: String, CustomStringConvertible, Codable, _SotoSendable {
        case efs = "EFS"
        case fsxlustre = "FSxLustre"
        public var description: String { return self.rawValue }
    }

    public enum FlowDefinitionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case deleting = "Deleting"
        case failed = "Failed"
        case initializing = "Initializing"
        public var description: String { return self.rawValue }
    }

    public enum Framework: String, CustomStringConvertible, Codable, _SotoSendable {
        case darknet = "DARKNET"
        case keras = "KERAS"
        case mxnet = "MXNET"
        case onnx = "ONNX"
        case pytorch = "PYTORCH"
        case sklearn = "SKLEARN"
        case tensorflow = "TENSORFLOW"
        case tflite = "TFLITE"
        case xgboost = "XGBOOST"
        public var description: String { return self.rawValue }
    }

    public enum HubContentSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case hubContentName = "HubContentName"
        case hubContentStatus = "HubContentStatus"
        public var description: String { return self.rawValue }
    }

    public enum HubContentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "Available"
        case deleteFailed = "DeleteFailed"
        case deleting = "Deleting"
        case importFailed = "ImportFailed"
        case importing = "Importing"
        public var description: String { return self.rawValue }
    }

    public enum HubContentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case model = "Model"
        case notebook = "Notebook"
        public var description: String { return self.rawValue }
    }

    public enum HubSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountIdOwner = "AccountIdOwner"
        case creationTime = "CreationTime"
        case hubName = "HubName"
        case hubStatus = "HubStatus"
        public var description: String { return self.rawValue }
    }

    public enum HubStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CreateFailed"
        case creating = "Creating"
        case deleteFailed = "DeleteFailed"
        case deleting = "Deleting"
        case inService = "InService"
        case updateFailed = "UpdateFailed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum HumanTaskUiStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterScalingType: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "Auto"
        case linear = "Linear"
        case logarithmic = "Logarithmic"
        case reverseLogarithmic = "ReverseLogarithmic"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningAllocationStrategy: String, CustomStringConvertible, Codable, _SotoSendable {
        case prioritized = "Prioritized"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobObjectiveType: String, CustomStringConvertible, Codable, _SotoSendable {
        case maximize = "Maximize"
        case minimize = "Minimize"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobSortByOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobStrategyType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bayesian = "Bayesian"
        case grid = "Grid"
        case hyperband = "Hyperband"
        case random = "Random"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobWarmStartType: String, CustomStringConvertible, Codable, _SotoSendable {
        case identicalDataAndAlgorithm = "IdenticalDataAndAlgorithm"
        case transferLearning = "TransferLearning"
        public var description: String { return self.rawValue }
    }

    public enum ImageSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CREATION_TIME"
        case imageName = "IMAGE_NAME"
        case lastModifiedTime = "LAST_MODIFIED_TIME"
        public var description: String { return self.rawValue }
    }

    public enum ImageSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ImageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case created = "CREATED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ImageVersionSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CREATION_TIME"
        case lastModifiedTime = "LAST_MODIFIED_TIME"
        case version = "VERSION"
        public var description: String { return self.rawValue }
    }

    public enum ImageVersionSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ImageVersionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case created = "CREATED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum InferenceExecutionMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case direct = "Direct"
        case serial = "Serial"
        public var description: String { return self.rawValue }
    }

    public enum InferenceExperimentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "Cancelled"
        case completed = "Completed"
        case created = "Created"
        case creating = "Creating"
        case running = "Running"
        case starting = "Starting"
        case stopping = "Stopping"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum InferenceExperimentStopDesiredState: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "Cancelled"
        case completed = "Completed"
        public var description: String { return self.rawValue }
    }

    public enum InferenceExperimentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case shadowMode = "ShadowMode"
        public var description: String { return self.rawValue }
    }

    public enum InputMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case file = "File"
        case pipe = "Pipe"
        public var description: String { return self.rawValue }
    }

    public enum InstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5D18Xlarge = "ml.c5d.18xlarge"
        case mlC5D2Xlarge = "ml.c5d.2xlarge"
        case mlC5D4Xlarge = "ml.c5d.4xlarge"
        case mlC5D9Xlarge = "ml.c5d.9xlarge"
        case mlC5DXlarge = "ml.c5d.xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlG512Xlarge = "ml.g5.12xlarge"
        case mlG516Xlarge = "ml.g5.16xlarge"
        case mlG524Xlarge = "ml.g5.24xlarge"
        case mlG52Xlarge = "ml.g5.2xlarge"
        case mlG548Xlarge = "ml.g5.48xlarge"
        case mlG54Xlarge = "ml.g5.4xlarge"
        case mlG58Xlarge = "ml.g5.8xlarge"
        case mlG5Xlarge = "ml.g5.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5D12Xlarge = "ml.m5d.12xlarge"
        case mlM5D16Xlarge = "ml.m5d.16xlarge"
        case mlM5D24Xlarge = "ml.m5d.24xlarge"
        case mlM5D2Xlarge = "ml.m5d.2xlarge"
        case mlM5D4Xlarge = "ml.m5d.4xlarge"
        case mlM5D8Xlarge = "ml.m5d.8xlarge"
        case mlM5DLarge = "ml.m5d.large"
        case mlM5DXlarge = "ml.m5d.xlarge"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP3Dn24Xlarge = "ml.p3dn.24xlarge"
        case mlR512Xlarge = "ml.r5.12xlarge"
        case mlR516Xlarge = "ml.r5.16xlarge"
        case mlR524Xlarge = "ml.r5.24xlarge"
        case mlR52Xlarge = "ml.r5.2xlarge"
        case mlR54Xlarge = "ml.r5.4xlarge"
        case mlR58Xlarge = "ml.r5.8xlarge"
        case mlR5Large = "ml.r5.large"
        case mlR5Xlarge = "ml.r5.xlarge"
        case mlT22Xlarge = "ml.t2.2xlarge"
        case mlT2Large = "ml.t2.large"
        case mlT2Medium = "ml.t2.medium"
        case mlT2Xlarge = "ml.t2.xlarge"
        case mlT32Xlarge = "ml.t3.2xlarge"
        case mlT3Large = "ml.t3.large"
        case mlT3Medium = "ml.t3.medium"
        case mlT3Xlarge = "ml.t3.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, _SotoSendable {
        case inference = "INFERENCE"
        case notebookKernel = "NOTEBOOK_KERNEL"
        case training = "TRAINING"
        public var description: String { return self.rawValue }
    }

    public enum JoinSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case input = "Input"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum LabelingJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case initializing = "Initializing"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatusValue: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum LineageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case action = "Action"
        case artifact = "Artifact"
        case context = "Context"
        case trialComponent = "TrialComponent"
        public var description: String { return self.rawValue }
    }

    public enum ListCompilationJobsSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum ListDeviceFleetsSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CREATION_TIME"
        case lastModifiedTime = "LAST_MODIFIED_TIME"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum ListEdgeDeploymentPlansSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CREATION_TIME"
        case deviceFleetName = "DEVICE_FLEET_NAME"
        case lastModifiedTime = "LAST_MODIFIED_TIME"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum ListEdgePackagingJobsSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CREATION_TIME"
        case edgePackagingJobStatus = "STATUS"
        case lastModifiedTime = "LAST_MODIFIED_TIME"
        case modelName = "MODEL_NAME"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum ListInferenceRecommendationsJobsSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum ListLabelingJobsForWorkteamSortByOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum ListWorkforcesSortByOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case createDate = "CreateDate"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ListWorkteamsSortByOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case createDate = "CreateDate"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum MetricSetSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case test = "Test"
        case train = "Train"
        case validation = "Validation"
        public var description: String { return self.rawValue }
    }

    public enum ModelApprovalStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case approved = "Approved"
        case pendingManualApproval = "PendingManualApproval"
        case rejected = "Rejected"
        public var description: String { return self.rawValue }
    }

    public enum ModelCacheSetting: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardExportJobSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardExportJobSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardExportJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardProcessingStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case contentDeleted = "ContentDeleted"
        case deleteCompleted = "DeleteCompleted"
        case deleteFailed = "DeleteFailed"
        case deleteInprogress = "DeleteInProgress"
        case deletePending = "DeletePending"
        case exportjobsDeleted = "ExportJobsDeleted"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case approved = "Approved"
        case archived = "Archived"
        case draft = "Draft"
        case pendingreview = "PendingReview"
        public var description: String { return self.rawValue }
    }

    public enum ModelCardVersionSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case version = "Version"
        public var description: String { return self.rawValue }
    }

    public enum ModelInfrastructureType: String, CustomStringConvertible, Codable, _SotoSendable {
        case realTimeInference = "RealTimeInference"
        public var description: String { return self.rawValue }
    }

    public enum ModelMetadataFilterType: String, CustomStringConvertible, Codable, _SotoSendable {
        case domain = "Domain"
        case framework = "Framework"
        case frameworkversion = "FrameworkVersion"
        case task = "Task"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageGroupSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageGroupStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case deleteFailed = "DeleteFailed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case both = "Both"
        case unversioned = "Unversioned"
        case versioned = "Versioned"
        public var description: String { return self.rawValue }
    }

    public enum ModelSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ModelVariantAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case promote = "Promote"
        case remove = "Remove"
        case retain = "Retain"
        public var description: String { return self.rawValue }
    }

    public enum ModelVariantStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case creating = "Creating"
        case deleted = "Deleted"
        case deleting = "Deleting"
        case inService = "InService"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringAlertHistorySortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringAlertStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case inAlert = "InAlert"
        case ok = "OK"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringExecutionSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case scheduledTime = "ScheduledTime"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringJobDefinitionSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringProblemType: String, CustomStringConvertible, Codable, _SotoSendable {
        case binaryClassification = "BinaryClassification"
        case multiclassClassification = "MulticlassClassification"
        case regression = "Regression"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringScheduleSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum MonitoringType: String, CustomStringConvertible, Codable, _SotoSendable {
        case dataQuality = "DataQuality"
        case modelBias = "ModelBias"
        case modelExplainability = "ModelExplainability"
        case modelQuality = "ModelQuality"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceAcceleratorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlEia1Large = "ml.eia1.large"
        case mlEia1Medium = "ml.eia1.medium"
        case mlEia1Xlarge = "ml.eia1.xlarge"
        case mlEia2Large = "ml.eia2.large"
        case mlEia2Medium = "ml.eia2.medium"
        case mlEia2Xlarge = "ml.eia2.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceLifecycleConfigSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceLifecycleConfigSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum NotebookInstanceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case pending = "Pending"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum NotebookOutputOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case allowed = "Allowed"
        case disabled = "Disabled"
        public var description: String { return self.rawValue }
    }

    public enum ObjectiveStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "Failed"
        case pending = "Pending"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum OfflineStoreStatusValue: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case blocked = "Blocked"
        case disabled = "Disabled"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, _SotoSendable {
        case `in` = "In"
        case contains = "Contains"
        case equals = "Equals"
        case exists = "Exists"
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThan = "LessThan"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
        case notEquals = "NotEquals"
        case notExists = "NotExists"
        public var description: String { return self.rawValue }
    }

    public enum OrderKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable, _SotoSendable {
        case categorical = "Categorical"
        case continuous = "Continuous"
        case freeText = "FreeText"
        case integer = "Integer"
        public var description: String { return self.rawValue }
    }

    public enum PipelineExecutionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case executing = "Executing"
        case failed = "Failed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        public var description: String { return self.rawValue }
    }

    public enum ProblemType: String, CustomStringConvertible, Codable, _SotoSendable {
        case binaryClassification = "BinaryClassification"
        case multiclassClassification = "MulticlassClassification"
        case regression = "Regression"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlR512Xlarge = "ml.r5.12xlarge"
        case mlR516Xlarge = "ml.r5.16xlarge"
        case mlR524Xlarge = "ml.r5.24xlarge"
        case mlR52Xlarge = "ml.r5.2xlarge"
        case mlR54Xlarge = "ml.r5.4xlarge"
        case mlR58Xlarge = "ml.r5.8xlarge"
        case mlR5Large = "ml.r5.large"
        case mlR5Xlarge = "ml.r5.xlarge"
        case mlT32Xlarge = "ml.t3.2xlarge"
        case mlT3Large = "ml.t3.large"
        case mlT3Medium = "ml.t3.medium"
        case mlT3Xlarge = "ml.t3.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingS3CompressionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gzip = "Gzip"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingS3DataDistributionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case fullyreplicated = "FullyReplicated"
        case shardedbys3key = "ShardedByS3Key"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingS3DataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case manifestFile = "ManifestFile"
        case s3Prefix = "S3Prefix"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingS3InputMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case file = "File"
        case pipe = "Pipe"
        public var description: String { return self.rawValue }
    }

    public enum ProcessingS3UploadMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case continuous = "Continuous"
        case endOfJob = "EndOfJob"
        public var description: String { return self.rawValue }
    }

    public enum Processor: String, CustomStringConvertible, Codable, _SotoSendable {
        case cpu = "CPU"
        case gpu = "GPU"
        public var description: String { return self.rawValue }
    }

    public enum ProductionVariantAcceleratorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlEia1Large = "ml.eia1.large"
        case mlEia1Medium = "ml.eia1.medium"
        case mlEia1Xlarge = "ml.eia1.xlarge"
        case mlEia2Large = "ml.eia2.large"
        case mlEia2Medium = "ml.eia2.medium"
        case mlEia2Xlarge = "ml.eia2.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum ProductionVariantInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Large = "ml.c4.large"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5D18Xlarge = "ml.c5d.18xlarge"
        case mlC5D2Xlarge = "ml.c5d.2xlarge"
        case mlC5D4Xlarge = "ml.c5d.4xlarge"
        case mlC5D9Xlarge = "ml.c5d.9xlarge"
        case mlC5DLarge = "ml.c5d.large"
        case mlC5DXlarge = "ml.c5d.xlarge"
        case mlC5Large = "ml.c5.large"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC6G12Xlarge = "ml.c6g.12xlarge"
        case mlC6G16Xlarge = "ml.c6g.16xlarge"
        case mlC6G2Xlarge = "ml.c6g.2xlarge"
        case mlC6G4Xlarge = "ml.c6g.4xlarge"
        case mlC6G8Xlarge = "ml.c6g.8xlarge"
        case mlC6GLarge = "ml.c6g.large"
        case mlC6GXlarge = "ml.c6g.xlarge"
        case mlC6Gd12Xlarge = "ml.c6gd.12xlarge"
        case mlC6Gd16Xlarge = "ml.c6gd.16xlarge"
        case mlC6Gd2Xlarge = "ml.c6gd.2xlarge"
        case mlC6Gd4Xlarge = "ml.c6gd.4xlarge"
        case mlC6Gd8Xlarge = "ml.c6gd.8xlarge"
        case mlC6GdLarge = "ml.c6gd.large"
        case mlC6GdXlarge = "ml.c6gd.xlarge"
        case mlC6Gn12Xlarge = "ml.c6gn.12xlarge"
        case mlC6Gn16Xlarge = "ml.c6gn.16xlarge"
        case mlC6Gn2Xlarge = "ml.c6gn.2xlarge"
        case mlC6Gn4Xlarge = "ml.c6gn.4xlarge"
        case mlC6Gn8Xlarge = "ml.c6gn.8xlarge"
        case mlC6GnLarge = "ml.c6gn.large"
        case mlC6GnXlarge = "ml.c6gn.xlarge"
        case mlC6I12Xlarge = "ml.c6i.12xlarge"
        case mlC6I16Xlarge = "ml.c6i.16xlarge"
        case mlC6I24Xlarge = "ml.c6i.24xlarge"
        case mlC6I2Xlarge = "ml.c6i.2xlarge"
        case mlC6I32Xlarge = "ml.c6i.32xlarge"
        case mlC6I4Xlarge = "ml.c6i.4xlarge"
        case mlC6I8Xlarge = "ml.c6i.8xlarge"
        case mlC6ILarge = "ml.c6i.large"
        case mlC6IXlarge = "ml.c6i.xlarge"
        case mlC7G12Xlarge = "ml.c7g.12xlarge"
        case mlC7G16Xlarge = "ml.c7g.16xlarge"
        case mlC7G2Xlarge = "ml.c7g.2xlarge"
        case mlC7G4Xlarge = "ml.c7g.4xlarge"
        case mlC7G8Xlarge = "ml.c7g.8xlarge"
        case mlC7GLarge = "ml.c7g.large"
        case mlC7GXlarge = "ml.c7g.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlG512Xlarge = "ml.g5.12xlarge"
        case mlG516Xlarge = "ml.g5.16xlarge"
        case mlG524Xlarge = "ml.g5.24xlarge"
        case mlG52Xlarge = "ml.g5.2xlarge"
        case mlG548Xlarge = "ml.g5.48xlarge"
        case mlG54Xlarge = "ml.g5.4xlarge"
        case mlG58Xlarge = "ml.g5.8xlarge"
        case mlG5Xlarge = "ml.g5.xlarge"
        case mlInf124Xlarge = "ml.inf1.24xlarge"
        case mlInf12Xlarge = "ml.inf1.2xlarge"
        case mlInf16Xlarge = "ml.inf1.6xlarge"
        case mlInf1Xlarge = "ml.inf1.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5D12Xlarge = "ml.m5d.12xlarge"
        case mlM5D24Xlarge = "ml.m5d.24xlarge"
        case mlM5D2Xlarge = "ml.m5d.2xlarge"
        case mlM5D4Xlarge = "ml.m5d.4xlarge"
        case mlM5DLarge = "ml.m5d.large"
        case mlM5DXlarge = "ml.m5d.xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlM6G12Xlarge = "ml.m6g.12xlarge"
        case mlM6G16Xlarge = "ml.m6g.16xlarge"
        case mlM6G2Xlarge = "ml.m6g.2xlarge"
        case mlM6G4Xlarge = "ml.m6g.4xlarge"
        case mlM6G8Xlarge = "ml.m6g.8xlarge"
        case mlM6GLarge = "ml.m6g.large"
        case mlM6GXlarge = "ml.m6g.xlarge"
        case mlM6Gd12Xlarge = "ml.m6gd.12xlarge"
        case mlM6Gd16Xlarge = "ml.m6gd.16xlarge"
        case mlM6Gd2Xlarge = "ml.m6gd.2xlarge"
        case mlM6Gd4Xlarge = "ml.m6gd.4xlarge"
        case mlM6Gd8Xlarge = "ml.m6gd.8xlarge"
        case mlM6GdLarge = "ml.m6gd.large"
        case mlM6GdXlarge = "ml.m6gd.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP4D24Xlarge = "ml.p4d.24xlarge"
        case mlR512Xlarge = "ml.r5.12xlarge"
        case mlR524Xlarge = "ml.r5.24xlarge"
        case mlR52Xlarge = "ml.r5.2xlarge"
        case mlR54Xlarge = "ml.r5.4xlarge"
        case mlR5D12Xlarge = "ml.r5d.12xlarge"
        case mlR5D24Xlarge = "ml.r5d.24xlarge"
        case mlR5D2Xlarge = "ml.r5d.2xlarge"
        case mlR5D4Xlarge = "ml.r5d.4xlarge"
        case mlR5DLarge = "ml.r5d.large"
        case mlR5DXlarge = "ml.r5d.xlarge"
        case mlR5Large = "ml.r5.large"
        case mlR5Xlarge = "ml.r5.xlarge"
        case mlR6G12Xlarge = "ml.r6g.12xlarge"
        case mlR6G16Xlarge = "ml.r6g.16xlarge"
        case mlR6G2Xlarge = "ml.r6g.2xlarge"
        case mlR6G4Xlarge = "ml.r6g.4xlarge"
        case mlR6G8Xlarge = "ml.r6g.8xlarge"
        case mlR6GLarge = "ml.r6g.large"
        case mlR6GXlarge = "ml.r6g.xlarge"
        case mlR6Gd12Xlarge = "ml.r6gd.12xlarge"
        case mlR6Gd16Xlarge = "ml.r6gd.16xlarge"
        case mlR6Gd2Xlarge = "ml.r6gd.2xlarge"
        case mlR6Gd4Xlarge = "ml.r6gd.4xlarge"
        case mlR6Gd8Xlarge = "ml.r6gd.8xlarge"
        case mlR6GdLarge = "ml.r6gd.large"
        case mlR6GdXlarge = "ml.r6gd.xlarge"
        case mlT22Xlarge = "ml.t2.2xlarge"
        case mlT2Large = "ml.t2.large"
        case mlT2Medium = "ml.t2.medium"
        case mlT2Xlarge = "ml.t2.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum ProfilingStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ProjectSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum ProjectSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum ProjectStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case createCompleted = "CreateCompleted"
        case createFailed = "CreateFailed"
        case createInProgress = "CreateInProgress"
        case deleteCompleted = "DeleteCompleted"
        case deleteFailed = "DeleteFailed"
        case deleteInProgress = "DeleteInProgress"
        case pending = "Pending"
        case updateCompleted = "UpdateCompleted"
        case updateFailed = "UpdateFailed"
        case updateInProgress = "UpdateInProgress"
        public var description: String { return self.rawValue }
    }

    public enum RStudioServerProAccessStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RStudioServerProUserGroup: String, CustomStringConvertible, Codable, _SotoSendable {
        case admin = "R_STUDIO_ADMIN"
        case user = "R_STUDIO_USER"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationJobType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "Default"
        case advanced = "Advanced"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationStepType: String, CustomStringConvertible, Codable, _SotoSendable {
        case benchmark = "BENCHMARK"
        public var description: String { return self.rawValue }
    }

    public enum RecordWrapper: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "None"
        case recordio = "RecordIO"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftResultCompressionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bzip2 = "BZIP2"
        case gzip = "GZIP"
        case none = "None"
        case snappy = "SNAPPY"
        case zstd = "ZSTD"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftResultFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case csv = "CSV"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum RepositoryAccessMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case platform = "Platform"
        case vpc = "Vpc"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case endpoint = "Endpoint"
        case experiment = "Experiment"
        case experimentTrial = "ExperimentTrial"
        case experimentTrialComponent = "ExperimentTrialComponent"
        case featureGroup = "FeatureGroup"
        case featureMetadata = "FeatureMetadata"
        case hyperParameterTuningJob = "HyperParameterTuningJob"
        case model = "Model"
        case modelCard = "ModelCard"
        case modelPackage = "ModelPackage"
        case modelPackageGroup = "ModelPackageGroup"
        case pipeline = "Pipeline"
        case pipelineExecution = "PipelineExecution"
        case project = "Project"
        case trainingJob = "TrainingJob"
        public var description: String { return self.rawValue }
    }

    public enum RetentionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case delete = "Delete"
        case retain = "Retain"
        public var description: String { return self.rawValue }
    }

    public enum RootAccess: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum RuleEvaluationStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "Error"
        case inProgress = "InProgress"
        case issuesFound = "IssuesFound"
        case noIssuesFound = "NoIssuesFound"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum S3DataDistribution: String, CustomStringConvertible, Codable, _SotoSendable {
        case fullyReplicated = "FullyReplicated"
        case shardedByS3Key = "ShardedByS3Key"
        public var description: String { return self.rawValue }
    }

    public enum S3DataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case augmentedManifestFile = "AugmentedManifestFile"
        case manifestFile = "ManifestFile"
        case s3Prefix = "S3Prefix"
        public var description: String { return self.rawValue }
    }

    public enum SagemakerServicecatalogStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "Failed"
        case pending = "Pending"
        case scheduled = "Scheduled"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public enum SearchSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum SecondaryStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case downloading = "Downloading"
        case downloadingTrainingImage = "DownloadingTrainingImage"
        case failed = "Failed"
        case interrupted = "Interrupted"
        case launchingMlInstances = "LaunchingMLInstances"
        case maxRuntimeExceeded = "MaxRuntimeExceeded"
        case maxWaitTimeExceeded = "MaxWaitTimeExceeded"
        case preparingTrainingStack = "PreparingTrainingStack"
        case restarting = "Restarting"
        case starting = "Starting"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case training = "Training"
        case updating = "Updating"
        case uploading = "Uploading"
        public var description: String { return self.rawValue }
    }

    public enum SortActionsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortArtifactsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortAssociationsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case destinationArn = "DestinationArn"
        case destinationType = "DestinationType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        public var description: String { return self.rawValue }
    }

    public enum SortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum SortContextsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortExperimentsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortInferenceExperimentsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum SortLineageGroupsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum SortPipelineExecutionsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case pipelineExecutionArn = "PipelineExecutionArn"
        public var description: String { return self.rawValue }
    }

    public enum SortPipelinesBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortTrialComponentsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SortTrialsBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum SpaceSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        public var description: String { return self.rawValue }
    }

    public enum SpaceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleteFailed = "Delete_Failed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case pending = "Pending"
        case updateFailed = "Update_Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum SplitType: String, CustomStringConvertible, Codable, _SotoSendable {
        case line = "Line"
        case none = "None"
        case recordio = "RecordIO"
        case tfrecord = "TFRecord"
        public var description: String { return self.rawValue }
    }

    public enum StageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case creating = "CREATING"
        case deployed = "DEPLOYED"
        case failed = "FAILED"
        case inProgress = "INPROGRESS"
        case readyToDeploy = "READYTODEPLOY"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum StepStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case executing = "Executing"
        case failed = "Failed"
        case starting = "Starting"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum StudioLifecycleConfigAppType: String, CustomStringConvertible, Codable, _SotoSendable {
        case jupyterServer = "JupyterServer"
        case kernelGateway = "KernelGateway"
        public var description: String { return self.rawValue }
    }

    public enum StudioLifecycleConfigSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum TableFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case glue = "Glue"
        case iceberg = "Iceberg"
        public var description: String { return self.rawValue }
    }

    public enum TargetDevice: String, CustomStringConvertible, Codable, _SotoSendable {
        case aisage
        case ambaCv2 = "amba_cv2"
        case ambaCv22 = "amba_cv22"
        case ambaCv25 = "amba_cv25"
        case coreml
        case deeplens
        case imx8mplus
        case imx8qm
        case jacintoTda4Vm = "jacinto_tda4vm"
        case jetsonNano = "jetson_nano"
        case jetsonTx1 = "jetson_tx1"
        case jetsonTx2 = "jetson_tx2"
        case jetsonXavier = "jetson_xavier"
        case lambda
        case mlC4 = "ml_c4"
        case mlC5 = "ml_c5"
        case mlEia2 = "ml_eia2"
        case mlG4Dn = "ml_g4dn"
        case mlInf1 = "ml_inf1"
        case mlM4 = "ml_m4"
        case mlM5 = "ml_m5"
        case mlP2 = "ml_p2"
        case mlP3 = "ml_p3"
        case qcs603
        case qcs605
        case rasp3b
        case rk3288
        case rk3399
        case sbeC = "sbe_c"
        case sitaraAm57X = "sitara_am57x"
        case x86Win32 = "x86_win32"
        case x86Win64 = "x86_win64"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformAccelerator: String, CustomStringConvertible, Codable, _SotoSendable {
        case intelGraphics = "INTEL_GRAPHICS"
        case mali = "MALI"
        case nna = "NNA"
        case nvidia = "NVIDIA"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformArch: String, CustomStringConvertible, Codable, _SotoSendable {
        case arm64 = "ARM64"
        case armEabi = "ARM_EABI"
        case armEabihf = "ARM_EABIHF"
        case x86 = "X86"
        case x8664 = "X86_64"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformOs: String, CustomStringConvertible, Codable, _SotoSendable {
        case android = "ANDROID"
        case linux = "LINUX"
        public var description: String { return self.rawValue }
    }

    public enum TrafficRoutingConfigType: String, CustomStringConvertible, Codable, _SotoSendable {
        case allAtOnce = "ALL_AT_ONCE"
        case canary = "CANARY"
        case linear = "LINEAR"
        public var description: String { return self.rawValue }
    }

    public enum TrafficType: String, CustomStringConvertible, Codable, _SotoSendable {
        case phases = "PHASES"
        public var description: String { return self.rawValue }
    }

    public enum TrainingInputMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case fastfile = "FastFile"
        case file = "File"
        case pipe = "Pipe"
        public var description: String { return self.rawValue }
    }

    public enum TrainingInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5N18Xlarge = "ml.c5n.18xlarge"
        case mlC5N2Xlarge = "ml.c5n.2xlarge"
        case mlC5N4Xlarge = "ml.c5n.4xlarge"
        case mlC5N9Xlarge = "ml.c5n.9xlarge"
        case mlC5NXlarge = "ml.c5n.xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlG512Xlarge = "ml.g5.12xlarge"
        case mlG516Xlarge = "ml.g5.16xlarge"
        case mlG524Xlarge = "ml.g5.24xlarge"
        case mlG52Xlarge = "ml.g5.2xlarge"
        case mlG548Xlarge = "ml.g5.48xlarge"
        case mlG54Xlarge = "ml.g5.4xlarge"
        case mlG58Xlarge = "ml.g5.8xlarge"
        case mlG5Xlarge = "ml.g5.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP3Dn24Xlarge = "ml.p3dn.24xlarge"
        case mlP4D24Xlarge = "ml.p4d.24xlarge"
        case mlTrn12Xlarge = "ml.trn1.2xlarge"
        case mlTrn132Xlarge = "ml.trn1.32xlarge"
        public var description: String { return self.rawValue }
    }

    public enum TrainingJobEarlyStoppingType: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "Auto"
        case off = "Off"
        public var description: String { return self.rawValue }
    }

    public enum TrainingJobSortByOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case finalObjectiveMetricValue = "FinalObjectiveMetricValue"
        case name = "Name"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum TrainingJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum TransformInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        public var description: String { return self.rawValue }
    }

    public enum TransformJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum TrialComponentPrimaryStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileSortKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleteFailed = "Delete_Failed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inService = "InService"
        case pending = "Pending"
        case updateFailed = "Update_Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum VariantPropertyType: String, CustomStringConvertible, Codable, _SotoSendable {
        case dataCaptureConfig = "DataCaptureConfig"
        case desiredInstanceCount = "DesiredInstanceCount"
        case desiredWeight = "DesiredWeight"
        public var description: String { return self.rawValue }
    }

    public enum VariantStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case activatingTraffic = "ActivatingTraffic"
        case baking = "Baking"
        case creating = "Creating"
        case deleting = "Deleting"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum VendorGuidance: String, CustomStringConvertible, Codable, _SotoSendable {
        case archived = "ARCHIVED"
        case notProvided = "NOT_PROVIDED"
        case stable = "STABLE"
        case toBeArchived = "TO_BE_ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum WarmPoolResourceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "Available"
        case inuse = "InUse"
        case reused = "Reused"
        case terminated = "Terminated"
        public var description: String { return self.rawValue }
    }

    public enum WorkforceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case deleting = "Deleting"
        case failed = "Failed"
        case initializing = "Initializing"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum TrialComponentParameterValue: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// The numeric value of a numeric hyperparameter. If you specify a value for this parameter, you can't specify the StringValue parameter.
        case numberValue(Double)
        /// The string value of a categorical hyperparameter. If you specify a value for this parameter, you can't specify the NumberValue parameter.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .numberValue:
                let value = try container.decode(Double.self, forKey: .numberValue)
                self = .numberValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .numberValue(let value):
                try container.encode(value, forKey: .numberValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 256)
                try self.validate(value, name: "stringValue", parent: name, pattern: ".*")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case numberValue = "NumberValue"
            case stringValue = "StringValue"
        }
    }

    // MARK: Shapes

    public struct ActionSource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the source.
        public let sourceId: String?
        /// The type of the source.
        public let sourceType: String?
        /// The URI of the source.
        public let sourceUri: String

        public init(sourceId: String? = nil, sourceType: String? = nil, sourceUri: String) {
            self.sourceId = sourceId
            self.sourceType = sourceType
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceId, name: "sourceId", parent: name, max: 256)
            try self.validate(self.sourceType, name: "sourceType", parent: name, max: 256)
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceId = "SourceId"
            case sourceType = "SourceType"
            case sourceUri = "SourceUri"
        }
    }

    public struct ActionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let actionArn: String?
        /// The name of the action.
        public let actionName: String?
        /// The type of the action.
        public let actionType: String?
        /// When the action was created.
        public let creationTime: Date?
        /// When the action was last modified.
        public let lastModifiedTime: Date?
        /// The source of the action.
        public let source: ActionSource?
        /// The status of the action.
        public let status: ActionStatus?

        public init(actionArn: String? = nil, actionName: String? = nil, actionType: String? = nil, creationTime: Date? = nil, lastModifiedTime: Date? = nil, source: ActionSource? = nil, status: ActionStatus? = nil) {
            self.actionArn = actionArn
            self.actionName = actionName
            self.actionType = actionType
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.source = source
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case actionArn = "ActionArn"
            case actionName = "ActionName"
            case actionType = "ActionType"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case source = "Source"
            case status = "Status"
        }
    }

    public struct AddAssociationRequest: AWSEncodableShape {
        /// The type of association. The following are suggested uses for each type. Amazon SageMaker places no restrictions on their use.   ContributedTo - The source contributed to the destination or had a part in enabling the destination. For example, the training data contributed to the training job.   AssociatedWith - The source is connected to the destination. For example, an approval workflow is associated with a model deployment.   DerivedFrom - The destination is a modification of the source. For example, a digest output of a channel input for a processing job is derived from the original inputs.   Produced - The source generated the destination. For example, a training job produced a model artifact.
        public let associationType: AssociationEdgeType?
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String
        /// The ARN of the source.
        public let sourceArn: String

        public init(associationType: AssociationEdgeType? = nil, destinationArn: String, sourceArn: String) {
            self.associationType = associationType
            self.destinationArn = destinationArn
            self.sourceArn = sourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 256)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 256)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "AssociationType"
            case destinationArn = "DestinationArn"
            case sourceArn = "SourceArn"
        }
    }

    public struct AddAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String?
        /// The ARN of the source.
        public let sourceArn: String?

        public init(destinationArn: String? = nil, sourceArn: String? = nil) {
            self.destinationArn = destinationArn
            self.sourceArn = sourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "DestinationArn"
            case sourceArn = "SourceArn"
        }
    }

    public struct AddTagsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z-]*:sagemaker:[a-z0-9-]*:[0-9]{12}:.+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct AddTagsOutput: AWSDecodableShape {
        /// A list of tags associated with the SageMaker resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct AdditionalInferenceSpecificationDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon ECR registry path of the Docker image that contains the inference code.
        public let containers: [ModelPackageContainerDefinition]
        /// A description of the additional Inference specification
        public let description: String?
        /// A unique name to identify the additional inference specification. The name must  be unique within the list of your additional inference specifications for a  particular model package.
        public let name: String
        /// The supported MIME types for the input data.
        public let supportedContentTypes: [String]?
        /// A list of the instance types that are used to generate inferences in real-time.
        public let supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType]?
        /// The supported MIME types for the output data.
        public let supportedResponseMIMETypes: [String]?
        /// A list of the instance types on which a transformation job can be run  or on which an endpoint can be deployed.
        public let supportedTransformInstanceTypes: [TransformInstanceType]?

        public init(containers: [ModelPackageContainerDefinition], description: String? = nil, name: String, supportedContentTypes: [String]? = nil, supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType]? = nil, supportedResponseMIMETypes: [String]? = nil, supportedTransformInstanceTypes: [TransformInstanceType]? = nil) {
            self.containers = containers
            self.description = description
            self.name = name
            self.supportedContentTypes = supportedContentTypes
            self.supportedRealtimeInferenceInstanceTypes = supportedRealtimeInferenceInstanceTypes
            self.supportedResponseMIMETypes = supportedResponseMIMETypes
            self.supportedTransformInstanceTypes = supportedTransformInstanceTypes
        }

        public func validate(name: String) throws {
            try self.containers.forEach {
                try $0.validate(name: "\(name).containers[]")
            }
            try self.validate(self.containers, name: "containers", parent: name, max: 15)
            try self.validate(self.containers, name: "containers", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.supportedContentTypes?.forEach {
                try validate($0, name: "supportedContentTypes[]", parent: name, max: 256)
                try validate($0, name: "supportedContentTypes[]", parent: name, pattern: ".*")
            }
            try self.supportedResponseMIMETypes?.forEach {
                try validate($0, name: "supportedResponseMIMETypes[]", parent: name, max: 1024)
                try validate($0, name: "supportedResponseMIMETypes[]", parent: name, pattern: "^[-\\w]+\\/.+$")
            }
            try self.validate(self.supportedTransformInstanceTypes, name: "supportedTransformInstanceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case description = "Description"
            case name = "Name"
            case supportedContentTypes = "SupportedContentTypes"
            case supportedRealtimeInferenceInstanceTypes = "SupportedRealtimeInferenceInstanceTypes"
            case supportedResponseMIMETypes = "SupportedResponseMIMETypes"
            case supportedTransformInstanceTypes = "SupportedTransformInstanceTypes"
        }
    }

    public struct AgentVersion: AWSDecodableShape {
        /// The number of Edge Manager agents.
        public let agentCount: Int64
        /// Version of the agent.
        public let version: String

        public init(agentCount: Int64, version: String) {
            self.agentCount = agentCount
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case agentCount = "AgentCount"
            case version = "Version"
        }
    }

    public struct Alarm: AWSEncodableShape & AWSDecodableShape {
        /// The name of a CloudWatch alarm in your account.
        public let alarmName: String?

        public init(alarmName: String? = nil) {
            self.alarmName = alarmName
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmName, name: "alarmName", parent: name, max: 255)
            try self.validate(self.alarmName, name: "alarmName", parent: name, min: 1)
            try self.validate(self.alarmName, name: "alarmName", parent: name, pattern: "^(?!\\s*$).+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmName = "AlarmName"
        }
    }

    public struct AlgorithmSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on Amazon Web Services Marketplace.  You must specify either the algorithm name to the AlgorithmName parameter or the image URI of the algorithm container to the TrainingImage parameter. Note that the AlgorithmName parameter is mutually exclusive with the TrainingImage parameter. If you specify a value for the AlgorithmName parameter, you can't specify a value for TrainingImage, and vice versa. If you specify values for both parameters, the training job might break; if you don't specify any value for both parameters, the training job might raise a null error.
        public let algorithmName: String?
        /// The arguments for a container used to run a training job. See How Amazon SageMaker Runs Your Training Image for additional information.
        public let containerArguments: [String]?
        /// The entrypoint script for a Docker container used to run a training job. This script takes precedence over the default train processing instructions. See How Amazon SageMaker Runs Your Training Image for more information.
        public let containerEntrypoint: [String]?
        /// To generate and save time-series metrics during training, set to true. The default is false and time-series metrics aren't generated except in the following cases:   You use one of the SageMaker built-in algorithms   You use one of the following Prebuilt SageMaker Docker Images:   Tensorflow (version >= 1.15)   MXNet (version >= 1.6)   PyTorch (version >= 1.3)     You specify at least one MetricDefinition
        public let enableSageMakerMetricsTimeSeries: Bool?
        /// A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. SageMaker publishes each metric to Amazon CloudWatch.
        public let metricDefinitions: [MetricDefinition]?
        /// The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for SageMaker built-in algorithms, see Docker Registry Paths and Example Code in the Amazon SageMaker developer guide. SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information about using your custom training container, see Using Your Own Algorithms with Amazon SageMaker.  You must specify either the algorithm name to the AlgorithmName parameter or the image URI of the algorithm container to the TrainingImage parameter. For more information, see the note in the AlgorithmName parameter description.
        public let trainingImage: String?
        public let trainingInputMode: TrainingInputMode

        public init(algorithmName: String? = nil, containerArguments: [String]? = nil, containerEntrypoint: [String]? = nil, enableSageMakerMetricsTimeSeries: Bool? = nil, metricDefinitions: [MetricDefinition]? = nil, trainingImage: String? = nil, trainingInputMode: TrainingInputMode) {
            self.algorithmName = algorithmName
            self.containerArguments = containerArguments
            self.containerEntrypoint = containerEntrypoint
            self.enableSageMakerMetricsTimeSeries = enableSageMakerMetricsTimeSeries
            self.metricDefinitions = metricDefinitions
            self.trainingImage = trainingImage
            self.trainingInputMode = trainingInputMode
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 170)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
            try self.containerArguments?.forEach {
                try validate($0, name: "containerArguments[]", parent: name, max: 256)
                try validate($0, name: "containerArguments[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, max: 100)
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, min: 1)
            try self.containerEntrypoint?.forEach {
                try validate($0, name: "containerEntrypoint[]", parent: name, max: 256)
                try validate($0, name: "containerEntrypoint[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, max: 10)
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, min: 1)
            try self.metricDefinitions?.forEach {
                try $0.validate(name: "\(name).metricDefinitions[]")
            }
            try self.validate(self.metricDefinitions, name: "metricDefinitions", parent: name, max: 40)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, max: 255)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case containerArguments = "ContainerArguments"
            case containerEntrypoint = "ContainerEntrypoint"
            case enableSageMakerMetricsTimeSeries = "EnableSageMakerMetricsTimeSeries"
            case metricDefinitions = "MetricDefinitions"
            case trainingImage = "TrainingImage"
            case trainingInputMode = "TrainingInputMode"
        }
    }

    public struct AlgorithmStatusDetails: AWSDecodableShape {
        /// The status of the scan of the algorithm's Docker image container.
        public let imageScanStatuses: [AlgorithmStatusItem]?
        /// The status of algorithm validation.
        public let validationStatuses: [AlgorithmStatusItem]?

        public init(imageScanStatuses: [AlgorithmStatusItem]? = nil, validationStatuses: [AlgorithmStatusItem]? = nil) {
            self.imageScanStatuses = imageScanStatuses
            self.validationStatuses = validationStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanStatuses = "ImageScanStatuses"
            case validationStatuses = "ValidationStatuses"
        }
    }

    public struct AlgorithmStatusItem: AWSDecodableShape {
        /// if the overall status is Failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the algorithm for which the overall status is being reported.
        public let name: String
        /// The current status.
        public let status: DetailedAlgorithmStatus

        public init(failureReason: String? = nil, name: String, status: DetailedAlgorithmStatus) {
            self.failureReason = failureReason
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AlgorithmSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String
        /// A brief description of the algorithm.
        public let algorithmDescription: String?
        /// The name of the algorithm that is described by the summary.
        public let algorithmName: String
        /// The overall status of the algorithm.
        public let algorithmStatus: AlgorithmStatus
        /// A timestamp that shows when the algorithm was created.
        public let creationTime: Date

        public init(algorithmArn: String, algorithmDescription: String? = nil, algorithmName: String, algorithmStatus: AlgorithmStatus, creationTime: Date) {
            self.algorithmArn = algorithmArn
            self.algorithmDescription = algorithmDescription
            self.algorithmName = algorithmName
            self.algorithmStatus = algorithmStatus
            self.creationTime = creationTime
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case algorithmDescription = "AlgorithmDescription"
            case algorithmName = "AlgorithmName"
            case algorithmStatus = "AlgorithmStatus"
            case creationTime = "CreationTime"
        }
    }

    public struct AlgorithmValidationProfile: AWSEncodableShape & AWSDecodableShape {
        /// The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let profileName: String
        /// The TrainingJobDefinition object that describes the training job that SageMaker runs to validate your algorithm.
        public let trainingJobDefinition: TrainingJobDefinition
        /// The TransformJobDefinition object that describes the transform job that SageMaker runs to validate your algorithm.
        public let transformJobDefinition: TransformJobDefinition?

        public init(profileName: String, trainingJobDefinition: TrainingJobDefinition, transformJobDefinition: TransformJobDefinition? = nil) {
            self.profileName = profileName
            self.trainingJobDefinition = trainingJobDefinition
            self.transformJobDefinition = transformJobDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 63)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 1)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.trainingJobDefinition.validate(name: "\(name).trainingJobDefinition")
            try self.transformJobDefinition?.validate(name: "\(name).transformJobDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "ProfileName"
            case trainingJobDefinition = "TrainingJobDefinition"
            case transformJobDefinition = "TransformJobDefinition"
        }
    }

    public struct AlgorithmValidationSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An array of AlgorithmValidationProfile objects, each of which specifies a training job and batch transform job that SageMaker runs to validate your algorithm.
        public let validationProfiles: [AlgorithmValidationProfile]
        /// The IAM roles that SageMaker uses to run the training jobs.
        public let validationRole: String

        public init(validationProfiles: [AlgorithmValidationProfile], validationRole: String) {
            self.validationProfiles = validationProfiles
            self.validationRole = validationRole
        }

        public func validate(name: String) throws {
            try self.validationProfiles.forEach {
                try $0.validate(name: "\(name).validationProfiles[]")
            }
            try self.validate(self.validationProfiles, name: "validationProfiles", parent: name, max: 1)
            try self.validate(self.validationProfiles, name: "validationProfiles", parent: name, min: 1)
            try self.validate(self.validationRole, name: "validationRole", parent: name, max: 2048)
            try self.validate(self.validationRole, name: "validationRole", parent: name, min: 20)
            try self.validate(self.validationRole, name: "validationRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case validationProfiles = "ValidationProfiles"
            case validationRole = "ValidationRole"
        }
    }

    public struct AnnotationConsolidationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a Lambda function implements the logic for annotation consolidation and to process output data. This parameter is required for all labeling jobs. For built-in task types, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for AnnotationConsolidationLambdaArn. For custom labeling workflows, see Post-annotation Lambda.   Bounding box - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.    arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox     arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox     arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox     Image classification - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass     arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass     arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass     Multi-label image classification - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel     arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel     Semantic segmentation - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.    arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation     Text classification - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass     arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass     arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass     Multi-label text classification - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel     arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel     Named entity recognition - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.    arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition     arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition     arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition     arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition     arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition     arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition     arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition     arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition     Video Classification - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.    arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass     arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass     arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass     Video Frame Object Detection - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.    arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection     Video Frame Object Tracking - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians.     arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking     3D Point Cloud Object Detection - Use this task type when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids around objects. For example, you can use this task type to ask workers to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.    arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection     3D Point Cloud Object Tracking - Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames. For example, you can use this task type to ask workers to track the movement of vehicles across multiple point cloud frames.     arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking     3D Point Cloud Semantic Segmentation - Use this task type when you want workers to create a point-level semantic segmentation masks by painting objects in a 3D point cloud using different colors where each color is assigned to one of the classes you specify.    arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation     Use the following ARNs for Label Verification and Adjustment Jobs  Use label verification and adjustment jobs to review and adjust labels. To learn more, see Verify and Adjust Labels .  Semantic Segmentation Adjustment - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.    arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation     Semantic Segmentation Verification - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation     Bounding Box Adjustment - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.    arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox     Bounding Box Verification - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox     arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox     arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox     Video Frame Object Detection Adjustment -  Use this task type when you want workers to adjust bounding boxes that workers have added  to video frames to classify and localize objects in a sequence of video frames.    arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection     Video Frame Object Tracking Adjustment -  Use this task type when you want workers to adjust bounding boxes that workers have added  to video frames to track object movement across a sequence of video frames.    arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking     3D Point Cloud Object Detection Adjustment - Use this task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud.     arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection     3D Point Cloud Object Tracking Adjustment - Use this task type when you want workers to adjust 3D cuboids around objects that appear in a sequence of 3D point cloud frames.    arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking     3D Point Cloud Semantic Segmentation Adjustment - Use this task type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.    arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation     arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation
        public let annotationConsolidationLambdaArn: String

        public init(annotationConsolidationLambdaArn: String) {
            self.annotationConsolidationLambdaArn = annotationConsolidationLambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.annotationConsolidationLambdaArn, name: "annotationConsolidationLambdaArn", parent: name, max: 2048)
            try self.validate(self.annotationConsolidationLambdaArn, name: "annotationConsolidationLambdaArn", parent: name, pattern: "^arn:aws[a-z\\-]*:lambda:[a-z0-9\\-]*:[0-9]{12}:function:")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationConsolidationLambdaArn = "AnnotationConsolidationLambdaArn"
        }
    }

    public struct AppDetails: AWSDecodableShape {
        /// The name of the app.
        public let appName: String?
        /// The type of app.
        public let appType: AppType?
        /// The creation time.
        public let creationTime: Date?
        /// The domain ID.
        public let domainId: String?
        /// The name of the space.
        public let spaceName: String?
        /// The status.
        public let status: AppStatus?
        /// The user profile name.
        public let userProfileName: String?

        public init(appName: String? = nil, appType: AppType? = nil, creationTime: Date? = nil, domainId: String? = nil, spaceName: String? = nil, status: AppStatus? = nil, userProfileName: String? = nil) {
            self.appName = appName
            self.appType = appType
            self.creationTime = creationTime
            self.domainId = domainId
            self.spaceName = spaceName
            self.status = status
            self.userProfileName = userProfileName
        }

        private enum CodingKeys: String, CodingKey {
            case appName = "AppName"
            case appType = "AppType"
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case spaceName = "SpaceName"
            case status = "Status"
            case userProfileName = "UserProfileName"
        }
    }

    public struct AppImageConfigDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppImageConfig.
        public let appImageConfigArn: String?
        /// The name of the AppImageConfig. Must be unique to your account.
        public let appImageConfigName: String?
        /// When the AppImageConfig was created.
        public let creationTime: Date?
        /// The configuration for the file system and kernels in the SageMaker image.
        public let kernelGatewayImageConfig: KernelGatewayImageConfig?
        /// When the AppImageConfig was last modified.
        public let lastModifiedTime: Date?

        public init(appImageConfigArn: String? = nil, appImageConfigName: String? = nil, creationTime: Date? = nil, kernelGatewayImageConfig: KernelGatewayImageConfig? = nil, lastModifiedTime: Date? = nil) {
            self.appImageConfigArn = appImageConfigArn
            self.appImageConfigName = appImageConfigName
            self.creationTime = creationTime
            self.kernelGatewayImageConfig = kernelGatewayImageConfig
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigArn = "AppImageConfigArn"
            case appImageConfigName = "AppImageConfigName"
            case creationTime = "CreationTime"
            case kernelGatewayImageConfig = "KernelGatewayImageConfig"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct AppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The arguments for a container used to run a processing job.
        public let containerArguments: [String]?
        /// The entrypoint for a container used to run a processing job.
        public let containerEntrypoint: [String]?
        /// The container image to be run by the processing job.
        public let imageUri: String

        public init(containerArguments: [String]? = nil, containerEntrypoint: [String]? = nil, imageUri: String) {
            self.containerArguments = containerArguments
            self.containerEntrypoint = containerEntrypoint
            self.imageUri = imageUri
        }

        public func validate(name: String) throws {
            try self.containerArguments?.forEach {
                try validate($0, name: "containerArguments[]", parent: name, max: 256)
                try validate($0, name: "containerArguments[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, max: 100)
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, min: 1)
            try self.containerEntrypoint?.forEach {
                try validate($0, name: "containerEntrypoint[]", parent: name, max: 256)
                try validate($0, name: "containerEntrypoint[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, max: 100)
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, min: 1)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case containerArguments = "ContainerArguments"
            case containerEntrypoint = "ContainerEntrypoint"
            case imageUri = "ImageUri"
        }
    }

    public struct ArtifactSource: AWSEncodableShape & AWSDecodableShape {
        /// A list of source types.
        public let sourceTypes: [ArtifactSourceType]?
        /// The URI of the source.
        public let sourceUri: String

        public init(sourceTypes: [ArtifactSourceType]? = nil, sourceUri: String) {
            self.sourceTypes = sourceTypes
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.sourceTypes?.forEach {
                try $0.validate(name: "\(name).sourceTypes[]")
            }
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTypes = "SourceTypes"
            case sourceUri = "SourceUri"
        }
    }

    public struct ArtifactSourceType: AWSEncodableShape & AWSDecodableShape {
        /// The type of ID.
        public let sourceIdType: ArtifactSourceIdType
        /// The ID.
        public let value: String

        public init(sourceIdType: ArtifactSourceIdType, value: String) {
            self.sourceIdType = sourceIdType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceIdType = "SourceIdType"
            case value = "Value"
        }
    }

    public struct ArtifactSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the artifact.
        public let artifactArn: String?
        /// The name of the artifact.
        public let artifactName: String?
        /// The type of the artifact.
        public let artifactType: String?
        /// When the artifact was created.
        public let creationTime: Date?
        /// When the artifact was last modified.
        public let lastModifiedTime: Date?
        /// The source of the artifact.
        public let source: ArtifactSource?

        public init(artifactArn: String? = nil, artifactName: String? = nil, artifactType: String? = nil, creationTime: Date? = nil, lastModifiedTime: Date? = nil, source: ArtifactSource? = nil) {
            self.artifactArn = artifactArn
            self.artifactName = artifactName
            self.artifactType = artifactType
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
            case artifactName = "ArtifactName"
            case artifactType = "ArtifactType"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case source = "Source"
        }
    }

    public struct AssociateTrialComponentRequest: AWSEncodableShape {
        /// The name of the component to associated with the trial.
        public let trialComponentName: String
        /// The name of the trial to associate with.
        public let trialName: String

        public init(trialComponentName: String, trialName: String) {
            self.trialComponentName = trialComponentName
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentName = "TrialComponentName"
            case trialName = "TrialName"
        }
    }

    public struct AssociateTrialComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?

        public init(trialArn: String? = nil, trialComponentArn: String? = nil) {
            self.trialArn = trialArn
            self.trialComponentArn = trialComponentArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialArn = "TrialArn"
            case trialComponentArn = "TrialComponentArn"
        }
    }

    public struct AssociationSummary: AWSDecodableShape {
        /// The type of the association.
        public let associationType: AssociationEdgeType?
        public let createdBy: UserContext?
        /// When the association was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String?
        /// The name of the destination.
        public let destinationName: String?
        /// The destination type.
        public let destinationType: String?
        /// The ARN of the source.
        public let sourceArn: String?
        /// The name of the source.
        public let sourceName: String?
        /// The source type.
        public let sourceType: String?

        public init(associationType: AssociationEdgeType? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, destinationArn: String? = nil, destinationName: String? = nil, destinationType: String? = nil, sourceArn: String? = nil, sourceName: String? = nil, sourceType: String? = nil) {
            self.associationType = associationType
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.destinationArn = destinationArn
            self.destinationName = destinationName
            self.destinationType = destinationType
            self.sourceArn = sourceArn
            self.sourceName = sourceName
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "AssociationType"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case destinationArn = "DestinationArn"
            case destinationName = "DestinationName"
            case destinationType = "DestinationType"
            case sourceArn = "SourceArn"
            case sourceName = "SourceName"
            case sourceType = "SourceType"
        }
    }

    public struct AsyncInferenceClientConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, SageMaker chooses an optimal value.
        public let maxConcurrentInvocationsPerInstance: Int?

        public init(maxConcurrentInvocationsPerInstance: Int? = nil) {
            self.maxConcurrentInvocationsPerInstance = maxConcurrentInvocationsPerInstance
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConcurrentInvocationsPerInstance, name: "maxConcurrentInvocationsPerInstance", parent: name, max: 1000)
            try self.validate(self.maxConcurrentInvocationsPerInstance, name: "maxConcurrentInvocationsPerInstance", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrentInvocationsPerInstance = "MaxConcurrentInvocationsPerInstance"
        }
    }

    public struct AsyncInferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configures the behavior of the client used by SageMaker to interact with the model container during asynchronous inference.
        public let clientConfig: AsyncInferenceClientConfig?
        /// Specifies the configuration for asynchronous inference invocation outputs.
        public let outputConfig: AsyncInferenceOutputConfig

        public init(clientConfig: AsyncInferenceClientConfig? = nil, outputConfig: AsyncInferenceOutputConfig) {
            self.clientConfig = clientConfig
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.clientConfig?.validate(name: "\(name).clientConfig")
            try self.outputConfig.validate(name: "\(name).outputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientConfig = "ClientConfig"
            case outputConfig = "OutputConfig"
        }
    }

    public struct AsyncInferenceNotificationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.
        public let errorTopic: String?
        /// Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.
        public let successTopic: String?

        public init(errorTopic: String? = nil, successTopic: String? = nil) {
            self.errorTopic = errorTopic
            self.successTopic = successTopic
        }

        public func validate(name: String) throws {
            try self.validate(self.errorTopic, name: "errorTopic", parent: name, max: 2048)
            try self.validate(self.errorTopic, name: "errorTopic", parent: name, pattern: "^arn:aws[a-z\\-]*:sns:[a-z0-9\\-]*:[0-9]{12}:[a-zA-Z0-9_.-]+$")
            try self.validate(self.successTopic, name: "successTopic", parent: name, max: 2048)
            try self.validate(self.successTopic, name: "successTopic", parent: name, pattern: "^arn:aws[a-z\\-]*:sns:[a-z0-9\\-]*:[0-9]{12}:[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case errorTopic = "ErrorTopic"
            case successTopic = "SuccessTopic"
        }
    }

    public struct AsyncInferenceOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the asynchronous inference output in Amazon S3.
        public let kmsKeyId: String?
        /// Specifies the configuration for notifications of inference results for asynchronous inference.
        public let notificationConfig: AsyncInferenceNotificationConfig?
        /// The Amazon S3 location to upload inference responses to.
        public let s3OutputPath: String

        public init(kmsKeyId: String? = nil, notificationConfig: AsyncInferenceNotificationConfig? = nil, s3OutputPath: String) {
            self.kmsKeyId = kmsKeyId
            self.notificationConfig = notificationConfig
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.notificationConfig?.validate(name: "\(name).notificationConfig")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 512)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/])/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case notificationConfig = "NotificationConfig"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct AthenaDatasetDefinition: AWSEncodableShape & AWSDecodableShape {
        public let catalog: String
        public let database: String
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from an Athena query execution.
        public let kmsKeyId: String?
        public let outputCompression: AthenaResultCompressionType?
        public let outputFormat: AthenaResultFormat
        /// The location in Amazon S3 where Athena query results are stored.
        public let outputS3Uri: String
        public let queryString: String
        public let workGroup: String?

        public init(catalog: String, database: String, kmsKeyId: String? = nil, outputCompression: AthenaResultCompressionType? = nil, outputFormat: AthenaResultFormat, outputS3Uri: String, queryString: String, workGroup: String? = nil) {
            self.catalog = catalog
            self.database = database
            self.kmsKeyId = kmsKeyId
            self.outputCompression = outputCompression
            self.outputFormat = outputFormat
            self.outputS3Uri = outputS3Uri
            self.queryString = queryString
            self.workGroup = workGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 256)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.database, name: "database", parent: name, max: 255)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, max: 1024)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.queryString, name: "queryString", parent: name, max: 4096)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
            try self.validate(self.queryString, name: "queryString", parent: name, pattern: "^[\\s\\S]+$")
            try self.validate(self.workGroup, name: "workGroup", parent: name, max: 128)
            try self.validate(self.workGroup, name: "workGroup", parent: name, min: 1)
            try self.validate(self.workGroup, name: "workGroup", parent: name, pattern: "^[a-zA-Z0-9._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case database = "Database"
            case kmsKeyId = "KmsKeyId"
            case outputCompression = "OutputCompression"
            case outputFormat = "OutputFormat"
            case outputS3Uri = "OutputS3Uri"
            case queryString = "QueryString"
            case workGroup = "WorkGroup"
        }
    }

    public struct AutoMLCandidate: AWSDecodableShape {
        /// The name of the candidate.
        public let candidateName: String
        /// The properties of an AutoML candidate job.
        public let candidateProperties: CandidateProperties?
        /// The candidate's status.
        public let candidateStatus: CandidateStatus
        /// Information about the candidate's steps.
        public let candidateSteps: [AutoMLCandidateStep]
        /// The creation time.
        public let creationTime: Date
        /// The end time.
        public let endTime: Date?
        /// The failure reason.
        public let failureReason: String?
        public let finalAutoMLJobObjectiveMetric: FinalAutoMLJobObjectiveMetric?
        /// Information about the inference container definitions.
        public let inferenceContainers: [AutoMLContainerDefinition]?
        /// The last modified time.
        public let lastModifiedTime: Date
        /// The objective's status.
        public let objectiveStatus: ObjectiveStatus

        public init(candidateName: String, candidateProperties: CandidateProperties? = nil, candidateStatus: CandidateStatus, candidateSteps: [AutoMLCandidateStep], creationTime: Date, endTime: Date? = nil, failureReason: String? = nil, finalAutoMLJobObjectiveMetric: FinalAutoMLJobObjectiveMetric? = nil, inferenceContainers: [AutoMLContainerDefinition]? = nil, lastModifiedTime: Date, objectiveStatus: ObjectiveStatus) {
            self.candidateName = candidateName
            self.candidateProperties = candidateProperties
            self.candidateStatus = candidateStatus
            self.candidateSteps = candidateSteps
            self.creationTime = creationTime
            self.endTime = endTime
            self.failureReason = failureReason
            self.finalAutoMLJobObjectiveMetric = finalAutoMLJobObjectiveMetric
            self.inferenceContainers = inferenceContainers
            self.lastModifiedTime = lastModifiedTime
            self.objectiveStatus = objectiveStatus
        }

        private enum CodingKeys: String, CodingKey {
            case candidateName = "CandidateName"
            case candidateProperties = "CandidateProperties"
            case candidateStatus = "CandidateStatus"
            case candidateSteps = "CandidateSteps"
            case creationTime = "CreationTime"
            case endTime = "EndTime"
            case failureReason = "FailureReason"
            case finalAutoMLJobObjectiveMetric = "FinalAutoMLJobObjectiveMetric"
            case inferenceContainers = "InferenceContainers"
            case lastModifiedTime = "LastModifiedTime"
            case objectiveStatus = "ObjectiveStatus"
        }
    }

    public struct AutoMLCandidateGenerationConfig: AWSEncodableShape & AWSDecodableShape {
        /// A URL to the Amazon S3 data source containing selected features from the input data source to run an Autopilot job. You can input FeatureAttributeNames (optional) in JSON format as shown below:   { "FeatureAttributeNames":["col1", "col2", ...] }. You can also specify the data type of the feature (optional) in the format shown below:  { "FeatureDataTypes":{"col1":"numeric", "col2":"categorical" ... } }   These column keys may not include the target column.  In ensembling mode, Autopilot will only support the following data types: numeric, categorical, text and datetime. In HPO mode, Autopilot can support numeric, categorical, text, datetime and sequence. If only FeatureDataTypes is provided, the column keys (col1, col2,..) should be a subset of the column names in the input data.  If both FeatureDataTypes and FeatureAttributeNames are provided, then the column keys should be a subset of the column names provided in FeatureAttributeNames.  The key name FeatureAttributeNames is fixed. The values listed in ["col1", "col2", ...] is case sensitive and should be a list of strings containing unique values that are a subset of the column names in the input data. The list of columns provided must not include the target column.
        public let featureSpecificationS3Uri: String?

        public init(featureSpecificationS3Uri: String? = nil) {
            self.featureSpecificationS3Uri = featureSpecificationS3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.featureSpecificationS3Uri, name: "featureSpecificationS3Uri", parent: name, max: 1024)
            try self.validate(self.featureSpecificationS3Uri, name: "featureSpecificationS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureSpecificationS3Uri = "FeatureSpecificationS3Uri"
        }
    }

    public struct AutoMLCandidateStep: AWSDecodableShape {
        /// The ARN for the candidate's step.
        public let candidateStepArn: String
        /// The name for the candidate's step.
        public let candidateStepName: String
        /// Whether the candidate is at the transform, training, or processing step.
        public let candidateStepType: CandidateStepType

        public init(candidateStepArn: String, candidateStepName: String, candidateStepType: CandidateStepType) {
            self.candidateStepArn = candidateStepArn
            self.candidateStepName = candidateStepName
            self.candidateStepType = candidateStepType
        }

        private enum CodingKeys: String, CodingKey {
            case candidateStepArn = "CandidateStepArn"
            case candidateStepName = "CandidateStepName"
            case candidateStepType = "CandidateStepType"
        }
    }

    public struct AutoMLChannel: AWSEncodableShape & AWSDecodableShape {
        /// The channel type (optional) is an enum string. The default value is training. Channels for training and validation must share the same ContentType and TargetAttributeName. For information on specifying training and validation channel types, see  How to specify training and validation datasets .
        public let channelType: AutoMLChannelType?
        /// You can use Gzip or None. The default value is None.
        public let compressionType: CompressionType?
        /// The content type of the data from the input source. You can use text/csv;header=present or x-application/vnd.amazon+parquet. The default value is text/csv;header=present.
        public let contentType: String?
        /// The data source for an AutoML channel.
        public let dataSource: AutoMLDataSource
        /// The name of the target variable in supervised learning, usually represented by 'y'.
        public let targetAttributeName: String

        public init(channelType: AutoMLChannelType? = nil, compressionType: CompressionType? = nil, contentType: String? = nil, dataSource: AutoMLDataSource, targetAttributeName: String) {
            self.channelType = channelType
            self.compressionType = compressionType
            self.contentType = contentType
            self.dataSource = dataSource
            self.targetAttributeName = targetAttributeName
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.targetAttributeName, name: "targetAttributeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channelType = "ChannelType"
            case compressionType = "CompressionType"
            case contentType = "ContentType"
            case dataSource = "DataSource"
            case targetAttributeName = "TargetAttributeName"
        }
    }

    public struct AutoMLContainerDefinition: AWSDecodableShape {
        /// The environment variables to set in the container. For more information, see .
        public let environment: [String: String]?
        /// The Amazon Elastic Container Registry (Amazon ECR) path of the container. For more information, see .
        public let image: String
        /// The location of the model artifacts. For more information, see .
        public let modelDataUrl: String

        public init(environment: [String: String]? = nil, image: String, modelDataUrl: String) {
            self.environment = environment
            self.image = image
            self.modelDataUrl = modelDataUrl
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "Environment"
            case image = "Image"
            case modelDataUrl = "ModelDataUrl"
        }
    }

    public struct AutoMLDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location of the input data.
        public let s3DataSource: AutoMLS3DataSource

        public init(s3DataSource: AutoMLS3DataSource) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
        }
    }

    public struct AutoMLDataSplitConfig: AWSEncodableShape & AWSDecodableShape {
        /// The validation fraction (optional) is a float that specifies the portion of the training dataset to be used for validation. The default value is 0.2, and values must be greater than 0 and less than 1. We recommend setting this value to be less than 0.5.
        public let validationFraction: Float?

        public init(validationFraction: Float? = nil) {
            self.validationFraction = validationFraction
        }

        public func validate(name: String) throws {
            try self.validate(self.validationFraction, name: "validationFraction", parent: name, max: 1.0)
            try self.validate(self.validationFraction, name: "validationFraction", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case validationFraction = "ValidationFraction"
        }
    }

    public struct AutoMLJobArtifacts: AWSDecodableShape {
        /// The URL of the notebook location.
        public let candidateDefinitionNotebookLocation: String?
        /// The URL of the notebook location.
        public let dataExplorationNotebookLocation: String?

        public init(candidateDefinitionNotebookLocation: String? = nil, dataExplorationNotebookLocation: String? = nil) {
            self.candidateDefinitionNotebookLocation = candidateDefinitionNotebookLocation
            self.dataExplorationNotebookLocation = dataExplorationNotebookLocation
        }

        private enum CodingKeys: String, CodingKey {
            case candidateDefinitionNotebookLocation = "CandidateDefinitionNotebookLocation"
            case dataExplorationNotebookLocation = "DataExplorationNotebookLocation"
        }
    }

    public struct AutoMLJobCompletionCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The maximum runtime, in seconds, an AutoML job has to complete. If an AutoML job exceeds the maximum runtime, the job is stopped automatically and its processing is ended gracefully. The AutoML job identifies the best model whose training was completed and marks it as the best-performing model. Any unfinished steps of the job, such as automatic one-click Autopilot model deployment, will not be completed.
        public let maxAutoMLJobRuntimeInSeconds: Int?
        /// The maximum number of times a training job is allowed to run.
        public let maxCandidates: Int?
        /// The maximum time, in seconds, that each training job executed inside hyperparameter tuning is allowed to run as part of a hyperparameter tuning job. For more information, see the  used by the  action.
        public let maxRuntimePerTrainingJobInSeconds: Int?

        public init(maxAutoMLJobRuntimeInSeconds: Int? = nil, maxCandidates: Int? = nil, maxRuntimePerTrainingJobInSeconds: Int? = nil) {
            self.maxAutoMLJobRuntimeInSeconds = maxAutoMLJobRuntimeInSeconds
            self.maxCandidates = maxCandidates
            self.maxRuntimePerTrainingJobInSeconds = maxRuntimePerTrainingJobInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxAutoMLJobRuntimeInSeconds, name: "maxAutoMLJobRuntimeInSeconds", parent: name, min: 1)
            try self.validate(self.maxCandidates, name: "maxCandidates", parent: name, min: 1)
            try self.validate(self.maxRuntimePerTrainingJobInSeconds, name: "maxRuntimePerTrainingJobInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxAutoMLJobRuntimeInSeconds = "MaxAutoMLJobRuntimeInSeconds"
            case maxCandidates = "MaxCandidates"
            case maxRuntimePerTrainingJobInSeconds = "MaxRuntimePerTrainingJobInSeconds"
        }
    }

    public struct AutoMLJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for generating a candidate for an AutoML job (optional).
        public let candidateGenerationConfig: AutoMLCandidateGenerationConfig?
        /// How long an AutoML job is allowed to run, or how many candidates a job is allowed to generate.
        public let completionCriteria: AutoMLJobCompletionCriteria?
        /// The configuration for splitting the input training dataset. Type: AutoMLDataSplitConfig
        public let dataSplitConfig: AutoMLDataSplitConfig?
        /// The method that Autopilot uses to train the data. You can either specify the mode manually or let Autopilot choose for you based on the dataset size by selecting AUTO. In AUTO mode, Autopilot chooses ENSEMBLING for datasets smaller than 100 MB, and HYPERPARAMETER_TUNING for larger ones. The ENSEMBLING mode uses a multi-stack ensemble model to predict classification and regression tasks directly from your dataset. This machine learning mode combines several base models to produce an optimal predictive model. It then uses a stacking ensemble method to combine predictions from contributing members. A multi-stack ensemble model can provide better performance over a single model by combining the predictive capabilities of multiple models. See Autopilot algorithm support for a list of algorithms supported by ENSEMBLING mode. The HYPERPARAMETER_TUNING (HPO) mode uses the best hyperparameters to train the best version of a model. HPO will automatically select an algorithm for the type of problem you want to solve. Then HPO finds the best hyperparameters according to your objective metric. See Autopilot algorithm support for a list of algorithms supported by HYPERPARAMETER_TUNING mode.
        public let mode: AutoMLMode?
        /// The security configuration for traffic encryption or Amazon VPC settings.
        public let securityConfig: AutoMLSecurityConfig?

        public init(candidateGenerationConfig: AutoMLCandidateGenerationConfig? = nil, completionCriteria: AutoMLJobCompletionCriteria? = nil, dataSplitConfig: AutoMLDataSplitConfig? = nil, mode: AutoMLMode? = nil, securityConfig: AutoMLSecurityConfig? = nil) {
            self.candidateGenerationConfig = candidateGenerationConfig
            self.completionCriteria = completionCriteria
            self.dataSplitConfig = dataSplitConfig
            self.mode = mode
            self.securityConfig = securityConfig
        }

        public func validate(name: String) throws {
            try self.candidateGenerationConfig?.validate(name: "\(name).candidateGenerationConfig")
            try self.completionCriteria?.validate(name: "\(name).completionCriteria")
            try self.dataSplitConfig?.validate(name: "\(name).dataSplitConfig")
            try self.securityConfig?.validate(name: "\(name).securityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case candidateGenerationConfig = "CandidateGenerationConfig"
            case completionCriteria = "CompletionCriteria"
            case dataSplitConfig = "DataSplitConfig"
            case mode = "Mode"
            case securityConfig = "SecurityConfig"
        }
    }

    public struct AutoMLJobObjective: AWSEncodableShape & AWSDecodableShape {
        /// The name of the objective metric used to measure the predictive quality of a machine learning system. This metric is optimized during training to provide the best estimate for model parameter values from data. Here are the options:  Accuracy  The ratio of the number of correctly classified items to the total number of (correctly and incorrectly) classified items. It is used for both binary and multiclass classification. Accuracy measures how close the predicted class values are to the actual values. Values for accuracy metrics vary between zero (0) and one (1). A value of 1 indicates perfect accuracy, and 0 indicates perfect inaccuracy.  AUC  The area under the curve (AUC) metric is used to compare and evaluate binary classification by algorithms that return probabilities, such as logistic regression. To map the probabilities into classifications, these are compared against a threshold value.  The relevant curve is the receiver operating characteristic curve (ROC curve). The ROC curve plots the true positive rate (TPR) of predictions (or recall) against the false positive rate (FPR) as a function of the threshold value, above which a prediction is considered positive. Increasing the threshold results in fewer false positives, but more false negatives.  AUC is the area under this ROC curve. Therefore, AUC provides an aggregated measure of the model performance across all possible classification thresholds. AUC scores vary between 0 and 1. A score of 1 indicates perfect accuracy, and a score of one half (0.5) indicates that the prediction is not better than a random classifier.   BalancedAccuracy   BalancedAccuracy is a metric that measures the ratio of accurate predictions to all predictions. This ratio is calculated after normalizing true positives (TP) and true negatives (TN) by the total number of positive (P) and negative (N) values. It is used in both binary and multiclass classification and is defined as follows: 0.5*((TP/P)+(TN/N)), with values ranging from 0 to 1. BalancedAccuracy gives a better measure of accuracy when the number of positives or negatives differ greatly from each other in an imbalanced dataset. For example, when only 1% of email is spam.   F1  The F1 score is the harmonic mean of the precision and recall, defined as follows: F1 = 2 * (precision * recall) / (precision + recall). It is used for binary classification into classes traditionally referred to as positive and negative. Predictions are said to be true when they match their actual (correct) class, and false when they do not.  Precision is the ratio of the true positive predictions to all positive predictions, and it includes the false positives in a dataset. Precision measures the quality of the prediction when it predicts the positive class.  Recall (or sensitivity) is the ratio of the true positive predictions to all actual positive instances. Recall measures how completely a model predicts the actual class members in a dataset.  F1 scores vary between 0 and 1. A score of 1 indicates the best possible performance, and 0 indicates the worst.  F1macro  The F1macro score applies F1 scoring to multiclass classification problems. It does this by calculating the precision and recall, and then taking their harmonic mean to calculate the F1 score for each class. Lastly, the F1macro averages the individual scores to obtain the F1macro score. F1macro scores vary between 0 and 1. A score of 1 indicates the best possible performance, and 0 indicates the worst.  MAE  The mean absolute error (MAE) is a measure of how different the predicted and actual values are, when they're averaged over all values. MAE is commonly used in regression analysis to understand model prediction error. If there is linear regression, MAE represents the average distance from a predicted line to the actual value. MAE is defined as the sum of absolute errors divided by the number of observations. Values range from 0 to infinity, with smaller numbers indicating a better model fit to the data.  MSE  The mean squared error (MSE) is the average of the squared differences between the predicted and actual values. It is used for regression. MSE values are always positive. The better a model is at predicting the actual values, the smaller the MSE value is  Precision  Precision measures how well an algorithm predicts the true positives (TP) out of all of the positives that it identifies. It is defined as follows: Precision = TP/(TP+FP), with values ranging from zero (0) to one (1), and is used in binary classification. Precision is an important metric when the cost of a false positive is high. For example, the cost of a false positive is very high if an airplane safety system is falsely deemed safe to fly. A false positive (FP) reflects a positive prediction that is actually negative in the data.  PrecisionMacro  The precision macro computes precision for multiclass classification problems. It does this by calculating precision for each class and averaging scores to obtain precision for several classes. PrecisionMacro scores range from zero (0) to one (1). Higher scores reflect the model's ability to predict true positives (TP) out of all of the positives that it identifies, averaged across multiple classes.  R2  R2, also known as the coefficient of determination, is used in regression to quantify how much a model can explain the variance of a dependent variable. Values range from one (1) to negative one (-1). Higher numbers indicate a higher fraction of explained variability. R2 values close to zero (0) indicate that very little of the dependent variable can be explained by the model. Negative values indicate a poor fit and that the model is outperformed by a constant function. For linear regression, this is a horizontal line.  Recall  Recall measures how well an algorithm correctly predicts all of the true positives (TP) in a dataset. A true positive is a positive prediction that is also an actual positive value in the data. Recall is defined as follows: Recall = TP/(TP+FN), with values ranging from 0 to 1. Higher scores reflect a better ability of the model to predict true positives (TP) in the data, and is used in binary classification.  Recall is important when testing for cancer because it's used to find all of the true positives. A false positive (FP) reflects a positive prediction that is actually negative in the data. It is often insufficient to measure only recall, because predicting every output as a true positive will yield a perfect recall score.  RecallMacro  The RecallMacro computes recall for multiclass classification problems by calculating recall for each class and averaging scores to obtain recall for several classes. RecallMacro scores range from 0 to 1. Higher scores reflect the model's ability to predict true positives (TP) in a dataset. Whereas, a true positive reflects a positive prediction that is also an actual positive value in the data. It is often insufficient to measure only recall, because predicting every output as a true positive will yield a perfect recall score.  RMSE  Root mean squared error (RMSE) measures the square root of the squared difference between predicted and actual values, and it's averaged over all values. It is used in regression analysis to understand model prediction error. It's an important metric to indicate the presence of large model errors and outliers. Values range from zero (0) to infinity, with smaller numbers indicating a better model fit to the data. RMSE is dependent on scale, and should not be used to compare datasets of different sizes.   If you do not specify a metric explicitly, the default behavior is to automatically use:    MSE: for regression.    F1: for binary classification    Accuracy: for multiclass classification.
        public let metricName: AutoMLMetricEnum

        public init(metricName: AutoMLMetricEnum) {
            self.metricName = metricName
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
        }
    }

    public struct AutoMLJobStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AutoML job.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct AutoMLJobSummary: AWSDecodableShape {
        /// The ARN of the AutoML job.
        public let autoMLJobArn: String
        /// The name of the AutoML job you are requesting.
        public let autoMLJobName: String
        /// The secondary status of the AutoML job.
        public let autoMLJobSecondaryStatus: AutoMLJobSecondaryStatus
        /// The status of the AutoML job.
        public let autoMLJobStatus: AutoMLJobStatus
        /// When the AutoML job was created.
        public let creationTime: Date
        /// The end time of an AutoML job.
        public let endTime: Date?
        /// The failure reason of an AutoML job.
        public let failureReason: String?
        /// When the AutoML job was last modified.
        public let lastModifiedTime: Date
        /// The list of reasons for partial failures within an AutoML job.
        public let partialFailureReasons: [AutoMLPartialFailureReason]?

        public init(autoMLJobArn: String, autoMLJobName: String, autoMLJobSecondaryStatus: AutoMLJobSecondaryStatus, autoMLJobStatus: AutoMLJobStatus, creationTime: Date, endTime: Date? = nil, failureReason: String? = nil, lastModifiedTime: Date, partialFailureReasons: [AutoMLPartialFailureReason]? = nil) {
            self.autoMLJobArn = autoMLJobArn
            self.autoMLJobName = autoMLJobName
            self.autoMLJobSecondaryStatus = autoMLJobSecondaryStatus
            self.autoMLJobStatus = autoMLJobStatus
            self.creationTime = creationTime
            self.endTime = endTime
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.partialFailureReasons = partialFailureReasons
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobArn = "AutoMLJobArn"
            case autoMLJobName = "AutoMLJobName"
            case autoMLJobSecondaryStatus = "AutoMLJobSecondaryStatus"
            case autoMLJobStatus = "AutoMLJobStatus"
            case creationTime = "CreationTime"
            case endTime = "EndTime"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case partialFailureReasons = "PartialFailureReasons"
        }
    }

    public struct AutoMLOutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Key Management Service (KMS) encryption key ID.
        public let kmsKeyId: String?
        /// The Amazon S3 output path. Must be 128 characters or less.
        public let s3OutputPath: String

        public init(kmsKeyId: String? = nil, s3OutputPath: String) {
            self.kmsKeyId = kmsKeyId
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct AutoMLPartialFailureReason: AWSDecodableShape {
        /// The message containing the reason for a partial failure of an AutoML job.
        public let partialFailureMessage: String?

        public init(partialFailureMessage: String? = nil) {
            self.partialFailureMessage = partialFailureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case partialFailureMessage = "PartialFailureMessage"
        }
    }

    public struct AutoMLS3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The data type. A ManifestFile should have the format shown below:  [ {"prefix": "s3://DOC-EXAMPLE-BUCKET/DOC-EXAMPLE-FOLDER/DOC-EXAMPLE-PREFIX/"},    "DOC-EXAMPLE-RELATIVE-PATH/DOC-EXAMPLE-FOLDER/DATA-1",   "DOC-EXAMPLE-RELATIVE-PATH/DOC-EXAMPLE-FOLDER/DATA-2",   ... "DOC-EXAMPLE-RELATIVE-PATH/DOC-EXAMPLE-FOLDER/DATA-N" ]  An S3Prefix should have the following format:   s3://DOC-EXAMPLE-BUCKET/DOC-EXAMPLE-FOLDER-OR-FILE
        public let s3DataType: AutoMLS3DataType
        /// The URL to the Amazon S3 data source.
        public let s3Uri: String

        public init(s3DataType: AutoMLS3DataType, s3Uri: String) {
            self.s3DataType = s3DataType
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataType = "S3DataType"
            case s3Uri = "S3Uri"
        }
    }

    public struct AutoMLSecurityConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether to use traffic encryption between the container layers.
        public let enableInterContainerTrafficEncryption: Bool?
        /// The key used to encrypt stored data.
        public let volumeKmsKeyId: String?
        /// The VPC configuration.
        public let vpcConfig: VpcConfig?

        public init(enableInterContainerTrafficEncryption: Bool? = nil, volumeKmsKeyId: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.volumeKmsKeyId = volumeKmsKeyId
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AutoRollbackConfig: AWSEncodableShape & AWSDecodableShape {
        /// List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment.
        public let alarms: [Alarm]?

        public init(alarms: [Alarm]? = nil) {
            self.alarms = alarms
        }

        public func validate(name: String) throws {
            try self.alarms?.forEach {
                try $0.validate(name: "\(name).alarms[]")
            }
            try self.validate(self.alarms, name: "alarms", parent: name, max: 10)
            try self.validate(self.alarms, name: "alarms", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "Alarms"
        }
    }

    public struct BatchDataCaptureConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location being used to capture the data.
        public let destinationS3Uri: String
        /// Flag that indicates whether to append inference id to the output.
        public let generateInferenceId: Bool?
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the batch transform job. The KmsKeyId can be any of the following formats:    Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias
        public let kmsKeyId: String?

        public init(destinationS3Uri: String, generateInferenceId: Bool? = nil, kmsKeyId: String? = nil) {
            self.destinationS3Uri = destinationS3Uri
            self.generateInferenceId = generateInferenceId
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, max: 1024)
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationS3Uri = "DestinationS3Uri"
            case generateInferenceId = "GenerateInferenceId"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct BatchDescribeModelPackageError: AWSDecodableShape {
        public let errorCode: String
        public let errorResponse: String

        public init(errorCode: String, errorResponse: String) {
            self.errorCode = errorCode
            self.errorResponse = errorResponse
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorResponse = "ErrorResponse"
        }
    }

    public struct BatchDescribeModelPackageInput: AWSEncodableShape {
        /// The list of Amazon Resource Name (ARN) of the model package groups.
        public let modelPackageArnList: [String]

        public init(modelPackageArnList: [String]) {
            self.modelPackageArnList = modelPackageArnList
        }

        public func validate(name: String) throws {
            try self.modelPackageArnList.forEach {
                try validate($0, name: "modelPackageArnList[]", parent: name, max: 2048)
                try validate($0, name: "modelPackageArnList[]", parent: name, min: 1)
                try validate($0, name: "modelPackageArnList[]", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:model-package/")
            }
            try self.validate(self.modelPackageArnList, name: "modelPackageArnList", parent: name, max: 100)
            try self.validate(self.modelPackageArnList, name: "modelPackageArnList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageArnList = "ModelPackageArnList"
        }
    }

    public struct BatchDescribeModelPackageOutput: AWSDecodableShape {
        /// A map of the resource and BatchDescribeModelPackageError objects  reporting the error associated with describing the model package.
        public let batchDescribeModelPackageErrorMap: [String: BatchDescribeModelPackageError]?
        /// The summaries for the model package versions
        public let modelPackageSummaries: [String: BatchDescribeModelPackageSummary]?

        public init(batchDescribeModelPackageErrorMap: [String: BatchDescribeModelPackageError]? = nil, modelPackageSummaries: [String: BatchDescribeModelPackageSummary]? = nil) {
            self.batchDescribeModelPackageErrorMap = batchDescribeModelPackageErrorMap
            self.modelPackageSummaries = modelPackageSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case batchDescribeModelPackageErrorMap = "BatchDescribeModelPackageErrorMap"
            case modelPackageSummaries = "ModelPackageSummaries"
        }
    }

    public struct BatchDescribeModelPackageSummary: AWSDecodableShape {
        /// The creation time of the mortgage package summary.
        public let creationTime: Date
        public let inferenceSpecification: InferenceSpecification
        /// The approval status of the model.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String
        /// The description of the model package.
        public let modelPackageDescription: String?
        /// The group name for the model package
        public let modelPackageGroupName: String
        /// The status of the mortgage package.
        public let modelPackageStatus: ModelPackageStatus
        /// The version number of a versioned model.
        public let modelPackageVersion: Int?

        public init(creationTime: Date, inferenceSpecification: InferenceSpecification, modelApprovalStatus: ModelApprovalStatus? = nil, modelPackageArn: String, modelPackageDescription: String? = nil, modelPackageGroupName: String, modelPackageStatus: ModelPackageStatus, modelPackageVersion: Int? = nil) {
            self.creationTime = creationTime
            self.inferenceSpecification = inferenceSpecification
            self.modelApprovalStatus = modelApprovalStatus
            self.modelPackageArn = modelPackageArn
            self.modelPackageDescription = modelPackageDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageVersion = modelPackageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case inferenceSpecification = "InferenceSpecification"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelPackageArn = "ModelPackageArn"
            case modelPackageDescription = "ModelPackageDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageVersion = "ModelPackageVersion"
        }
    }

    public struct BatchTransformInput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location being used to capture the data.
        public let dataCapturedDestinationS3Uri: String
        /// The dataset format for your batch transform job.
        public let datasetFormat: MonitoringDatasetFormat
        /// If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see Schedule Model Quality Monitoring Jobs.
        public let endTimeOffset: String?
        /// The attributes of the input data that are the input features.
        public let featuresAttribute: String?
        /// The attribute of the input data that represents the ground truth label.
        public let inferenceAttribute: String?
        /// Path to the filesystem where the batch transform data is available to the container.
        public let localPath: String
        /// In a classification problem, the attribute that represents the class probability.
        public let probabilityAttribute: String?
        /// The threshold for the class probability to be evaluated as a positive result.
        public let probabilityThresholdAttribute: Double?
        /// Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to FullyReplicated
        public let s3DataDistributionType: ProcessingS3DataDistributionType?
        /// Whether the Pipe or File is used as the input mode for transferring data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        public let s3InputMode: ProcessingS3InputMode?
        /// If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see Schedule Model Quality Monitoring Jobs.
        public let startTimeOffset: String?

        public init(dataCapturedDestinationS3Uri: String, datasetFormat: MonitoringDatasetFormat, endTimeOffset: String? = nil, featuresAttribute: String? = nil, inferenceAttribute: String? = nil, localPath: String, probabilityAttribute: String? = nil, probabilityThresholdAttribute: Double? = nil, s3DataDistributionType: ProcessingS3DataDistributionType? = nil, s3InputMode: ProcessingS3InputMode? = nil, startTimeOffset: String? = nil) {
            self.dataCapturedDestinationS3Uri = dataCapturedDestinationS3Uri
            self.datasetFormat = datasetFormat
            self.endTimeOffset = endTimeOffset
            self.featuresAttribute = featuresAttribute
            self.inferenceAttribute = inferenceAttribute
            self.localPath = localPath
            self.probabilityAttribute = probabilityAttribute
            self.probabilityThresholdAttribute = probabilityThresholdAttribute
            self.s3DataDistributionType = s3DataDistributionType
            self.s3InputMode = s3InputMode
            self.startTimeOffset = startTimeOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.dataCapturedDestinationS3Uri, name: "dataCapturedDestinationS3Uri", parent: name, max: 512)
            try self.validate(self.dataCapturedDestinationS3Uri, name: "dataCapturedDestinationS3Uri", parent: name, pattern: "^(https|s3)://([^/])/?(.*)$")
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, max: 15)
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, min: 1)
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, pattern: "^.?P")
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, max: 15)
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, min: 1)
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, pattern: "^.?P")
        }

        private enum CodingKeys: String, CodingKey {
            case dataCapturedDestinationS3Uri = "DataCapturedDestinationS3Uri"
            case datasetFormat = "DatasetFormat"
            case endTimeOffset = "EndTimeOffset"
            case featuresAttribute = "FeaturesAttribute"
            case inferenceAttribute = "InferenceAttribute"
            case localPath = "LocalPath"
            case probabilityAttribute = "ProbabilityAttribute"
            case probabilityThresholdAttribute = "ProbabilityThresholdAttribute"
            case s3DataDistributionType = "S3DataDistributionType"
            case s3InputMode = "S3InputMode"
            case startTimeOffset = "StartTimeOffset"
        }
    }

    public struct Bias: AWSEncodableShape & AWSDecodableShape {
        /// The post-training bias report for a model.
        public let postTrainingReport: MetricsSource?
        /// The pre-training bias report for a model.
        public let preTrainingReport: MetricsSource?
        /// The bias report for a model
        public let report: MetricsSource?

        public init(postTrainingReport: MetricsSource? = nil, preTrainingReport: MetricsSource? = nil, report: MetricsSource? = nil) {
            self.postTrainingReport = postTrainingReport
            self.preTrainingReport = preTrainingReport
            self.report = report
        }

        public func validate(name: String) throws {
            try self.postTrainingReport?.validate(name: "\(name).postTrainingReport")
            try self.preTrainingReport?.validate(name: "\(name).preTrainingReport")
            try self.report?.validate(name: "\(name).report")
        }

        private enum CodingKeys: String, CodingKey {
            case postTrainingReport = "PostTrainingReport"
            case preTrainingReport = "PreTrainingReport"
            case report = "Report"
        }
    }

    public struct BlueGreenUpdatePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in TerminationWaitInSeconds and WaitIntervalInSeconds.
        public let maximumExecutionTimeoutInSeconds: Int?
        /// Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is 0.
        public let terminationWaitInSeconds: Int?
        /// Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment.
        public let trafficRoutingConfiguration: TrafficRoutingConfig

        public init(maximumExecutionTimeoutInSeconds: Int? = nil, terminationWaitInSeconds: Int? = nil, trafficRoutingConfiguration: TrafficRoutingConfig) {
            self.maximumExecutionTimeoutInSeconds = maximumExecutionTimeoutInSeconds
            self.terminationWaitInSeconds = terminationWaitInSeconds
            self.trafficRoutingConfiguration = trafficRoutingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumExecutionTimeoutInSeconds, name: "maximumExecutionTimeoutInSeconds", parent: name, max: 14400)
            try self.validate(self.maximumExecutionTimeoutInSeconds, name: "maximumExecutionTimeoutInSeconds", parent: name, min: 600)
            try self.validate(self.terminationWaitInSeconds, name: "terminationWaitInSeconds", parent: name, max: 3600)
            try self.validate(self.terminationWaitInSeconds, name: "terminationWaitInSeconds", parent: name, min: 0)
            try self.trafficRoutingConfiguration.validate(name: "\(name).trafficRoutingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case maximumExecutionTimeoutInSeconds = "MaximumExecutionTimeoutInSeconds"
            case terminationWaitInSeconds = "TerminationWaitInSeconds"
            case trafficRoutingConfiguration = "TrafficRoutingConfiguration"
        }
    }

    public struct CacheHitResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let sourcePipelineExecutionArn: String?

        public init(sourcePipelineExecutionArn: String? = nil) {
            self.sourcePipelineExecutionArn = sourcePipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePipelineExecutionArn = "SourcePipelineExecutionArn"
        }
    }

    public struct CallbackStepMetadata: AWSDecodableShape {
        /// The pipeline generated token from the Amazon SQS queue.
        public let callbackToken: String?
        /// A list of the output parameters of the callback step.
        public let outputParameters: [OutputParameter]?
        /// The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.
        public let sqsQueueUrl: String?

        public init(callbackToken: String? = nil, outputParameters: [OutputParameter]? = nil, sqsQueueUrl: String? = nil) {
            self.callbackToken = callbackToken
            self.outputParameters = outputParameters
            self.sqsQueueUrl = sqsQueueUrl
        }

        private enum CodingKeys: String, CodingKey {
            case callbackToken = "CallbackToken"
            case outputParameters = "OutputParameters"
            case sqsQueueUrl = "SqsQueueUrl"
        }
    }

    public struct CandidateArtifactLocations: AWSDecodableShape {
        /// The Amazon S3 prefix to the explainability artifacts generated for the AutoML candidate.
        public let explainability: String
        /// The Amazon S3 prefix to the model insight artifacts generated for the AutoML candidate.
        public let modelInsights: String?

        public init(explainability: String, modelInsights: String? = nil) {
            self.explainability = explainability
            self.modelInsights = modelInsights
        }

        private enum CodingKeys: String, CodingKey {
            case explainability = "Explainability"
            case modelInsights = "ModelInsights"
        }
    }

    public struct CandidateProperties: AWSDecodableShape {
        /// The Amazon S3 prefix to the artifacts generated for an AutoML candidate.
        public let candidateArtifactLocations: CandidateArtifactLocations?
        /// Information about the candidate metrics for an AutoML job.
        public let candidateMetrics: [MetricDatum]?

        public init(candidateArtifactLocations: CandidateArtifactLocations? = nil, candidateMetrics: [MetricDatum]? = nil) {
            self.candidateArtifactLocations = candidateArtifactLocations
            self.candidateMetrics = candidateMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case candidateArtifactLocations = "CandidateArtifactLocations"
            case candidateMetrics = "CandidateMetrics"
        }
    }

    public struct CanvasAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// Time series forecast settings for the Canvas app.
        public let timeSeriesForecastingSettings: TimeSeriesForecastingSettings?

        public init(timeSeriesForecastingSettings: TimeSeriesForecastingSettings? = nil) {
            self.timeSeriesForecastingSettings = timeSeriesForecastingSettings
        }

        public func validate(name: String) throws {
            try self.timeSeriesForecastingSettings?.validate(name: "\(name).timeSeriesForecastingSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case timeSeriesForecastingSettings = "TimeSeriesForecastingSettings"
        }
    }

    public struct CapacitySize: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the endpoint capacity type.    INSTANCE_COUNT: The endpoint activates based on the number of instances.    CAPACITY_PERCENT: The endpoint activates based on the specified percentage of capacity.
        public let type: CapacitySizeType
        /// Defines the capacity size, either as a number of instances or a capacity percentage.
        public let value: Int

        public init(type: CapacitySizeType, value: Int) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct CaptureContentTypeHeader: AWSEncodableShape & AWSDecodableShape {
        /// The list of all content type headers that SageMaker will treat as CSV and capture accordingly.
        public let csvContentTypes: [String]?
        /// The list of all content type headers that SageMaker will treat as JSON and capture accordingly.
        public let jsonContentTypes: [String]?

        public init(csvContentTypes: [String]? = nil, jsonContentTypes: [String]? = nil) {
            self.csvContentTypes = csvContentTypes
            self.jsonContentTypes = jsonContentTypes
        }

        public func validate(name: String) throws {
            try self.csvContentTypes?.forEach {
                try validate($0, name: "csvContentTypes[]", parent: name, max: 256)
                try validate($0, name: "csvContentTypes[]", parent: name, min: 1)
                try validate($0, name: "csvContentTypes[]", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*\\/[a-zA-Z0-9](-*[a-zA-Z0-9.])*$")
            }
            try self.validate(self.csvContentTypes, name: "csvContentTypes", parent: name, max: 10)
            try self.validate(self.csvContentTypes, name: "csvContentTypes", parent: name, min: 1)
            try self.jsonContentTypes?.forEach {
                try validate($0, name: "jsonContentTypes[]", parent: name, max: 256)
                try validate($0, name: "jsonContentTypes[]", parent: name, min: 1)
                try validate($0, name: "jsonContentTypes[]", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*\\/[a-zA-Z0-9](-*[a-zA-Z0-9.])*$")
            }
            try self.validate(self.jsonContentTypes, name: "jsonContentTypes", parent: name, max: 10)
            try self.validate(self.jsonContentTypes, name: "jsonContentTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case csvContentTypes = "CsvContentTypes"
            case jsonContentTypes = "JsonContentTypes"
        }
    }

    public struct CaptureOption: AWSEncodableShape & AWSDecodableShape {
        /// Specify the boundary of data to capture.
        public let captureMode: CaptureMode

        public init(captureMode: CaptureMode) {
            self.captureMode = captureMode
        }

        private enum CodingKeys: String, CodingKey {
            case captureMode = "CaptureMode"
        }
    }

    public struct CategoricalParameter: AWSEncodableShape & AWSDecodableShape {
        /// The Name of the environment variable.
        public let name: String
        /// The list of values you can pass.
        public let value: [String]

        public init(name: String, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, max: 128)
            }
            try self.validate(self.value, name: "value", parent: name, max: 3)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct CategoricalParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The name of the categorical hyperparameter to tune.
        public let name: String
        /// A list of the categories for the hyperparameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, pattern: ".*")
            }
            try self.validate(self.values, name: "values", parent: name, max: 30)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct CategoricalParameterRangeSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The allowed categories for the hyperparameter.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, pattern: ".*")
            }
            try self.validate(self.values, name: "values", parent: name, max: 30)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct Channel: AWSEncodableShape & AWSDecodableShape {
        /// The name of the channel.
        public let channelName: String
        /// If training data is compressed, the compression type. The default value is None. CompressionType is used only in Pipe input mode. In File mode, leave this field unset or set it to None.
        public let compressionType: CompressionType?
        /// The MIME type of the data.
        public let contentType: String?
        /// The location of the channel data.
        public let dataSource: DataSource
        /// (Optional) The input mode to use for the data channel in a training job. If you don't set a value for InputMode, SageMaker uses the value set for TrainingInputMode. Use this parameter to override the TrainingInputMode setting in a AlgorithmSpecification request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use File input mode. To stream data directly from Amazon S3 to the container, choose Pipe input mode. To use a model for incremental training, choose File input model.
        public let inputMode: TrainingInputMode?
        ///  Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see Create a Dataset Using RecordIO.  In File mode, leave this field unset or set it to None.
        public let recordWrapperType: RecordWrapper?
        /// A configuration for a shuffle option for input data in a channel. If you use S3Prefix for S3DataType, this shuffles the results of the S3 key prefix matches. If you use ManifestFile, the order of the S3 object references in the ManifestFile is shuffled. If you use AugmentedManifestFile, the order of the JSON lines in the AugmentedManifestFile is shuffled. The shuffling order is determined using the Seed value. For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with S3DataDistributionType of ShardedByS3Key, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.
        public let shuffleConfig: ShuffleConfig?

        public init(channelName: String, compressionType: CompressionType? = nil, contentType: String? = nil, dataSource: DataSource, inputMode: TrainingInputMode? = nil, recordWrapperType: RecordWrapper? = nil, shuffleConfig: ShuffleConfig? = nil) {
            self.channelName = channelName
            self.compressionType = compressionType
            self.contentType = contentType
            self.dataSource = dataSource
            self.inputMode = inputMode
            self.recordWrapperType = recordWrapperType
            self.shuffleConfig = shuffleConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.channelName, name: "channelName", parent: name, max: 64)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[A-Za-z0-9\\.\\-_]+$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "ChannelName"
            case compressionType = "CompressionType"
            case contentType = "ContentType"
            case dataSource = "DataSource"
            case inputMode = "InputMode"
            case recordWrapperType = "RecordWrapperType"
            case shuffleConfig = "ShuffleConfig"
        }
    }

    public struct ChannelSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A brief description of the channel.
        public let description: String?
        /// Indicates whether the channel is required by the algorithm.
        public let isRequired: Bool?
        /// The name of the channel.
        public let name: String
        /// The allowed compression types, if data compression is used.
        public let supportedCompressionTypes: [CompressionType]?
        /// The supported MIME types for the data.
        public let supportedContentTypes: [String]
        /// The allowed input mode, either FILE or PIPE. In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.
        public let supportedInputModes: [TrainingInputMode]

        public init(description: String? = nil, isRequired: Bool? = nil, name: String, supportedCompressionTypes: [CompressionType]? = nil, supportedContentTypes: [String], supportedInputModes: [TrainingInputMode]) {
            self.description = description
            self.isRequired = isRequired
            self.name = name
            self.supportedCompressionTypes = supportedCompressionTypes
            self.supportedContentTypes = supportedContentTypes
            self.supportedInputModes = supportedInputModes
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9\\.\\-_]+$")
            try self.supportedContentTypes.forEach {
                try validate($0, name: "supportedContentTypes[]", parent: name, max: 256)
                try validate($0, name: "supportedContentTypes[]", parent: name, pattern: ".*")
            }
            try self.validate(self.supportedInputModes, name: "supportedInputModes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case isRequired = "IsRequired"
            case name = "Name"
            case supportedCompressionTypes = "SupportedCompressionTypes"
            case supportedContentTypes = "SupportedContentTypes"
            case supportedInputModes = "SupportedInputModes"
        }
    }

    public struct CheckpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// (Optional) The local directory where checkpoints are written. The default directory is /opt/ml/checkpoints/.
        public let localPath: String?
        /// Identifies the S3 path where you want SageMaker to store checkpoints. For example, s3://bucket-name/key-name-prefix.
        public let s3Uri: String

        public init(localPath: String? = nil, s3Uri: String) {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "LocalPath"
            case s3Uri = "S3Uri"
        }
    }

    public struct ClarifyCheckStepMetadata: AWSDecodableShape {
        /// The Amazon S3 URI of baseline constraints file to be used for the drift check.
        public let baselineUsedForDriftCheckConstraints: String?
        /// The Amazon S3 URI of the newly calculated baseline constraints file.
        public let calculatedBaselineConstraints: String?
        /// The Amazon Resource Name (ARN) of the check processing job that was run by this step's execution.
        public let checkJobArn: String?
        /// The type of the Clarify Check step
        public let checkType: String?
        /// The model package group name.
        public let modelPackageGroupName: String?
        /// This flag indicates if a newly calculated baseline can be accessed through step properties  BaselineUsedForDriftCheckConstraints and BaselineUsedForDriftCheckStatistics.  If it is set to False, the previous baseline of the configured check type must also be available.  These can be accessed through the BaselineUsedForDriftCheckConstraints property.
        public let registerNewBaseline: Bool?
        /// This flag indicates if the drift check against the previous baseline will be skipped or not.  If it is set to False, the previous baseline of the configured check type must be available.
        public let skipCheck: Bool?
        /// The Amazon S3 URI of the violation report if violations are detected.
        public let violationReport: String?

        public init(baselineUsedForDriftCheckConstraints: String? = nil, calculatedBaselineConstraints: String? = nil, checkJobArn: String? = nil, checkType: String? = nil, modelPackageGroupName: String? = nil, registerNewBaseline: Bool? = nil, skipCheck: Bool? = nil, violationReport: String? = nil) {
            self.baselineUsedForDriftCheckConstraints = baselineUsedForDriftCheckConstraints
            self.calculatedBaselineConstraints = calculatedBaselineConstraints
            self.checkJobArn = checkJobArn
            self.checkType = checkType
            self.modelPackageGroupName = modelPackageGroupName
            self.registerNewBaseline = registerNewBaseline
            self.skipCheck = skipCheck
            self.violationReport = violationReport
        }

        private enum CodingKeys: String, CodingKey {
            case baselineUsedForDriftCheckConstraints = "BaselineUsedForDriftCheckConstraints"
            case calculatedBaselineConstraints = "CalculatedBaselineConstraints"
            case checkJobArn = "CheckJobArn"
            case checkType = "CheckType"
            case modelPackageGroupName = "ModelPackageGroupName"
            case registerNewBaseline = "RegisterNewBaseline"
            case skipCheck = "SkipCheck"
            case violationReport = "ViolationReport"
        }
    }

    public struct ClarifyExplainerConfig: AWSEncodableShape & AWSDecodableShape {
        /// A JMESPath boolean expression used to filter which records to explain. Explanations are activated by default. See  EnableExplanations for additional information.
        public let enableExplanations: String?
        /// The inference configuration parameter for the model container.
        public let inferenceConfig: ClarifyInferenceConfig?
        /// The configuration for SHAP analysis.
        public let shapConfig: ClarifyShapConfig

        public init(enableExplanations: String? = nil, inferenceConfig: ClarifyInferenceConfig? = nil, shapConfig: ClarifyShapConfig) {
            self.enableExplanations = enableExplanations
            self.inferenceConfig = inferenceConfig
            self.shapConfig = shapConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.enableExplanations, name: "enableExplanations", parent: name, max: 64)
            try self.validate(self.enableExplanations, name: "enableExplanations", parent: name, min: 1)
            try self.validate(self.enableExplanations, name: "enableExplanations", parent: name, pattern: ".*")
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.shapConfig.validate(name: "\(name).shapConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableExplanations = "EnableExplanations"
            case inferenceConfig = "InferenceConfig"
            case shapConfig = "ShapConfig"
        }
    }

    public struct ClarifyInferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// A template string used to format a JSON record into an acceptable model container input. For example, a ContentTemplate string '{"myfeatures":$features}' will format a list of features [1,2,3] into the record string '{"myfeatures":[1,2,3]}'. Required only when the model container input is in JSON Lines format.
        public let contentTemplate: String?
        /// The names of the features. If provided, these are included in the endpoint response payload to help readability of the InvokeEndpoint output. See the Response section under Invoke the endpoint in the Developer Guide for more information.
        public let featureHeaders: [String]?
        /// Provides the JMESPath expression to extract the features from a model container input in JSON Lines format. For example, if FeaturesAttribute is the JMESPath expression 'myfeatures', it extracts a list of features [1,2,3] from request data '{"myfeatures":[1,2,3]}'.
        public let featuresAttribute: String?
        /// A list of data types of the features (optional). Applicable only to NLP explainability. If provided, FeatureTypes must have at least one 'text' string (for example, ['text']). If FeatureTypes is not provided, the explainer infers the feature types based on the baseline data. The feature types are included in the endpoint response payload. For additional information see the response section under Invoke the endpoint in the Developer Guide for more information.
        public let featureTypes: [ClarifyFeatureType]?
        /// A JMESPath expression used to locate the list of label headers in the model container output.  Example: If the model container output of a batch request is '{"labels":["cat","dog","fish"],"probability":[0.6,0.3,0.1]}', then set LabelAttribute to 'labels' to extract the list of label headers ["cat","dog","fish"]
        public let labelAttribute: String?
        /// For multiclass classification problems, the label headers are the names of the classes. Otherwise, the label header is the name of the predicted label. These are used to help readability for the output of the InvokeEndpoint API. See the response section under Invoke the endpoint in the Developer Guide for more information. If there are no label headers in the model container output, provide them manually using this parameter.
        public let labelHeaders: [String]?
        /// A zero-based index used to extract a label header or list of label headers from model container output in CSV format.  Example for a multiclass model: If the model container output consists of label headers followed by probabilities: '"[\'cat\',\'dog\',\'fish\']","[0.1,0.6,0.3]"', set LabelIndex to 0 to select the label headers ['cat','dog','fish'].
        public let labelIndex: Int?
        /// The maximum payload size (MB) allowed of a request from the explainer to the model container. Defaults to 6 MB.
        public let maxPayloadInMB: Int?
        /// The maximum number of records in a request that the model container can process when querying the model container for the predictions of a synthetic dataset. A record is a unit of input data that inference can be made on, for example, a single line in CSV data. If MaxRecordCount is 1, the model container expects one record per request. A value of 2 or greater means that the model expects batch requests, which can reduce overhead and speed up the inferencing process. If this parameter is not provided, the explainer will tune the record count per request according to the model container's capacity at runtime.
        public let maxRecordCount: Int?
        /// A JMESPath expression used to extract the probability (or score) from the model container output if the model container is in JSON Lines format.  Example: If the model container output of a single request is '{"predicted_label":1,"probability":0.6}', then set ProbabilityAttribute to 'probability'.
        public let probabilityAttribute: String?
        /// A zero-based index used to extract a probability value (score) or list from model container output in CSV format. If this value is not provided, the entire model container output will be treated as a probability value (score) or list.  Example for a single class model: If the model container output consists of a string-formatted prediction label followed by its probability: '1,0.6', set ProbabilityIndex to 1 to select the probability value 0.6.  Example for a multiclass model: If the model container output consists of a string-formatted prediction label followed by its probability: '"[\'cat\',\'dog\',\'fish\']","[0.1,0.6,0.3]"', set ProbabilityIndex to 1 to select the probability values [0.1,0.6,0.3].
        public let probabilityIndex: Int?

        public init(contentTemplate: String? = nil, featureHeaders: [String]? = nil, featuresAttribute: String? = nil, featureTypes: [ClarifyFeatureType]? = nil, labelAttribute: String? = nil, labelHeaders: [String]? = nil, labelIndex: Int? = nil, maxPayloadInMB: Int? = nil, maxRecordCount: Int? = nil, probabilityAttribute: String? = nil, probabilityIndex: Int? = nil) {
            self.contentTemplate = contentTemplate
            self.featureHeaders = featureHeaders
            self.featuresAttribute = featuresAttribute
            self.featureTypes = featureTypes
            self.labelAttribute = labelAttribute
            self.labelHeaders = labelHeaders
            self.labelIndex = labelIndex
            self.maxPayloadInMB = maxPayloadInMB
            self.maxRecordCount = maxRecordCount
            self.probabilityAttribute = probabilityAttribute
            self.probabilityIndex = probabilityIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.contentTemplate, name: "contentTemplate", parent: name, max: 64)
            try self.validate(self.contentTemplate, name: "contentTemplate", parent: name, min: 1)
            try self.validate(self.contentTemplate, name: "contentTemplate", parent: name, pattern: ".*")
            try self.featureHeaders?.forEach {
                try validate($0, name: "featureHeaders[]", parent: name, max: 64)
                try validate($0, name: "featureHeaders[]", parent: name, min: 1)
                try validate($0, name: "featureHeaders[]", parent: name, pattern: ".*")
            }
            try self.validate(self.featureHeaders, name: "featureHeaders", parent: name, max: 256)
            try self.validate(self.featureHeaders, name: "featureHeaders", parent: name, min: 1)
            try self.validate(self.featuresAttribute, name: "featuresAttribute", parent: name, max: 64)
            try self.validate(self.featuresAttribute, name: "featuresAttribute", parent: name, min: 1)
            try self.validate(self.featuresAttribute, name: "featuresAttribute", parent: name, pattern: ".*")
            try self.validate(self.featureTypes, name: "featureTypes", parent: name, max: 256)
            try self.validate(self.featureTypes, name: "featureTypes", parent: name, min: 1)
            try self.validate(self.labelAttribute, name: "labelAttribute", parent: name, max: 64)
            try self.validate(self.labelAttribute, name: "labelAttribute", parent: name, min: 1)
            try self.validate(self.labelAttribute, name: "labelAttribute", parent: name, pattern: ".*")
            try self.labelHeaders?.forEach {
                try validate($0, name: "labelHeaders[]", parent: name, max: 64)
                try validate($0, name: "labelHeaders[]", parent: name, min: 1)
                try validate($0, name: "labelHeaders[]", parent: name, pattern: ".*")
            }
            try self.validate(self.labelHeaders, name: "labelHeaders", parent: name, max: 16)
            try self.validate(self.labelHeaders, name: "labelHeaders", parent: name, min: 1)
            try self.validate(self.labelIndex, name: "labelIndex", parent: name, min: 0)
            try self.validate(self.maxPayloadInMB, name: "maxPayloadInMB", parent: name, max: 25)
            try self.validate(self.maxPayloadInMB, name: "maxPayloadInMB", parent: name, min: 1)
            try self.validate(self.maxRecordCount, name: "maxRecordCount", parent: name, min: 1)
            try self.validate(self.probabilityAttribute, name: "probabilityAttribute", parent: name, max: 64)
            try self.validate(self.probabilityAttribute, name: "probabilityAttribute", parent: name, min: 1)
            try self.validate(self.probabilityAttribute, name: "probabilityAttribute", parent: name, pattern: ".*")
            try self.validate(self.probabilityIndex, name: "probabilityIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case contentTemplate = "ContentTemplate"
            case featureHeaders = "FeatureHeaders"
            case featuresAttribute = "FeaturesAttribute"
            case featureTypes = "FeatureTypes"
            case labelAttribute = "LabelAttribute"
            case labelHeaders = "LabelHeaders"
            case labelIndex = "LabelIndex"
            case maxPayloadInMB = "MaxPayloadInMB"
            case maxRecordCount = "MaxRecordCount"
            case probabilityAttribute = "ProbabilityAttribute"
            case probabilityIndex = "ProbabilityIndex"
        }
    }

    public struct ClarifyShapBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The MIME type of the baseline data. Choose from 'text/csv' or 'application/jsonlines'. Defaults to 'text/csv'.
        public let mimeType: String?
        /// The inline SHAP baseline data in string format. ShapBaseline can have one or multiple records to be used as the baseline dataset. The format of the SHAP baseline file should be the same format as the training dataset. For example, if the training dataset is in CSV format and each record contains four features, and all features are numerical, then the format of the baseline data should also share these characteristics. For natural language processing (NLP) of text columns, the baseline value should be the value used to replace the unit of text specified by the Granularity of the TextConfig parameter. The size limit for ShapBasline is 4 KB. Use the ShapBaselineUri parameter if you want to provide more than 4 KB of baseline data.
        public let shapBaseline: String?
        /// The uniform resource identifier (URI) of the S3 bucket where the SHAP baseline file is stored. The format of the SHAP baseline file should be the same format as the format of the training dataset. For example, if the training dataset is in CSV format, and each record in the training dataset has four features, and all features are numerical, then the baseline file should also have this same format. Each record should contain only the features. If you are using a virtual private cloud (VPC), the ShapBaselineUri should be accessible to the VPC. For more information about setting up endpoints with Amazon Virtual Private Cloud, see Give SageMaker access to Resources in your Amazon Virtual Private Cloud.
        public let shapBaselineUri: String?

        public init(mimeType: String? = nil, shapBaseline: String? = nil, shapBaselineUri: String? = nil) {
            self.mimeType = mimeType
            self.shapBaseline = shapBaseline
            self.shapBaselineUri = shapBaselineUri
        }

        public func validate(name: String) throws {
            try self.validate(self.mimeType, name: "mimeType", parent: name, max: 255)
            try self.validate(self.mimeType, name: "mimeType", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*\\/[a-zA-Z0-9](-*[a-zA-Z0-9+.])*$")
            try self.validate(self.shapBaseline, name: "shapBaseline", parent: name, max: 4096)
            try self.validate(self.shapBaseline, name: "shapBaseline", parent: name, min: 1)
            try self.validate(self.shapBaseline, name: "shapBaseline", parent: name, pattern: "^[\\s\\S]+$")
            try self.validate(self.shapBaselineUri, name: "shapBaselineUri", parent: name, max: 1024)
            try self.validate(self.shapBaselineUri, name: "shapBaselineUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case mimeType = "MimeType"
            case shapBaseline = "ShapBaseline"
            case shapBaselineUri = "ShapBaselineUri"
        }
    }

    public struct ClarifyShapConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of samples to be used for analysis by the Kernal SHAP algorithm.   The number of samples determines the size of the synthetic dataset, which has an impact on latency of explainability requests. For more information, see the Synthetic data of Configure and create an endpoint.
        public let numberOfSamples: Int?
        /// The starting value used to initialize the random number generator in the explainer. Provide a value for this parameter to obtain a deterministic SHAP result.
        public let seed: Int?
        /// The configuration for the SHAP baseline of the Kernal SHAP algorithm.
        public let shapBaselineConfig: ClarifyShapBaselineConfig
        /// A parameter that indicates if text features are treated as text and explanations are provided for individual units of text. Required for natural language processing (NLP) explainability only.
        public let textConfig: ClarifyTextConfig?
        /// A Boolean toggle to indicate if you want to use the logit function (true) or log-odds units (false) for model predictions. Defaults to false.
        public let useLogit: Bool?

        public init(numberOfSamples: Int? = nil, seed: Int? = nil, shapBaselineConfig: ClarifyShapBaselineConfig, textConfig: ClarifyTextConfig? = nil, useLogit: Bool? = nil) {
            self.numberOfSamples = numberOfSamples
            self.seed = seed
            self.shapBaselineConfig = shapBaselineConfig
            self.textConfig = textConfig
            self.useLogit = useLogit
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfSamples, name: "numberOfSamples", parent: name, min: 1)
            try self.shapBaselineConfig.validate(name: "\(name).shapBaselineConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfSamples = "NumberOfSamples"
            case seed = "Seed"
            case shapBaselineConfig = "ShapBaselineConfig"
            case textConfig = "TextConfig"
            case useLogit = "UseLogit"
        }
    }

    public struct ClarifyTextConfig: AWSEncodableShape & AWSDecodableShape {
        /// The unit of granularity for the analysis of text features. For example, if the unit is 'token', then each token (like a word in English) of the text is treated as a feature. SHAP values are computed for each unit/feature.
        public let granularity: ClarifyTextGranularity
        /// Specifies the language of the text features in ISO 639-1 or ISO 639-3 code of a supported language.   For a mix of multiple languages, use code 'xx'.
        public let language: ClarifyTextLanguage

        public init(granularity: ClarifyTextGranularity, language: ClarifyTextLanguage) {
            self.granularity = granularity
            self.language = language
        }

        private enum CodingKeys: String, CodingKey {
            case granularity = "Granularity"
            case language = "Language"
        }
    }

    public struct CodeRepository: AWSEncodableShape & AWSDecodableShape {
        /// The URL of the Git repository.
        public let repositoryUrl: String

        public init(repositoryUrl: String) {
            self.repositoryUrl = repositoryUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, max: 1024)
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, pattern: "^https://([.\\-_a-zA-Z0-9]+/?){3,1016}$")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryUrl = "RepositoryUrl"
        }
    }

    public struct CodeRepositorySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Git repository.
        public let codeRepositoryArn: String
        /// The name of the Git repository.
        public let codeRepositoryName: String
        /// The date and time that the Git repository was created.
        public let creationTime: Date
        /// Configuration details for the Git repository, including the URL where it is located and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.
        public let gitConfig: GitConfig?
        /// The date and time that the Git repository was last modified.
        public let lastModifiedTime: Date

        public init(codeRepositoryArn: String, codeRepositoryName: String, creationTime: Date, gitConfig: GitConfig? = nil, lastModifiedTime: Date) {
            self.codeRepositoryArn = codeRepositoryArn
            self.codeRepositoryName = codeRepositoryName
            self.creationTime = creationTime
            self.gitConfig = gitConfig
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
            case codeRepositoryName = "CodeRepositoryName"
            case creationTime = "CreationTime"
            case gitConfig = "GitConfig"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct CognitoConfig: AWSEncodableShape & AWSDecodableShape {
        /// The client ID for your Amazon Cognito user pool.
        public let clientId: String
        /// A  user pool is a user directory in Amazon Cognito.  With a user pool, your users can sign in to your web or mobile app through Amazon Cognito.  Your users can also sign in through social identity providers like  Google, Facebook, Amazon, or Apple, and through SAML identity providers.
        public let userPool: String

        public init(clientId: String, userPool: String) {
            self.clientId = clientId
            self.userPool = userPool
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 1024)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.userPool, name: "userPool", parent: name, max: 55)
            try self.validate(self.userPool, name: "userPool", parent: name, min: 1)
            try self.validate(self.userPool, name: "userPool", parent: name, pattern: "^[\\w-]+_[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case userPool = "UserPool"
        }
    }

    public struct CognitoMemberDefinition: AWSEncodableShape & AWSDecodableShape {
        /// An identifier for an application client. You must create the app client ID using Amazon Cognito.
        public let clientId: String
        /// An identifier for a user group.
        public let userGroup: String
        /// An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
        public let userPool: String

        public init(clientId: String, userGroup: String, userPool: String) {
            self.clientId = clientId
            self.userGroup = userGroup
            self.userPool = userPool
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 1024)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.userGroup, name: "userGroup", parent: name, max: 128)
            try self.validate(self.userGroup, name: "userGroup", parent: name, min: 1)
            try self.validate(self.userGroup, name: "userGroup", parent: name, pattern: "^[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}]+$")
            try self.validate(self.userPool, name: "userPool", parent: name, max: 55)
            try self.validate(self.userPool, name: "userPool", parent: name, min: 1)
            try self.validate(self.userPool, name: "userPool", parent: name, pattern: "^[\\w-]+_[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case userGroup = "UserGroup"
            case userPool = "UserPool"
        }
    }

    public struct CollectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the tensor collection. The name must be unique relative to other rule configuration names.
        public let collectionName: String?
        /// Parameter values for the tensor collection. The allowed parameters are "name", "include_regex", "reduction_config", "save_config", "tensor_names", and "save_histogram".
        public let collectionParameters: [String: String]?

        public init(collectionName: String? = nil, collectionParameters: [String: String]? = nil) {
            self.collectionName = collectionName
            self.collectionParameters = collectionParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 256)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: ".*")
            try self.collectionParameters?.forEach {
                try validate($0.key, name: "collectionParameters.key", parent: name, max: 256)
                try validate($0.key, name: "collectionParameters.key", parent: name, min: 1)
                try validate($0.key, name: "collectionParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "collectionParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "collectionParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.collectionParameters, name: "collectionParameters", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case collectionParameters = "CollectionParameters"
        }
    }

    public struct CompilationJobSummary: AWSDecodableShape {
        /// The time when the model compilation job completed.
        public let compilationEndTime: Date?
        /// The Amazon Resource Name (ARN) of the model compilation job.
        public let compilationJobArn: String
        /// The name of the model compilation job that you want a summary for.
        public let compilationJobName: String
        /// The status of the model compilation job.
        public let compilationJobStatus: CompilationJobStatus
        /// The time when the model compilation job started.
        public let compilationStartTime: Date?
        /// The type of device that the model will run on after the compilation job has completed.
        public let compilationTargetDevice: TargetDevice?
        /// The type of accelerator that the model will run on after the compilation job has completed.
        public let compilationTargetPlatformAccelerator: TargetPlatformAccelerator?
        /// The type of architecture that the model will run on after the compilation job has completed.
        public let compilationTargetPlatformArch: TargetPlatformArch?
        /// The type of OS that the model will run on after the compilation job has completed.
        public let compilationTargetPlatformOs: TargetPlatformOs?
        /// The time when the model compilation job was created.
        public let creationTime: Date
        /// The time when the model compilation job was last modified.
        public let lastModifiedTime: Date?

        public init(compilationEndTime: Date? = nil, compilationJobArn: String, compilationJobName: String, compilationJobStatus: CompilationJobStatus, compilationStartTime: Date? = nil, compilationTargetDevice: TargetDevice? = nil, compilationTargetPlatformAccelerator: TargetPlatformAccelerator? = nil, compilationTargetPlatformArch: TargetPlatformArch? = nil, compilationTargetPlatformOs: TargetPlatformOs? = nil, creationTime: Date, lastModifiedTime: Date? = nil) {
            self.compilationEndTime = compilationEndTime
            self.compilationJobArn = compilationJobArn
            self.compilationJobName = compilationJobName
            self.compilationJobStatus = compilationJobStatus
            self.compilationStartTime = compilationStartTime
            self.compilationTargetDevice = compilationTargetDevice
            self.compilationTargetPlatformAccelerator = compilationTargetPlatformAccelerator
            self.compilationTargetPlatformArch = compilationTargetPlatformArch
            self.compilationTargetPlatformOs = compilationTargetPlatformOs
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case compilationEndTime = "CompilationEndTime"
            case compilationJobArn = "CompilationJobArn"
            case compilationJobName = "CompilationJobName"
            case compilationJobStatus = "CompilationJobStatus"
            case compilationStartTime = "CompilationStartTime"
            case compilationTargetDevice = "CompilationTargetDevice"
            case compilationTargetPlatformAccelerator = "CompilationTargetPlatformAccelerator"
            case compilationTargetPlatformArch = "CompilationTargetPlatformArch"
            case compilationTargetPlatformOs = "CompilationTargetPlatformOs"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct ConditionStepMetadata: AWSDecodableShape {
        /// The outcome of the Condition step evaluation.
        public let outcome: ConditionOutcome?

        public init(outcome: ConditionOutcome? = nil) {
            self.outcome = outcome
        }

        private enum CodingKeys: String, CodingKey {
            case outcome = "Outcome"
        }
    }

    public struct ContainerDefinition: AWSEncodableShape & AWSDecodableShape {
        /// This parameter is ignored for models that contain only a PrimaryContainer. When a ContainerDefinition is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. For information, see Use Logs and Metrics to Monitor an Inference Pipeline. If you don't specify a value for this parameter for a ContainerDefinition that is part of an inference pipeline, a unique name is automatically assigned based on the position of the ContainerDefinition in the pipeline. If you specify a value for the ContainerHostName for any ContainerDefinition that is part of an inference pipeline, you must specify a value for the ContainerHostName parameter of every ContainerDefinition in that pipeline.
        public let containerHostname: String?
        /// The environment variables to set in the Docker container. Each key and value in the Environment string to string map can have length of up to 1024. We support up to 16 entries in the map.
        public let environment: [String: String]?
        /// The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a Docker registry that is accessible from the same VPC that you configure for your endpoint. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information, see Using Your Own Algorithms with Amazon SageMaker
        public let image: String?
        /// Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a private Docker registry, see Use a Private Docker Registry for Real-Time Inference Containers
        public let imageConfig: ImageConfig?
        /// The inference specification name in the model package version.
        public let inferenceSpecificationName: String?
        /// Whether the container hosts a single model or multiple models.
        public let mode: ContainerMode?
        /// The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for SageMaker built-in algorithms, but not if you use your own algorithms. For more information on built-in algorithms, see Common Parameters.   The model artifacts must be in an S3 bucket that is in the same region as the model or endpoint you are creating.  If you provide a value for this parameter, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region in the Amazon Web Services Identity and Access Management User Guide.  If you use a built-in algorithm to create a model, SageMaker requires that you provide a S3 path to the model artifacts in ModelDataUrl.
        public let modelDataUrl: String?
        /// The name or Amazon Resource Name (ARN) of the model package to use to create the model.
        public let modelPackageName: String?
        /// Specifies additional configuration for multi-model endpoints.
        public let multiModelConfig: MultiModelConfig?

        public init(containerHostname: String? = nil, environment: [String: String]? = nil, image: String? = nil, imageConfig: ImageConfig? = nil, inferenceSpecificationName: String? = nil, mode: ContainerMode? = nil, modelDataUrl: String? = nil, modelPackageName: String? = nil, multiModelConfig: MultiModelConfig? = nil) {
            self.containerHostname = containerHostname
            self.environment = environment
            self.image = image
            self.imageConfig = imageConfig
            self.inferenceSpecificationName = inferenceSpecificationName
            self.mode = mode
            self.modelDataUrl = modelDataUrl
            self.modelPackageName = modelPackageName
            self.multiModelConfig = multiModelConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.containerHostname, name: "containerHostname", parent: name, max: 63)
            try self.validate(self.containerHostname, name: "containerHostname", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 1024)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 16)
            try self.validate(self.image, name: "image", parent: name, max: 255)
            try self.validate(self.image, name: "image", parent: name, pattern: "^[\\S]+$")
            try self.imageConfig?.validate(name: "\(name).imageConfig")
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, max: 63)
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, min: 1)
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, max: 1024)
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, max: 176)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, min: 1)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)(\\/[0-9]{1,5})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerHostname = "ContainerHostname"
            case environment = "Environment"
            case image = "Image"
            case imageConfig = "ImageConfig"
            case inferenceSpecificationName = "InferenceSpecificationName"
            case mode = "Mode"
            case modelDataUrl = "ModelDataUrl"
            case modelPackageName = "ModelPackageName"
            case multiModelConfig = "MultiModelConfig"
        }
    }

    public struct ContextSource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the source.
        public let sourceId: String?
        /// The type of the source.
        public let sourceType: String?
        /// The URI of the source.
        public let sourceUri: String

        public init(sourceId: String? = nil, sourceType: String? = nil, sourceUri: String) {
            self.sourceId = sourceId
            self.sourceType = sourceType
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceId, name: "sourceId", parent: name, max: 256)
            try self.validate(self.sourceType, name: "sourceType", parent: name, max: 256)
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceId = "SourceId"
            case sourceType = "SourceType"
            case sourceUri = "SourceUri"
        }
    }

    public struct ContextSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the context.
        public let contextArn: String?
        /// The name of the context.
        public let contextName: String?
        /// The type of the context.
        public let contextType: String?
        /// When the context was created.
        public let creationTime: Date?
        /// When the context was last modified.
        public let lastModifiedTime: Date?
        /// The source of the context.
        public let source: ContextSource?

        public init(contextArn: String? = nil, contextName: String? = nil, contextType: String? = nil, creationTime: Date? = nil, lastModifiedTime: Date? = nil, source: ContextSource? = nil) {
            self.contextArn = contextArn
            self.contextName = contextName
            self.contextType = contextType
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case contextArn = "ContextArn"
            case contextName = "ContextName"
            case contextType = "ContextType"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case source = "Source"
        }
    }

    public struct ContinuousParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum value for the hyperparameter. The tuning job uses floating-point values between MinValue value and this value for tuning.
        public let maxValue: String
        /// The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and MaxValuefor tuning.
        public let minValue: String
        /// The name of the continuous hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:  Auto  SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have only values greater than 0.  ReverseLogarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0
        public let scalingType: HyperParameterScalingType?

        public init(maxValue: String, minValue: String, name: String, scalingType: HyperParameterScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 256)
            try self.validate(self.maxValue, name: "maxValue", parent: name, pattern: ".*")
            try self.validate(self.minValue, name: "minValue", parent: name, max: 256)
            try self.validate(self.minValue, name: "minValue", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct ContinuousParameterRangeSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The maximum floating-point value allowed.
        public let maxValue: String
        /// The minimum floating-point value allowed.
        public let minValue: String

        public init(maxValue: String, minValue: String) {
            self.maxValue = maxValue
            self.minValue = minValue
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 256)
            try self.validate(self.maxValue, name: "maxValue", parent: name, pattern: ".*")
            try self.validate(self.minValue, name: "minValue", parent: name, max: 256)
            try self.validate(self.minValue, name: "minValue", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public struct CreateActionRequest: AWSEncodableShape {
        /// The name of the action. Must be unique to your account in an Amazon Web Services Region.
        public let actionName: String
        /// The action type.
        public let actionType: String
        /// The description of the action.
        public let description: String?
        public let metadataProperties: MetadataProperties?
        /// A list of properties to add to the action.
        public let properties: [String: String]?
        /// The source type, ID, and URI.
        public let source: ActionSource
        /// The status of the action.
        public let status: ActionStatus?
        /// A list of tags to apply to the action.
        public let tags: [Tag]?

        public init(actionName: String, actionType: String, description: String? = nil, metadataProperties: MetadataProperties? = nil, properties: [String: String]? = nil, source: ActionSource, status: ActionStatus? = nil, tags: [Tag]? = nil) {
            self.actionName = actionName
            self.actionType = actionType
            self.description = description
            self.metadataProperties = metadataProperties
            self.properties = properties
            self.source = source
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 120)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.actionType, name: "actionType", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.metadataProperties?.validate(name: "\(name).metadataProperties")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "ActionName"
            case actionType = "ActionType"
            case description = "Description"
            case metadataProperties = "MetadataProperties"
            case properties = "Properties"
            case source = "Source"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct CreateActionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let actionArn: String?

        public init(actionArn: String? = nil) {
            self.actionArn = actionArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionArn = "ActionArn"
        }
    }

    public struct CreateAlgorithmInput: AWSEncodableShape {
        /// A description of the algorithm.
        public let algorithmDescription: String?
        /// The name of the algorithm.
        public let algorithmName: String
        /// Whether to certify the algorithm so that it can be listed in Amazon Web Services Marketplace.
        public let certifyForMarketplace: Bool?
        /// Specifies details about inference jobs that the algorithm runs, including the following:   The Amazon ECR paths of containers that contain the inference code and model artifacts.   The instance types that the algorithm supports for transform jobs and real-time endpoints used for inference.   The input and output content formats that the algorithm supports for inference.
        public let inferenceSpecification: InferenceSpecification?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        /// Specifies details about training jobs run by this algorithm, including the following:   The Amazon ECR path of the container and the version digest of the algorithm.   The hyperparameters that the algorithm supports.   The instance types that the algorithm supports for training.   Whether the algorithm supports distributed training.   The metrics that the algorithm emits to Amazon CloudWatch.   Which metrics that the algorithm emits can be used as the objective metric for hyperparameter tuning jobs.   The input channels that the algorithm supports for training data. For example, an algorithm might support train, validation, and test channels.
        public let trainingSpecification: TrainingSpecification
        /// Specifies configurations for one or more training jobs and that SageMaker runs to test the algorithm's training code and, optionally, one or more batch transform jobs that SageMaker runs to test the algorithm's inference code.
        public let validationSpecification: AlgorithmValidationSpecification?

        public init(algorithmDescription: String? = nil, algorithmName: String, certifyForMarketplace: Bool? = nil, inferenceSpecification: InferenceSpecification? = nil, tags: [Tag]? = nil, trainingSpecification: TrainingSpecification, validationSpecification: AlgorithmValidationSpecification? = nil) {
            self.algorithmDescription = algorithmDescription
            self.algorithmName = algorithmName
            self.certifyForMarketplace = certifyForMarketplace
            self.inferenceSpecification = inferenceSpecification
            self.tags = tags
            self.trainingSpecification = trainingSpecification
            self.validationSpecification = validationSpecification
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmDescription, name: "algorithmDescription", parent: name, max: 1024)
            try self.validate(self.algorithmDescription, name: "algorithmDescription", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 63)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.inferenceSpecification?.validate(name: "\(name).inferenceSpecification")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.trainingSpecification.validate(name: "\(name).trainingSpecification")
            try self.validationSpecification?.validate(name: "\(name).validationSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmDescription = "AlgorithmDescription"
            case algorithmName = "AlgorithmName"
            case certifyForMarketplace = "CertifyForMarketplace"
            case inferenceSpecification = "InferenceSpecification"
            case tags = "Tags"
            case trainingSpecification = "TrainingSpecification"
            case validationSpecification = "ValidationSpecification"
        }
    }

    public struct CreateAlgorithmOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new algorithm.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
        }
    }

    public struct CreateAppImageConfigRequest: AWSEncodableShape {
        /// The name of the AppImageConfig. Must be unique to your account.
        public let appImageConfigName: String
        /// The KernelGatewayImageConfig. You can only specify one image kernel in the
        /// 	AppImageConfig API. This kernel will be shown to users before the
        /// 	image starts. Once the image runs, all kernels are visible in JupyterLab.
        public let kernelGatewayImageConfig: KernelGatewayImageConfig?
        /// A list of tags to apply to the AppImageConfig.
        public let tags: [Tag]?

        public init(appImageConfigName: String, kernelGatewayImageConfig: KernelGatewayImageConfig? = nil, tags: [Tag]? = nil) {
            self.appImageConfigName = appImageConfigName
            self.kernelGatewayImageConfig = kernelGatewayImageConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, max: 63)
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.kernelGatewayImageConfig?.validate(name: "\(name).kernelGatewayImageConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigName = "AppImageConfigName"
            case kernelGatewayImageConfig = "KernelGatewayImageConfig"
            case tags = "Tags"
        }
    }

    public struct CreateAppImageConfigResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppImageConfig.
        public let appImageConfigArn: String?

        public init(appImageConfigArn: String? = nil) {
            self.appImageConfigArn = appImageConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigArn = "AppImageConfigArn"
        }
    }

    public struct CreateAppRequest: AWSEncodableShape {
        /// The name of the app.
        public let appName: String
        /// The type of app.
        public let appType: AppType
        /// The domain ID.
        public let domainId: String
        /// The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.  The value of InstanceType passed as part of the ResourceSpec in the CreateApp call overrides the value passed as part of the ResourceSpec configured for the user profile or the domain. If InstanceType is not specified in any of those three ResourceSpec values for a KernelGateway app, the CreateApp call fails with a request validation error.
        public let resourceSpec: ResourceSpec?
        /// The name of the space. If this value is not set, then UserProfileName must be set.
        public let spaceName: String?
        /// Each tag consists of a key and an optional value. Tag keys must be unique per resource.
        public let tags: [Tag]?
        /// The user profile name. If this value is not set, then SpaceName must be set.
        public let userProfileName: String?

        public init(appName: String, appType: AppType, domainId: String, resourceSpec: ResourceSpec? = nil, spaceName: String? = nil, tags: [Tag]? = nil, userProfileName: String? = nil) {
            self.appName = appName
            self.appType = appType
            self.domainId = domainId
            self.resourceSpec = resourceSpec
            self.spaceName = spaceName
            self.tags = tags
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.appName, name: "appName", parent: name, max: 63)
            try self.validate(self.appName, name: "appName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.resourceSpec?.validate(name: "\(name).resourceSpec")
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appName = "AppName"
            case appType = "AppType"
            case domainId = "DomainId"
            case resourceSpec = "ResourceSpec"
            case spaceName = "SpaceName"
            case tags = "Tags"
            case userProfileName = "UserProfileName"
        }
    }

    public struct CreateAppResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the app.
        public let appArn: String?

        public init(appArn: String? = nil) {
            self.appArn = appArn
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "AppArn"
        }
    }

    public struct CreateArtifactRequest: AWSEncodableShape {
        /// The name of the artifact. Must be unique to your account in an Amazon Web Services Region.
        public let artifactName: String?
        /// The artifact type.
        public let artifactType: String
        public let metadataProperties: MetadataProperties?
        /// A list of properties to add to the artifact.
        public let properties: [String: String]?
        /// The ID, ID type, and URI of the source.
        public let source: ArtifactSource
        /// A list of tags to apply to the artifact.
        public let tags: [Tag]?

        public init(artifactName: String? = nil, artifactType: String, metadataProperties: MetadataProperties? = nil, properties: [String: String]? = nil, source: ArtifactSource, tags: [Tag]? = nil) {
            self.artifactName = artifactName
            self.artifactType = artifactType
            self.metadataProperties = metadataProperties
            self.properties = properties
            self.source = source
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactName, name: "artifactName", parent: name, max: 120)
            try self.validate(self.artifactName, name: "artifactName", parent: name, min: 1)
            try self.validate(self.artifactName, name: "artifactName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.artifactType, name: "artifactType", parent: name, max: 256)
            try self.metadataProperties?.validate(name: "\(name).metadataProperties")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case artifactName = "ArtifactName"
            case artifactType = "ArtifactType"
            case metadataProperties = "MetadataProperties"
            case properties = "Properties"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct CreateArtifactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the artifact.
        public let artifactArn: String?

        public init(artifactArn: String? = nil) {
            self.artifactArn = artifactArn
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
        }
    }

    public struct CreateAutoMLJobRequest: AWSEncodableShape {
        /// A collection of settings used to configure an AutoML job.
        public let autoMLJobConfig: AutoMLJobConfig?
        /// Identifies an Autopilot job. The name must be unique to your account and is case-insensitive.
        public let autoMLJobName: String
        /// Defines the objective metric used to measure the predictive quality of an AutoML job. You provide an AutoMLJobObjective$MetricName and Autopilot infers whether to minimize or maximize it.
        public let autoMLJobObjective: AutoMLJobObjective?
        /// Generates possible candidates without training the models. A candidate is a combination of data preprocessors, algorithms, and algorithm parameter settings.
        public let generateCandidateDefinitionsOnly: Bool?
        /// An array of channel objects that describes the input data and its location. Each channel is a named input source. Similar to InputDataConfig supported by . Format(s) supported: CSV, Parquet. A minimum of 500 rows is required for the training dataset. There is not a minimum number of rows required for the validation dataset.
        public let inputDataConfig: [AutoMLChannel]
        /// Specifies how to generate the endpoint name for an automatic one-click Autopilot model deployment.
        public let modelDeployConfig: ModelDeployConfig?
        /// Provides information about encryption and the Amazon S3 output path needed to store artifacts from an AutoML job. Format(s) supported: CSV.
        public let outputDataConfig: AutoMLOutputDataConfig
        /// Defines the type of supervised learning available for the candidates. For more information, see  Amazon SageMaker Autopilot problem types and algorithm support.
        public let problemType: ProblemType?
        /// The ARN of the role that is used to access the data.
        public let roleArn: String
        /// Each tag consists of a key and an optional value. Tag keys must be unique per resource.
        public let tags: [Tag]?

        public init(autoMLJobConfig: AutoMLJobConfig? = nil, autoMLJobName: String, autoMLJobObjective: AutoMLJobObjective? = nil, generateCandidateDefinitionsOnly: Bool? = nil, inputDataConfig: [AutoMLChannel], modelDeployConfig: ModelDeployConfig? = nil, outputDataConfig: AutoMLOutputDataConfig, problemType: ProblemType? = nil, roleArn: String, tags: [Tag]? = nil) {
            self.autoMLJobConfig = autoMLJobConfig
            self.autoMLJobName = autoMLJobName
            self.autoMLJobObjective = autoMLJobObjective
            self.generateCandidateDefinitionsOnly = generateCandidateDefinitionsOnly
            self.inputDataConfig = inputDataConfig
            self.modelDeployConfig = modelDeployConfig
            self.outputDataConfig = outputDataConfig
            self.problemType = problemType
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.autoMLJobConfig?.validate(name: "\(name).autoMLJobConfig")
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, max: 32)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, min: 1)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.inputDataConfig.forEach {
                try $0.validate(name: "\(name).inputDataConfig[]")
            }
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, max: 2)
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, min: 1)
            try self.modelDeployConfig?.validate(name: "\(name).modelDeployConfig")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobConfig = "AutoMLJobConfig"
            case autoMLJobName = "AutoMLJobName"
            case autoMLJobObjective = "AutoMLJobObjective"
            case generateCandidateDefinitionsOnly = "GenerateCandidateDefinitionsOnly"
            case inputDataConfig = "InputDataConfig"
            case modelDeployConfig = "ModelDeployConfig"
            case outputDataConfig = "OutputDataConfig"
            case problemType = "ProblemType"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateAutoMLJobResponse: AWSDecodableShape {
        /// The unique ARN assigned to the AutoML job when it is created.
        public let autoMLJobArn: String

        public init(autoMLJobArn: String) {
            self.autoMLJobArn = autoMLJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobArn = "AutoMLJobArn"
        }
    }

    public struct CreateCodeRepositoryInput: AWSEncodableShape {
        /// The name of the Git repository. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let codeRepositoryName: String
        /// Specifies details about the repository, including the URL where the repository is located, the default branch, and credentials to use to access the repository.
        public let gitConfig: GitConfig
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?

        public init(codeRepositoryName: String, gitConfig: GitConfig, tags: [Tag]? = nil) {
            self.codeRepositoryName = codeRepositoryName
            self.gitConfig = gitConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, max: 63)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, min: 1)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.gitConfig.validate(name: "\(name).gitConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
            case gitConfig = "GitConfig"
            case tags = "Tags"
        }
    }

    public struct CreateCodeRepositoryOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new repository.
        public let codeRepositoryArn: String

        public init(codeRepositoryArn: String) {
            self.codeRepositoryArn = codeRepositoryArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
        }
    }

    public struct CreateCompilationJobRequest: AWSEncodableShape {
        /// A name for the model compilation job. The name must be unique within the Amazon Web Services Region and within your Amazon Web Services account.
        public let compilationJobName: String
        /// Provides information about the location of input model artifacts, the name and shape of the expected data inputs, and the framework in which the model was trained.
        public let inputConfig: InputConfig?
        /// The Amazon Resource Name (ARN) of a versioned model package. Provide either a  ModelPackageVersionArn or an InputConfig object in the  request syntax. The presence of both objects in the CreateCompilationJob  request will return an exception.
        public let modelPackageVersionArn: String?
        /// Provides information about the output location for the compiled model and the target device the model runs on.
        public let outputConfig: OutputConfig
        /// The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.  During model compilation, Amazon SageMaker needs your permission to:   Read input data from an S3 bucket   Write model artifacts to an S3 bucket   Write logs to Amazon CloudWatch Logs   Publish metrics to Amazon CloudWatch   You grant permissions for all of these tasks to an IAM role. To pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. For more information, see Amazon SageMaker Roles.
        public let roleArn: String
        /// Specifies a limit to how long a model compilation job can run. When the job reaches the time limit, Amazon SageMaker ends the compilation job. Use this API to cap model training costs.
        public let stoppingCondition: StoppingCondition
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        /// A VpcConfig object that specifies the VPC that you want your compilation job to connect to. Control access to your models by configuring the VPC. For more information, see Protect Compilation Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: NeoVpcConfig?

        public init(compilationJobName: String, inputConfig: InputConfig? = nil, modelPackageVersionArn: String? = nil, outputConfig: OutputConfig, roleArn: String, stoppingCondition: StoppingCondition, tags: [Tag]? = nil, vpcConfig: NeoVpcConfig? = nil) {
            self.compilationJobName = compilationJobName
            self.inputConfig = inputConfig
            self.modelPackageVersionArn = modelPackageVersionArn
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, max: 63)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, min: 1)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.inputConfig?.validate(name: "\(name).inputConfig")
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, max: 2048)
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, min: 1)
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:model-package/")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case inputConfig = "InputConfig"
            case modelPackageVersionArn = "ModelPackageVersionArn"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct CreateCompilationJobResponse: AWSDecodableShape {
        /// If the action is successful, the service sends back an HTTP 200 response. Amazon SageMaker returns the following data in JSON format:    CompilationJobArn: The Amazon Resource Name (ARN) of the compiled job.
        public let compilationJobArn: String

        public init(compilationJobArn: String) {
            self.compilationJobArn = compilationJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobArn = "CompilationJobArn"
        }
    }

    public struct CreateContextRequest: AWSEncodableShape {
        /// The name of the context. Must be unique to your account in an Amazon Web Services Region.
        public let contextName: String
        /// The context type.
        public let contextType: String
        /// The description of the context.
        public let description: String?
        /// A list of properties to add to the context.
        public let properties: [String: String]?
        /// The source type, ID, and URI.
        public let source: ContextSource
        /// A list of tags to apply to the context.
        public let tags: [Tag]?

        public init(contextName: String, contextType: String, description: String? = nil, properties: [String: String]? = nil, source: ContextSource, tags: [Tag]? = nil) {
            self.contextName = contextName
            self.contextType = contextType
            self.description = description
            self.properties = properties
            self.source = source
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.contextName, name: "contextName", parent: name, max: 120)
            try self.validate(self.contextName, name: "contextName", parent: name, min: 1)
            try self.validate(self.contextName, name: "contextName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.contextType, name: "contextType", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case contextName = "ContextName"
            case contextType = "ContextType"
            case description = "Description"
            case properties = "Properties"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct CreateContextResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the context.
        public let contextArn: String?

        public init(contextArn: String? = nil) {
            self.contextArn = contextArn
        }

        private enum CodingKeys: String, CodingKey {
            case contextArn = "ContextArn"
        }
    }

    public struct CreateDataQualityJobDefinitionRequest: AWSEncodableShape {
        /// Specifies the container that runs the monitoring job.
        public let dataQualityAppSpecification: DataQualityAppSpecification
        /// Configures the constraints and baselines for the monitoring job.
        public let dataQualityBaselineConfig: DataQualityBaselineConfig?
        /// A list of inputs for the monitoring job. Currently endpoints are supported as monitoring inputs.
        public let dataQualityJobInput: DataQualityJobInput
        public let dataQualityJobOutputConfig: MonitoringOutputConfig
        /// The name for the monitoring job definition.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Specifies networking configuration for the monitoring job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(dataQualityAppSpecification: DataQualityAppSpecification, dataQualityBaselineConfig: DataQualityBaselineConfig? = nil, dataQualityJobInput: DataQualityJobInput, dataQualityJobOutputConfig: MonitoringOutputConfig, jobDefinitionName: String, jobResources: MonitoringResources, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil, tags: [Tag]? = nil) {
            self.dataQualityAppSpecification = dataQualityAppSpecification
            self.dataQualityBaselineConfig = dataQualityBaselineConfig
            self.dataQualityJobInput = dataQualityJobInput
            self.dataQualityJobOutputConfig = dataQualityJobOutputConfig
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataQualityAppSpecification.validate(name: "\(name).dataQualityAppSpecification")
            try self.dataQualityBaselineConfig?.validate(name: "\(name).dataQualityBaselineConfig")
            try self.dataQualityJobInput.validate(name: "\(name).dataQualityJobInput")
            try self.dataQualityJobOutputConfig.validate(name: "\(name).dataQualityJobOutputConfig")
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.jobResources.validate(name: "\(name).jobResources")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dataQualityAppSpecification = "DataQualityAppSpecification"
            case dataQualityBaselineConfig = "DataQualityBaselineConfig"
            case dataQualityJobInput = "DataQualityJobInput"
            case dataQualityJobOutputConfig = "DataQualityJobOutputConfig"
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
        }
    }

    public struct CreateDataQualityJobDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the job definition.
        public let jobDefinitionArn: String

        public init(jobDefinitionArn: String) {
            self.jobDefinitionArn = jobDefinitionArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionArn = "JobDefinitionArn"
        }
    }

    public struct CreateDeviceFleetRequest: AWSEncodableShape {
        /// A description of the fleet.
        public let description: String?
        /// The name of the fleet that the device belongs to.
        public let deviceFleetName: String
        /// Whether to create an Amazon Web Services IoT Role Alias during device fleet creation.  The name of the role alias generated will match this pattern:  "SageMakerEdge-{DeviceFleetName}". For example, if your device fleet is called "demo-fleet", the name of  the role alias will be "SageMakerEdge-demo-fleet".
        public let enableIotRoleAlias: Bool?
        /// The output configuration for storing sample data collected by the fleet.
        public let outputConfig: EdgeOutputConfig
        /// The Amazon Resource Name (ARN) that has access to Amazon Web Services Internet of Things (IoT).
        public let roleArn: String?
        /// Creates tags for the specified fleet.
        public let tags: [Tag]?

        public init(description: String? = nil, deviceFleetName: String, enableIotRoleAlias: Bool? = nil, outputConfig: EdgeOutputConfig, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.deviceFleetName = deviceFleetName
            self.enableIotRoleAlias = enableIotRoleAlias
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 800)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case deviceFleetName = "DeviceFleetName"
            case enableIotRoleAlias = "EnableIotRoleAlias"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly.    PublicInternetOnly - Non-EFS traffic is through a VPC managed by Amazon SageMaker, which allows direct internet access    VpcOnly - All Studio traffic is through the specified VPC and subnets
        public let appNetworkAccessType: AppNetworkAccessType?
        /// The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Required when CreateDomain.AppNetworkAccessType is VPCOnly and DomainSettings.RStudioServerProDomainSettings.DomainExecutionRoleArn is provided.
        public let appSecurityGroupManagement: AppSecurityGroupManagement?
        /// The mode of authentication that members use to access the domain.
        public let authMode: AuthMode
        /// The default settings used to create a space.
        public let defaultSpaceSettings: DefaultSpaceSettings?
        /// The default settings to use to create a user profile when UserSettings isn't specified in the call to the CreateUserProfile API.  SecurityGroups is aggregated when specified in both calls. For all other settings in UserSettings, the values specified in CreateUserProfile take precedence over those specified in CreateDomain.
        public let defaultUserSettings: UserSettings
        /// A name for the domain.
        public let domainName: String
        /// A collection of Domain settings.
        public let domainSettings: DomainSettings?
        /// Use KmsKeyId.
        public let homeEfsFileSystemKmsKeyId: String?
        /// SageMaker uses Amazon Web Services KMS to encrypt the EFS volume attached to the domain with an Amazon Web Services managed key by default. For more control, specify a customer managed key.
        public let kmsKeyId: String?
        /// The VPC subnets that Studio uses for communication.
        public let subnetIds: [String]
        /// Tags to associated with the Domain. Each tag consists of a key and an optional value. Tag keys must be unique per resource. Tags are searchable using the Search API. Tags that you specify for the Domain are also added to all Apps that the Domain launches.
        public let tags: [Tag]?
        /// The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        public let vpcId: String

        public init(appNetworkAccessType: AppNetworkAccessType? = nil, appSecurityGroupManagement: AppSecurityGroupManagement? = nil, authMode: AuthMode, defaultSpaceSettings: DefaultSpaceSettings? = nil, defaultUserSettings: UserSettings, domainName: String, domainSettings: DomainSettings? = nil, kmsKeyId: String? = nil, subnetIds: [String], tags: [Tag]? = nil, vpcId: String) {
            self.appNetworkAccessType = appNetworkAccessType
            self.appSecurityGroupManagement = appSecurityGroupManagement
            self.authMode = authMode
            self.defaultSpaceSettings = defaultSpaceSettings
            self.defaultUserSettings = defaultUserSettings
            self.domainName = domainName
            self.domainSettings = domainSettings
            self.homeEfsFileSystemKmsKeyId = nil
            self.kmsKeyId = kmsKeyId
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        @available(*, deprecated, message: "Members homeEfsFileSystemKmsKeyId have been deprecated")
        public init(appNetworkAccessType: AppNetworkAccessType? = nil, appSecurityGroupManagement: AppSecurityGroupManagement? = nil, authMode: AuthMode, defaultSpaceSettings: DefaultSpaceSettings? = nil, defaultUserSettings: UserSettings, domainName: String, domainSettings: DomainSettings? = nil, homeEfsFileSystemKmsKeyId: String? = nil, kmsKeyId: String? = nil, subnetIds: [String], tags: [Tag]? = nil, vpcId: String) {
            self.appNetworkAccessType = appNetworkAccessType
            self.appSecurityGroupManagement = appSecurityGroupManagement
            self.authMode = authMode
            self.defaultSpaceSettings = defaultSpaceSettings
            self.defaultUserSettings = defaultUserSettings
            self.domainName = domainName
            self.domainSettings = domainSettings
            self.homeEfsFileSystemKmsKeyId = homeEfsFileSystemKmsKeyId
            self.kmsKeyId = kmsKeyId
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.defaultSpaceSettings?.validate(name: "\(name).defaultSpaceSettings")
            try self.defaultUserSettings.validate(name: "\(name).defaultUserSettings")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 63)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.domainSettings?.validate(name: "\(name).domainSettings")
            try self.validate(self.homeEfsFileSystemKmsKeyId, name: "homeEfsFileSystemKmsKeyId", parent: name, max: 2048)
            try self.validate(self.homeEfsFileSystemKmsKeyId, name: "homeEfsFileSystemKmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 32)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^[-0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case appNetworkAccessType = "AppNetworkAccessType"
            case appSecurityGroupManagement = "AppSecurityGroupManagement"
            case authMode = "AuthMode"
            case defaultSpaceSettings = "DefaultSpaceSettings"
            case defaultUserSettings = "DefaultUserSettings"
            case domainName = "DomainName"
            case domainSettings = "DomainSettings"
            case homeEfsFileSystemKmsKeyId = "HomeEfsFileSystemKmsKeyId"
            case kmsKeyId = "KmsKeyId"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
            case vpcId = "VpcId"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created domain.
        public let domainArn: String?
        /// The URL to the created domain.
        public let url: String?

        public init(domainArn: String? = nil, url: String? = nil) {
            self.domainArn = domainArn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "DomainArn"
            case url = "Url"
        }
    }

    public struct CreateEdgeDeploymentPlanRequest: AWSEncodableShape {
        /// The device fleet used for this edge deployment plan.
        public let deviceFleetName: String
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// List of models associated with the edge deployment plan.
        public let modelConfigs: [EdgeDeploymentModelConfig]
        /// List of stages of the edge deployment plan. The number of stages is limited to 10 per deployment.
        public let stages: [DeploymentStage]?
        /// List of tags with which to tag the edge deployment plan.
        public let tags: [Tag]?

        public init(deviceFleetName: String, edgeDeploymentPlanName: String, modelConfigs: [EdgeDeploymentModelConfig], stages: [DeploymentStage]? = nil, tags: [Tag]? = nil) {
            self.deviceFleetName = deviceFleetName
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.modelConfigs = modelConfigs
            self.stages = stages
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.modelConfigs.forEach {
                try $0.validate(name: "\(name).modelConfigs[]")
            }
            try self.stages?.forEach {
                try $0.validate(name: "\(name).stages[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case modelConfigs = "ModelConfigs"
            case stages = "Stages"
            case tags = "Tags"
        }
    }

    public struct CreateEdgeDeploymentPlanResponse: AWSDecodableShape {
        /// The ARN of the edge deployment plan.
        public let edgeDeploymentPlanArn: String

        public init(edgeDeploymentPlanArn: String) {
            self.edgeDeploymentPlanArn = edgeDeploymentPlanArn
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanArn = "EdgeDeploymentPlanArn"
        }
    }

    public struct CreateEdgeDeploymentStageRequest: AWSEncodableShape {
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// List of stages to be added to the edge deployment plan.
        public let stages: [DeploymentStage]

        public init(edgeDeploymentPlanName: String, stages: [DeploymentStage]) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.stages = stages
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.stages.forEach {
                try $0.validate(name: "\(name).stages[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case stages = "Stages"
        }
    }

    public struct CreateEdgePackagingJobRequest: AWSEncodableShape {
        /// The name of the SageMaker Neo compilation job that will be used to locate model artifacts for packaging.
        public let compilationJobName: String
        /// The name of the edge packaging job.
        public let edgePackagingJobName: String
        /// The name of the model.
        public let modelName: String
        /// The version of the model.
        public let modelVersion: String
        /// Provides information about the output location for the packaged model.
        public let outputConfig: EdgeOutputConfig
        /// The Amazon Web Services KMS key to use when encrypting the EBS volume the edge packaging job runs on.
        public let resourceKey: String?
        /// The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to download and upload the model, and to contact SageMaker Neo.
        public let roleArn: String
        /// Creates tags for the packaging job.
        public let tags: [Tag]?

        public init(compilationJobName: String, edgePackagingJobName: String, modelName: String, modelVersion: String, outputConfig: EdgeOutputConfig, resourceKey: String? = nil, roleArn: String, tags: [Tag]? = nil) {
            self.compilationJobName = compilationJobName
            self.edgePackagingJobName = edgePackagingJobName
            self.modelName = modelName
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.resourceKey = resourceKey
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, max: 63)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, min: 1)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, max: 63)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, min: 1)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, min: 1)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 30)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^[a-zA-Z0-9\\ \\_\\.]+$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.resourceKey, name: "resourceKey", parent: name, max: 2048)
            try self.validate(self.resourceKey, name: "resourceKey", parent: name, pattern: ".*")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case edgePackagingJobName = "EdgePackagingJobName"
            case modelName = "ModelName"
            case modelVersion = "ModelVersion"
            case outputConfig = "OutputConfig"
            case resourceKey = "ResourceKey"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateEndpointConfigInput: AWSEncodableShape {
        /// Specifies configuration for how an endpoint performs asynchronous inference. This is a required field in order for your Endpoint to be invoked using InvokeEndpointAsync.
        public let asyncInferenceConfig: AsyncInferenceConfig?
        public let dataCaptureConfig: DataCaptureConfig?
        /// The name of the endpoint configuration. You specify this name in a CreateEndpoint request.
        public let endpointConfigName: String
        /// A member of CreateEndpointConfig that enables explainers.
        public let explainerConfig: ExplainerConfig?
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. The KmsKeyId can be any of the following formats:    Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias    The KMS key policy must grant permission to the IAM role that you specify in your CreateEndpoint, UpdateEndpoint requests. For more information, refer to the Amazon Web Services Key Management Service section Using Key Policies in Amazon Web Services KMS    Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a KmsKeyId when using an instance type with local storage. If any of the models that you specify in the ProductionVariants parameter use nitro-based instances with local storage, do not specify a value for the KmsKeyId parameter. If you specify a value for KmsKeyId when using any nitro-based instances with local storage, the call to CreateEndpointConfig fails. For a list of instance types that support local instance storage, see Instance Store Volumes. For more information about local instance storage encryption, see SSD Instance Store Volumes.
        public let kmsKeyId: String?
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint.
        public let productionVariants: [ProductionVariant]
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants. If you use this field, you can only specify one variant for ProductionVariants and one variant for ShadowProductionVariants.
        public let shadowProductionVariants: [ProductionVariant]?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?

        public init(asyncInferenceConfig: AsyncInferenceConfig? = nil, dataCaptureConfig: DataCaptureConfig? = nil, endpointConfigName: String, explainerConfig: ExplainerConfig? = nil, kmsKeyId: String? = nil, productionVariants: [ProductionVariant], shadowProductionVariants: [ProductionVariant]? = nil, tags: [Tag]? = nil) {
            self.asyncInferenceConfig = asyncInferenceConfig
            self.dataCaptureConfig = dataCaptureConfig
            self.endpointConfigName = endpointConfigName
            self.explainerConfig = explainerConfig
            self.kmsKeyId = kmsKeyId
            self.productionVariants = productionVariants
            self.shadowProductionVariants = shadowProductionVariants
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.asyncInferenceConfig?.validate(name: "\(name).asyncInferenceConfig")
            try self.dataCaptureConfig?.validate(name: "\(name).dataCaptureConfig")
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, max: 63)
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.explainerConfig?.validate(name: "\(name).explainerConfig")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.productionVariants.forEach {
                try $0.validate(name: "\(name).productionVariants[]")
            }
            try self.validate(self.productionVariants, name: "productionVariants", parent: name, max: 10)
            try self.validate(self.productionVariants, name: "productionVariants", parent: name, min: 1)
            try self.shadowProductionVariants?.forEach {
                try $0.validate(name: "\(name).shadowProductionVariants[]")
            }
            try self.validate(self.shadowProductionVariants, name: "shadowProductionVariants", parent: name, max: 10)
            try self.validate(self.shadowProductionVariants, name: "shadowProductionVariants", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case asyncInferenceConfig = "AsyncInferenceConfig"
            case dataCaptureConfig = "DataCaptureConfig"
            case endpointConfigName = "EndpointConfigName"
            case explainerConfig = "ExplainerConfig"
            case kmsKeyId = "KmsKeyId"
            case productionVariants = "ProductionVariants"
            case shadowProductionVariants = "ShadowProductionVariants"
            case tags = "Tags"
        }
    }

    public struct CreateEndpointConfigOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint configuration.
        public let endpointConfigArn: String

        public init(endpointConfigArn: String) {
            self.endpointConfigArn = endpointConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigArn = "EndpointConfigArn"
        }
    }

    public struct CreateEndpointInput: AWSEncodableShape {
        public let deploymentConfig: DeploymentConfig?
        /// The name of an endpoint configuration. For more information, see CreateEndpointConfig.
        public let endpointConfigName: String
        /// The name of the endpoint.The name must be unique within an Amazon Web Services Region in your Amazon Web Services account. The name is case-insensitive in CreateEndpoint, but the case is preserved and must be matched in .
        public let endpointName: String
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?

        public init(deploymentConfig: DeploymentConfig? = nil, endpointConfigName: String, endpointName: String, tags: [Tag]? = nil) {
            self.deploymentConfig = deploymentConfig
            self.endpointConfigName = endpointConfigName
            self.endpointName = endpointName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.deploymentConfig?.validate(name: "\(name).deploymentConfig")
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, max: 63)
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentConfig = "DeploymentConfig"
            case endpointConfigName = "EndpointConfigName"
            case endpointName = "EndpointName"
            case tags = "Tags"
        }
    }

    public struct CreateEndpointOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct CreateExperimentRequest: AWSEncodableShape {
        /// The description of the experiment.
        public let description: String?
        /// The name of the experiment as displayed. The name doesn't need to be unique. If you don't specify DisplayName, the value in ExperimentName is displayed.
        public let displayName: String?
        /// The name of the experiment. The name must be unique in your Amazon Web Services account and is not case-sensitive.
        public let experimentName: String
        /// A list of tags to associate with the experiment. You can use Search API to search on the tags.
        public let tags: [Tag]?

        public init(description: String? = nil, displayName: String? = nil, experimentName: String, tags: [Tag]? = nil) {
            self.description = description
            self.displayName = displayName
            self.experimentName = experimentName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case experimentName = "ExperimentName"
            case tags = "Tags"
        }
    }

    public struct CreateExperimentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the experiment.
        public let experimentArn: String?

        public init(experimentArn: String? = nil) {
            self.experimentArn = experimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case experimentArn = "ExperimentArn"
        }
    }

    public struct CreateFeatureGroupRequest: AWSEncodableShape {
        /// A free-form description of a FeatureGroup.
        public let description: String?
        /// The name of the feature that stores the EventTime of a Record in a FeatureGroup. An EventTime is a point in time when a new event occurs that corresponds to the creation or update of a Record in a FeatureGroup. All Records in the FeatureGroup must have a corresponding EventTime. An EventTime can be a String or Fractional.     Fractional: EventTime feature values must be a Unix timestamp in seconds.    String: EventTime feature values must be an ISO-8601 string in the format. The following formats are supported yyyy-MM-dd'T'HH:mm:ssZ and yyyy-MM-dd'T'HH:mm:ss.SSSZ where yyyy, MM, and dd represent the year, month, and day respectively and HH, mm, ss, and if applicable, SSS represent the hour, month, second and milliseconds respsectively. 'T' and Z are constants.
        public let eventTimeFeatureName: String
        /// A list of Feature names and types. Name and Type is compulsory per Feature.  Valid feature FeatureTypes are Integral, Fractional and String.  FeatureNames cannot be any of the following: is_deleted, write_time, api_invocation_time  You can create up to 2,500 FeatureDefinitions per FeatureGroup.
        public let featureDefinitions: [FeatureDefinition]
        /// The name of the FeatureGroup. The name must be unique within an Amazon Web Services Region in an Amazon Web Services account. The name:   Must start and end with an alphanumeric character.   Can only contain alphanumeric character and hyphens. Spaces are not allowed.
        public let featureGroupName: String
        /// Use this to configure an OfflineFeatureStore. This parameter allows you to specify:   The Amazon Simple Storage Service (Amazon S3) location of an OfflineStore.   A configuration for an Amazon Web Services Glue or Amazon Web Services Hive data catalog.    An KMS encryption key to encrypt the Amazon S3 location used for OfflineStore. If KMS encryption key is not specified, by default we encrypt all data at rest using  Amazon Web Services KMS key. By defining your bucket-level key for SSE,  you can reduce Amazon Web Services KMS requests costs by up to 99 percent.   Format for the offline store table. Supported formats are Glue (Default) and Apache Iceberg.   To learn more about this parameter, see OfflineStoreConfig.
        public let offlineStoreConfig: OfflineStoreConfig?
        /// You can turn the OnlineStore on or off by specifying True for the EnableOnlineStore flag in OnlineStoreConfig; the default value is False. You can also include an Amazon Web Services KMS key ID (KMSKeyId) for at-rest encryption of the OnlineStore.
        public let onlineStoreConfig: OnlineStoreConfig?
        /// The name of the Feature whose value uniquely identifies a Record defined in the FeatureStore. Only the latest record per identifier value will be stored in the OnlineStore. RecordIdentifierFeatureName must be one of feature definitions' names. You use the RecordIdentifierFeatureName to access data in a FeatureStore. This name:   Must start and end with an alphanumeric character.   Can only contains alphanumeric characters, hyphens, underscores. Spaces are not allowed.
        public let recordIdentifierFeatureName: String
        /// The Amazon Resource Name (ARN) of the IAM execution role used to persist data into the OfflineStore if an OfflineStoreConfig is provided.
        public let roleArn: String?
        /// Tags used to identify Features in each FeatureGroup.
        public let tags: [Tag]?

        public init(description: String? = nil, eventTimeFeatureName: String, featureDefinitions: [FeatureDefinition], featureGroupName: String, offlineStoreConfig: OfflineStoreConfig? = nil, onlineStoreConfig: OnlineStoreConfig? = nil, recordIdentifierFeatureName: String, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.eventTimeFeatureName = eventTimeFeatureName
            self.featureDefinitions = featureDefinitions
            self.featureGroupName = featureGroupName
            self.offlineStoreConfig = offlineStoreConfig
            self.onlineStoreConfig = onlineStoreConfig
            self.recordIdentifierFeatureName = recordIdentifierFeatureName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.eventTimeFeatureName, name: "eventTimeFeatureName", parent: name, max: 64)
            try self.validate(self.eventTimeFeatureName, name: "eventTimeFeatureName", parent: name, min: 1)
            try self.validate(self.eventTimeFeatureName, name: "eventTimeFeatureName", parent: name, pattern: "^[a-zA-Z0-9]([-_]*[a-zA-Z0-9]){0,63}$")
            try self.featureDefinitions.forEach {
                try $0.validate(name: "\(name).featureDefinitions[]")
            }
            try self.validate(self.featureDefinitions, name: "featureDefinitions", parent: name, max: 2500)
            try self.validate(self.featureDefinitions, name: "featureDefinitions", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.offlineStoreConfig?.validate(name: "\(name).offlineStoreConfig")
            try self.onlineStoreConfig?.validate(name: "\(name).onlineStoreConfig")
            try self.validate(self.recordIdentifierFeatureName, name: "recordIdentifierFeatureName", parent: name, max: 64)
            try self.validate(self.recordIdentifierFeatureName, name: "recordIdentifierFeatureName", parent: name, min: 1)
            try self.validate(self.recordIdentifierFeatureName, name: "recordIdentifierFeatureName", parent: name, pattern: "^[a-zA-Z0-9]([-_]*[a-zA-Z0-9]){0,63}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventTimeFeatureName = "EventTimeFeatureName"
            case featureDefinitions = "FeatureDefinitions"
            case featureGroupName = "FeatureGroupName"
            case offlineStoreConfig = "OfflineStoreConfig"
            case onlineStoreConfig = "OnlineStoreConfig"
            case recordIdentifierFeatureName = "RecordIdentifierFeatureName"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateFeatureGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the FeatureGroup. This is a unique identifier for the feature group.
        public let featureGroupArn: String

        public init(featureGroupArn: String) {
            self.featureGroupArn = featureGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupArn = "FeatureGroupArn"
        }
    }

    public struct CreateFlowDefinitionRequest: AWSEncodableShape {
        /// The name of your flow definition.
        public let flowDefinitionName: String
        /// An object containing information about the events that trigger a human workflow.
        public let humanLoopActivationConfig: HumanLoopActivationConfig?
        /// An object containing information about the tasks the human reviewers will perform.
        public let humanLoopConfig: HumanLoopConfig
        /// Container for configuring the source of human task requests. Use to specify if Amazon Rekognition or Amazon Textract is used as an integration source.
        public let humanLoopRequestSource: HumanLoopRequestSource?
        /// An object containing information about where the human review results will be uploaded.
        public let outputConfig: FlowDefinitionOutputConfig
        /// The Amazon Resource Name (ARN) of the role needed to call other services on your behalf. For example, arn:aws:iam::1234567890:role/service-role/AmazonSageMaker-ExecutionRole-20180111T151298.
        public let roleArn: String
        /// An array of key-value pairs that contain metadata to help you categorize and organize a flow definition. Each tag consists of a key and a value, both of which you define.
        public let tags: [Tag]?

        public init(flowDefinitionName: String, humanLoopActivationConfig: HumanLoopActivationConfig? = nil, humanLoopConfig: HumanLoopConfig, humanLoopRequestSource: HumanLoopRequestSource? = nil, outputConfig: FlowDefinitionOutputConfig, roleArn: String, tags: [Tag]? = nil) {
            self.flowDefinitionName = flowDefinitionName
            self.humanLoopActivationConfig = humanLoopActivationConfig
            self.humanLoopConfig = humanLoopConfig
            self.humanLoopRequestSource = humanLoopRequestSource
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, max: 63)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, min: 1)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9]){0,62}$")
            try self.humanLoopActivationConfig?.validate(name: "\(name).humanLoopActivationConfig")
            try self.humanLoopConfig.validate(name: "\(name).humanLoopConfig")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionName = "FlowDefinitionName"
            case humanLoopActivationConfig = "HumanLoopActivationConfig"
            case humanLoopConfig = "HumanLoopConfig"
            case humanLoopRequestSource = "HumanLoopRequestSource"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateFlowDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow definition you create.
        public let flowDefinitionArn: String

        public init(flowDefinitionArn: String) {
            self.flowDefinitionArn = flowDefinitionArn
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionArn = "FlowDefinitionArn"
        }
    }

    public struct CreateHubRequest: AWSEncodableShape {
        /// A description of the hub.
        public let hubDescription: String
        /// The display name of the hub.
        public let hubDisplayName: String?
        /// The name of the hub to create.
        public let hubName: String
        /// The searchable keywords for the hub.
        public let hubSearchKeywords: [String]?
        /// The Amazon S3 storage configuration for the hub.
        public let s3StorageConfig: HubS3StorageConfig?
        /// Any tags to associate with the hub.
        public let tags: [Tag]?

        public init(hubDescription: String, hubDisplayName: String? = nil, hubName: String, hubSearchKeywords: [String]? = nil, s3StorageConfig: HubS3StorageConfig? = nil, tags: [Tag]? = nil) {
            self.hubDescription = hubDescription
            self.hubDisplayName = hubDisplayName
            self.hubName = hubName
            self.hubSearchKeywords = hubSearchKeywords
            self.s3StorageConfig = s3StorageConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.hubDescription, name: "hubDescription", parent: name, max: 1023)
            try self.validate(self.hubDescription, name: "hubDescription", parent: name, pattern: ".*")
            try self.validate(self.hubDisplayName, name: "hubDisplayName", parent: name, max: 255)
            try self.validate(self.hubDisplayName, name: "hubDisplayName", parent: name, pattern: ".*")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.hubSearchKeywords?.forEach {
                try validate($0, name: "hubSearchKeywords[]", parent: name, max: 255)
                try validate($0, name: "hubSearchKeywords[]", parent: name, pattern: "^[^A-Z]*$")
            }
            try self.validate(self.hubSearchKeywords, name: "hubSearchKeywords", parent: name, max: 50)
            try self.s3StorageConfig?.validate(name: "\(name).s3StorageConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case hubDescription = "HubDescription"
            case hubDisplayName = "HubDisplayName"
            case hubName = "HubName"
            case hubSearchKeywords = "HubSearchKeywords"
            case s3StorageConfig = "S3StorageConfig"
            case tags = "Tags"
        }
    }

    public struct CreateHubResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hub.
        public let hubArn: String

        public init(hubArn: String) {
            self.hubArn = hubArn
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
        }
    }

    public struct CreateHumanTaskUiRequest: AWSEncodableShape {
        /// The name of the user interface you are creating.
        public let humanTaskUiName: String
        /// An array of key-value pairs that contain metadata to help you categorize and organize a human review workflow user interface. Each tag consists of a key and a value, both of which you define.
        public let tags: [Tag]?
        public let uiTemplate: UiTemplate

        public init(humanTaskUiName: String, tags: [Tag]? = nil, uiTemplate: UiTemplate) {
            self.humanTaskUiName = humanTaskUiName
            self.tags = tags
            self.uiTemplate = uiTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, max: 63)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, min: 1)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9])*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.uiTemplate.validate(name: "\(name).uiTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiName = "HumanTaskUiName"
            case tags = "Tags"
            case uiTemplate = "UiTemplate"
        }
    }

    public struct CreateHumanTaskUiResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the human review workflow user interface you create.
        public let humanTaskUiArn: String

        public init(humanTaskUiArn: String) {
            self.humanTaskUiArn = humanTaskUiArn
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiArn = "HumanTaskUiArn"
        }
    }

    public struct CreateHyperParameterTuningJobRequest: AWSEncodableShape {
        /// The HyperParameterTuningJobConfig object that describes the tuning job, including the search strategy, the objective metric used to evaluate training jobs, ranges of parameters to search, and resource limits for the tuning job. For more information, see How Hyperparameter Tuning Works.
        public let hyperParameterTuningJobConfig: HyperParameterTuningJobConfig
        /// The name of the tuning job. This name is the prefix for the names of all training jobs that this tuning job launches. The name must be unique within the same Amazon Web Services account and Amazon Web Services Region. The name must have 1 to 32 characters. Valid characters are a-z, A-Z, 0-9, and : + = @ _ % - (hyphen). The name is not case sensitive.
        public let hyperParameterTuningJobName: String
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources. Tags that you specify for the tuning job are also added to all training jobs that the tuning job launches.
        public let tags: [Tag]?
        /// The HyperParameterTrainingJobDefinition object that describes the training jobs that this tuning job launches, including static hyperparameters, input data configuration, output data configuration, resource configuration, and stopping condition.
        public let trainingJobDefinition: HyperParameterTrainingJobDefinition?
        /// A list of the HyperParameterTrainingJobDefinition objects launched for this tuning job.
        public let trainingJobDefinitions: [HyperParameterTrainingJobDefinition]?
        /// Specifies the configuration for starting the hyperparameter tuning job using one or more previous tuning jobs as a starting point. The results of previous tuning jobs are used to inform which combinations of hyperparameters to search over in the new tuning job. All training jobs launched by the new hyperparameter tuning job are evaluated by using the objective metric. If you specify IDENTICAL_DATA_AND_ALGORITHM as the WarmStartType value for the warm start configuration, the training job that performs the best in the new tuning job is compared to the best training jobs from the parent tuning jobs. From these, the training job that performs the best as measured by the objective metric is returned as the overall best training job.  All training jobs launched by parent hyperparameter tuning jobs and the new hyperparameter tuning jobs count against the limit of training jobs for the tuning job.
        public let warmStartConfig: HyperParameterTuningJobWarmStartConfig?

        public init(hyperParameterTuningJobConfig: HyperParameterTuningJobConfig, hyperParameterTuningJobName: String, tags: [Tag]? = nil, trainingJobDefinition: HyperParameterTrainingJobDefinition? = nil, trainingJobDefinitions: [HyperParameterTrainingJobDefinition]? = nil, warmStartConfig: HyperParameterTuningJobWarmStartConfig? = nil) {
            self.hyperParameterTuningJobConfig = hyperParameterTuningJobConfig
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.tags = tags
            self.trainingJobDefinition = trainingJobDefinition
            self.trainingJobDefinitions = trainingJobDefinitions
            self.warmStartConfig = warmStartConfig
        }

        public func validate(name: String) throws {
            try self.hyperParameterTuningJobConfig.validate(name: "\(name).hyperParameterTuningJobConfig")
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, max: 32)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, min: 1)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.trainingJobDefinition?.validate(name: "\(name).trainingJobDefinition")
            try self.trainingJobDefinitions?.forEach {
                try $0.validate(name: "\(name).trainingJobDefinitions[]")
            }
            try self.validate(self.trainingJobDefinitions, name: "trainingJobDefinitions", parent: name, max: 10)
            try self.validate(self.trainingJobDefinitions, name: "trainingJobDefinitions", parent: name, min: 1)
            try self.warmStartConfig?.validate(name: "\(name).warmStartConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobConfig = "HyperParameterTuningJobConfig"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case tags = "Tags"
            case trainingJobDefinition = "TrainingJobDefinition"
            case trainingJobDefinitions = "TrainingJobDefinitions"
            case warmStartConfig = "WarmStartConfig"
        }
    }

    public struct CreateHyperParameterTuningJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the tuning job. SageMaker assigns an ARN to a hyperparameter tuning job when you create it.
        public let hyperParameterTuningJobArn: String

        public init(hyperParameterTuningJobArn: String) {
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
        }
    }

    public struct CreateImageRequest: AWSEncodableShape {
        /// The description of the image.
        public let description: String?
        /// The display name of the image. If not provided, ImageName is displayed.
        public let displayName: String?
        /// The name of the image. Must be unique to your account.
        public let imageName: String
        /// The ARN of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.
        public let roleArn: String
        /// A list of tags to apply to the image.
        public let tags: [Tag]?

        public init(description: String? = nil, displayName: String? = nil, imageName: String, roleArn: String, tags: [Tag]? = nil) {
            self.description = description
            self.displayName = displayName
            self.imageName = imageName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 128)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^\\S(.*\\S)?$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case imageName = "ImageName"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateImageResponse: AWSDecodableShape {
        /// The ARN of the image.
        public let imageArn: String?

        public init(imageArn: String? = nil) {
            self.imageArn = imageArn
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "ImageArn"
        }
    }

    public struct CreateImageVersionRequest: AWSEncodableShape {
        /// A list of aliases created with the image version.
        public let aliases: [String]?
        /// The registry path of the container image to use as the starting point for this version. The path is an Amazon Elastic Container Registry (ECR) URI in the following format:  .dkr.ecr..amazonaws.com/
        public let baseImage: String
        /// A unique ID. If not specified, the Amazon Web Services CLI and Amazon Web Services SDKs, such as the SDK for Python (Boto3), add a unique value to the call.
        public let clientToken: String
        /// Indicates Horovod compatibility.
        public let horovod: Bool?
        /// The ImageName of the Image to create a version of.
        public let imageName: String
        /// Indicates SageMaker job type compatibility.    TRAINING: The image version is compatible with SageMaker training jobs.    INFERENCE: The image version is compatible with SageMaker inference jobs.    NOTEBOOK_KERNEL: The image version is compatible with SageMaker notebook kernels.
        public let jobType: JobType?
        /// The machine learning framework vended in the image version.
        public let mlFramework: String?
        /// Indicates CPU or GPU compatibility.    CPU: The image version is compatible with CPU.    GPU: The image version is compatible with GPU.
        public let processor: Processor?
        /// The supported programming language and its version.
        public let programmingLang: String?
        /// The maintainer description of the image version.
        public let releaseNotes: String?
        /// The stability of the image version, specified by the maintainer.    NOT_PROVIDED: The maintainers did not provide a status for image version stability.    STABLE: The image version is stable.    TO_BE_ARCHIVED: The image version is set to be archived. Custom image versions that are set to be archived are automatically archived after three months.    ARCHIVED: The image version is archived. Archived image versions are not searchable and are no longer actively supported.
        public let vendorGuidance: VendorGuidance?

        public init(aliases: [String]? = nil, baseImage: String, clientToken: String = CreateImageVersionRequest.idempotencyToken(), horovod: Bool? = nil, imageName: String, jobType: JobType? = nil, mlFramework: String? = nil, processor: Processor? = nil, programmingLang: String? = nil, releaseNotes: String? = nil, vendorGuidance: VendorGuidance? = nil) {
            self.aliases = aliases
            self.baseImage = baseImage
            self.clientToken = clientToken
            self.horovod = horovod
            self.imageName = imageName
            self.jobType = jobType
            self.mlFramework = mlFramework
            self.processor = processor
            self.programmingLang = programmingLang
            self.releaseNotes = releaseNotes
            self.vendorGuidance = vendorGuidance
        }

        public func validate(name: String) throws {
            try self.aliases?.forEach {
                try validate($0, name: "aliases[]", parent: name, max: 128)
                try validate($0, name: "aliases[]", parent: name, min: 1)
                try validate($0, name: "aliases[]", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            }
            try self.validate(self.baseImage, name: "baseImage", parent: name, max: 255)
            try self.validate(self.baseImage, name: "baseImage", parent: name, min: 1)
            try self.validate(self.baseImage, name: "baseImage", parent: name, pattern: ".*")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, max: 128)
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, min: 1)
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, pattern: "^[a-zA-Z]+ ?\\d+\\.\\d+(\\.\\d+)?$")
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, max: 128)
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, min: 1)
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, pattern: "^[a-zA-Z]+ ?\\d+\\.\\d+(\\.\\d+)?$")
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, max: 255)
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, min: 1)
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case baseImage = "BaseImage"
            case clientToken = "ClientToken"
            case horovod = "Horovod"
            case imageName = "ImageName"
            case jobType = "JobType"
            case mlFramework = "MLFramework"
            case processor = "Processor"
            case programmingLang = "ProgrammingLang"
            case releaseNotes = "ReleaseNotes"
            case vendorGuidance = "VendorGuidance"
        }
    }

    public struct CreateImageVersionResponse: AWSDecodableShape {
        /// The ARN of the image version.
        public let imageVersionArn: String?

        public init(imageVersionArn: String? = nil) {
            self.imageVersionArn = imageVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionArn = "ImageVersionArn"
        }
    }

    public struct CreateInferenceExperimentRequest: AWSEncodableShape {
        ///  The Amazon S3 location and configuration for storing inference request and response data.   This is an optional parameter that you can use for data capture. For more information, see Capture data.
        public let dataStorageConfig: InferenceExperimentDataStorageConfig?
        /// A description for the inference experiment.
        public let description: String?
        ///  The name of the Amazon SageMaker endpoint on which you want to run the inference experiment.
        public let endpointName: String
        ///  The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.  The KmsKey can be any of the following formats:    KMS key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    Amazon Resource Name (ARN) of a KMS key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"    KMS key Alias  "alias/ExampleAlias"    Amazon Resource Name (ARN) of a KMS key Alias  "arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"     If you use a KMS key ID or an alias of your KMS key, the Amazon SageMaker execution role must include permissions to call kms:Encrypt. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. Amazon SageMaker uses server-side encryption with KMS managed keys for OutputDataConfig. If you use a bucket policy with an s3:PutObject permission that only allows objects with server-side encryption, set the condition key of s3:x-amz-server-side-encryption to "aws:kms". For more information, see KMS managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.   The KMS key policy must grant permission to the IAM role that you specify in your CreateEndpoint and UpdateEndpoint requests. For more information, see Using Key Policies in Amazon Web Services KMS in the Amazon Web Services Key Management Service Developer Guide.
        public let kmsKey: String?
        ///  An array of ModelVariantConfig objects. There is one for each variant in the inference experiment. Each ModelVariantConfig object in the array describes the infrastructure configuration for the corresponding variant.
        public let modelVariants: [ModelVariantConfig]
        /// The name for the inference experiment.
        public let name: String
        ///  The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and container images, and manage Amazon SageMaker Inference endpoints for model deployment.
        public let roleArn: String
        ///  The duration for which you want the inference experiment to run. If you don't specify this field, the experiment automatically starts immediately upon creation and concludes after 7 days.
        public let schedule: InferenceExperimentSchedule?
        ///  The configuration of ShadowMode inference experiment type. Use this field to specify a production variant which takes all the inference requests, and a shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant also specify the percentage of requests that Amazon SageMaker replicates.
        public let shadowModeConfig: ShadowModeConfig
        ///  Array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging your Amazon Web Services Resources.
        public let tags: [Tag]?
        ///  The type of the inference experiment that you want to run. The following types of experiments are possible:     ShadowMode: You can use this type to validate a shadow variant. For more information, see Shadow tests.
        public let type: InferenceExperimentType

        public init(dataStorageConfig: InferenceExperimentDataStorageConfig? = nil, description: String? = nil, endpointName: String, kmsKey: String? = nil, modelVariants: [ModelVariantConfig], name: String, roleArn: String, schedule: InferenceExperimentSchedule? = nil, shadowModeConfig: ShadowModeConfig, tags: [Tag]? = nil, type: InferenceExperimentType) {
            self.dataStorageConfig = dataStorageConfig
            self.description = description
            self.endpointName = endpointName
            self.kmsKey = kmsKey
            self.modelVariants = modelVariants
            self.name = name
            self.roleArn = roleArn
            self.schedule = schedule
            self.shadowModeConfig = shadowModeConfig
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.dataStorageConfig?.validate(name: "\(name).dataStorageConfig")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.modelVariants.forEach {
                try $0.validate(name: "\(name).modelVariants[]")
            }
            try self.validate(self.modelVariants, name: "modelVariants", parent: name, max: 2)
            try self.validate(self.modelVariants, name: "modelVariants", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.shadowModeConfig.validate(name: "\(name).shadowModeConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dataStorageConfig = "DataStorageConfig"
            case description = "Description"
            case endpointName = "EndpointName"
            case kmsKey = "KmsKey"
            case modelVariants = "ModelVariants"
            case name = "Name"
            case roleArn = "RoleArn"
            case schedule = "Schedule"
            case shadowModeConfig = "ShadowModeConfig"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN for your inference experiment.
        public let inferenceExperimentArn: String

        public init(inferenceExperimentArn: String) {
            self.inferenceExperimentArn = inferenceExperimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperimentArn = "InferenceExperimentArn"
        }
    }

    public struct CreateInferenceRecommendationsJobRequest: AWSEncodableShape {
        /// Provides information about the versioned model package Amazon Resource Name (ARN),  the traffic pattern, and endpoint configurations.
        public let inputConfig: RecommendationJobInputConfig
        /// Description of the recommendation job.
        public let jobDescription: String?
        /// A name for the recommendation job. The name must be unique within  the Amazon Web Services Region and within your Amazon Web Services account.
        public let jobName: String
        /// Defines the type of recommendation job. Specify Default to initiate an instance  recommendation and Advanced to initiate a load test. If left unspecified,  Amazon SageMaker Inference Recommender will run an instance recommendation (DEFAULT) job.
        public let jobType: RecommendationJobType
        /// Provides information about the output artifacts and the KMS key  to use for Amazon S3 server-side encryption.
        public let outputConfig: RecommendationJobOutputConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker  to perform tasks on your behalf.
        public let roleArn: String
        /// A set of conditions for stopping a recommendation job.  If any of  the conditions are met, the job is automatically stopped.
        public let stoppingConditions: RecommendationJobStoppingConditions?
        /// The metadata that you apply to Amazon Web Services resources to help you  categorize and organize them. Each tag consists of a key and a value, both of  which you define. For more information, see  Tagging Amazon Web Services Resources  in the Amazon Web Services General Reference.
        public let tags: [Tag]?

        public init(inputConfig: RecommendationJobInputConfig, jobDescription: String? = nil, jobName: String, jobType: RecommendationJobType, outputConfig: RecommendationJobOutputConfig? = nil, roleArn: String, stoppingConditions: RecommendationJobStoppingConditions? = nil, tags: [Tag]? = nil) {
            self.inputConfig = inputConfig
            self.jobDescription = jobDescription
            self.jobName = jobName
            self.jobType = jobType
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.stoppingConditions = stoppingConditions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.validate(self.jobDescription, name: "jobDescription", parent: name, max: 128)
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.outputConfig?.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingConditions?.validate(name: "\(name).stoppingConditions")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfig = "InputConfig"
            case jobDescription = "JobDescription"
            case jobName = "JobName"
            case jobType = "JobType"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case stoppingConditions = "StoppingConditions"
            case tags = "Tags"
        }
    }

    public struct CreateInferenceRecommendationsJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the recommendation job.
        public let jobArn: String

        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "JobArn"
        }
    }

    public struct CreateLabelingJobRequest: AWSEncodableShape {
        /// Configures the labeling task and how it is presented to workers; including, but not limited to price, keywords, and batch size (task count).
        public let humanTaskConfig: HumanTaskConfig
        /// Input data for the labeling job, such as the Amazon S3 location of the data objects and the location of the manifest file that describes the data objects. You must specify at least one of the following: S3DataSource or SnsDataSource.    Use SnsDataSource to specify an SNS input topic for a streaming labeling job. If you do not specify and SNS input topic ARN, Ground Truth will create a one-time labeling job that stops after all data objects in the input manifest file have been labeled.   Use S3DataSource to specify an input manifest file for both streaming and one-time labeling jobs. Adding an S3DataSource is optional if you use SnsDataSource to create a streaming labeling job.   If you use the Amazon Mechanical Turk workforce, your input data should not include confidential information, personal information or protected health information. Use ContentClassifiers to specify that your data is free of personally identifiable information and adult content.
        public let inputConfig: LabelingJobInputConfig
        /// The attribute name to use for the label in the output manifest file. This is the key for the key/value pair formed with the label that a worker assigns to the object. The LabelAttributeName must meet the following requirements.   The name can't end with "-metadata".    If you are using one of the following built-in task types, the attribute name must end with "-ref". If the task type you are using is not listed below, the attribute name must not end with "-ref".   Image semantic segmentation (SemanticSegmentation), and adjustment (AdjustmentSemanticSegmentation) and verification (VerificationSemanticSegmentation) labeling jobs for this task type.   Video frame object detection (VideoObjectDetection), and adjustment and verification (AdjustmentVideoObjectDetection) labeling jobs for this task type.   Video frame object tracking (VideoObjectTracking), and adjustment and verification (AdjustmentVideoObjectTracking) labeling jobs for this task type.   3D point cloud semantic segmentation (3DPointCloudSemanticSegmentation), and adjustment and verification (Adjustment3DPointCloudSemanticSegmentation) labeling jobs for this task type.    3D point cloud object tracking (3DPointCloudObjectTracking), and adjustment and verification (Adjustment3DPointCloudObjectTracking) labeling jobs for this task type.        If you are creating an adjustment or verification labeling job, you must use a different LabelAttributeName than the one used in the original labeling job. The original labeling job is the Ground Truth labeling job that produced the labels that you want verified or adjusted. To learn more about adjustment and verification labeling jobs, see Verify and Adjust Labels.
        public let labelAttributeName: String
        /// The S3 URI of the file, referred to as a label category configuration file, that defines the categories used to label the data objects. For 3D point cloud and video frame task types, you can add label category attributes and frame attributes to your label category configuration file. To learn how, see Create a Labeling Category Configuration File for 3D Point Cloud Labeling Jobs.  For named entity recognition jobs, in addition to "labels", you must provide worker instructions in the label category configuration file using the "instructions" parameter: "instructions": {"shortInstruction":"Add headerAdd Instructions", "fullInstruction":"Add additional instructions."}. For details and an example, see Create a Named Entity Recognition Labeling Job (API) . For all other built-in task types and custom tasks, your label category configuration file must be a JSON file in the following format. Identify the labels you want to use by replacing label_1, label_2,...,label_n with your label categories.  {    "document-version": "2018-11-28",   "labels": [{"label": "label_1"},{"label": "label_2"},...{"label": "label_n"}]   }  Note the following about the label category configuration file:   For image classification and text classification (single and multi-label) you must specify at least two label categories. For all other task types, the minimum number of label categories required is one.    Each label category must be unique, you cannot specify duplicate label categories.   If you create a 3D point cloud or video frame adjustment or verification labeling job, you must include auditLabelAttributeName in the label category configuration. Use this parameter to enter the  LabelAttributeName of the labeling job you want to adjust or verify annotations of.
        public let labelCategoryConfigS3Uri: String?
        /// Configures the information required to perform automated data labeling.
        public let labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig?
        /// The name of the labeling job. This name is used to identify the job in a list of labeling jobs. Labeling job names must be unique within an Amazon Web Services account and region. LabelingJobName is not case sensitive. For example, Example-job and example-job are considered the same labeling job name by Ground Truth.
        public let labelingJobName: String
        /// The location of the output data and the Amazon Web Services Key Management Service key ID for the key used to encrypt the output data, if any.
        public let outputConfig: LabelingJobOutputConfig
        /// The Amazon Resource Number (ARN) that Amazon SageMaker assumes to perform tasks on your behalf during data labeling. You must grant this role the necessary permissions so that Amazon SageMaker can successfully complete data labeling.
        public let roleArn: String
        /// A set of conditions for stopping the labeling job. If any of the conditions are met, the job is automatically stopped. You can use these conditions to control the cost of data labeling.
        public let stoppingConditions: LabelingJobStoppingConditions?
        /// An array of key/value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(humanTaskConfig: HumanTaskConfig, inputConfig: LabelingJobInputConfig, labelAttributeName: String, labelCategoryConfigS3Uri: String? = nil, labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig? = nil, labelingJobName: String, outputConfig: LabelingJobOutputConfig, roleArn: String, stoppingConditions: LabelingJobStoppingConditions? = nil, tags: [Tag]? = nil) {
            self.humanTaskConfig = humanTaskConfig
            self.inputConfig = inputConfig
            self.labelAttributeName = labelAttributeName
            self.labelCategoryConfigS3Uri = labelCategoryConfigS3Uri
            self.labelingJobAlgorithmsConfig = labelingJobAlgorithmsConfig
            self.labelingJobName = labelingJobName
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.stoppingConditions = stoppingConditions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.humanTaskConfig.validate(name: "\(name).humanTaskConfig")
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.validate(self.labelAttributeName, name: "labelAttributeName", parent: name, max: 127)
            try self.validate(self.labelAttributeName, name: "labelAttributeName", parent: name, min: 1)
            try self.validate(self.labelAttributeName, name: "labelAttributeName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,126}$")
            try self.validate(self.labelCategoryConfigS3Uri, name: "labelCategoryConfigS3Uri", parent: name, max: 1024)
            try self.validate(self.labelCategoryConfigS3Uri, name: "labelCategoryConfigS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.labelingJobAlgorithmsConfig?.validate(name: "\(name).labelingJobAlgorithmsConfig")
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, max: 63)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, min: 1)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingConditions?.validate(name: "\(name).stoppingConditions")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskConfig = "HumanTaskConfig"
            case inputConfig = "InputConfig"
            case labelAttributeName = "LabelAttributeName"
            case labelCategoryConfigS3Uri = "LabelCategoryConfigS3Uri"
            case labelingJobAlgorithmsConfig = "LabelingJobAlgorithmsConfig"
            case labelingJobName = "LabelingJobName"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case stoppingConditions = "StoppingConditions"
            case tags = "Tags"
        }
    }

    public struct CreateLabelingJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the labeling job. You use this ARN to identify the labeling job.
        public let labelingJobArn: String

        public init(labelingJobArn: String) {
            self.labelingJobArn = labelingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobArn = "LabelingJobArn"
        }
    }

    public struct CreateModelBiasJobDefinitionRequest: AWSEncodableShape {
        /// The name of the bias job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Configures the model bias job to run a specified Docker container image.
        public let modelBiasAppSpecification: ModelBiasAppSpecification
        /// The baseline configuration for a model bias job.
        public let modelBiasBaselineConfig: ModelBiasBaselineConfig?
        /// Inputs for the model bias job.
        public let modelBiasJobInput: ModelBiasJobInput
        public let modelBiasJobOutputConfig: MonitoringOutputConfig
        /// Networking options for a model bias job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(jobDefinitionName: String, jobResources: MonitoringResources, modelBiasAppSpecification: ModelBiasAppSpecification, modelBiasBaselineConfig: ModelBiasBaselineConfig? = nil, modelBiasJobInput: ModelBiasJobInput, modelBiasJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil, tags: [Tag]? = nil) {
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelBiasAppSpecification = modelBiasAppSpecification
            self.modelBiasBaselineConfig = modelBiasBaselineConfig
            self.modelBiasJobInput = modelBiasJobInput
            self.modelBiasJobOutputConfig = modelBiasJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.jobResources.validate(name: "\(name).jobResources")
            try self.modelBiasAppSpecification.validate(name: "\(name).modelBiasAppSpecification")
            try self.modelBiasBaselineConfig?.validate(name: "\(name).modelBiasBaselineConfig")
            try self.modelBiasJobInput.validate(name: "\(name).modelBiasJobInput")
            try self.modelBiasJobOutputConfig.validate(name: "\(name).modelBiasJobOutputConfig")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelBiasAppSpecification = "ModelBiasAppSpecification"
            case modelBiasBaselineConfig = "ModelBiasBaselineConfig"
            case modelBiasJobInput = "ModelBiasJobInput"
            case modelBiasJobOutputConfig = "ModelBiasJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
        }
    }

    public struct CreateModelBiasJobDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model bias job.
        public let jobDefinitionArn: String

        public init(jobDefinitionArn: String) {
            self.jobDefinitionArn = jobDefinitionArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionArn = "JobDefinitionArn"
        }
    }

    public struct CreateModelCardExportJobRequest: AWSEncodableShape {
        /// The name of the model card export job.
        public let modelCardExportJobName: String
        /// The name of the model card to export.
        public let modelCardName: String
        /// The version of the model card to export. If a version is not provided, then the latest version of the model card is exported.
        public let modelCardVersion: Int?
        /// The model card output configuration that specifies the Amazon S3 path for exporting.
        public let outputConfig: ModelCardExportOutputConfig

        public init(modelCardExportJobName: String, modelCardName: String, modelCardVersion: Int? = nil, outputConfig: ModelCardExportOutputConfig) {
            self.modelCardExportJobName = modelCardExportJobName
            self.modelCardName = modelCardName
            self.modelCardVersion = modelCardVersion
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.modelCardExportJobName, name: "modelCardExportJobName", parent: name, max: 63)
            try self.validate(self.modelCardExportJobName, name: "modelCardExportJobName", parent: name, min: 1)
            try self.validate(self.modelCardExportJobName, name: "modelCardExportJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardExportJobName = "ModelCardExportJobName"
            case modelCardName = "ModelCardName"
            case modelCardVersion = "ModelCardVersion"
            case outputConfig = "OutputConfig"
        }
    }

    public struct CreateModelCardExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model card export job.
        public let modelCardExportJobArn: String

        public init(modelCardExportJobArn: String) {
            self.modelCardExportJobArn = modelCardExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardExportJobArn = "ModelCardExportJobArn"
        }
    }

    public struct CreateModelCardRequest: AWSEncodableShape {
        /// The content of the model card. Content must be in model card JSON schema and provided as a string.
        public let content: String
        /// The unique name of the model card.
        public let modelCardName: String
        /// The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus
        /// An optional Key Management Service  key to encrypt, decrypt, and re-encrypt model card content for regulated workloads with highly sensitive data.
        public let securityConfig: ModelCardSecurityConfig?
        /// Key-value pairs used to manage metadata for model cards.
        public let tags: [Tag]?

        public init(content: String, modelCardName: String, modelCardStatus: ModelCardStatus, securityConfig: ModelCardSecurityConfig? = nil, tags: [Tag]? = nil) {
            self.content = content
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
            self.securityConfig = securityConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 100_000)
            try self.validate(self.content, name: "content", parent: name, pattern: ".*")
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.securityConfig?.validate(name: "\(name).securityConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
            case securityConfig = "SecurityConfig"
            case tags = "Tags"
        }
    }

    public struct CreateModelCardResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the successfully created model card.
        public let modelCardArn: String

        public init(modelCardArn: String) {
            self.modelCardArn = modelCardArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardArn = "ModelCardArn"
        }
    }

    public struct CreateModelExplainabilityJobDefinitionRequest: AWSEncodableShape {
        ///  The name of the model explainability job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Configures the model explainability job to run a specified Docker container image.
        public let modelExplainabilityAppSpecification: ModelExplainabilityAppSpecification
        /// The baseline configuration for a model explainability job.
        public let modelExplainabilityBaselineConfig: ModelExplainabilityBaselineConfig?
        /// Inputs for the model explainability job.
        public let modelExplainabilityJobInput: ModelExplainabilityJobInput
        public let modelExplainabilityJobOutputConfig: MonitoringOutputConfig
        /// Networking options for a model explainability job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(jobDefinitionName: String, jobResources: MonitoringResources, modelExplainabilityAppSpecification: ModelExplainabilityAppSpecification, modelExplainabilityBaselineConfig: ModelExplainabilityBaselineConfig? = nil, modelExplainabilityJobInput: ModelExplainabilityJobInput, modelExplainabilityJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil, tags: [Tag]? = nil) {
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelExplainabilityAppSpecification = modelExplainabilityAppSpecification
            self.modelExplainabilityBaselineConfig = modelExplainabilityBaselineConfig
            self.modelExplainabilityJobInput = modelExplainabilityJobInput
            self.modelExplainabilityJobOutputConfig = modelExplainabilityJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.jobResources.validate(name: "\(name).jobResources")
            try self.modelExplainabilityAppSpecification.validate(name: "\(name).modelExplainabilityAppSpecification")
            try self.modelExplainabilityBaselineConfig?.validate(name: "\(name).modelExplainabilityBaselineConfig")
            try self.modelExplainabilityJobInput.validate(name: "\(name).modelExplainabilityJobInput")
            try self.modelExplainabilityJobOutputConfig.validate(name: "\(name).modelExplainabilityJobOutputConfig")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelExplainabilityAppSpecification = "ModelExplainabilityAppSpecification"
            case modelExplainabilityBaselineConfig = "ModelExplainabilityBaselineConfig"
            case modelExplainabilityJobInput = "ModelExplainabilityJobInput"
            case modelExplainabilityJobOutputConfig = "ModelExplainabilityJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
        }
    }

    public struct CreateModelExplainabilityJobDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model explainability job.
        public let jobDefinitionArn: String

        public init(jobDefinitionArn: String) {
            self.jobDefinitionArn = jobDefinitionArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionArn = "JobDefinitionArn"
        }
    }

    public struct CreateModelInput: AWSEncodableShape {
        /// Specifies the containers in the inference pipeline.
        public let containers: [ContainerDefinition]?
        /// Isolates the model container. No inbound or outbound network calls can be made to or from the model container.
        public let enableNetworkIsolation: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that SageMaker can assume to access model artifacts and docker image for deployment on ML compute instances or for batch transform jobs. Deploying on ML compute instances is part of model hosting. For more information, see SageMaker Roles.   To be able to pass this role to SageMaker, the caller of this API must have the iam:PassRole permission.
        public let executionRoleArn: String
        /// Specifies details of how containers in a multi-container endpoint are called.
        public let inferenceExecutionConfig: InferenceExecutionConfig?
        /// The name of the new model.
        public let modelName: String
        /// The location of the primary docker image containing inference code, associated artifacts, and custom environment map that the inference code uses when the model is deployed for predictions.
        public let primaryContainer: ContainerDefinition?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        /// A VpcConfig object that specifies the VPC that you want your model to connect to. Control access to and from your model container by configuring the VPC. VpcConfig is used in hosting services and in batch transform. For more information, see Protect Endpoints by Using an Amazon Virtual Private Cloud and Protect Data in Batch Transform Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?

        public init(containers: [ContainerDefinition]? = nil, enableNetworkIsolation: Bool? = nil, executionRoleArn: String, inferenceExecutionConfig: InferenceExecutionConfig? = nil, modelName: String, primaryContainer: ContainerDefinition? = nil, tags: [Tag]? = nil, vpcConfig: VpcConfig? = nil) {
            self.containers = containers
            self.enableNetworkIsolation = enableNetworkIsolation
            self.executionRoleArn = executionRoleArn
            self.inferenceExecutionConfig = inferenceExecutionConfig
            self.modelName = modelName
            self.primaryContainer = primaryContainer
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.containers?.forEach {
                try $0.validate(name: "\(name).containers[]")
            }
            try self.validate(self.containers, name: "containers", parent: name, max: 15)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.primaryContainer?.validate(name: "\(name).primaryContainer")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case executionRoleArn = "ExecutionRoleArn"
            case inferenceExecutionConfig = "InferenceExecutionConfig"
            case modelName = "ModelName"
            case primaryContainer = "PrimaryContainer"
            case tags = "Tags"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct CreateModelOutput: AWSDecodableShape {
        /// The ARN of the model created in SageMaker.
        public let modelArn: String

        public init(modelArn: String) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "ModelArn"
        }
    }

    public struct CreateModelPackageGroupInput: AWSEncodableShape {
        /// A description for the model group.
        public let modelPackageGroupDescription: String?
        /// The name of the model group.
        public let modelPackageGroupName: String
        /// A list of key value pairs associated with the model group. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        public init(modelPackageGroupDescription: String? = nil, modelPackageGroupName: String, tags: [Tag]? = nil) {
            self.modelPackageGroupDescription = modelPackageGroupDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupDescription, name: "modelPackageGroupDescription", parent: name, max: 1024)
            try self.validate(self.modelPackageGroupDescription, name: "modelPackageGroupDescription", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 63)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupDescription = "ModelPackageGroupDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case tags = "Tags"
        }
    }

    public struct CreateModelPackageGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model group.
        public let modelPackageGroupArn: String

        public init(modelPackageGroupArn: String) {
            self.modelPackageGroupArn = modelPackageGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupArn = "ModelPackageGroupArn"
        }
    }

    public struct CreateModelPackageInput: AWSEncodableShape {
        /// An array of additional Inference Specification objects. Each additional  Inference Specification specifies artifacts based on this model package that can  be used on inference endpoints. Generally used with SageMaker Neo to store the  compiled artifacts.
        public let additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]?
        /// Whether to certify the model package for listing on Amazon Web Services Marketplace. This parameter is optional for unversioned models, and does not apply to versioned models.
        public let certifyForMarketplace: Bool?
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The metadata properties associated with the model package versions.
        public let customerMetadataProperties: [String: String]?
        /// The machine learning domain of your model package and its components. Common  machine learning domains include computer vision and natural language processing.
        public let domain: String?
        /// Represents the drift check baselines that can be used when the model monitor is set using the model package. For more information, see the topic on Drift Detection against Previous Baselines in SageMaker Pipelines in the Amazon SageMaker Developer Guide.
        public let driftCheckBaselines: DriftCheckBaselines?
        /// Specifies details about inference jobs that can be run with models based on this model package, including the following:   The Amazon ECR paths of containers that contain the inference code and model artifacts.   The instance types that the model package supports for transform jobs and real-time endpoints used for inference.   The input and output content formats that the model package supports for inference.
        public let inferenceSpecification: InferenceSpecification?
        public let metadataProperties: MetadataProperties?
        /// Whether the model is approved for deployment. This parameter is optional for versioned models, and does not apply to unversioned models. For versioned models, the value of this parameter must be set to Approved to deploy the model.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// A structure that contains model metrics reports.
        public let modelMetrics: ModelMetrics?
        /// A description of the model package.
        public let modelPackageDescription: String?
        /// The name or Amazon Resource Name (ARN) of the model package group that this model version belongs to. This parameter is required for versioned models, and does not apply to unversioned models.
        public let modelPackageGroupName: String?
        /// The name of the model package. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen). This parameter is required for unversioned models. It is not applicable to versioned models.
        public let modelPackageName: String?
        /// The Amazon Simple Storage Service (Amazon S3) path where the sample payload are stored. This path must point  to a single gzip compressed tar archive (.tar.gz suffix).
        public let samplePayloadUrl: String?
        /// Details about the algorithm that was used to create the model package.
        public let sourceAlgorithmSpecification: SourceAlgorithmSpecification?
        /// A list of key value pairs associated with the model. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?
        /// The machine learning task your model package accomplishes. Common machine  learning tasks include object detection and image classification. The following  tasks are supported by Inference Recommender:  "IMAGE_CLASSIFICATION" | "OBJECT_DETECTION" | "TEXT_GENERATION" |"IMAGE_SEGMENTATION" |  "FILL_MASK" | "CLASSIFICATION" | "REGRESSION" | "OTHER". Specify "OTHER" if none of the tasks listed fit your use case.
        public let task: String?
        /// Specifies configurations for one or more transform jobs that SageMaker runs to test the model package.
        public let validationSpecification: ModelPackageValidationSpecification?

        public init(additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]? = nil, certifyForMarketplace: Bool? = nil, clientToken: String? = CreateModelPackageInput.idempotencyToken(), customerMetadataProperties: [String: String]? = nil, domain: String? = nil, driftCheckBaselines: DriftCheckBaselines? = nil, inferenceSpecification: InferenceSpecification? = nil, metadataProperties: MetadataProperties? = nil, modelApprovalStatus: ModelApprovalStatus? = nil, modelMetrics: ModelMetrics? = nil, modelPackageDescription: String? = nil, modelPackageGroupName: String? = nil, modelPackageName: String? = nil, samplePayloadUrl: String? = nil, sourceAlgorithmSpecification: SourceAlgorithmSpecification? = nil, tags: [Tag]? = nil, task: String? = nil, validationSpecification: ModelPackageValidationSpecification? = nil) {
            self.additionalInferenceSpecifications = additionalInferenceSpecifications
            self.certifyForMarketplace = certifyForMarketplace
            self.clientToken = clientToken
            self.customerMetadataProperties = customerMetadataProperties
            self.domain = domain
            self.driftCheckBaselines = driftCheckBaselines
            self.inferenceSpecification = inferenceSpecification
            self.metadataProperties = metadataProperties
            self.modelApprovalStatus = modelApprovalStatus
            self.modelMetrics = modelMetrics
            self.modelPackageDescription = modelPackageDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageName = modelPackageName
            self.samplePayloadUrl = samplePayloadUrl
            self.sourceAlgorithmSpecification = sourceAlgorithmSpecification
            self.tags = tags
            self.task = task
            self.validationSpecification = validationSpecification
        }

        public func validate(name: String) throws {
            try self.additionalInferenceSpecifications?.forEach {
                try $0.validate(name: "\(name).additionalInferenceSpecifications[]")
            }
            try self.validate(self.additionalInferenceSpecifications, name: "additionalInferenceSpecifications", parent: name, max: 15)
            try self.validate(self.additionalInferenceSpecifications, name: "additionalInferenceSpecifications", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.customerMetadataProperties?.forEach {
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, max: 128)
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, min: 1)
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,128}$")
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,256}$")
            }
            try self.validate(self.customerMetadataProperties, name: "customerMetadataProperties", parent: name, max: 50)
            try self.validate(self.customerMetadataProperties, name: "customerMetadataProperties", parent: name, min: 1)
            try self.driftCheckBaselines?.validate(name: "\(name).driftCheckBaselines")
            try self.inferenceSpecification?.validate(name: "\(name).inferenceSpecification")
            try self.metadataProperties?.validate(name: "\(name).metadataProperties")
            try self.modelMetrics?.validate(name: "\(name).modelMetrics")
            try self.validate(self.modelPackageDescription, name: "modelPackageDescription", parent: name, max: 1024)
            try self.validate(self.modelPackageDescription, name: "modelPackageDescription", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 170)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, max: 63)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, min: 1)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.samplePayloadUrl, name: "samplePayloadUrl", parent: name, max: 1024)
            try self.validate(self.samplePayloadUrl, name: "samplePayloadUrl", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.sourceAlgorithmSpecification?.validate(name: "\(name).sourceAlgorithmSpecification")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validationSpecification?.validate(name: "\(name).validationSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInferenceSpecifications = "AdditionalInferenceSpecifications"
            case certifyForMarketplace = "CertifyForMarketplace"
            case clientToken = "ClientToken"
            case customerMetadataProperties = "CustomerMetadataProperties"
            case domain = "Domain"
            case driftCheckBaselines = "DriftCheckBaselines"
            case inferenceSpecification = "InferenceSpecification"
            case metadataProperties = "MetadataProperties"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelMetrics = "ModelMetrics"
            case modelPackageDescription = "ModelPackageDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageName = "ModelPackageName"
            case samplePayloadUrl = "SamplePayloadUrl"
            case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
            case tags = "Tags"
            case task = "Task"
            case validationSpecification = "ValidationSpecification"
        }
    }

    public struct CreateModelPackageOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new model package.
        public let modelPackageArn: String

        public init(modelPackageArn: String) {
            self.modelPackageArn = modelPackageArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageArn = "ModelPackageArn"
        }
    }

    public struct CreateModelQualityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the monitoring job definition.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// The container that runs the monitoring job.
        public let modelQualityAppSpecification: ModelQualityAppSpecification
        /// Specifies the constraints and baselines for the monitoring job.
        public let modelQualityBaselineConfig: ModelQualityBaselineConfig?
        /// A list of the inputs that are monitored. Currently endpoints are supported.
        public let modelQualityJobInput: ModelQualityJobInput
        public let modelQualityJobOutputConfig: MonitoringOutputConfig
        /// Specifies the network configuration for the monitoring job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(jobDefinitionName: String, jobResources: MonitoringResources, modelQualityAppSpecification: ModelQualityAppSpecification, modelQualityBaselineConfig: ModelQualityBaselineConfig? = nil, modelQualityJobInput: ModelQualityJobInput, modelQualityJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil, tags: [Tag]? = nil) {
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelQualityAppSpecification = modelQualityAppSpecification
            self.modelQualityBaselineConfig = modelQualityBaselineConfig
            self.modelQualityJobInput = modelQualityJobInput
            self.modelQualityJobOutputConfig = modelQualityJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.jobResources.validate(name: "\(name).jobResources")
            try self.modelQualityAppSpecification.validate(name: "\(name).modelQualityAppSpecification")
            try self.modelQualityBaselineConfig?.validate(name: "\(name).modelQualityBaselineConfig")
            try self.modelQualityJobInput.validate(name: "\(name).modelQualityJobInput")
            try self.modelQualityJobOutputConfig.validate(name: "\(name).modelQualityJobOutputConfig")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelQualityAppSpecification = "ModelQualityAppSpecification"
            case modelQualityBaselineConfig = "ModelQualityBaselineConfig"
            case modelQualityJobInput = "ModelQualityJobInput"
            case modelQualityJobOutputConfig = "ModelQualityJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
        }
    }

    public struct CreateModelQualityJobDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model quality monitoring job.
        public let jobDefinitionArn: String

        public init(jobDefinitionArn: String) {
            self.jobDefinitionArn = jobDefinitionArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionArn = "JobDefinitionArn"
        }
    }

    public struct CreateMonitoringScheduleRequest: AWSEncodableShape {
        /// The configuration object that specifies the monitoring schedule and defines the monitoring job.
        public let monitoringScheduleConfig: MonitoringScheduleConfig
        /// The name of the monitoring schedule. The name must be unique within an Amazon Web Services Region within an Amazon Web Services account.
        public let monitoringScheduleName: String
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(monitoringScheduleConfig: MonitoringScheduleConfig, monitoringScheduleName: String, tags: [Tag]? = nil) {
            self.monitoringScheduleConfig = monitoringScheduleConfig
            self.monitoringScheduleName = monitoringScheduleName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.monitoringScheduleConfig.validate(name: "\(name).monitoringScheduleConfig")
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleConfig = "MonitoringScheduleConfig"
            case monitoringScheduleName = "MonitoringScheduleName"
            case tags = "Tags"
        }
    }

    public struct CreateMonitoringScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String

        public init(monitoringScheduleArn: String) {
            self.monitoringScheduleArn = monitoringScheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleArn = "MonitoringScheduleArn"
        }
    }

    public struct CreateNotebookInstanceInput: AWSEncodableShape {
        /// A list of Elastic Inference (EI) instance types to associate with this notebook instance. Currently, only one instance type can be associated with a notebook instance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        /// An array of up to three Git repositories to associate with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in Amazon Web Services CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// A Git repository to associate with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in Amazon Web Services CodeCommit or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// Sets whether SageMaker provides internet access to the notebook instance. If you set this to Disabled this notebook instance is able to access resources only in your VPC, and is not be able to connect to SageMaker training and endpoint services unless you configure a NAT Gateway in your VPC. For more information, see Notebook Instances Are Internet-Enabled by Default. You can set the value of this parameter to Disabled only if you set a value for the SubnetId parameter.
        public let directInternetAccess: DirectInternetAccess?
        /// Information on the IMDS configuration of the notebook instance
        public let instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration?
        /// The type of ML compute instance to launch for the notebook instance.
        public let instanceType: InstanceType
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt data on the storage volume attached to your notebook instance. The KMS key you provide must be enabled. For information, see Enabling and Disabling Keys in the Amazon Web Services Key Management Service Developer Guide.
        public let kmsKeyId: String?
        /// The name of a lifecycle configuration to associate with the notebook instance. For information about lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let lifecycleConfigName: String?
        /// The name of the new notebook instance.
        public let notebookInstanceName: String
        /// The platform identifier of the notebook instance runtime environment.
        public let platformIdentifier: String?
        ///  When you send any requests to Amazon Web Services resources from the notebook instance, SageMaker assumes this role to perform tasks on your behalf. You must grant this role necessary permissions so SageMaker can perform these tasks. The policy must allow the SageMaker service principal (sagemaker.amazonaws.com) permissions to assume this role. For more information, see SageMaker Roles.   To be able to pass this role to SageMaker, the caller of this API must have the iam:PassRole permission.
        public let roleArn: String
        /// Whether root access is enabled or disabled for users of the notebook instance. The default value is Enabled.  Lifecycle configurations need root access to be able to set up a notebook instance. Because of this, lifecycle configurations associated with a notebook instance always run with root access even if you disable root access for users.
        public let rootAccess: RootAccess?
        /// The VPC security group IDs, in the form sg-xxxxxxxx. The security groups must be for the same VPC as specified in the subnet.
        public let securityGroupIds: [String]?
        /// The ID of the subnet in a VPC to which you would like to have a connectivity from your ML compute instance.
        public let subnetId: String?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        /// The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB.
        public let volumeSizeInGB: Int?

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, directInternetAccess: DirectInternetAccess? = nil, instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration? = nil, instanceType: InstanceType, kmsKeyId: String? = nil, lifecycleConfigName: String? = nil, notebookInstanceName: String, platformIdentifier: String? = nil, roleArn: String, rootAccess: RootAccess? = nil, securityGroupIds: [String]? = nil, subnetId: String? = nil, tags: [Tag]? = nil, volumeSizeInGB: Int? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.lifecycleConfigName = lifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
            self.tags = tags
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.additionalCodeRepositories?.forEach {
                try validate($0, name: "additionalCodeRepositories[]", parent: name, max: 1024)
                try validate($0, name: "additionalCodeRepositories[]", parent: name, min: 1)
                try validate($0, name: "additionalCodeRepositories[]", parent: name, pattern: "^https://([^/]+)/?(.*)$|^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            }
            try self.validate(self.additionalCodeRepositories, name: "additionalCodeRepositories", parent: name, max: 3)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, max: 1024)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, min: 1)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, pattern: "^https://([^/]+)/?(.*)$|^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.instanceMetadataServiceConfiguration?.validate(name: "\(name).instanceMetadataServiceConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.lifecycleConfigName, name: "lifecycleConfigName", parent: name, max: 63)
            try self.validate(self.lifecycleConfigName, name: "lifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.platformIdentifier, name: "platformIdentifier", parent: name, max: 15)
            try self.validate(self.platformIdentifier, name: "platformIdentifier", parent: name, pattern: "^(notebook-al1-v1|notebook-al2-v1|notebook-al2-v2)$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 32)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, max: 16384)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case defaultCodeRepository = "DefaultCodeRepository"
            case directInternetAccess = "DirectInternetAccess"
            case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
            case instanceType = "InstanceType"
            case kmsKeyId = "KmsKeyId"
            case lifecycleConfigName = "LifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case platformIdentifier = "PlatformIdentifier"
            case roleArn = "RoleArn"
            case rootAccess = "RootAccess"
            case securityGroupIds = "SecurityGroupIds"
            case subnetId = "SubnetId"
            case tags = "Tags"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct CreateNotebookInstanceLifecycleConfigInput: AWSEncodableShape {
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String
        /// A shell script that runs only once, when you create a notebook instance. The shell script must be a base64-encoded string.
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// A shell script that runs every time you start a notebook instance, including when you create the notebook instance. The shell script must be a base64-encoded string.
        public let onStart: [NotebookInstanceLifecycleHook]?

        public init(notebookInstanceLifecycleConfigName: String, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.onCreate = onCreate
            self.onStart = onStart
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.onCreate?.forEach {
                try $0.validate(name: "\(name).onCreate[]")
            }
            try self.validate(self.onCreate, name: "onCreate", parent: name, max: 1)
            try self.onStart?.forEach {
                try $0.validate(name: "\(name).onStart[]")
            }
            try self.validate(self.onStart, name: "onStart", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case onCreate = "OnCreate"
            case onStart = "OnStart"
        }
    }

    public struct CreateNotebookInstanceLifecycleConfigOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String?

        public init(notebookInstanceLifecycleConfigArn: String? = nil) {
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
        }
    }

    public struct CreateNotebookInstanceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String?

        public init(notebookInstanceArn: String? = nil) {
            self.notebookInstanceArn = notebookInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceArn = "NotebookInstanceArn"
        }
    }

    public struct CreatePipelineRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time.
        public let clientRequestToken: String
        /// This is the configuration that controls the parallelism of the pipeline.  If specified, it applies to all runs of this pipeline by default.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The JSON pipeline definition of the pipeline.
        public let pipelineDefinition: String?
        /// The location of the pipeline definition stored in Amazon S3. If specified,  SageMaker will retrieve the pipeline definition from this location.
        public let pipelineDefinitionS3Location: PipelineDefinitionS3Location?
        /// A description of the pipeline.
        public let pipelineDescription: String?
        /// The display name of the pipeline.
        public let pipelineDisplayName: String?
        /// The name of the pipeline.
        public let pipelineName: String
        /// The Amazon Resource Name (ARN) of the role used by the pipeline to access and create resources.
        public let roleArn: String
        /// A list of tags to apply to the created pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String = CreatePipelineRequest.idempotencyToken(), parallelismConfiguration: ParallelismConfiguration? = nil, pipelineDefinition: String? = nil, pipelineDefinitionS3Location: PipelineDefinitionS3Location? = nil, pipelineDescription: String? = nil, pipelineDisplayName: String? = nil, pipelineName: String, roleArn: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineDefinition = pipelineDefinition
            self.pipelineDefinitionS3Location = pipelineDefinitionS3Location
            self.pipelineDescription = pipelineDescription
            self.pipelineDisplayName = pipelineDisplayName
            self.pipelineName = pipelineName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, max: 1_048_576)
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, min: 1)
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, pattern: "(?:[ \\r\\n\\t].*)*$")
            try self.pipelineDefinitionS3Location?.validate(name: "\(name).pipelineDefinitionS3Location")
            try self.validate(self.pipelineDescription, name: "pipelineDescription", parent: name, max: 3072)
            try self.validate(self.pipelineDescription, name: "pipelineDescription", parent: name, pattern: ".*")
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, max: 256)
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, min: 1)
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 256)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineDefinition = "PipelineDefinition"
            case pipelineDefinitionS3Location = "PipelineDefinitionS3Location"
            case pipelineDescription = "PipelineDescription"
            case pipelineDisplayName = "PipelineDisplayName"
            case pipelineName = "PipelineName"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreatePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created pipeline.
        public let pipelineArn: String?

        public init(pipelineArn: String? = nil) {
            self.pipelineArn = pipelineArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineArn = "PipelineArn"
        }
    }

    public struct CreatePresignedDomainUrlRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String
        /// The number of seconds until the pre-signed URL expires. This value defaults to 300.
        public let expiresInSeconds: Int?
        /// The session expiration duration in seconds. This value defaults to 43200.
        public let sessionExpirationDurationInSeconds: Int?
        /// The name of the space.
        public let spaceName: String?
        /// The name of the UserProfile to sign-in as.
        public let userProfileName: String

        public init(domainId: String, expiresInSeconds: Int? = nil, sessionExpirationDurationInSeconds: Int? = nil, spaceName: String? = nil, userProfileName: String) {
            self.domainId = domainId
            self.expiresInSeconds = expiresInSeconds
            self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
            self.spaceName = spaceName
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.expiresInSeconds, name: "expiresInSeconds", parent: name, max: 300)
            try self.validate(self.expiresInSeconds, name: "expiresInSeconds", parent: name, min: 5)
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, max: 43200)
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, min: 1800)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case expiresInSeconds = "ExpiresInSeconds"
            case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
            case spaceName = "SpaceName"
            case userProfileName = "UserProfileName"
        }
    }

    public struct CreatePresignedDomainUrlResponse: AWSDecodableShape {
        /// The presigned URL.
        public let authorizedUrl: String?

        public init(authorizedUrl: String? = nil) {
            self.authorizedUrl = authorizedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedUrl = "AuthorizedUrl"
        }
    }

    public struct CreatePresignedNotebookInstanceUrlInput: AWSEncodableShape {
        /// The name of the notebook instance.
        public let notebookInstanceName: String
        /// The duration of the session, in seconds. The default is 12 hours.
        public let sessionExpirationDurationInSeconds: Int?

        public init(notebookInstanceName: String, sessionExpirationDurationInSeconds: Int? = nil) {
            self.notebookInstanceName = notebookInstanceName
            self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, max: 43200)
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, min: 1800)
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
            case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
        }
    }

    public struct CreatePresignedNotebookInstanceUrlOutput: AWSDecodableShape {
        /// A JSON object that contains the URL string.
        public let authorizedUrl: String?

        public init(authorizedUrl: String? = nil) {
            self.authorizedUrl = authorizedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedUrl = "AuthorizedUrl"
        }
    }

    public struct CreateProcessingJobRequest: AWSEncodableShape {
        /// Configures the processing job to run a specified Docker container image.
        public let appSpecification: AppSpecification
        /// The environment variables to set in the Docker container. Up to  100 key and values entries in the map are supported.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// Networking options for a processing job, such as whether to allow inbound and  outbound network calls to and from processing containers, and the VPC subnets and  security groups to use for VPC-enabled processing jobs.
        public let networkConfig: NetworkConfig?
        /// An array of inputs configuring the data to download into the  processing container.
        public let processingInputs: [ProcessingInput]?
        ///  The name of the processing job. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let processingJobName: String
        /// Output configuration for the processing job.
        public let processingOutputConfig: ProcessingOutputConfig?
        /// Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.
        public let processingResources: ProcessingResources
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        /// The time limit for how long the processing job is allowed to run.
        public let stoppingCondition: ProcessingStoppingCondition?
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(appSpecification: AppSpecification, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, networkConfig: NetworkConfig? = nil, processingInputs: [ProcessingInput]? = nil, processingJobName: String, processingOutputConfig: ProcessingOutputConfig? = nil, processingResources: ProcessingResources, roleArn: String, stoppingCondition: ProcessingStoppingCondition? = nil, tags: [Tag]? = nil) {
            self.appSpecification = appSpecification
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.networkConfig = networkConfig
            self.processingInputs = processingInputs
            self.processingJobName = processingJobName
            self.processingOutputConfig = processingOutputConfig
            self.processingResources = processingResources
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.appSpecification.validate(name: "\(name).appSpecification")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 100)
            try self.experimentConfig?.validate(name: "\(name).experimentConfig")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.processingInputs?.forEach {
                try $0.validate(name: "\(name).processingInputs[]")
            }
            try self.validate(self.processingInputs, name: "processingInputs", parent: name, max: 10)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, max: 63)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, min: 1)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.processingOutputConfig?.validate(name: "\(name).processingOutputConfig")
            try self.processingResources.validate(name: "\(name).processingResources")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case appSpecification = "AppSpecification"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case networkConfig = "NetworkConfig"
            case processingInputs = "ProcessingInputs"
            case processingJobName = "ProcessingJobName"
            case processingOutputConfig = "ProcessingOutputConfig"
            case processingResources = "ProcessingResources"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
        }
    }

    public struct CreateProcessingJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the processing job.
        public let processingJobArn: String

        public init(processingJobArn: String) {
            self.processingJobArn = processingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case processingJobArn = "ProcessingJobArn"
        }
    }

    public struct CreateProjectInput: AWSEncodableShape {
        /// A description for the project.
        public let projectDescription: String?
        /// The name of the project.
        public let projectName: String
        /// The product ID and provisioning artifact ID to provision a service catalog. The provisioning  artifact ID will default to the latest provisioning artifact ID of the product, if you don't  provide the provisioning artifact ID. For more information, see What is Amazon Web Services Service Catalog.
        public let serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails
        /// An array of key-value pairs that you want to use to organize and track your Amazon Web Services resource costs. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        public init(projectDescription: String? = nil, projectName: String, serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails, tags: [Tag]? = nil) {
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.serviceCatalogProvisioningDetails = serviceCatalogProvisioningDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 1024)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 32)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.serviceCatalogProvisioningDetails.validate(name: "\(name).serviceCatalogProvisioningDetails")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case projectDescription = "ProjectDescription"
            case projectName = "ProjectName"
            case serviceCatalogProvisioningDetails = "ServiceCatalogProvisioningDetails"
            case tags = "Tags"
        }
    }

    public struct CreateProjectOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String
        /// The ID of the new project.
        public let projectId: String

        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
            case projectId = "ProjectId"
        }
    }

    public struct CreateSpaceRequest: AWSEncodableShape {
        /// The ID of the associated Domain.
        public let domainId: String
        /// The name of the space.
        public let spaceName: String
        /// A collection of space settings.
        public let spaceSettings: SpaceSettings?
        /// Tags to associated with the space. Each tag consists of a key and an optional value. Tag keys must be unique for each resource. Tags are searchable using the Search API.
        public let tags: [Tag]?

        public init(domainId: String, spaceName: String, spaceSettings: SpaceSettings? = nil, tags: [Tag]? = nil) {
            self.domainId = domainId
            self.spaceName = spaceName
            self.spaceSettings = spaceSettings
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.spaceSettings?.validate(name: "\(name).spaceSettings")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case spaceName = "SpaceName"
            case spaceSettings = "SpaceSettings"
            case tags = "Tags"
        }
    }

    public struct CreateSpaceResponse: AWSDecodableShape {
        /// The space's Amazon Resource Name (ARN).
        public let spaceArn: String?

        public init(spaceArn: String? = nil) {
            self.spaceArn = spaceArn
        }

        private enum CodingKeys: String, CodingKey {
            case spaceArn = "SpaceArn"
        }
    }

    public struct CreateStudioLifecycleConfigRequest: AWSEncodableShape {
        /// The App type that the Lifecycle Configuration is attached to.
        public let studioLifecycleConfigAppType: StudioLifecycleConfigAppType
        /// The content of your Studio Lifecycle Configuration script. This content must be base64 encoded.
        public let studioLifecycleConfigContent: String
        /// The name of the Studio Lifecycle Configuration to create.
        public let studioLifecycleConfigName: String
        /// Tags to be associated with the Lifecycle Configuration. Each tag consists of a key and an optional value. Tag keys must be unique per resource. Tags are searchable using the Search API.
        public let tags: [Tag]?

        public init(studioLifecycleConfigAppType: StudioLifecycleConfigAppType, studioLifecycleConfigContent: String, studioLifecycleConfigName: String, tags: [Tag]? = nil) {
            self.studioLifecycleConfigAppType = studioLifecycleConfigAppType
            self.studioLifecycleConfigContent = studioLifecycleConfigContent
            self.studioLifecycleConfigName = studioLifecycleConfigName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.studioLifecycleConfigContent, name: "studioLifecycleConfigContent", parent: name, max: 16384)
            try self.validate(self.studioLifecycleConfigContent, name: "studioLifecycleConfigContent", parent: name, min: 1)
            try self.validate(self.studioLifecycleConfigContent, name: "studioLifecycleConfigContent", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case studioLifecycleConfigAppType = "StudioLifecycleConfigAppType"
            case studioLifecycleConfigContent = "StudioLifecycleConfigContent"
            case studioLifecycleConfigName = "StudioLifecycleConfigName"
            case tags = "Tags"
        }
    }

    public struct CreateStudioLifecycleConfigResponse: AWSDecodableShape {
        /// The ARN of your created Lifecycle Configuration.
        public let studioLifecycleConfigArn: String?

        public init(studioLifecycleConfigArn: String? = nil) {
            self.studioLifecycleConfigArn = studioLifecycleConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case studioLifecycleConfigArn = "StudioLifecycleConfigArn"
        }
    }

    public struct CreateTrainingJobRequest: AWSEncodableShape {
        /// The registry path of the Docker image that contains the training algorithm and algorithm-specific metadata, including the input mode. For more information about algorithms provided by SageMaker, see Algorithms. For information about providing your own algorithms, see Using Your Own Algorithms with Amazon SageMaker.
        public let algorithmSpecification: AlgorithmSpecification
        /// Contains information about the output location for managed spot training checkpoint data.
        public let checkpointConfig: CheckpointConfig?
        public let debugHookConfig: DebugHookConfig?
        /// Configuration information for Amazon SageMaker Debugger rules for debugging output tensors.
        public let debugRuleConfigurations: [DebugRuleConfiguration]?
        /// To encrypt all communications between ML compute instances in distributed training, choose True. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training. For more information, see Protect Communications Between ML Compute Instances in a Distributed Training Job.
        public let enableInterContainerTrafficEncryption: Bool?
        /// To train models using managed spot training, choose True. Managed spot training provides a fully managed and scalable infrastructure for training machine learning models. this option is useful when training jobs can be interrupted and when there is flexibility when the training job is run.  The complete and intermediate results of jobs are stored in an Amazon S3 bucket, and can be used as a starting point to train models incrementally. Amazon SageMaker provides metrics and logs in CloudWatch. They can be used to see when managed spot training jobs are running, interrupted, resumed, or completed.
        public let enableManagedSpotTraining: Bool?
        /// Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If you enable network isolation for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.
        public let enableNetworkIsolation: Bool?
        /// The environment variables to set in the Docker container.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// Algorithm-specific parameters that influence the quality of the model. You set hyperparameters before you start the learning process. For a list of hyperparameters for each training algorithm provided by SageMaker, see Algorithms.  You can specify a maximum of 100 hyperparameters. Each hyperparameter is a key-value pair. Each key and value is limited to 256 characters, as specified by the Length Constraint.   Do not include any security-sensitive information including account access IDs, secrets or tokens in any hyperparameter field. If the use of security-sensitive credentials are detected, SageMaker will reject your training job request and return an exception error.
        public let hyperParameters: [String: String]?
        /// An array of Channel objects. Each channel is a named input source. InputDataConfig describes the input data and its location.  Algorithms can accept input data from one or more channels. For example, an algorithm might have two channels of input data, training_data and validation_data. The configuration for each channel provides the S3, EFS, or FSx location where the input data is stored. It also provides information about the stored data: the MIME type, compression method, and whether the data is wrapped in RecordIO format.  Depending on the input mode that the algorithm supports, SageMaker either copies input data files from an S3 bucket to a local directory in the Docker container, or makes it available as input streams. For example, if you specify an EFS location, input data files are available as input streams. They do not need to be downloaded.
        public let inputDataConfig: [Channel]?
        /// Specifies the path to the S3 location where you want to store model artifacts. SageMaker creates subfolders for the artifacts.
        public let outputDataConfig: OutputDataConfig
        public let profilerConfig: ProfilerConfig?
        /// Configuration information for Amazon SageMaker Debugger rules for profiling system and framework metrics.
        public let profilerRuleConfigurations: [ProfilerRuleConfiguration]?
        /// The resources, including the ML compute instances and ML storage volumes, to use for model training.  ML storage volumes store model artifacts and incremental states. Training algorithms might also use ML storage volumes for scratch space. If you want SageMaker to use the ML storage volume to store the training data, choose File as the TrainingInputMode in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.
        public let resourceConfig: ResourceConfig
        /// The number of times to retry the job when the job fails due to an InternalServerError.
        public let retryStrategy: RetryStrategy?
        /// The Amazon Resource Name (ARN) of an IAM role that SageMaker can assume to perform tasks on your behalf.  During model training, SageMaker needs your permission to read input data from an S3 bucket, download a Docker image that contains training code, write model artifacts to an S3 bucket, write logs to Amazon CloudWatch Logs, and publish metrics to Amazon CloudWatch. You grant permissions for all of these tasks to an IAM role. For more information, see SageMaker Roles.   To be able to pass this role to SageMaker, the caller of this API must have the iam:PassRole permission.
        public let roleArn: String
        /// Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs. To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost.
        public let stoppingCondition: StoppingCondition
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        public let tensorBoardOutputConfig: TensorBoardOutputConfig?
        /// The name of the training job. The name must be unique within an Amazon Web Services Region in an Amazon Web Services account.
        public let trainingJobName: String
        /// A VpcConfig object that specifies the VPC that you want your training job to connect to. Control access to and from your training container by configuring the VPC. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?

        public init(algorithmSpecification: AlgorithmSpecification, checkpointConfig: CheckpointConfig? = nil, debugHookConfig: DebugHookConfig? = nil, debugRuleConfigurations: [DebugRuleConfiguration]? = nil, enableInterContainerTrafficEncryption: Bool? = nil, enableManagedSpotTraining: Bool? = nil, enableNetworkIsolation: Bool? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, outputDataConfig: OutputDataConfig, profilerConfig: ProfilerConfig? = nil, profilerRuleConfigurations: [ProfilerRuleConfiguration]? = nil, resourceConfig: ResourceConfig, retryStrategy: RetryStrategy? = nil, roleArn: String, stoppingCondition: StoppingCondition, tags: [Tag]? = nil, tensorBoardOutputConfig: TensorBoardOutputConfig? = nil, trainingJobName: String, vpcConfig: VpcConfig? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.checkpointConfig = checkpointConfig
            self.debugHookConfig = debugHookConfig
            self.debugRuleConfigurations = debugRuleConfigurations
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableManagedSpotTraining = enableManagedSpotTraining
            self.enableNetworkIsolation = enableNetworkIsolation
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.outputDataConfig = outputDataConfig
            self.profilerConfig = profilerConfig
            self.profilerRuleConfigurations = profilerRuleConfigurations
            self.resourceConfig = resourceConfig
            self.retryStrategy = retryStrategy
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
            self.tensorBoardOutputConfig = tensorBoardOutputConfig
            self.trainingJobName = trainingJobName
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.algorithmSpecification.validate(name: "\(name).algorithmSpecification")
            try self.checkpointConfig?.validate(name: "\(name).checkpointConfig")
            try self.debugHookConfig?.validate(name: "\(name).debugHookConfig")
            try self.debugRuleConfigurations?.forEach {
                try $0.validate(name: "\(name).debugRuleConfigurations[]")
            }
            try self.validate(self.debugRuleConfigurations, name: "debugRuleConfigurations", parent: name, max: 20)
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 512)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 512)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 48)
            try self.experimentConfig?.validate(name: "\(name).experimentConfig")
            try self.hyperParameters?.forEach {
                try validate($0.key, name: "hyperParameters.key", parent: name, max: 256)
                try validate($0.key, name: "hyperParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "hyperParameters[\"\($0.key)\"]", parent: name, max: 2500)
                try validate($0.value, name: "hyperParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.hyperParameters, name: "hyperParameters", parent: name, max: 100)
            try self.inputDataConfig?.forEach {
                try $0.validate(name: "\(name).inputDataConfig[]")
            }
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, max: 20)
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, min: 1)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.profilerConfig?.validate(name: "\(name).profilerConfig")
            try self.profilerRuleConfigurations?.forEach {
                try $0.validate(name: "\(name).profilerRuleConfigurations[]")
            }
            try self.validate(self.profilerRuleConfigurations, name: "profilerRuleConfigurations", parent: name, max: 20)
            try self.resourceConfig.validate(name: "\(name).resourceConfig")
            try self.retryStrategy?.validate(name: "\(name).retryStrategy")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition.validate(name: "\(name).stoppingCondition")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.tensorBoardOutputConfig?.validate(name: "\(name).tensorBoardOutputConfig")
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, max: 63)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, min: 1)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "AlgorithmSpecification"
            case checkpointConfig = "CheckpointConfig"
            case debugHookConfig = "DebugHookConfig"
            case debugRuleConfigurations = "DebugRuleConfigurations"
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableManagedSpotTraining = "EnableManagedSpotTraining"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case hyperParameters = "HyperParameters"
            case inputDataConfig = "InputDataConfig"
            case outputDataConfig = "OutputDataConfig"
            case profilerConfig = "ProfilerConfig"
            case profilerRuleConfigurations = "ProfilerRuleConfigurations"
            case resourceConfig = "ResourceConfig"
            case retryStrategy = "RetryStrategy"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
            case tensorBoardOutputConfig = "TensorBoardOutputConfig"
            case trainingJobName = "TrainingJobName"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct CreateTrainingJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String

        public init(trainingJobArn: String) {
            self.trainingJobArn = trainingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobArn = "TrainingJobArn"
        }
    }

    public struct CreateTransformJobRequest: AWSEncodableShape {
        /// Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.  To enable the batch strategy, you must set the SplitType property to Line, RecordIO, or TFRecord. To use only one record when making an HTTP invocation request to a container, set BatchStrategy to SingleRecord and SplitType to Line. To fit as many records in a mini-batch as can fit within the MaxPayloadInMB limit, set BatchStrategy to MultiRecord and SplitType to Line.
        public let batchStrategy: BatchStrategy?
        /// Configuration to control how SageMaker captures inference data.
        public let dataCaptureConfig: BatchDataCaptureConfig?
        /// The data structure used to specify the data to be used for inference in a batch transform job and to associate the data that is relevant to the prediction results in the output. The input filter provided allows you to exclude input data that is not needed for inference in a batch transform job. The output filter provided allows you to include input data relevant to interpreting the predictions in the output from the job. For more information, see Associate Prediction Results with their Corresponding Input Records.
        public let dataProcessing: DataProcessing?
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// The maximum number of parallel requests that can be sent to each instance in a transform job. If MaxConcurrentTransforms is set to 0 or left unset, Amazon SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For more information on execution-parameters, see How Containers Serve Requests. For built-in algorithms, you don't need to set a value for MaxConcurrentTransforms.
        public let maxConcurrentTransforms: Int?
        /// The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in MaxPayloadInMB must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB.  The value of MaxPayloadInMB cannot be greater than 100 MB. If you specify the MaxConcurrentTransforms parameter, the value of (MaxConcurrentTransforms * MaxPayloadInMB) also cannot exceed 100 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, Amazon SageMaker built-in algorithms do not support HTTP chunked encoding.
        public let maxPayloadInMB: Int?
        /// Configures the timeout and maximum number of retries for processing a transform job invocation.
        public let modelClientConfig: ModelClientConfig?
        /// The name of the model that you want to use for the transform job. ModelName must be the name of an existing Amazon SageMaker model within an Amazon Web Services Region in an Amazon Web Services account.
        public let modelName: String
        /// (Optional) An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// Describes the input source and the way the transform job consumes it.
        public let transformInput: TransformInput
        /// The name of the transform job. The name must be unique within an Amazon Web Services Region in an Amazon Web Services account.
        public let transformJobName: String
        /// Describes the results of the transform job.
        public let transformOutput: TransformOutput
        /// Describes the resources, including ML instance types and ML instance count, to use for the transform job.
        public let transformResources: TransformResources

        public init(batchStrategy: BatchStrategy? = nil, dataCaptureConfig: BatchDataCaptureConfig? = nil, dataProcessing: DataProcessing? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, maxConcurrentTransforms: Int? = nil, maxPayloadInMB: Int? = nil, modelClientConfig: ModelClientConfig? = nil, modelName: String, tags: [Tag]? = nil, transformInput: TransformInput, transformJobName: String, transformOutput: TransformOutput, transformResources: TransformResources) {
            self.batchStrategy = batchStrategy
            self.dataCaptureConfig = dataCaptureConfig
            self.dataProcessing = dataProcessing
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.maxPayloadInMB = maxPayloadInMB
            self.modelClientConfig = modelClientConfig
            self.modelName = modelName
            self.tags = tags
            self.transformInput = transformInput
            self.transformJobName = transformJobName
            self.transformOutput = transformOutput
            self.transformResources = transformResources
        }

        public func validate(name: String) throws {
            try self.dataCaptureConfig?.validate(name: "\(name).dataCaptureConfig")
            try self.dataProcessing?.validate(name: "\(name).dataProcessing")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 1024)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]{0,1023}$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 10240)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 16)
            try self.experimentConfig?.validate(name: "\(name).experimentConfig")
            try self.validate(self.maxConcurrentTransforms, name: "maxConcurrentTransforms", parent: name, min: 0)
            try self.validate(self.maxPayloadInMB, name: "maxPayloadInMB", parent: name, min: 0)
            try self.modelClientConfig?.validate(name: "\(name).modelClientConfig")
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.transformInput.validate(name: "\(name).transformInput")
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, max: 63)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, min: 1)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.transformOutput.validate(name: "\(name).transformOutput")
            try self.transformResources.validate(name: "\(name).transformResources")
        }

        private enum CodingKeys: String, CodingKey {
            case batchStrategy = "BatchStrategy"
            case dataCaptureConfig = "DataCaptureConfig"
            case dataProcessing = "DataProcessing"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case maxPayloadInMB = "MaxPayloadInMB"
            case modelClientConfig = "ModelClientConfig"
            case modelName = "ModelName"
            case tags = "Tags"
            case transformInput = "TransformInput"
            case transformJobName = "TransformJobName"
            case transformOutput = "TransformOutput"
            case transformResources = "TransformResources"
        }
    }

    public struct CreateTransformJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String

        public init(transformJobArn: String) {
            self.transformJobArn = transformJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobArn = "TransformJobArn"
        }
    }

    public struct CreateTrialComponentRequest: AWSEncodableShape {
        /// The name of the component as displayed. The name doesn't need to be unique. If DisplayName isn't specified, TrialComponentName is displayed.
        public let displayName: String?
        /// When the component ended.
        public let endTime: Date?
        /// The input artifacts for the component. Examples of input artifacts are datasets, algorithms, hyperparameters, source code, and instance types.
        public let inputArtifacts: [String: TrialComponentArtifact]?
        public let metadataProperties: MetadataProperties?
        /// The output artifacts for the component. Examples of output artifacts are metrics, snapshots, logs, and images.
        public let outputArtifacts: [String: TrialComponentArtifact]?
        /// The hyperparameters for the component.
        public let parameters: [String: TrialComponentParameterValue]?
        /// When the component started.
        public let startTime: Date?
        /// The status of the component. States include:   InProgress   Completed   Failed
        public let status: TrialComponentStatus?
        /// A list of tags to associate with the component. You can use Search API to search on the tags.
        public let tags: [Tag]?
        /// The name of the component. The name must be unique in your Amazon Web Services account and is not case-sensitive.
        public let trialComponentName: String

        public init(displayName: String? = nil, endTime: Date? = nil, inputArtifacts: [String: TrialComponentArtifact]? = nil, metadataProperties: MetadataProperties? = nil, outputArtifacts: [String: TrialComponentArtifact]? = nil, parameters: [String: TrialComponentParameterValue]? = nil, startTime: Date? = nil, status: TrialComponentStatus? = nil, tags: [Tag]? = nil, trialComponentName: String) {
            self.displayName = displayName
            self.endTime = endTime
            self.inputArtifacts = inputArtifacts
            self.metadataProperties = metadataProperties
            self.outputArtifacts = outputArtifacts
            self.parameters = parameters
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.trialComponentName = trialComponentName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.inputArtifacts?.forEach {
                try validate($0.key, name: "inputArtifacts.key", parent: name, max: 64)
                try validate($0.key, name: "inputArtifacts.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).inputArtifacts[\"\($0.key)\"]")
            }
            try self.validate(self.inputArtifacts, name: "inputArtifacts", parent: name, max: 30)
            try self.metadataProperties?.validate(name: "\(name).metadataProperties")
            try self.outputArtifacts?.forEach {
                try validate($0.key, name: "outputArtifacts.key", parent: name, max: 64)
                try validate($0.key, name: "outputArtifacts.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).outputArtifacts[\"\($0.key)\"]")
            }
            try self.validate(self.outputArtifacts, name: "outputArtifacts", parent: name, max: 30)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 256)
                try validate($0.key, name: "parameters.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 150)
            try self.status?.validate(name: "\(name).status")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case endTime = "EndTime"
            case inputArtifacts = "InputArtifacts"
            case metadataProperties = "MetadataProperties"
            case outputArtifacts = "OutputArtifacts"
            case parameters = "Parameters"
            case startTime = "StartTime"
            case status = "Status"
            case tags = "Tags"
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct CreateTrialComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?

        public init(trialComponentArn: String? = nil) {
            self.trialComponentArn = trialComponentArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentArn = "TrialComponentArn"
        }
    }

    public struct CreateTrialRequest: AWSEncodableShape {
        /// The name of the trial as displayed. The name doesn't need to be unique. If DisplayName isn't specified, TrialName is displayed.
        public let displayName: String?
        /// The name of the experiment to associate the trial with.
        public let experimentName: String
        public let metadataProperties: MetadataProperties?
        /// A list of tags to associate with the trial. You can use Search API to search on the tags.
        public let tags: [Tag]?
        /// The name of the trial. The name must be unique in your Amazon Web Services account and is not case-sensitive.
        public let trialName: String

        public init(displayName: String? = nil, experimentName: String, metadataProperties: MetadataProperties? = nil, tags: [Tag]? = nil, trialName: String) {
            self.displayName = displayName
            self.experimentName = experimentName
            self.metadataProperties = metadataProperties
            self.tags = tags
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.metadataProperties?.validate(name: "\(name).metadataProperties")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case experimentName = "ExperimentName"
            case metadataProperties = "MetadataProperties"
            case tags = "Tags"
            case trialName = "TrialName"
        }
    }

    public struct CreateTrialResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?

        public init(trialArn: String? = nil) {
            self.trialArn = trialArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialArn = "TrialArn"
        }
    }

    public struct CreateUserProfileRequest: AWSEncodableShape {
        /// The ID of the associated Domain.
        public let domainId: String
        /// A specifier for the type of value specified in SingleSignOnUserValue.  Currently, the only supported value is "UserName". If the Domain's AuthMode is IAM Identity Center, this field is required.  If the Domain's AuthMode is not IAM Identity Center, this field cannot be specified.
        public let singleSignOnUserIdentifier: String?
        /// The username of the associated Amazon Web Services Single Sign-On User for this UserProfile.  If the Domain's AuthMode is IAM Identity Center, this field is required, and must match a valid username of a user in your directory.  If the Domain's AuthMode is not IAM Identity Center, this field cannot be specified.
        public let singleSignOnUserValue: String?
        /// Each tag consists of a key and an optional value. Tag keys must be unique per resource. Tags that you specify for the User Profile are also added to all Apps that the User Profile launches.
        public let tags: [Tag]?
        /// A name for the UserProfile. This value is not case sensitive.
        public let userProfileName: String
        /// A collection of settings.
        public let userSettings: UserSettings?

        public init(domainId: String, singleSignOnUserIdentifier: String? = nil, singleSignOnUserValue: String? = nil, tags: [Tag]? = nil, userProfileName: String, userSettings: UserSettings? = nil) {
            self.domainId = domainId
            self.singleSignOnUserIdentifier = singleSignOnUserIdentifier
            self.singleSignOnUserValue = singleSignOnUserValue
            self.tags = tags
            self.userProfileName = userProfileName
            self.userSettings = userSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.singleSignOnUserIdentifier, name: "singleSignOnUserIdentifier", parent: name, pattern: "^UserName$")
            try self.validate(self.singleSignOnUserValue, name: "singleSignOnUserValue", parent: name, max: 256)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.userSettings?.validate(name: "\(name).userSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case singleSignOnUserIdentifier = "SingleSignOnUserIdentifier"
            case singleSignOnUserValue = "SingleSignOnUserValue"
            case tags = "Tags"
            case userProfileName = "UserProfileName"
            case userSettings = "UserSettings"
        }
    }

    public struct CreateUserProfileResponse: AWSDecodableShape {
        /// The user profile Amazon Resource Name (ARN).
        public let userProfileArn: String?

        public init(userProfileArn: String? = nil) {
            self.userProfileArn = userProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case userProfileArn = "UserProfileArn"
        }
    }

    public struct CreateWorkforceRequest: AWSEncodableShape {
        /// Use this parameter to configure an Amazon Cognito private workforce. A single Cognito workforce is created using and corresponds to a single  Amazon Cognito user pool. Do not use OidcConfig if you specify values for  CognitoConfig.
        public let cognitoConfig: CognitoConfig?
        /// Use this parameter to configure a private workforce using your own OIDC Identity Provider. Do not use CognitoConfig if you specify values for  OidcConfig.
        public let oidcConfig: OidcConfig?
        public let sourceIpConfig: SourceIpConfig?
        /// An array of key-value pairs that contain metadata to help you categorize and  organize our workforce. Each tag consists of a key and a value,  both of which you define.
        public let tags: [Tag]?
        /// The name of the private workforce.
        public let workforceName: String
        /// Use this parameter to configure a workforce using VPC.
        public let workforceVpcConfig: WorkforceVpcConfigRequest?

        public init(cognitoConfig: CognitoConfig? = nil, oidcConfig: OidcConfig? = nil, sourceIpConfig: SourceIpConfig? = nil, tags: [Tag]? = nil, workforceName: String, workforceVpcConfig: WorkforceVpcConfigRequest? = nil) {
            self.cognitoConfig = cognitoConfig
            self.oidcConfig = oidcConfig
            self.sourceIpConfig = sourceIpConfig
            self.tags = tags
            self.workforceName = workforceName
            self.workforceVpcConfig = workforceVpcConfig
        }

        public func validate(name: String) throws {
            try self.cognitoConfig?.validate(name: "\(name).cognitoConfig")
            try self.oidcConfig?.validate(name: "\(name).oidcConfig")
            try self.sourceIpConfig?.validate(name: "\(name).sourceIpConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workforceName, name: "workforceName", parent: name, max: 63)
            try self.validate(self.workforceName, name: "workforceName", parent: name, min: 1)
            try self.validate(self.workforceName, name: "workforceName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
            try self.workforceVpcConfig?.validate(name: "\(name).workforceVpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case cognitoConfig = "CognitoConfig"
            case oidcConfig = "OidcConfig"
            case sourceIpConfig = "SourceIpConfig"
            case tags = "Tags"
            case workforceName = "WorkforceName"
            case workforceVpcConfig = "WorkforceVpcConfig"
        }
    }

    public struct CreateWorkforceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the workforce.
        public let workforceArn: String

        public init(workforceArn: String) {
            self.workforceArn = workforceArn
        }

        private enum CodingKeys: String, CodingKey {
            case workforceArn = "WorkforceArn"
        }
    }

    public struct CreateWorkteamRequest: AWSEncodableShape {
        /// A description of the work team.
        public let description: String
        /// A list of MemberDefinition objects that contains objects that identify the workers that make up the work team.  Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use CognitoMemberDefinition. For workforces created using your own OIDC identity provider (IdP) use OidcMemberDefinition. Do not provide input for both of these parameters in a single request. For workforces created using Amazon Cognito, private work teams correspond to Amazon Cognito user groups within the user pool used to create a workforce. All of the CognitoMemberDefinition objects that make up the member definition must have the same ClientId and UserPool values. To add a Amazon Cognito user group to an existing worker pool, see Adding groups to a User Pool. For more information about user pools, see Amazon Cognito User Pools. For workforces created using your own OIDC IdP, specify the user groups that you want to  include in your private work team in OidcMemberDefinition by listing those groups in Groups.
        public let memberDefinitions: [MemberDefinition]
        /// Configures notification of workers regarding available or expiring work items.
        public let notificationConfiguration: NotificationConfiguration?
        /// An array of key-value pairs. For more information, see Resource Tag and Using Cost Allocation Tags in the  Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// The name of the workforce.
        public let workforceName: String?
        /// The name of the work team. Use this name to identify the work team.
        public let workteamName: String

        public init(description: String, memberDefinitions: [MemberDefinition], notificationConfiguration: NotificationConfiguration? = nil, tags: [Tag]? = nil, workforceName: String? = nil, workteamName: String) {
            self.description = description
            self.memberDefinitions = memberDefinitions
            self.notificationConfiguration = notificationConfiguration
            self.tags = tags
            self.workforceName = workforceName
            self.workteamName = workteamName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.memberDefinitions.forEach {
                try $0.validate(name: "\(name).memberDefinitions[]")
            }
            try self.validate(self.memberDefinitions, name: "memberDefinitions", parent: name, max: 10)
            try self.validate(self.memberDefinitions, name: "memberDefinitions", parent: name, min: 1)
            try self.notificationConfiguration?.validate(name: "\(name).notificationConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workforceName, name: "workforceName", parent: name, max: 63)
            try self.validate(self.workforceName, name: "workforceName", parent: name, min: 1)
            try self.validate(self.workforceName, name: "workforceName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
            try self.validate(self.workteamName, name: "workteamName", parent: name, max: 63)
            try self.validate(self.workteamName, name: "workteamName", parent: name, min: 1)
            try self.validate(self.workteamName, name: "workteamName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case memberDefinitions = "MemberDefinitions"
            case notificationConfiguration = "NotificationConfiguration"
            case tags = "Tags"
            case workforceName = "WorkforceName"
            case workteamName = "WorkteamName"
        }
    }

    public struct CreateWorkteamResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the work team. You can use this ARN to identify the work team.
        public let workteamArn: String?

        public init(workteamArn: String? = nil) {
            self.workteamArn = workteamArn
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
        }
    }

    public struct CustomImage: AWSEncodableShape & AWSDecodableShape {
        /// The name of the AppImageConfig.
        public let appImageConfigName: String
        /// The name of the CustomImage. Must be unique to your account.
        public let imageName: String
        /// The version number of the CustomImage.
        public let imageVersionNumber: Int?

        public init(appImageConfigName: String, imageName: String, imageVersionNumber: Int? = nil) {
            self.appImageConfigName = appImageConfigName
            self.imageName = imageName
            self.imageVersionNumber = imageVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, max: 63)
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.imageVersionNumber, name: "imageVersionNumber", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigName = "AppImageConfigName"
            case imageName = "ImageName"
            case imageVersionNumber = "ImageVersionNumber"
        }
    }

    public struct DataCaptureConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configuration specifying how to treat different headers. If no headers are specified SageMaker will  by default base64 encode when capturing the data.
        public let captureContentTypeHeader: CaptureContentTypeHeader?
        /// Specifies data Model Monitor will capture. You can configure whether to  collect only input, only output, or both
        public let captureOptions: [CaptureOption]
        /// The Amazon S3 location used to capture the data.
        public let destinationS3Uri: String
        /// Whether data capture should be enabled or disabled (defaults to enabled).
        public let enableCapture: Bool?
        /// The percentage of requests SageMaker will capture. A lower value is recommended for  Endpoints with high traffic.
        public let initialSamplingPercentage: Int
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service key that SageMaker uses to encrypt the captured data at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias
        public let kmsKeyId: String?

        public init(captureContentTypeHeader: CaptureContentTypeHeader? = nil, captureOptions: [CaptureOption], destinationS3Uri: String, enableCapture: Bool? = nil, initialSamplingPercentage: Int, kmsKeyId: String? = nil) {
            self.captureContentTypeHeader = captureContentTypeHeader
            self.captureOptions = captureOptions
            self.destinationS3Uri = destinationS3Uri
            self.enableCapture = enableCapture
            self.initialSamplingPercentage = initialSamplingPercentage
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.captureContentTypeHeader?.validate(name: "\(name).captureContentTypeHeader")
            try self.validate(self.captureOptions, name: "captureOptions", parent: name, max: 2)
            try self.validate(self.captureOptions, name: "captureOptions", parent: name, min: 1)
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, max: 512)
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, pattern: "^(https|s3)://([^/])/?(.*)$")
            try self.validate(self.initialSamplingPercentage, name: "initialSamplingPercentage", parent: name, max: 100)
            try self.validate(self.initialSamplingPercentage, name: "initialSamplingPercentage", parent: name, min: 0)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case captureContentTypeHeader = "CaptureContentTypeHeader"
            case captureOptions = "CaptureOptions"
            case destinationS3Uri = "DestinationS3Uri"
            case enableCapture = "EnableCapture"
            case initialSamplingPercentage = "InitialSamplingPercentage"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct DataCaptureConfigSummary: AWSDecodableShape {
        /// Whether data capture is currently functional.
        public let captureStatus: CaptureStatus
        /// The percentage of requests being captured by your Endpoint.
        public let currentSamplingPercentage: Int
        /// The Amazon S3 location being used to capture the data.
        public let destinationS3Uri: String
        /// Whether data capture is enabled or disabled.
        public let enableCapture: Bool
        /// The KMS key being used to encrypt the data in Amazon S3.
        public let kmsKeyId: String

        public init(captureStatus: CaptureStatus, currentSamplingPercentage: Int, destinationS3Uri: String, enableCapture: Bool, kmsKeyId: String) {
            self.captureStatus = captureStatus
            self.currentSamplingPercentage = currentSamplingPercentage
            self.destinationS3Uri = destinationS3Uri
            self.enableCapture = enableCapture
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case captureStatus = "CaptureStatus"
            case currentSamplingPercentage = "CurrentSamplingPercentage"
            case destinationS3Uri = "DestinationS3Uri"
            case enableCapture = "EnableCapture"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct DataCatalogConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Glue table catalog.
        public let catalog: String
        /// The name of the Glue table database.
        public let database: String
        /// The name of the Glue table.
        public let tableName: String

        public init(catalog: String, database: String, tableName: String) {
            self.catalog = catalog
            self.database = database
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 255)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.database, name: "database", parent: name, max: 255)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case database = "Database"
            case tableName = "TableName"
        }
    }

    public struct DataProcessing: AWSEncodableShape & AWSDecodableShape {
        /// A JSONPath expression used to select a portion of the input data to pass to the algorithm. Use the InputFilter parameter to exclude fields, such as an ID column, from the input. If you want SageMaker to pass the entire input dataset to the algorithm, accept the default value $. Examples: "$", "$[1:]", "$.features"
        public let inputFilter: String?
        /// Specifies the source of the data to join with the transformed data. The valid values are None and Input. The default value is None, which specifies not to join the input with the transformed data. If you want the batch transform job to join the original input data with the transformed data, set JoinSource to Input. You can specify OutputFilter as an additional filter to select a portion of the joined dataset and store it in the output file. For JSON or JSONLines objects, such as a JSON array, SageMaker adds the transformed data to the input JSON object in an attribute called SageMakerOutput. The joined result for JSON must be a key-value pair object. If the input is not a key-value pair object, SageMaker creates a new JSON file. In the new JSON file, and the input data is stored under the SageMakerInput key and the results are stored in SageMakerOutput. For CSV data, SageMaker takes each row as a JSON array and joins the transformed data with the input by appending each transformed row to the end of the input. The joined data has the original input data followed by the transformed data and the output is a CSV file. For information on how joining in applied, see Workflow for Associating Inferences with Input Records.
        public let joinSource: JoinSource?
        /// A JSONPath expression used to select a portion of the joined dataset to save in the output file for a batch transform job. If you want SageMaker to store the entire input dataset in the output file, leave the default value, $. If you specify indexes that aren't within the dimension size of the joined dataset, you get an error. Examples: "$", "$[0,5:]", "$['id','SageMakerOutput']"
        public let outputFilter: String?

        public init(inputFilter: String? = nil, joinSource: JoinSource? = nil, outputFilter: String? = nil) {
            self.inputFilter = inputFilter
            self.joinSource = joinSource
            self.outputFilter = outputFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.inputFilter, name: "inputFilter", parent: name, max: 63)
            try self.validate(self.outputFilter, name: "outputFilter", parent: name, max: 63)
        }

        private enum CodingKeys: String, CodingKey {
            case inputFilter = "InputFilter"
            case joinSource = "JoinSource"
            case outputFilter = "OutputFilter"
        }
    }

    public struct DataQualityAppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The arguments to send to the container that the monitoring job runs.
        public let containerArguments: [String]?
        /// The entrypoint for a container used to run a monitoring job.
        public let containerEntrypoint: [String]?
        /// Sets the environment variables in the container that the monitoring job runs.
        public let environment: [String: String]?
        /// The container image that the data quality monitoring job runs.
        public let imageUri: String
        /// An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        public let postAnalyticsProcessorSourceUri: String?
        /// An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.
        public let recordPreprocessorSourceUri: String?

        public init(containerArguments: [String]? = nil, containerEntrypoint: [String]? = nil, environment: [String: String]? = nil, imageUri: String, postAnalyticsProcessorSourceUri: String? = nil, recordPreprocessorSourceUri: String? = nil) {
            self.containerArguments = containerArguments
            self.containerEntrypoint = containerEntrypoint
            self.environment = environment
            self.imageUri = imageUri
            self.postAnalyticsProcessorSourceUri = postAnalyticsProcessorSourceUri
            self.recordPreprocessorSourceUri = recordPreprocessorSourceUri
        }

        public func validate(name: String) throws {
            try self.containerArguments?.forEach {
                try validate($0, name: "containerArguments[]", parent: name, max: 256)
                try validate($0, name: "containerArguments[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, max: 50)
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, min: 1)
            try self.containerEntrypoint?.forEach {
                try validate($0, name: "containerEntrypoint[]", parent: name, max: 256)
                try validate($0, name: "containerEntrypoint[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, max: 100)
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, min: 1)
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 50)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, max: 1024)
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, max: 1024)
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerArguments = "ContainerArguments"
            case containerEntrypoint = "ContainerEntrypoint"
            case environment = "Environment"
            case imageUri = "ImageUri"
            case postAnalyticsProcessorSourceUri = "PostAnalyticsProcessorSourceUri"
            case recordPreprocessorSourceUri = "RecordPreprocessorSourceUri"
        }
    }

    public struct DataQualityBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the job that performs baselining for the data quality monitoring job.
        public let baseliningJobName: String?
        public let constraintsResource: MonitoringConstraintsResource?
        public let statisticsResource: MonitoringStatisticsResource?

        public init(baseliningJobName: String? = nil, constraintsResource: MonitoringConstraintsResource? = nil, statisticsResource: MonitoringStatisticsResource? = nil) {
            self.baseliningJobName = baseliningJobName
            self.constraintsResource = constraintsResource
            self.statisticsResource = statisticsResource
        }

        public func validate(name: String) throws {
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, max: 63)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, min: 1)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.constraintsResource?.validate(name: "\(name).constraintsResource")
            try self.statisticsResource?.validate(name: "\(name).statisticsResource")
        }

        private enum CodingKeys: String, CodingKey {
            case baseliningJobName = "BaseliningJobName"
            case constraintsResource = "ConstraintsResource"
            case statisticsResource = "StatisticsResource"
        }
    }

    public struct DataQualityJobInput: AWSEncodableShape & AWSDecodableShape {
        /// Input object for the batch transform job.
        public let batchTransformInput: BatchTransformInput?
        public let endpointInput: EndpointInput?

        public init(batchTransformInput: BatchTransformInput? = nil, endpointInput: EndpointInput? = nil) {
            self.batchTransformInput = batchTransformInput
            self.endpointInput = endpointInput
        }

        public func validate(name: String) throws {
            try self.batchTransformInput?.validate(name: "\(name).batchTransformInput")
            try self.endpointInput?.validate(name: "\(name).endpointInput")
        }

        private enum CodingKeys: String, CodingKey {
            case batchTransformInput = "BatchTransformInput"
            case endpointInput = "EndpointInput"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The file system that is associated with a channel.
        public let fileSystemDataSource: FileSystemDataSource?
        /// The S3 location of the data source that is associated with a channel.
        public let s3DataSource: S3DataSource?

        public init(fileSystemDataSource: FileSystemDataSource? = nil, s3DataSource: S3DataSource? = nil) {
            self.fileSystemDataSource = fileSystemDataSource
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.fileSystemDataSource?.validate(name: "\(name).fileSystemDataSource")
            try self.s3DataSource?.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemDataSource = "FileSystemDataSource"
            case s3DataSource = "S3DataSource"
        }
    }

    public struct DatasetDefinition: AWSEncodableShape & AWSDecodableShape {
        public let athenaDatasetDefinition: AthenaDatasetDefinition?
        /// Whether the generated dataset is FullyReplicated or ShardedByS3Key (default).
        public let dataDistributionType: DataDistributionType?
        /// Whether to use File or Pipe input mode. In File (default) mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In Pipe mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.
        public let inputMode: InputMode?
        /// The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a processing job. LocalPath is an absolute path to the input data. This is a required parameter when AppManaged is False (default).
        public let localPath: String?
        public let redshiftDatasetDefinition: RedshiftDatasetDefinition?

        public init(athenaDatasetDefinition: AthenaDatasetDefinition? = nil, dataDistributionType: DataDistributionType? = nil, inputMode: InputMode? = nil, localPath: String? = nil, redshiftDatasetDefinition: RedshiftDatasetDefinition? = nil) {
            self.athenaDatasetDefinition = athenaDatasetDefinition
            self.dataDistributionType = dataDistributionType
            self.inputMode = inputMode
            self.localPath = localPath
            self.redshiftDatasetDefinition = redshiftDatasetDefinition
        }

        public func validate(name: String) throws {
            try self.athenaDatasetDefinition?.validate(name: "\(name).athenaDatasetDefinition")
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.redshiftDatasetDefinition?.validate(name: "\(name).redshiftDatasetDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case athenaDatasetDefinition = "AthenaDatasetDefinition"
            case dataDistributionType = "DataDistributionType"
            case inputMode = "InputMode"
            case localPath = "LocalPath"
            case redshiftDatasetDefinition = "RedshiftDatasetDefinition"
        }
    }

    public struct DebugHookConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information for Amazon SageMaker Debugger tensor collections. To learn more about how to configure the CollectionConfiguration parameter,  see Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job.
        public let collectionConfigurations: [CollectionConfiguration]?
        /// Configuration information for the Amazon SageMaker Debugger hook parameters.
        public let hookParameters: [String: String]?
        /// Path to local storage location for metrics and tensors. Defaults to /opt/ml/output/tensors/.
        public let localPath: String?
        /// Path to Amazon S3 storage location for metrics and tensors.
        public let s3OutputPath: String

        public init(collectionConfigurations: [CollectionConfiguration]? = nil, hookParameters: [String: String]? = nil, localPath: String? = nil, s3OutputPath: String) {
            self.collectionConfigurations = collectionConfigurations
            self.hookParameters = hookParameters
            self.localPath = localPath
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.collectionConfigurations?.forEach {
                try $0.validate(name: "\(name).collectionConfigurations[]")
            }
            try self.validate(self.collectionConfigurations, name: "collectionConfigurations", parent: name, max: 20)
            try self.hookParameters?.forEach {
                try validate($0.key, name: "hookParameters.key", parent: name, max: 256)
                try validate($0.key, name: "hookParameters.key", parent: name, min: 1)
                try validate($0.key, name: "hookParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "hookParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "hookParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.hookParameters, name: "hookParameters", parent: name, max: 20)
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionConfigurations = "CollectionConfigurations"
            case hookParameters = "HookParameters"
            case localPath = "LocalPath"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct DebugRuleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The instance type to deploy a custom rule for debugging a training job.
        public let instanceType: ProcessingInstanceType?
        /// Path to local storage location for output of rules. Defaults to /opt/ml/processing/output/rule/.
        public let localPath: String?
        /// The name of the rule configuration. It must be unique relative to other rule configuration names.
        public let ruleConfigurationName: String
        /// The Amazon Elastic Container (ECR) Image for the managed rule evaluation.
        public let ruleEvaluatorImage: String
        /// Runtime configuration for rule container.
        public let ruleParameters: [String: String]?
        /// Path to Amazon S3 storage location for rules.
        public let s3OutputPath: String?
        /// The size, in GB, of the ML storage volume attached to the processing instance.
        public let volumeSizeInGB: Int?

        public init(instanceType: ProcessingInstanceType? = nil, localPath: String? = nil, ruleConfigurationName: String, ruleEvaluatorImage: String, ruleParameters: [String: String]? = nil, s3OutputPath: String? = nil, volumeSizeInGB: Int? = nil) {
            self.instanceType = instanceType
            self.localPath = localPath
            self.ruleConfigurationName = ruleConfigurationName
            self.ruleEvaluatorImage = ruleEvaluatorImage
            self.ruleParameters = ruleParameters
            self.s3OutputPath = s3OutputPath
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, max: 256)
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, min: 1)
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, pattern: ".*")
            try self.validate(self.ruleEvaluatorImage, name: "ruleEvaluatorImage", parent: name, max: 255)
            try self.validate(self.ruleEvaluatorImage, name: "ruleEvaluatorImage", parent: name, pattern: ".*")
            try self.ruleParameters?.forEach {
                try validate($0.key, name: "ruleParameters.key", parent: name, max: 256)
                try validate($0.key, name: "ruleParameters.key", parent: name, min: 1)
                try validate($0.key, name: "ruleParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "ruleParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "ruleParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.ruleParameters, name: "ruleParameters", parent: name, max: 100)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case localPath = "LocalPath"
            case ruleConfigurationName = "RuleConfigurationName"
            case ruleEvaluatorImage = "RuleEvaluatorImage"
            case ruleParameters = "RuleParameters"
            case s3OutputPath = "S3OutputPath"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct DebugRuleEvaluationStatus: AWSDecodableShape {
        /// Timestamp when the rule evaluation status was last modified.
        public let lastModifiedTime: Date?
        /// The name of the rule configuration.
        public let ruleConfigurationName: String?
        /// The Amazon Resource Name (ARN) of the rule evaluation job.
        public let ruleEvaluationJobArn: String?
        /// Status of the rule evaluation.
        public let ruleEvaluationStatus: RuleEvaluationStatus?
        /// Details from the rule evaluation.
        public let statusDetails: String?

        public init(lastModifiedTime: Date? = nil, ruleConfigurationName: String? = nil, ruleEvaluationJobArn: String? = nil, ruleEvaluationStatus: RuleEvaluationStatus? = nil, statusDetails: String? = nil) {
            self.lastModifiedTime = lastModifiedTime
            self.ruleConfigurationName = ruleConfigurationName
            self.ruleEvaluationJobArn = ruleEvaluationJobArn
            self.ruleEvaluationStatus = ruleEvaluationStatus
            self.statusDetails = statusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case ruleConfigurationName = "RuleConfigurationName"
            case ruleEvaluationJobArn = "RuleEvaluationJobArn"
            case ruleEvaluationStatus = "RuleEvaluationStatus"
            case statusDetails = "StatusDetails"
        }
    }

    public struct DefaultSpaceSettings: AWSEncodableShape & AWSDecodableShape {
        /// The execution role for the space.
        public let executionRole: String?
        public let jupyterServerAppSettings: JupyterServerAppSettings?
        public let kernelGatewayAppSettings: KernelGatewayAppSettings?
        /// The security groups for the Amazon Virtual Private Cloud that the space uses for communication.
        public let securityGroups: [String]?

        public init(executionRole: String? = nil, jupyterServerAppSettings: JupyterServerAppSettings? = nil, kernelGatewayAppSettings: KernelGatewayAppSettings? = nil, securityGroups: [String]? = nil) {
            self.executionRole = executionRole
            self.jupyterServerAppSettings = jupyterServerAppSettings
            self.kernelGatewayAppSettings = kernelGatewayAppSettings
            self.securityGroups = securityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 20)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.jupyterServerAppSettings?.validate(name: "\(name).jupyterServerAppSettings")
            try self.kernelGatewayAppSettings?.validate(name: "\(name).kernelGatewayAppSettings")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 32)
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case executionRole = "ExecutionRole"
            case jupyterServerAppSettings = "JupyterServerAppSettings"
            case kernelGatewayAppSettings = "KernelGatewayAppSettings"
            case securityGroups = "SecurityGroups"
        }
    }

    public struct DeleteActionRequest: AWSEncodableShape {
        /// The name of the action to delete.
        public let actionName: String

        public init(actionName: String) {
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 120)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "ActionName"
        }
    }

    public struct DeleteActionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let actionArn: String?

        public init(actionArn: String? = nil) {
            self.actionArn = actionArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionArn = "ActionArn"
        }
    }

    public struct DeleteAlgorithmInput: AWSEncodableShape {
        /// The name of the algorithm to delete.
        public let algorithmName: String

        public init(algorithmName: String) {
            self.algorithmName = algorithmName
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 63)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
        }
    }

    public struct DeleteAppImageConfigRequest: AWSEncodableShape {
        /// The name of the AppImageConfig to delete.
        public let appImageConfigName: String

        public init(appImageConfigName: String) {
            self.appImageConfigName = appImageConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, max: 63)
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigName = "AppImageConfigName"
        }
    }

    public struct DeleteAppRequest: AWSEncodableShape {
        /// The name of the app.
        public let appName: String
        /// The type of app.
        public let appType: AppType
        /// The domain ID.
        public let domainId: String
        /// The name of the space. If this value is not set, then UserProfileName must be set.
        public let spaceName: String?
        /// The user profile name. If this value is not set, then SpaceName must be set.
        public let userProfileName: String?

        public init(appName: String, appType: AppType, domainId: String, spaceName: String? = nil, userProfileName: String? = nil) {
            self.appName = appName
            self.appType = appType
            self.domainId = domainId
            self.spaceName = spaceName
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.appName, name: "appName", parent: name, max: 63)
            try self.validate(self.appName, name: "appName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appName = "AppName"
            case appType = "AppType"
            case domainId = "DomainId"
            case spaceName = "SpaceName"
            case userProfileName = "UserProfileName"
        }
    }

    public struct DeleteArtifactRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the artifact to delete.
        public let artifactArn: String?
        /// The URI of the source.
        public let source: ArtifactSource?

        public init(artifactArn: String? = nil, source: ArtifactSource? = nil) {
            self.artifactArn = artifactArn
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, max: 256)
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:artifact/")
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
            case source = "Source"
        }
    }

    public struct DeleteArtifactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the artifact.
        public let artifactArn: String?

        public init(artifactArn: String? = nil) {
            self.artifactArn = artifactArn
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
        }
    }

    public struct DeleteAssociationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String
        /// The ARN of the source.
        public let sourceArn: String

        public init(destinationArn: String, sourceArn: String) {
            self.destinationArn = destinationArn
            self.sourceArn = sourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 256)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 256)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "DestinationArn"
            case sourceArn = "SourceArn"
        }
    }

    public struct DeleteAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String?
        /// The ARN of the source.
        public let sourceArn: String?

        public init(destinationArn: String? = nil, sourceArn: String? = nil) {
            self.destinationArn = destinationArn
            self.sourceArn = sourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "DestinationArn"
            case sourceArn = "SourceArn"
        }
    }

    public struct DeleteCodeRepositoryInput: AWSEncodableShape {
        /// The name of the Git repository to delete.
        public let codeRepositoryName: String

        public init(codeRepositoryName: String) {
            self.codeRepositoryName = codeRepositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, max: 63)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, min: 1)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
        }
    }

    public struct DeleteContextRequest: AWSEncodableShape {
        /// The name of the context to delete.
        public let contextName: String

        public init(contextName: String) {
            self.contextName = contextName
        }

        public func validate(name: String) throws {
            try self.validate(self.contextName, name: "contextName", parent: name, max: 120)
            try self.validate(self.contextName, name: "contextName", parent: name, min: 1)
            try self.validate(self.contextName, name: "contextName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contextName = "ContextName"
        }
    }

    public struct DeleteContextResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the context.
        public let contextArn: String?

        public init(contextArn: String? = nil) {
            self.contextArn = contextArn
        }

        private enum CodingKeys: String, CodingKey {
            case contextArn = "ContextArn"
        }
    }

    public struct DeleteDataQualityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the data quality monitoring job definition to delete.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DeleteDeviceFleetRequest: AWSEncodableShape {
        /// The name of the fleet to delete.
        public let deviceFleetName: String

        public init(deviceFleetName: String) {
            self.deviceFleetName = deviceFleetName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String
        /// The retention policy for this domain, which specifies whether resources will be retained after the Domain is deleted. By default, all resources are retained (not automatically deleted).
        public let retentionPolicy: RetentionPolicy?

        public init(domainId: String, retentionPolicy: RetentionPolicy? = nil) {
            self.domainId = domainId
            self.retentionPolicy = retentionPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case retentionPolicy = "RetentionPolicy"
        }
    }

    public struct DeleteEdgeDeploymentPlanRequest: AWSEncodableShape {
        /// The name of the edge deployment plan to delete.
        public let edgeDeploymentPlanName: String

        public init(edgeDeploymentPlanName: String) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
        }
    }

    public struct DeleteEdgeDeploymentStageRequest: AWSEncodableShape {
        /// The name of the edge deployment plan from which the stage will be deleted.
        public let edgeDeploymentPlanName: String
        /// The name of the stage.
        public let stageName: String

        public init(edgeDeploymentPlanName: String, stageName: String) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 63)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case stageName = "StageName"
        }
    }

    public struct DeleteEndpointConfigInput: AWSEncodableShape {
        /// The name of the endpoint configuration that you want to delete.
        public let endpointConfigName: String

        public init(endpointConfigName: String) {
            self.endpointConfigName = endpointConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, max: 63)
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct DeleteEndpointInput: AWSEncodableShape {
        /// The name of the endpoint that you want to delete.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DeleteExperimentRequest: AWSEncodableShape {
        /// The name of the experiment to delete.
        public let experimentName: String

        public init(experimentName: String) {
            self.experimentName = experimentName
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case experimentName = "ExperimentName"
        }
    }

    public struct DeleteExperimentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the experiment that is being deleted.
        public let experimentArn: String?

        public init(experimentArn: String? = nil) {
            self.experimentArn = experimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case experimentArn = "ExperimentArn"
        }
    }

    public struct DeleteFeatureGroupRequest: AWSEncodableShape {
        /// The name of the FeatureGroup you want to delete. The name must be unique within an Amazon Web Services Region in an Amazon Web Services account.
        public let featureGroupName: String

        public init(featureGroupName: String) {
            self.featureGroupName = featureGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupName = "FeatureGroupName"
        }
    }

    public struct DeleteFlowDefinitionRequest: AWSEncodableShape {
        /// The name of the flow definition you are deleting.
        public let flowDefinitionName: String

        public init(flowDefinitionName: String) {
            self.flowDefinitionName = flowDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, max: 63)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, min: 1)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionName = "FlowDefinitionName"
        }
    }

    public struct DeleteFlowDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteHubContentRequest: AWSEncodableShape {
        /// The name of the content that you want to delete from a hub.
        public let hubContentName: String
        /// The type of content that you want to delete from a hub.
        public let hubContentType: HubContentType
        /// The version of the content that you want to delete from a hub.
        public let hubContentVersion: String
        /// The name of the hub that you want to delete content in.
        public let hubName: String

        public init(hubContentName: String, hubContentType: HubContentType, hubContentVersion: String, hubName: String) {
            self.hubContentName = hubContentName
            self.hubContentType = hubContentType
            self.hubContentVersion = hubContentVersion
            self.hubName = hubName
        }

        public func validate(name: String) throws {
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, max: 63)
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, max: 14)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, min: 5)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hubContentName = "HubContentName"
            case hubContentType = "HubContentType"
            case hubContentVersion = "HubContentVersion"
            case hubName = "HubName"
        }
    }

    public struct DeleteHubRequest: AWSEncodableShape {
        /// The name of the hub to delete.
        public let hubName: String

        public init(hubName: String) {
            self.hubName = hubName
        }

        public func validate(name: String) throws {
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hubName = "HubName"
        }
    }

    public struct DeleteHumanTaskUiRequest: AWSEncodableShape {
        /// The name of the human task user interface (work task template) you want to delete.
        public let humanTaskUiName: String

        public init(humanTaskUiName: String) {
            self.humanTaskUiName = humanTaskUiName
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, max: 63)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, min: 1)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiName = "HumanTaskUiName"
        }
    }

    public struct DeleteHumanTaskUiResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImageRequest: AWSEncodableShape {
        /// The name of the image to delete.
        public let imageName: String

        public init(imageName: String) {
            self.imageName = imageName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageName = "ImageName"
        }
    }

    public struct DeleteImageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImageVersionRequest: AWSEncodableShape {
        /// The alias of the image to delete.
        public let alias: String?
        /// The name of the image to delete.
        public let imageName: String
        /// The version to delete.
        public let version: Int?

        public init(alias: String? = nil, imageName: String, version: Int? = nil) {
            self.alias = alias
            self.imageName = imageName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 128)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.version, name: "version", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case imageName = "ImageName"
            case version = "Version"
        }
    }

    public struct DeleteImageVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInferenceExperimentRequest: AWSEncodableShape {
        /// The name of the inference experiment you want to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN of the deleted inference experiment.
        public let inferenceExperimentArn: String

        public init(inferenceExperimentArn: String) {
            self.inferenceExperimentArn = inferenceExperimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperimentArn = "InferenceExperimentArn"
        }
    }

    public struct DeleteModelBiasJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model bias job definition to delete.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DeleteModelCardRequest: AWSEncodableShape {
        /// The name of the model card to delete.
        public let modelCardName: String

        public init(modelCardName: String) {
            self.modelCardName = modelCardName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardName = "ModelCardName"
        }
    }

    public struct DeleteModelExplainabilityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model explainability job definition to delete.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DeleteModelInput: AWSEncodableShape {
        /// The name of the model to delete.
        public let modelName: String

        public init(modelName: String) {
            self.modelName = modelName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
        }
    }

    public struct DeleteModelPackageGroupInput: AWSEncodableShape {
        /// The name of the model group to delete.
        public let modelPackageGroupName: String

        public init(modelPackageGroupName: String) {
            self.modelPackageGroupName = modelPackageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 170)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupName = "ModelPackageGroupName"
        }
    }

    public struct DeleteModelPackageGroupPolicyInput: AWSEncodableShape {
        /// The name of the model group for which to delete the policy.
        public let modelPackageGroupName: String

        public init(modelPackageGroupName: String) {
            self.modelPackageGroupName = modelPackageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 63)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupName = "ModelPackageGroupName"
        }
    }

    public struct DeleteModelPackageInput: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the model package to delete. When you specify a name, the name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let modelPackageName: String

        public init(modelPackageName: String) {
            self.modelPackageName = modelPackageName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, max: 176)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, min: 1)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)(\\/[0-9]{1,5})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageName = "ModelPackageName"
        }
    }

    public struct DeleteModelQualityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model quality monitoring job definition to delete.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DeleteMonitoringScheduleRequest: AWSEncodableShape {
        /// The name of the monitoring schedule to delete.
        public let monitoringScheduleName: String

        public init(monitoringScheduleName: String) {
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct DeleteNotebookInstanceInput: AWSEncodableShape {
        /// The name of the SageMaker notebook instance to delete.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct DeleteNotebookInstanceLifecycleConfigInput: AWSEncodableShape {
        /// The name of the lifecycle configuration to delete.
        public let notebookInstanceLifecycleConfigName: String

        public init(notebookInstanceLifecycleConfigName: String) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        }
    }

    public struct DeletePipelineRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time.
        public let clientRequestToken: String
        /// The name of the pipeline to delete.
        public let pipelineName: String

        public init(clientRequestToken: String = DeletePipelineRequest.idempotencyToken(), pipelineName: String) {
            self.clientRequestToken = clientRequestToken
            self.pipelineName = pipelineName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 256)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case pipelineName = "PipelineName"
        }
    }

    public struct DeletePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline to delete.
        public let pipelineArn: String?

        public init(pipelineArn: String? = nil) {
            self.pipelineArn = pipelineArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineArn = "PipelineArn"
        }
    }

    public struct DeleteProjectInput: AWSEncodableShape {
        /// The name of the project to delete.
        public let projectName: String

        public init(projectName: String) {
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.projectName, name: "projectName", parent: name, max: 32)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectName = "ProjectName"
        }
    }

    public struct DeleteSpaceRequest: AWSEncodableShape {
        /// The ID of the associated Domain.
        public let domainId: String
        /// The name of the space.
        public let spaceName: String

        public init(domainId: String, spaceName: String) {
            self.domainId = domainId
            self.spaceName = spaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case spaceName = "SpaceName"
        }
    }

    public struct DeleteStudioLifecycleConfigRequest: AWSEncodableShape {
        /// The name of the Studio Lifecycle Configuration to delete.
        public let studioLifecycleConfigName: String

        public init(studioLifecycleConfigName: String) {
            self.studioLifecycleConfigName = studioLifecycleConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case studioLifecycleConfigName = "StudioLifecycleConfigName"
        }
    }

    public struct DeleteTagsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to delete.
        public let resourceArn: String
        /// An array or one or more tag keys to delete.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z-]*:sagemaker:[a-z0-9-]*:[0-9]{12}:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct DeleteTagsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrialComponentRequest: AWSEncodableShape {
        /// The name of the component to delete.
        public let trialComponentName: String

        public init(trialComponentName: String) {
            self.trialComponentName = trialComponentName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct DeleteTrialComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component is being deleted.
        public let trialComponentArn: String?

        public init(trialComponentArn: String? = nil) {
            self.trialComponentArn = trialComponentArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentArn = "TrialComponentArn"
        }
    }

    public struct DeleteTrialRequest: AWSEncodableShape {
        /// The name of the trial to delete.
        public let trialName: String

        public init(trialName: String) {
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialName = "TrialName"
        }
    }

    public struct DeleteTrialResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial that is being deleted.
        public let trialArn: String?

        public init(trialArn: String? = nil) {
            self.trialArn = trialArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialArn = "TrialArn"
        }
    }

    public struct DeleteUserProfileRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String
        /// The user profile name.
        public let userProfileName: String

        public init(domainId: String, userProfileName: String) {
            self.domainId = domainId
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case userProfileName = "UserProfileName"
        }
    }

    public struct DeleteWorkforceRequest: AWSEncodableShape {
        /// The name of the workforce.
        public let workforceName: String

        public init(workforceName: String) {
            self.workforceName = workforceName
        }

        public func validate(name: String) throws {
            try self.validate(self.workforceName, name: "workforceName", parent: name, max: 63)
            try self.validate(self.workforceName, name: "workforceName", parent: name, min: 1)
            try self.validate(self.workforceName, name: "workforceName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workforceName = "WorkforceName"
        }
    }

    public struct DeleteWorkforceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkteamRequest: AWSEncodableShape {
        /// The name of the work team to delete.
        public let workteamName: String

        public init(workteamName: String) {
            self.workteamName = workteamName
        }

        public func validate(name: String) throws {
            try self.validate(self.workteamName, name: "workteamName", parent: name, max: 63)
            try self.validate(self.workteamName, name: "workteamName", parent: name, min: 1)
            try self.validate(self.workteamName, name: "workteamName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
        }
    }

    public struct DeleteWorkteamResponse: AWSDecodableShape {
        /// Returns true if the work team was successfully deleted; otherwise, returns false.
        public let success: Bool

        public init(success: Bool) {
            self.success = success
        }

        private enum CodingKeys: String, CodingKey {
            case success = "Success"
        }
    }

    public struct DeployedImage: AWSDecodableShape {
        /// The date and time when the image path for the model resolved to the ResolvedImage
        public let resolutionTime: Date?
        /// The specific digest path of the image hosted in this ProductionVariant.
        public let resolvedImage: String?
        /// The image path you specified when you created the model.
        public let specifiedImage: String?

        public init(resolutionTime: Date? = nil, resolvedImage: String? = nil, specifiedImage: String? = nil) {
            self.resolutionTime = resolutionTime
            self.resolvedImage = resolvedImage
            self.specifiedImage = specifiedImage
        }

        private enum CodingKeys: String, CodingKey {
            case resolutionTime = "ResolutionTime"
            case resolvedImage = "ResolvedImage"
            case specifiedImage = "SpecifiedImage"
        }
    }

    public struct DeploymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Automatic rollback configuration for handling endpoint deployment failures and recovery.
        public let autoRollbackConfiguration: AutoRollbackConfig?
        /// Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default.
        public let blueGreenUpdatePolicy: BlueGreenUpdatePolicy

        public init(autoRollbackConfiguration: AutoRollbackConfig? = nil, blueGreenUpdatePolicy: BlueGreenUpdatePolicy) {
            self.autoRollbackConfiguration = autoRollbackConfiguration
            self.blueGreenUpdatePolicy = blueGreenUpdatePolicy
        }

        public func validate(name: String) throws {
            try self.autoRollbackConfiguration?.validate(name: "\(name).autoRollbackConfiguration")
            try self.blueGreenUpdatePolicy.validate(name: "\(name).blueGreenUpdatePolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case autoRollbackConfiguration = "AutoRollbackConfiguration"
            case blueGreenUpdatePolicy = "BlueGreenUpdatePolicy"
        }
    }

    public struct DeploymentStage: AWSEncodableShape {
        /// Configuration of the deployment details.
        public let deploymentConfig: EdgeDeploymentConfig?
        /// Configuration of the devices in the stage.
        public let deviceSelectionConfig: DeviceSelectionConfig
        /// The name of the stage.
        public let stageName: String

        public init(deploymentConfig: EdgeDeploymentConfig? = nil, deviceSelectionConfig: DeviceSelectionConfig, stageName: String) {
            self.deploymentConfig = deploymentConfig
            self.deviceSelectionConfig = deviceSelectionConfig
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.deviceSelectionConfig.validate(name: "\(name).deviceSelectionConfig")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 63)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentConfig = "DeploymentConfig"
            case deviceSelectionConfig = "DeviceSelectionConfig"
            case stageName = "StageName"
        }
    }

    public struct DeploymentStageStatusSummary: AWSDecodableShape {
        /// Configuration of the deployment details.
        public let deploymentConfig: EdgeDeploymentConfig
        /// General status of the current state.
        public let deploymentStatus: EdgeDeploymentStatus
        /// Configuration of the devices in the stage.
        public let deviceSelectionConfig: DeviceSelectionConfig
        /// The name of the stage.
        public let stageName: String

        public init(deploymentConfig: EdgeDeploymentConfig, deploymentStatus: EdgeDeploymentStatus, deviceSelectionConfig: DeviceSelectionConfig, stageName: String) {
            self.deploymentConfig = deploymentConfig
            self.deploymentStatus = deploymentStatus
            self.deviceSelectionConfig = deviceSelectionConfig
            self.stageName = stageName
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentConfig = "DeploymentConfig"
            case deploymentStatus = "DeploymentStatus"
            case deviceSelectionConfig = "DeviceSelectionConfig"
            case stageName = "StageName"
        }
    }

    public struct DeregisterDevicesRequest: AWSEncodableShape {
        /// The name of the fleet the devices belong to.
        public let deviceFleetName: String
        /// The unique IDs of the devices.
        public let deviceNames: [String]

        public init(deviceFleetName: String, deviceNames: [String]) {
            self.deviceFleetName = deviceFleetName
            self.deviceNames = deviceNames
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.deviceNames.forEach {
                try validate($0, name: "deviceNames[]", parent: name, max: 63)
                try validate($0, name: "deviceNames[]", parent: name, min: 1)
                try validate($0, name: "deviceNames[]", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case deviceNames = "DeviceNames"
        }
    }

    public struct DescribeActionRequest: AWSEncodableShape {
        /// The name of the action to describe.
        public let actionName: String

        public init(actionName: String) {
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 120)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "ActionName"
        }
    }

    public struct DescribeActionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let actionArn: String?
        /// The name of the action.
        public let actionName: String?
        /// The type of the action.
        public let actionType: String?
        public let createdBy: UserContext?
        /// When the action was created.
        public let creationTime: Date?
        /// The description of the action.
        public let description: String?
        public let lastModifiedBy: UserContext?
        /// When the action was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        public let metadataProperties: MetadataProperties?
        /// A list of the action's properties.
        public let properties: [String: String]?
        /// The source of the action.
        public let source: ActionSource?
        /// The status of the action.
        public let status: ActionStatus?

        public init(actionArn: String? = nil, actionName: String? = nil, actionType: String? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, description: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, metadataProperties: MetadataProperties? = nil, properties: [String: String]? = nil, source: ActionSource? = nil, status: ActionStatus? = nil) {
            self.actionArn = actionArn
            self.actionName = actionName
            self.actionType = actionType
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.metadataProperties = metadataProperties
            self.properties = properties
            self.source = source
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case actionArn = "ActionArn"
            case actionName = "ActionName"
            case actionType = "ActionType"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case metadataProperties = "MetadataProperties"
            case properties = "Properties"
            case source = "Source"
            case status = "Status"
        }
    }

    public struct DescribeAlgorithmInput: AWSEncodableShape {
        /// The name of the algorithm to describe.
        public let algorithmName: String

        public init(algorithmName: String) {
            self.algorithmName = algorithmName
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 170)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
        }
    }

    public struct DescribeAlgorithmOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String
        /// A brief summary about the algorithm.
        public let algorithmDescription: String?
        /// The name of the algorithm being described.
        public let algorithmName: String
        /// The current status of the algorithm.
        public let algorithmStatus: AlgorithmStatus
        /// Details about the current status of the algorithm.
        public let algorithmStatusDetails: AlgorithmStatusDetails
        /// Whether the algorithm is certified to be listed in Amazon Web Services Marketplace.
        public let certifyForMarketplace: Bool?
        /// A timestamp specifying when the algorithm was created.
        public let creationTime: Date
        /// Details about inference jobs that the algorithm runs.
        public let inferenceSpecification: InferenceSpecification?
        /// The product identifier of the algorithm.
        public let productId: String?
        /// Details about training jobs run by this algorithm.
        public let trainingSpecification: TrainingSpecification
        /// Details about configurations for one or more training jobs that SageMaker runs to test the algorithm.
        public let validationSpecification: AlgorithmValidationSpecification?

        public init(algorithmArn: String, algorithmDescription: String? = nil, algorithmName: String, algorithmStatus: AlgorithmStatus, algorithmStatusDetails: AlgorithmStatusDetails, certifyForMarketplace: Bool? = nil, creationTime: Date, inferenceSpecification: InferenceSpecification? = nil, productId: String? = nil, trainingSpecification: TrainingSpecification, validationSpecification: AlgorithmValidationSpecification? = nil) {
            self.algorithmArn = algorithmArn
            self.algorithmDescription = algorithmDescription
            self.algorithmName = algorithmName
            self.algorithmStatus = algorithmStatus
            self.algorithmStatusDetails = algorithmStatusDetails
            self.certifyForMarketplace = certifyForMarketplace
            self.creationTime = creationTime
            self.inferenceSpecification = inferenceSpecification
            self.productId = productId
            self.trainingSpecification = trainingSpecification
            self.validationSpecification = validationSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case algorithmDescription = "AlgorithmDescription"
            case algorithmName = "AlgorithmName"
            case algorithmStatus = "AlgorithmStatus"
            case algorithmStatusDetails = "AlgorithmStatusDetails"
            case certifyForMarketplace = "CertifyForMarketplace"
            case creationTime = "CreationTime"
            case inferenceSpecification = "InferenceSpecification"
            case productId = "ProductId"
            case trainingSpecification = "TrainingSpecification"
            case validationSpecification = "ValidationSpecification"
        }
    }

    public struct DescribeAppImageConfigRequest: AWSEncodableShape {
        /// The name of the AppImageConfig to describe.
        public let appImageConfigName: String

        public init(appImageConfigName: String) {
            self.appImageConfigName = appImageConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, max: 63)
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigName = "AppImageConfigName"
        }
    }

    public struct DescribeAppImageConfigResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppImageConfig.
        public let appImageConfigArn: String?
        /// The name of the AppImageConfig.
        public let appImageConfigName: String?
        /// When the AppImageConfig was created.
        public let creationTime: Date?
        /// The configuration of a KernelGateway app.
        public let kernelGatewayImageConfig: KernelGatewayImageConfig?
        /// When the AppImageConfig was last modified.
        public let lastModifiedTime: Date?

        public init(appImageConfigArn: String? = nil, appImageConfigName: String? = nil, creationTime: Date? = nil, kernelGatewayImageConfig: KernelGatewayImageConfig? = nil, lastModifiedTime: Date? = nil) {
            self.appImageConfigArn = appImageConfigArn
            self.appImageConfigName = appImageConfigName
            self.creationTime = creationTime
            self.kernelGatewayImageConfig = kernelGatewayImageConfig
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigArn = "AppImageConfigArn"
            case appImageConfigName = "AppImageConfigName"
            case creationTime = "CreationTime"
            case kernelGatewayImageConfig = "KernelGatewayImageConfig"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct DescribeAppRequest: AWSEncodableShape {
        /// The name of the app.
        public let appName: String
        /// The type of app.
        public let appType: AppType
        /// The domain ID.
        public let domainId: String
        /// The name of the space.
        public let spaceName: String?
        /// The user profile name. If this value is not set, then SpaceName must be set.
        public let userProfileName: String?

        public init(appName: String, appType: AppType, domainId: String, spaceName: String? = nil, userProfileName: String? = nil) {
            self.appName = appName
            self.appType = appType
            self.domainId = domainId
            self.spaceName = spaceName
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.appName, name: "appName", parent: name, max: 63)
            try self.validate(self.appName, name: "appName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appName = "AppName"
            case appType = "AppType"
            case domainId = "DomainId"
            case spaceName = "SpaceName"
            case userProfileName = "UserProfileName"
        }
    }

    public struct DescribeAppResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the app.
        public let appArn: String?
        /// The name of the app.
        public let appName: String?
        /// The type of app.
        public let appType: AppType?
        /// The creation time.
        public let creationTime: Date?
        /// The domain ID.
        public let domainId: String?
        /// The failure reason.
        public let failureReason: String?
        /// The timestamp of the last health check.
        public let lastHealthCheckTimestamp: Date?
        /// The timestamp of the last user's activity. LastUserActivityTimestamp is also updated when SageMaker performs health checks without user activity. As a result, this value is set to the same value as LastHealthCheckTimestamp.
        public let lastUserActivityTimestamp: Date?
        /// The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.
        public let resourceSpec: ResourceSpec?
        /// The name of the space. If this value is not set, then UserProfileName must be set.
        public let spaceName: String?
        /// The status.
        public let status: AppStatus?
        /// The user profile name.
        public let userProfileName: String?

        public init(appArn: String? = nil, appName: String? = nil, appType: AppType? = nil, creationTime: Date? = nil, domainId: String? = nil, failureReason: String? = nil, lastHealthCheckTimestamp: Date? = nil, lastUserActivityTimestamp: Date? = nil, resourceSpec: ResourceSpec? = nil, spaceName: String? = nil, status: AppStatus? = nil, userProfileName: String? = nil) {
            self.appArn = appArn
            self.appName = appName
            self.appType = appType
            self.creationTime = creationTime
            self.domainId = domainId
            self.failureReason = failureReason
            self.lastHealthCheckTimestamp = lastHealthCheckTimestamp
            self.lastUserActivityTimestamp = lastUserActivityTimestamp
            self.resourceSpec = resourceSpec
            self.spaceName = spaceName
            self.status = status
            self.userProfileName = userProfileName
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "AppArn"
            case appName = "AppName"
            case appType = "AppType"
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case failureReason = "FailureReason"
            case lastHealthCheckTimestamp = "LastHealthCheckTimestamp"
            case lastUserActivityTimestamp = "LastUserActivityTimestamp"
            case resourceSpec = "ResourceSpec"
            case spaceName = "SpaceName"
            case status = "Status"
            case userProfileName = "UserProfileName"
        }
    }

    public struct DescribeArtifactRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the artifact to describe.
        public let artifactArn: String

        public init(artifactArn: String) {
            self.artifactArn = artifactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, max: 256)
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:artifact/")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
        }
    }

    public struct DescribeArtifactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the artifact.
        public let artifactArn: String?
        /// The name of the artifact.
        public let artifactName: String?
        /// The type of the artifact.
        public let artifactType: String?
        public let createdBy: UserContext?
        /// When the artifact was created.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// When the artifact was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        public let metadataProperties: MetadataProperties?
        /// A list of the artifact's properties.
        public let properties: [String: String]?
        /// The source of the artifact.
        public let source: ArtifactSource?

        public init(artifactArn: String? = nil, artifactName: String? = nil, artifactType: String? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, metadataProperties: MetadataProperties? = nil, properties: [String: String]? = nil, source: ArtifactSource? = nil) {
            self.artifactArn = artifactArn
            self.artifactName = artifactName
            self.artifactType = artifactType
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.metadataProperties = metadataProperties
            self.properties = properties
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
            case artifactName = "ArtifactName"
            case artifactType = "ArtifactType"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case metadataProperties = "MetadataProperties"
            case properties = "Properties"
            case source = "Source"
        }
    }

    public struct DescribeAutoMLJobRequest: AWSEncodableShape {
        /// Requests information about an AutoML job using its unique name.
        public let autoMLJobName: String

        public init(autoMLJobName: String) {
            self.autoMLJobName = autoMLJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, max: 32)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, min: 1)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobName = "AutoMLJobName"
        }
    }

    public struct DescribeAutoMLJobResponse: AWSDecodableShape {
        /// Returns the ARN of the AutoML job.
        public let autoMLJobArn: String
        /// Returns information on the job's artifacts found in AutoMLJobArtifacts.
        public let autoMLJobArtifacts: AutoMLJobArtifacts?
        /// Returns the configuration for the AutoML job.
        public let autoMLJobConfig: AutoMLJobConfig?
        /// Returns the name of the AutoML job.
        public let autoMLJobName: String
        /// Returns the job's objective.
        public let autoMLJobObjective: AutoMLJobObjective?
        /// Returns the secondary status of the AutoML job.
        public let autoMLJobSecondaryStatus: AutoMLJobSecondaryStatus
        /// Returns the status of the AutoML job.
        public let autoMLJobStatus: AutoMLJobStatus
        /// The best model candidate selected by SageMaker Autopilot using both the best objective metric and lowest InferenceLatency for an experiment.
        public let bestCandidate: AutoMLCandidate?
        /// Returns the creation time of the AutoML job.
        public let creationTime: Date
        /// Returns the end time of the AutoML job.
        public let endTime: Date?
        /// Returns the failure reason for an AutoML job, when applicable.
        public let failureReason: String?
        /// Indicates whether the output for an AutoML job generates candidate definitions only.
        public let generateCandidateDefinitionsOnly: Bool?
        /// Returns the input data configuration for the AutoML job..
        public let inputDataConfig: [AutoMLChannel]
        /// Returns the job's last modified time.
        public let lastModifiedTime: Date
        /// Indicates whether the model was deployed automatically to an endpoint and the name of that endpoint if deployed automatically.
        public let modelDeployConfig: ModelDeployConfig?
        /// Provides information about endpoint for the model deployment.
        public let modelDeployResult: ModelDeployResult?
        /// Returns the job's output data config.
        public let outputDataConfig: AutoMLOutputDataConfig
        /// Returns a list of reasons for partial failures within an AutoML job.
        public let partialFailureReasons: [AutoMLPartialFailureReason]?
        /// Returns the job's problem type.
        public let problemType: ProblemType?
        /// This contains ProblemType, AutoMLJobObjective, and CompletionCriteria. If you do not provide these values, they are auto-inferred. If you do provide them, the values used are the ones you provide.
        public let resolvedAttributes: ResolvedAttributes?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that has read permission to the input data location and write permission to the output data location in Amazon S3.
        public let roleArn: String

        public init(autoMLJobArn: String, autoMLJobArtifacts: AutoMLJobArtifacts? = nil, autoMLJobConfig: AutoMLJobConfig? = nil, autoMLJobName: String, autoMLJobObjective: AutoMLJobObjective? = nil, autoMLJobSecondaryStatus: AutoMLJobSecondaryStatus, autoMLJobStatus: AutoMLJobStatus, bestCandidate: AutoMLCandidate? = nil, creationTime: Date, endTime: Date? = nil, failureReason: String? = nil, generateCandidateDefinitionsOnly: Bool? = nil, inputDataConfig: [AutoMLChannel], lastModifiedTime: Date, modelDeployConfig: ModelDeployConfig? = nil, modelDeployResult: ModelDeployResult? = nil, outputDataConfig: AutoMLOutputDataConfig, partialFailureReasons: [AutoMLPartialFailureReason]? = nil, problemType: ProblemType? = nil, resolvedAttributes: ResolvedAttributes? = nil, roleArn: String) {
            self.autoMLJobArn = autoMLJobArn
            self.autoMLJobArtifacts = autoMLJobArtifacts
            self.autoMLJobConfig = autoMLJobConfig
            self.autoMLJobName = autoMLJobName
            self.autoMLJobObjective = autoMLJobObjective
            self.autoMLJobSecondaryStatus = autoMLJobSecondaryStatus
            self.autoMLJobStatus = autoMLJobStatus
            self.bestCandidate = bestCandidate
            self.creationTime = creationTime
            self.endTime = endTime
            self.failureReason = failureReason
            self.generateCandidateDefinitionsOnly = generateCandidateDefinitionsOnly
            self.inputDataConfig = inputDataConfig
            self.lastModifiedTime = lastModifiedTime
            self.modelDeployConfig = modelDeployConfig
            self.modelDeployResult = modelDeployResult
            self.outputDataConfig = outputDataConfig
            self.partialFailureReasons = partialFailureReasons
            self.problemType = problemType
            self.resolvedAttributes = resolvedAttributes
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobArn = "AutoMLJobArn"
            case autoMLJobArtifacts = "AutoMLJobArtifacts"
            case autoMLJobConfig = "AutoMLJobConfig"
            case autoMLJobName = "AutoMLJobName"
            case autoMLJobObjective = "AutoMLJobObjective"
            case autoMLJobSecondaryStatus = "AutoMLJobSecondaryStatus"
            case autoMLJobStatus = "AutoMLJobStatus"
            case bestCandidate = "BestCandidate"
            case creationTime = "CreationTime"
            case endTime = "EndTime"
            case failureReason = "FailureReason"
            case generateCandidateDefinitionsOnly = "GenerateCandidateDefinitionsOnly"
            case inputDataConfig = "InputDataConfig"
            case lastModifiedTime = "LastModifiedTime"
            case modelDeployConfig = "ModelDeployConfig"
            case modelDeployResult = "ModelDeployResult"
            case outputDataConfig = "OutputDataConfig"
            case partialFailureReasons = "PartialFailureReasons"
            case problemType = "ProblemType"
            case resolvedAttributes = "ResolvedAttributes"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeCodeRepositoryInput: AWSEncodableShape {
        /// The name of the Git repository to describe.
        public let codeRepositoryName: String

        public init(codeRepositoryName: String) {
            self.codeRepositoryName = codeRepositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, max: 63)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, min: 1)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
        }
    }

    public struct DescribeCodeRepositoryOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Git repository.
        public let codeRepositoryArn: String
        /// The name of the Git repository.
        public let codeRepositoryName: String
        /// The date and time that the repository was created.
        public let creationTime: Date
        /// Configuration details about the repository, including the URL where the repository is located, the default branch, and the Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.
        public let gitConfig: GitConfig?
        /// The date and time that the repository was last changed.
        public let lastModifiedTime: Date

        public init(codeRepositoryArn: String, codeRepositoryName: String, creationTime: Date, gitConfig: GitConfig? = nil, lastModifiedTime: Date) {
            self.codeRepositoryArn = codeRepositoryArn
            self.codeRepositoryName = codeRepositoryName
            self.creationTime = creationTime
            self.gitConfig = gitConfig
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
            case codeRepositoryName = "CodeRepositoryName"
            case creationTime = "CreationTime"
            case gitConfig = "GitConfig"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct DescribeCompilationJobRequest: AWSEncodableShape {
        /// The name of the model compilation job that you want information about.
        public let compilationJobName: String

        public init(compilationJobName: String) {
            self.compilationJobName = compilationJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, max: 63)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, min: 1)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
        }
    }

    public struct DescribeCompilationJobResponse: AWSDecodableShape {
        /// The time when the model compilation job on a compilation job instance ended. For a successful or stopped job, this is when the job's model artifacts have finished uploading. For a failed job, this is when Amazon SageMaker detected that the job failed.
        public let compilationEndTime: Date?
        /// The Amazon Resource Name (ARN) of the model compilation job.
        public let compilationJobArn: String
        /// The name of the model compilation job.
        public let compilationJobName: String
        /// The status of the model compilation job.
        public let compilationJobStatus: CompilationJobStatus
        /// The time when the model compilation job started the CompilationJob instances.  You are billed for the time between this timestamp and the timestamp in the DescribeCompilationJobResponse$CompilationEndTime field. In Amazon CloudWatch Logs, the start time might be later than this time. That's because it takes time to download the compilation job, which depends on the size of the compilation job container.
        public let compilationStartTime: Date?
        /// The time that the model compilation job was created.
        public let creationTime: Date
        /// If a model compilation job failed, the reason it failed.
        public let failureReason: String
        /// The inference image to use when compiling a model.  Specify an image only if the target device is a cloud instance.
        public let inferenceImage: String?
        /// Information about the location in Amazon S3 of the input model artifacts, the name and shape of the expected data inputs, and the framework in which the model was trained.
        public let inputConfig: InputConfig
        /// The time that the status of the model compilation job was last modified.
        public let lastModifiedTime: Date
        /// Information about the location in Amazon S3 that has been configured for storing the model artifacts used in the compilation job.
        public let modelArtifacts: ModelArtifacts
        /// Provides a BLAKE2 hash value that identifies the compiled model artifacts in Amazon S3.
        public let modelDigests: ModelDigests?
        /// The Amazon Resource Name (ARN) of the versioned model package that was  provided to SageMaker Neo when you initiated a compilation job.
        public let modelPackageVersionArn: String?
        /// Information about the output location for the compiled model and the target device that the model runs on.
        public let outputConfig: OutputConfig
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker assumes to perform the model compilation job.
        public let roleArn: String
        /// Specifies a limit to how long a model compilation job can run. When the job reaches the time limit, Amazon SageMaker ends the compilation job. Use this API to cap model training costs.
        public let stoppingCondition: StoppingCondition
        /// A VpcConfig object that specifies the VPC that you want your compilation job to connect to. Control access to your models by configuring the VPC. For more information, see Protect Compilation Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: NeoVpcConfig?

        public init(compilationEndTime: Date? = nil, compilationJobArn: String, compilationJobName: String, compilationJobStatus: CompilationJobStatus, compilationStartTime: Date? = nil, creationTime: Date, failureReason: String, inferenceImage: String? = nil, inputConfig: InputConfig, lastModifiedTime: Date, modelArtifacts: ModelArtifacts, modelDigests: ModelDigests? = nil, modelPackageVersionArn: String? = nil, outputConfig: OutputConfig, roleArn: String, stoppingCondition: StoppingCondition, vpcConfig: NeoVpcConfig? = nil) {
            self.compilationEndTime = compilationEndTime
            self.compilationJobArn = compilationJobArn
            self.compilationJobName = compilationJobName
            self.compilationJobStatus = compilationJobStatus
            self.compilationStartTime = compilationStartTime
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.inferenceImage = inferenceImage
            self.inputConfig = inputConfig
            self.lastModifiedTime = lastModifiedTime
            self.modelArtifacts = modelArtifacts
            self.modelDigests = modelDigests
            self.modelPackageVersionArn = modelPackageVersionArn
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case compilationEndTime = "CompilationEndTime"
            case compilationJobArn = "CompilationJobArn"
            case compilationJobName = "CompilationJobName"
            case compilationJobStatus = "CompilationJobStatus"
            case compilationStartTime = "CompilationStartTime"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case inferenceImage = "InferenceImage"
            case inputConfig = "InputConfig"
            case lastModifiedTime = "LastModifiedTime"
            case modelArtifacts = "ModelArtifacts"
            case modelDigests = "ModelDigests"
            case modelPackageVersionArn = "ModelPackageVersionArn"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct DescribeContextRequest: AWSEncodableShape {
        /// The name of the context to describe.
        public let contextName: String

        public init(contextName: String) {
            self.contextName = contextName
        }

        public func validate(name: String) throws {
            try self.validate(self.contextName, name: "contextName", parent: name, max: 256)
            try self.validate(self.contextName, name: "contextName", parent: name, min: 1)
            try self.validate(self.contextName, name: "contextName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial|experiment-trial-component|artifact|action|context)\\/)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,119})$")
        }

        private enum CodingKeys: String, CodingKey {
            case contextName = "ContextName"
        }
    }

    public struct DescribeContextResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the context.
        public let contextArn: String?
        /// The name of the context.
        public let contextName: String?
        /// The type of the context.
        public let contextType: String?
        public let createdBy: UserContext?
        /// When the context was created.
        public let creationTime: Date?
        /// The description of the context.
        public let description: String?
        public let lastModifiedBy: UserContext?
        /// When the context was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        /// A list of the context's properties.
        public let properties: [String: String]?
        /// The source of the context.
        public let source: ContextSource?

        public init(contextArn: String? = nil, contextName: String? = nil, contextType: String? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, description: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, properties: [String: String]? = nil, source: ContextSource? = nil) {
            self.contextArn = contextArn
            self.contextName = contextName
            self.contextType = contextType
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.properties = properties
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case contextArn = "ContextArn"
            case contextName = "ContextName"
            case contextType = "ContextType"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case properties = "Properties"
            case source = "Source"
        }
    }

    public struct DescribeDataQualityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the data quality monitoring job definition to describe.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DescribeDataQualityJobDefinitionResponse: AWSDecodableShape {
        /// The time that the data quality monitoring job definition was created.
        public let creationTime: Date
        /// Information about the container that runs the data quality monitoring job.
        public let dataQualityAppSpecification: DataQualityAppSpecification
        /// The constraints and baselines for the data quality monitoring job definition.
        public let dataQualityBaselineConfig: DataQualityBaselineConfig?
        /// The list of inputs for the data quality monitoring job. Currently endpoints are supported.
        public let dataQualityJobInput: DataQualityJobInput
        public let dataQualityJobOutputConfig: MonitoringOutputConfig
        /// The Amazon Resource Name (ARN) of the data quality monitoring job definition.
        public let jobDefinitionArn: String
        /// The name of the data quality monitoring job definition.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// The networking configuration for the data quality monitoring job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?

        public init(creationTime: Date, dataQualityAppSpecification: DataQualityAppSpecification, dataQualityBaselineConfig: DataQualityBaselineConfig? = nil, dataQualityJobInput: DataQualityJobInput, dataQualityJobOutputConfig: MonitoringOutputConfig, jobDefinitionArn: String, jobDefinitionName: String, jobResources: MonitoringResources, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil) {
            self.creationTime = creationTime
            self.dataQualityAppSpecification = dataQualityAppSpecification
            self.dataQualityBaselineConfig = dataQualityBaselineConfig
            self.dataQualityJobInput = dataQualityJobInput
            self.dataQualityJobOutputConfig = dataQualityJobOutputConfig
            self.jobDefinitionArn = jobDefinitionArn
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataQualityAppSpecification = "DataQualityAppSpecification"
            case dataQualityBaselineConfig = "DataQualityBaselineConfig"
            case dataQualityJobInput = "DataQualityJobInput"
            case dataQualityJobOutputConfig = "DataQualityJobOutputConfig"
            case jobDefinitionArn = "JobDefinitionArn"
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct DescribeDeviceFleetRequest: AWSEncodableShape {
        /// The name of the fleet.
        public let deviceFleetName: String

        public init(deviceFleetName: String) {
            self.deviceFleetName = deviceFleetName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
        }
    }

    public struct DescribeDeviceFleetResponse: AWSDecodableShape {
        /// Timestamp of when the device fleet was created.
        public let creationTime: Date
        /// A description of the fleet.
        public let description: String?
        /// The The Amazon Resource Name (ARN) of the fleet.
        public let deviceFleetArn: String
        /// The name of the fleet.
        public let deviceFleetName: String
        /// The Amazon Resource Name (ARN) alias created in Amazon Web Services Internet of Things (IoT).
        public let iotRoleAlias: String?
        /// Timestamp of when the device fleet was last updated.
        public let lastModifiedTime: Date
        /// The output configuration for storing sampled data.
        public let outputConfig: EdgeOutputConfig
        /// The Amazon Resource Name (ARN) that has access to Amazon Web Services Internet of Things (IoT).
        public let roleArn: String?

        public init(creationTime: Date, description: String? = nil, deviceFleetArn: String, deviceFleetName: String, iotRoleAlias: String? = nil, lastModifiedTime: Date, outputConfig: EdgeOutputConfig, roleArn: String? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.deviceFleetArn = deviceFleetArn
            self.deviceFleetName = deviceFleetName
            self.iotRoleAlias = iotRoleAlias
            self.lastModifiedTime = lastModifiedTime
            self.outputConfig = outputConfig
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case deviceFleetArn = "DeviceFleetArn"
            case deviceFleetName = "DeviceFleetName"
            case iotRoleAlias = "IotRoleAlias"
            case lastModifiedTime = "LastModifiedTime"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeDeviceRequest: AWSEncodableShape {
        /// The name of the fleet the devices belong to.
        public let deviceFleetName: String
        /// The unique ID of the device.
        public let deviceName: String
        /// Next token of device description.
        public let nextToken: String?

        public init(deviceFleetName: String, deviceName: String, nextToken: String? = nil) {
            self.deviceFleetName = deviceFleetName
            self.deviceName = deviceName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 63)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case deviceName = "DeviceName"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDeviceResponse: AWSDecodableShape {
        /// Edge Manager agent version.
        public let agentVersion: String?
        /// A description of the device.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the device.
        public let deviceArn: String?
        /// The name of the fleet the device belongs to.
        public let deviceFleetName: String
        /// The unique identifier of the device.
        public let deviceName: String
        /// The Amazon Web Services Internet of Things (IoT) object thing name associated with the device.
        public let iotThingName: String?
        /// The last heartbeat received from the device.
        public let latestHeartbeat: Date?
        /// The maximum number of models.
        public let maxModels: Int?
        /// Models on the device.
        public let models: [EdgeModel]?
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?
        /// The timestamp of the last registration or de-reregistration.
        public let registrationTime: Date

        public init(agentVersion: String? = nil, description: String? = nil, deviceArn: String? = nil, deviceFleetName: String, deviceName: String, iotThingName: String? = nil, latestHeartbeat: Date? = nil, maxModels: Int? = nil, models: [EdgeModel]? = nil, nextToken: String? = nil, registrationTime: Date) {
            self.agentVersion = agentVersion
            self.description = description
            self.deviceArn = deviceArn
            self.deviceFleetName = deviceFleetName
            self.deviceName = deviceName
            self.iotThingName = iotThingName
            self.latestHeartbeat = latestHeartbeat
            self.maxModels = maxModels
            self.models = models
            self.nextToken = nextToken
            self.registrationTime = registrationTime
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "AgentVersion"
            case description = "Description"
            case deviceArn = "DeviceArn"
            case deviceFleetName = "DeviceFleetName"
            case deviceName = "DeviceName"
            case iotThingName = "IotThingName"
            case latestHeartbeat = "LatestHeartbeat"
            case maxModels = "MaxModels"
            case models = "Models"
            case nextToken = "NextToken"
            case registrationTime = "RegistrationTime"
        }
    }

    public struct DescribeDomainRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
        }
    }

    public struct DescribeDomainResponse: AWSDecodableShape {
        /// Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly.    PublicInternetOnly - Non-EFS traffic is through a VPC managed by Amazon SageMaker, which allows direct internet access    VpcOnly - All Studio traffic is through the specified VPC and subnets
        public let appNetworkAccessType: AppNetworkAccessType?
        /// The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Required when CreateDomain.AppNetworkAccessType is VPCOnly and DomainSettings.RStudioServerProDomainSettings.DomainExecutionRoleArn is provided.
        public let appSecurityGroupManagement: AppSecurityGroupManagement?
        /// The domain's authentication mode.
        public let authMode: AuthMode?
        /// The creation time.
        public let creationTime: Date?
        /// The default settings used to create a space.
        public let defaultSpaceSettings: DefaultSpaceSettings?
        /// Settings which are applied to UserProfiles in this domain if settings are not explicitly specified in a given UserProfile.
        public let defaultUserSettings: UserSettings?
        /// The domain's Amazon Resource Name (ARN).
        public let domainArn: String?
        /// The domain ID.
        public let domainId: String?
        /// The domain name.
        public let domainName: String?
        /// A collection of Domain settings.
        public let domainSettings: DomainSettings?
        /// The failure reason.
        public let failureReason: String?
        /// The ID of the Amazon Elastic File System (EFS) managed by this Domain.
        public let homeEfsFileSystemId: String?
        /// Use KmsKeyId.
        public let homeEfsFileSystemKmsKeyId: String?
        /// The Amazon Web Services KMS customer managed key used to encrypt the EFS volume attached to the domain.
        public let kmsKeyId: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The ID of the security group that authorizes traffic between the RSessionGateway apps and the RStudioServerPro app.
        public let securityGroupIdForDomainBoundary: String?
        /// The IAM Identity Center managed application instance ID.
        public let singleSignOnManagedApplicationInstanceId: String?
        /// The status.
        public let status: DomainStatus?
        /// The VPC subnets that Studio uses for communication.
        public let subnetIds: [String]?
        /// The domain's URL.
        public let url: String?
        /// The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        public let vpcId: String?

        public init(appNetworkAccessType: AppNetworkAccessType? = nil, appSecurityGroupManagement: AppSecurityGroupManagement? = nil, authMode: AuthMode? = nil, creationTime: Date? = nil, defaultSpaceSettings: DefaultSpaceSettings? = nil, defaultUserSettings: UserSettings? = nil, domainArn: String? = nil, domainId: String? = nil, domainName: String? = nil, domainSettings: DomainSettings? = nil, failureReason: String? = nil, homeEfsFileSystemId: String? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date? = nil, securityGroupIdForDomainBoundary: String? = nil, singleSignOnManagedApplicationInstanceId: String? = nil, status: DomainStatus? = nil, subnetIds: [String]? = nil, url: String? = nil, vpcId: String? = nil) {
            self.appNetworkAccessType = appNetworkAccessType
            self.appSecurityGroupManagement = appSecurityGroupManagement
            self.authMode = authMode
            self.creationTime = creationTime
            self.defaultSpaceSettings = defaultSpaceSettings
            self.defaultUserSettings = defaultUserSettings
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainName = domainName
            self.domainSettings = domainSettings
            self.failureReason = failureReason
            self.homeEfsFileSystemId = homeEfsFileSystemId
            self.homeEfsFileSystemKmsKeyId = nil
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.securityGroupIdForDomainBoundary = securityGroupIdForDomainBoundary
            self.singleSignOnManagedApplicationInstanceId = singleSignOnManagedApplicationInstanceId
            self.status = status
            self.subnetIds = subnetIds
            self.url = url
            self.vpcId = vpcId
        }

        @available(*, deprecated, message: "Members homeEfsFileSystemKmsKeyId have been deprecated")
        public init(appNetworkAccessType: AppNetworkAccessType? = nil, appSecurityGroupManagement: AppSecurityGroupManagement? = nil, authMode: AuthMode? = nil, creationTime: Date? = nil, defaultSpaceSettings: DefaultSpaceSettings? = nil, defaultUserSettings: UserSettings? = nil, domainArn: String? = nil, domainId: String? = nil, domainName: String? = nil, domainSettings: DomainSettings? = nil, failureReason: String? = nil, homeEfsFileSystemId: String? = nil, homeEfsFileSystemKmsKeyId: String? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date? = nil, securityGroupIdForDomainBoundary: String? = nil, singleSignOnManagedApplicationInstanceId: String? = nil, status: DomainStatus? = nil, subnetIds: [String]? = nil, url: String? = nil, vpcId: String? = nil) {
            self.appNetworkAccessType = appNetworkAccessType
            self.appSecurityGroupManagement = appSecurityGroupManagement
            self.authMode = authMode
            self.creationTime = creationTime
            self.defaultSpaceSettings = defaultSpaceSettings
            self.defaultUserSettings = defaultUserSettings
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainName = domainName
            self.domainSettings = domainSettings
            self.failureReason = failureReason
            self.homeEfsFileSystemId = homeEfsFileSystemId
            self.homeEfsFileSystemKmsKeyId = homeEfsFileSystemKmsKeyId
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.securityGroupIdForDomainBoundary = securityGroupIdForDomainBoundary
            self.singleSignOnManagedApplicationInstanceId = singleSignOnManagedApplicationInstanceId
            self.status = status
            self.subnetIds = subnetIds
            self.url = url
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case appNetworkAccessType = "AppNetworkAccessType"
            case appSecurityGroupManagement = "AppSecurityGroupManagement"
            case authMode = "AuthMode"
            case creationTime = "CreationTime"
            case defaultSpaceSettings = "DefaultSpaceSettings"
            case defaultUserSettings = "DefaultUserSettings"
            case domainArn = "DomainArn"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case domainSettings = "DomainSettings"
            case failureReason = "FailureReason"
            case homeEfsFileSystemId = "HomeEfsFileSystemId"
            case homeEfsFileSystemKmsKeyId = "HomeEfsFileSystemKmsKeyId"
            case kmsKeyId = "KmsKeyId"
            case lastModifiedTime = "LastModifiedTime"
            case securityGroupIdForDomainBoundary = "SecurityGroupIdForDomainBoundary"
            case singleSignOnManagedApplicationInstanceId = "SingleSignOnManagedApplicationInstanceId"
            case status = "Status"
            case subnetIds = "SubnetIds"
            case url = "Url"
            case vpcId = "VpcId"
        }
    }

    public struct DescribeEdgeDeploymentPlanRequest: AWSEncodableShape {
        /// The name of the deployment plan to describe.
        public let edgeDeploymentPlanName: String
        /// The maximum number of results to select (50 by default).
        public let maxResults: Int?
        /// If the edge deployment plan has enough stages to require tokening, then this is the response from the last list of stages returned.
        public let nextToken: String?

        public init(edgeDeploymentPlanName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeEdgeDeploymentPlanResponse: AWSDecodableShape {
        /// The time when the edge deployment plan was created.
        public let creationTime: Date?
        /// The device fleet used for this edge deployment plan.
        public let deviceFleetName: String
        /// The number of edge devices that failed the deployment.
        public let edgeDeploymentFailed: Int?
        /// The number of edge devices yet to pick up deployment, or in progress.
        public let edgeDeploymentPending: Int?
        /// The ARN of edge deployment plan.
        public let edgeDeploymentPlanArn: String
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// The number of edge devices with the successful deployment.
        public let edgeDeploymentSuccess: Int?
        /// The time when the edge deployment plan was last updated.
        public let lastModifiedTime: Date?
        /// List of models associated with the edge deployment plan.
        public let modelConfigs: [EdgeDeploymentModelConfig]
        /// Token to use when calling the next set of stages in the edge deployment plan.
        public let nextToken: String?
        /// List of stages in the edge deployment plan.
        public let stages: [DeploymentStageStatusSummary]

        public init(creationTime: Date? = nil, deviceFleetName: String, edgeDeploymentFailed: Int? = nil, edgeDeploymentPending: Int? = nil, edgeDeploymentPlanArn: String, edgeDeploymentPlanName: String, edgeDeploymentSuccess: Int? = nil, lastModifiedTime: Date? = nil, modelConfigs: [EdgeDeploymentModelConfig], nextToken: String? = nil, stages: [DeploymentStageStatusSummary]) {
            self.creationTime = creationTime
            self.deviceFleetName = deviceFleetName
            self.edgeDeploymentFailed = edgeDeploymentFailed
            self.edgeDeploymentPending = edgeDeploymentPending
            self.edgeDeploymentPlanArn = edgeDeploymentPlanArn
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.edgeDeploymentSuccess = edgeDeploymentSuccess
            self.lastModifiedTime = lastModifiedTime
            self.modelConfigs = modelConfigs
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deviceFleetName = "DeviceFleetName"
            case edgeDeploymentFailed = "EdgeDeploymentFailed"
            case edgeDeploymentPending = "EdgeDeploymentPending"
            case edgeDeploymentPlanArn = "EdgeDeploymentPlanArn"
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case edgeDeploymentSuccess = "EdgeDeploymentSuccess"
            case lastModifiedTime = "LastModifiedTime"
            case modelConfigs = "ModelConfigs"
            case nextToken = "NextToken"
            case stages = "Stages"
        }
    }

    public struct DescribeEdgePackagingJobRequest: AWSEncodableShape {
        /// The name of the edge packaging job.
        public let edgePackagingJobName: String

        public init(edgePackagingJobName: String) {
            self.edgePackagingJobName = edgePackagingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, max: 63)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, min: 1)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgePackagingJobName = "EdgePackagingJobName"
        }
    }

    public struct DescribeEdgePackagingJobResponse: AWSDecodableShape {
        /// The name of the SageMaker Neo compilation job that is used to locate model artifacts that are being packaged.
        public let compilationJobName: String?
        /// The timestamp of when the packaging job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the edge packaging job.
        public let edgePackagingJobArn: String
        /// The name of the edge packaging job.
        public let edgePackagingJobName: String
        /// The current status of the packaging job.
        public let edgePackagingJobStatus: EdgePackagingJobStatus
        /// Returns a message describing the job status and error messages.
        public let edgePackagingJobStatusMessage: String?
        /// The timestamp of when the job was last updated.
        public let lastModifiedTime: Date?
        /// The Amazon Simple Storage (S3) URI where model artifacts ares stored.
        public let modelArtifact: String?
        /// The name of the model.
        public let modelName: String?
        /// The signature document of files in the model artifact.
        public let modelSignature: String?
        /// The version of the model.
        public let modelVersion: String?
        /// The output configuration for the edge packaging job.
        public let outputConfig: EdgeOutputConfig?
        /// The output of a SageMaker Edge Manager deployable resource.
        public let presetDeploymentOutput: EdgePresetDeploymentOutput?
        /// The Amazon Web Services KMS key to use when encrypting the EBS volume the job run on.
        public let resourceKey: String?
        /// The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to  download and upload the model, and to contact Neo.
        public let roleArn: String?

        public init(compilationJobName: String? = nil, creationTime: Date? = nil, edgePackagingJobArn: String, edgePackagingJobName: String, edgePackagingJobStatus: EdgePackagingJobStatus, edgePackagingJobStatusMessage: String? = nil, lastModifiedTime: Date? = nil, modelArtifact: String? = nil, modelName: String? = nil, modelSignature: String? = nil, modelVersion: String? = nil, outputConfig: EdgeOutputConfig? = nil, presetDeploymentOutput: EdgePresetDeploymentOutput? = nil, resourceKey: String? = nil, roleArn: String? = nil) {
            self.compilationJobName = compilationJobName
            self.creationTime = creationTime
            self.edgePackagingJobArn = edgePackagingJobArn
            self.edgePackagingJobName = edgePackagingJobName
            self.edgePackagingJobStatus = edgePackagingJobStatus
            self.edgePackagingJobStatusMessage = edgePackagingJobStatusMessage
            self.lastModifiedTime = lastModifiedTime
            self.modelArtifact = modelArtifact
            self.modelName = modelName
            self.modelSignature = modelSignature
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.presetDeploymentOutput = presetDeploymentOutput
            self.resourceKey = resourceKey
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case creationTime = "CreationTime"
            case edgePackagingJobArn = "EdgePackagingJobArn"
            case edgePackagingJobName = "EdgePackagingJobName"
            case edgePackagingJobStatus = "EdgePackagingJobStatus"
            case edgePackagingJobStatusMessage = "EdgePackagingJobStatusMessage"
            case lastModifiedTime = "LastModifiedTime"
            case modelArtifact = "ModelArtifact"
            case modelName = "ModelName"
            case modelSignature = "ModelSignature"
            case modelVersion = "ModelVersion"
            case outputConfig = "OutputConfig"
            case presetDeploymentOutput = "PresetDeploymentOutput"
            case resourceKey = "ResourceKey"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeEndpointConfigInput: AWSEncodableShape {
        /// The name of the endpoint configuration.
        public let endpointConfigName: String

        public init(endpointConfigName: String) {
            self.endpointConfigName = endpointConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, max: 63)
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct DescribeEndpointConfigOutput: AWSDecodableShape {
        /// Returns the description of an endpoint configuration created using the  CreateEndpointConfig API.
        public let asyncInferenceConfig: AsyncInferenceConfig?
        /// A timestamp that shows when the endpoint configuration was created.
        public let creationTime: Date
        public let dataCaptureConfig: DataCaptureConfig?
        /// The Amazon Resource Name (ARN) of the endpoint configuration.
        public let endpointConfigArn: String
        /// Name of the SageMaker endpoint configuration.
        public let endpointConfigName: String
        /// The configuration parameters for an explainer.
        public let explainerConfig: ExplainerConfig?
        /// Amazon Web Services KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance.
        public let kmsKeyId: String?
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint.
        public let productionVariants: [ProductionVariant]
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants.
        public let shadowProductionVariants: [ProductionVariant]?

        public init(asyncInferenceConfig: AsyncInferenceConfig? = nil, creationTime: Date, dataCaptureConfig: DataCaptureConfig? = nil, endpointConfigArn: String, endpointConfigName: String, explainerConfig: ExplainerConfig? = nil, kmsKeyId: String? = nil, productionVariants: [ProductionVariant], shadowProductionVariants: [ProductionVariant]? = nil) {
            self.asyncInferenceConfig = asyncInferenceConfig
            self.creationTime = creationTime
            self.dataCaptureConfig = dataCaptureConfig
            self.endpointConfigArn = endpointConfigArn
            self.endpointConfigName = endpointConfigName
            self.explainerConfig = explainerConfig
            self.kmsKeyId = kmsKeyId
            self.productionVariants = productionVariants
            self.shadowProductionVariants = shadowProductionVariants
        }

        private enum CodingKeys: String, CodingKey {
            case asyncInferenceConfig = "AsyncInferenceConfig"
            case creationTime = "CreationTime"
            case dataCaptureConfig = "DataCaptureConfig"
            case endpointConfigArn = "EndpointConfigArn"
            case endpointConfigName = "EndpointConfigName"
            case explainerConfig = "ExplainerConfig"
            case kmsKeyId = "KmsKeyId"
            case productionVariants = "ProductionVariants"
            case shadowProductionVariants = "ShadowProductionVariants"
        }
    }

    public struct DescribeEndpointInput: AWSEncodableShape {
        /// The name of the endpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DescribeEndpointOutput: AWSDecodableShape {
        /// Returns the description of an endpoint configuration created using the  CreateEndpointConfig API.
        public let asyncInferenceConfig: AsyncInferenceConfig?
        /// A timestamp that shows when the endpoint was created.
        public let creationTime: Date
        public let dataCaptureConfig: DataCaptureConfigSummary?
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The name of the endpoint configuration associated with this endpoint.
        public let endpointConfigName: String
        /// Name of the endpoint.
        public let endpointName: String
        /// The status of the endpoint.    OutOfService: Endpoint is not available to take incoming requests.    Creating: CreateEndpoint is executing.    Updating: UpdateEndpoint or UpdateEndpointWeightsAndCapacities is executing.    SystemUpdating: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.    RollingBack: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an InService status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an UpdateEndpointWeightsAndCapacities call or when the UpdateEndpointWeightsAndCapacities operation is called explicitly.    InService: Endpoint is available to process incoming requests.    Deleting: DeleteEndpoint is executing.    Failed: Endpoint could not be created, updated, or re-scaled. Use DescribeEndpointOutput$FailureReason for information about the failure. DeleteEndpoint is the only operation that can be performed on a failed endpoint.
        public let endpointStatus: EndpointStatus
        /// The configuration parameters for an explainer.
        public let explainerConfig: ExplainerConfig?
        /// If the status of the endpoint is Failed, the reason why it failed.
        public let failureReason: String?
        /// The most recent deployment configuration for the endpoint.
        public let lastDeploymentConfig: DeploymentConfig?
        /// A timestamp that shows when the endpoint was last modified.
        public let lastModifiedTime: Date
        /// Returns the summary of an in-progress deployment. This field is only returned when the endpoint is creating or updating with a new endpoint configuration.
        public let pendingDeploymentSummary: PendingDeploymentSummary?
        /// An array of ProductionVariantSummary objects, one for each model hosted behind this endpoint.
        public let productionVariants: [ProductionVariantSummary]?
        /// An array of ProductionVariantSummary objects, one for each model that you want to host at this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants.
        public let shadowProductionVariants: [ProductionVariantSummary]?

        public init(asyncInferenceConfig: AsyncInferenceConfig? = nil, creationTime: Date, dataCaptureConfig: DataCaptureConfigSummary? = nil, endpointArn: String, endpointConfigName: String, endpointName: String, endpointStatus: EndpointStatus, explainerConfig: ExplainerConfig? = nil, failureReason: String? = nil, lastDeploymentConfig: DeploymentConfig? = nil, lastModifiedTime: Date, pendingDeploymentSummary: PendingDeploymentSummary? = nil, productionVariants: [ProductionVariantSummary]? = nil, shadowProductionVariants: [ProductionVariantSummary]? = nil) {
            self.asyncInferenceConfig = asyncInferenceConfig
            self.creationTime = creationTime
            self.dataCaptureConfig = dataCaptureConfig
            self.endpointArn = endpointArn
            self.endpointConfigName = endpointConfigName
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.explainerConfig = explainerConfig
            self.failureReason = failureReason
            self.lastDeploymentConfig = lastDeploymentConfig
            self.lastModifiedTime = lastModifiedTime
            self.pendingDeploymentSummary = pendingDeploymentSummary
            self.productionVariants = productionVariants
            self.shadowProductionVariants = shadowProductionVariants
        }

        private enum CodingKeys: String, CodingKey {
            case asyncInferenceConfig = "AsyncInferenceConfig"
            case creationTime = "CreationTime"
            case dataCaptureConfig = "DataCaptureConfig"
            case endpointArn = "EndpointArn"
            case endpointConfigName = "EndpointConfigName"
            case endpointName = "EndpointName"
            case endpointStatus = "EndpointStatus"
            case explainerConfig = "ExplainerConfig"
            case failureReason = "FailureReason"
            case lastDeploymentConfig = "LastDeploymentConfig"
            case lastModifiedTime = "LastModifiedTime"
            case pendingDeploymentSummary = "PendingDeploymentSummary"
            case productionVariants = "ProductionVariants"
            case shadowProductionVariants = "ShadowProductionVariants"
        }
    }

    public struct DescribeExperimentRequest: AWSEncodableShape {
        /// The name of the experiment to describe.
        public let experimentName: String

        public init(experimentName: String) {
            self.experimentName = experimentName
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case experimentName = "ExperimentName"
        }
    }

    public struct DescribeExperimentResponse: AWSDecodableShape {
        /// Who created the experiment.
        public let createdBy: UserContext?
        /// When the experiment was created.
        public let creationTime: Date?
        /// The description of the experiment.
        public let description: String?
        /// The name of the experiment as displayed. If DisplayName isn't specified, ExperimentName is displayed.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the experiment.
        public let experimentArn: String?
        /// The name of the experiment.
        public let experimentName: String?
        /// Who last modified the experiment.
        public let lastModifiedBy: UserContext?
        /// When the experiment was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the source and, optionally, the type.
        public let source: ExperimentSource?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, description: String? = nil, displayName: String? = nil, experimentArn: String? = nil, experimentName: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, source: ExperimentSource? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.displayName = displayName
            self.experimentArn = experimentArn
            self.experimentName = experimentName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case description = "Description"
            case displayName = "DisplayName"
            case experimentArn = "ExperimentArn"
            case experimentName = "ExperimentName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case source = "Source"
        }
    }

    public struct DescribeFeatureGroupRequest: AWSEncodableShape {
        /// The name of the FeatureGroup you want described.
        public let featureGroupName: String
        /// A token to resume pagination of the list of Features (FeatureDefinitions). 2,500 Features are returned by default.
        public let nextToken: String?

        public init(featureGroupName: String, nextToken: String? = nil) {
            self.featureGroupName = featureGroupName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupName = "FeatureGroupName"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFeatureGroupResponse: AWSDecodableShape {
        /// A timestamp indicating when SageMaker created the FeatureGroup.
        public let creationTime: Date
        /// A free form description of the feature group.
        public let description: String?
        /// The name of the feature that stores the EventTime of a Record in a FeatureGroup. An EventTime is a point in time when a new event occurs that corresponds to the creation or update of a Record in a FeatureGroup. All Records in the FeatureGroup have a corresponding EventTime.
        public let eventTimeFeatureName: String
        /// The reason that the FeatureGroup failed to be replicated in the OfflineStore. This is failure can occur because:   The FeatureGroup could not be created in the OfflineStore.   The FeatureGroup could not be deleted from the OfflineStore.
        public let failureReason: String?
        /// A list of the Features in the FeatureGroup.  Each feature is defined by a FeatureName and FeatureType.
        public let featureDefinitions: [FeatureDefinition]
        /// The Amazon Resource Name (ARN) of the FeatureGroup.
        public let featureGroupArn: String
        /// he name of the FeatureGroup.
        public let featureGroupName: String
        /// The status of the feature group.
        public let featureGroupStatus: FeatureGroupStatus?
        /// A timestamp indicating when the feature group was last updated.
        public let lastModifiedTime: Date?
        /// A value indicating whether the update made to the feature group was successful.
        public let lastUpdateStatus: LastUpdateStatus?
        /// A token to resume pagination of the list of Features (FeatureDefinitions).
        public let nextToken: String
        /// The configuration of the offline store. It includes the following configurations:   Amazon S3 location of the offline store.   Configuration of the Glue data catalog.   Table format of the offline store.   Option to disable the automatic creation of a Glue table for the offline store.   Encryption configuration.
        public let offlineStoreConfig: OfflineStoreConfig?
        /// The status of the OfflineStore. Notifies you if replicating data into the OfflineStore has failed. Returns either: Active or Blocked
        public let offlineStoreStatus: OfflineStoreStatus?
        /// The configuration for the OnlineStore.
        public let onlineStoreConfig: OnlineStoreConfig?
        /// The size of the OnlineStore in bytes.
        public let onlineStoreTotalSizeBytes: Int64?
        /// The name of the Feature used for RecordIdentifier, whose value uniquely identifies a record stored in the feature store.
        public let recordIdentifierFeatureName: String
        /// The Amazon Resource Name (ARN) of the IAM execution role used to persist data into the OfflineStore if an OfflineStoreConfig is provided.
        public let roleArn: String?

        public init(creationTime: Date, description: String? = nil, eventTimeFeatureName: String, failureReason: String? = nil, featureDefinitions: [FeatureDefinition], featureGroupArn: String, featureGroupName: String, featureGroupStatus: FeatureGroupStatus? = nil, lastModifiedTime: Date? = nil, lastUpdateStatus: LastUpdateStatus? = nil, nextToken: String, offlineStoreConfig: OfflineStoreConfig? = nil, offlineStoreStatus: OfflineStoreStatus? = nil, onlineStoreConfig: OnlineStoreConfig? = nil, onlineStoreTotalSizeBytes: Int64? = nil, recordIdentifierFeatureName: String, roleArn: String? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.eventTimeFeatureName = eventTimeFeatureName
            self.failureReason = failureReason
            self.featureDefinitions = featureDefinitions
            self.featureGroupArn = featureGroupArn
            self.featureGroupName = featureGroupName
            self.featureGroupStatus = featureGroupStatus
            self.lastModifiedTime = lastModifiedTime
            self.lastUpdateStatus = lastUpdateStatus
            self.nextToken = nextToken
            self.offlineStoreConfig = offlineStoreConfig
            self.offlineStoreStatus = offlineStoreStatus
            self.onlineStoreConfig = onlineStoreConfig
            self.onlineStoreTotalSizeBytes = onlineStoreTotalSizeBytes
            self.recordIdentifierFeatureName = recordIdentifierFeatureName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case eventTimeFeatureName = "EventTimeFeatureName"
            case failureReason = "FailureReason"
            case featureDefinitions = "FeatureDefinitions"
            case featureGroupArn = "FeatureGroupArn"
            case featureGroupName = "FeatureGroupName"
            case featureGroupStatus = "FeatureGroupStatus"
            case lastModifiedTime = "LastModifiedTime"
            case lastUpdateStatus = "LastUpdateStatus"
            case nextToken = "NextToken"
            case offlineStoreConfig = "OfflineStoreConfig"
            case offlineStoreStatus = "OfflineStoreStatus"
            case onlineStoreConfig = "OnlineStoreConfig"
            case onlineStoreTotalSizeBytes = "OnlineStoreTotalSizeBytes"
            case recordIdentifierFeatureName = "RecordIdentifierFeatureName"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeFeatureMetadataRequest: AWSEncodableShape {
        /// The name of the feature group containing the feature.
        public let featureGroupName: String
        /// The name of the feature.
        public let featureName: String

        public init(featureGroupName: String, featureName: String) {
            self.featureGroupName = featureGroupName
            self.featureName = featureName
        }

        public func validate(name: String) throws {
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.validate(self.featureName, name: "featureName", parent: name, max: 64)
            try self.validate(self.featureName, name: "featureName", parent: name, min: 1)
            try self.validate(self.featureName, name: "featureName", parent: name, pattern: "^[a-zA-Z0-9]([-_]*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupName = "FeatureGroupName"
            case featureName = "FeatureName"
        }
    }

    public struct DescribeFeatureMetadataResponse: AWSDecodableShape {
        /// A timestamp indicating when the feature was created.
        public let creationTime: Date
        /// The description you added to describe the feature.
        public let description: String?
        /// The Amazon Resource Number (ARN) of the feature group that contains the feature.
        public let featureGroupArn: String
        /// The name of the feature group that you've specified.
        public let featureGroupName: String
        /// The name of the feature that you've specified.
        public let featureName: String
        /// The data type of the feature.
        public let featureType: FeatureType
        /// A timestamp indicating when the metadata for the feature group was modified. For example, if you add a parameter describing the feature, the timestamp changes to reflect the last time you
        public let lastModifiedTime: Date
        /// The key-value pairs that you added to describe the feature.
        public let parameters: [FeatureParameter]?

        public init(creationTime: Date, description: String? = nil, featureGroupArn: String, featureGroupName: String, featureName: String, featureType: FeatureType, lastModifiedTime: Date, parameters: [FeatureParameter]? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.featureGroupArn = featureGroupArn
            self.featureGroupName = featureGroupName
            self.featureName = featureName
            self.featureType = featureType
            self.lastModifiedTime = lastModifiedTime
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case featureGroupArn = "FeatureGroupArn"
            case featureGroupName = "FeatureGroupName"
            case featureName = "FeatureName"
            case featureType = "FeatureType"
            case lastModifiedTime = "LastModifiedTime"
            case parameters = "Parameters"
        }
    }

    public struct DescribeFlowDefinitionRequest: AWSEncodableShape {
        /// The name of the flow definition.
        public let flowDefinitionName: String

        public init(flowDefinitionName: String) {
            self.flowDefinitionName = flowDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, max: 63)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, min: 1)
            try self.validate(self.flowDefinitionName, name: "flowDefinitionName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionName = "FlowDefinitionName"
        }
    }

    public struct DescribeFlowDefinitionResponse: AWSDecodableShape {
        /// The timestamp when the flow definition was created.
        public let creationTime: Date
        /// The reason your flow definition failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the flow defintion.
        public let flowDefinitionArn: String
        /// The Amazon Resource Name (ARN) of the flow definition.
        public let flowDefinitionName: String
        /// The status of the flow definition. Valid values are listed below.
        public let flowDefinitionStatus: FlowDefinitionStatus
        /// An object containing information about what triggers a human review workflow.
        public let humanLoopActivationConfig: HumanLoopActivationConfig?
        /// An object containing information about who works on the task, the workforce task price, and other task details.
        public let humanLoopConfig: HumanLoopConfig
        /// Container for configuring the source of human task requests. Used to specify if Amazon Rekognition or Amazon Textract is used as an integration source.
        public let humanLoopRequestSource: HumanLoopRequestSource?
        /// An object containing information about the output file.
        public let outputConfig: FlowDefinitionOutputConfig
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) execution role for the flow definition.
        public let roleArn: String

        public init(creationTime: Date, failureReason: String? = nil, flowDefinitionArn: String, flowDefinitionName: String, flowDefinitionStatus: FlowDefinitionStatus, humanLoopActivationConfig: HumanLoopActivationConfig? = nil, humanLoopConfig: HumanLoopConfig, humanLoopRequestSource: HumanLoopRequestSource? = nil, outputConfig: FlowDefinitionOutputConfig, roleArn: String) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.flowDefinitionName = flowDefinitionName
            self.flowDefinitionStatus = flowDefinitionStatus
            self.humanLoopActivationConfig = humanLoopActivationConfig
            self.humanLoopConfig = humanLoopConfig
            self.humanLoopRequestSource = humanLoopRequestSource
            self.outputConfig = outputConfig
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case flowDefinitionArn = "FlowDefinitionArn"
            case flowDefinitionName = "FlowDefinitionName"
            case flowDefinitionStatus = "FlowDefinitionStatus"
            case humanLoopActivationConfig = "HumanLoopActivationConfig"
            case humanLoopConfig = "HumanLoopConfig"
            case humanLoopRequestSource = "HumanLoopRequestSource"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeHubContentRequest: AWSEncodableShape {
        /// The name of the content to describe.
        public let hubContentName: String
        /// The type of content in the hub.
        public let hubContentType: HubContentType
        /// The version of the content to describe.
        public let hubContentVersion: String?
        /// The name of the hub that contains the content to describe.
        public let hubName: String

        public init(hubContentName: String, hubContentType: HubContentType, hubContentVersion: String? = nil, hubName: String) {
            self.hubContentName = hubContentName
            self.hubContentType = hubContentType
            self.hubContentVersion = hubContentVersion
            self.hubName = hubName
        }

        public func validate(name: String) throws {
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, max: 63)
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, max: 14)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, min: 5)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hubContentName = "HubContentName"
            case hubContentType = "HubContentType"
            case hubContentVersion = "HubContentVersion"
            case hubName = "HubName"
        }
    }

    public struct DescribeHubContentResponse: AWSDecodableShape {
        /// The date and time that hub content was created.
        public let creationTime: Date
        /// The document schema version for the hub content.
        public let documentSchemaVersion: String
        /// The failure reason if importing hub content failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the hub that contains the content.
        public let hubArn: String
        /// The Amazon Resource Name (ARN) of the hub content.
        public let hubContentArn: String
        /// The location of any dependencies that the hub content has, such as scripts, model artifacts, datasets, or notebooks.
        public let hubContentDependencies: [HubContentDependency]?
        /// A description of the hub content.
        public let hubContentDescription: String?
        /// The display name of the hub content.
        public let hubContentDisplayName: String?
        /// The hub content document that describes information about the hub content such as type, associated containers, scripts, and more.
        public let hubContentDocument: String
        /// Markdown files associated with the hub content to import.
        public let hubContentMarkdown: String?
        /// The name of the hub content.
        public let hubContentName: String
        /// The searchable keywords for the hub content.
        public let hubContentSearchKeywords: [String]?
        /// The status of the hub content.
        public let hubContentStatus: HubContentStatus
        /// The type of hub content.
        public let hubContentType: HubContentType
        /// The version of the hub content.
        public let hubContentVersion: String
        /// The name of the hub that contains the content.
        public let hubName: String

        public init(creationTime: Date, documentSchemaVersion: String, failureReason: String? = nil, hubArn: String, hubContentArn: String, hubContentDependencies: [HubContentDependency]? = nil, hubContentDescription: String? = nil, hubContentDisplayName: String? = nil, hubContentDocument: String, hubContentMarkdown: String? = nil, hubContentName: String, hubContentSearchKeywords: [String]? = nil, hubContentStatus: HubContentStatus, hubContentType: HubContentType, hubContentVersion: String, hubName: String) {
            self.creationTime = creationTime
            self.documentSchemaVersion = documentSchemaVersion
            self.failureReason = failureReason
            self.hubArn = hubArn
            self.hubContentArn = hubContentArn
            self.hubContentDependencies = hubContentDependencies
            self.hubContentDescription = hubContentDescription
            self.hubContentDisplayName = hubContentDisplayName
            self.hubContentDocument = hubContentDocument
            self.hubContentMarkdown = hubContentMarkdown
            self.hubContentName = hubContentName
            self.hubContentSearchKeywords = hubContentSearchKeywords
            self.hubContentStatus = hubContentStatus
            self.hubContentType = hubContentType
            self.hubContentVersion = hubContentVersion
            self.hubName = hubName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case documentSchemaVersion = "DocumentSchemaVersion"
            case failureReason = "FailureReason"
            case hubArn = "HubArn"
            case hubContentArn = "HubContentArn"
            case hubContentDependencies = "HubContentDependencies"
            case hubContentDescription = "HubContentDescription"
            case hubContentDisplayName = "HubContentDisplayName"
            case hubContentDocument = "HubContentDocument"
            case hubContentMarkdown = "HubContentMarkdown"
            case hubContentName = "HubContentName"
            case hubContentSearchKeywords = "HubContentSearchKeywords"
            case hubContentStatus = "HubContentStatus"
            case hubContentType = "HubContentType"
            case hubContentVersion = "HubContentVersion"
            case hubName = "HubName"
        }
    }

    public struct DescribeHubRequest: AWSEncodableShape {
        /// The name of the hub to describe.
        public let hubName: String

        public init(hubName: String) {
            self.hubName = hubName
        }

        public func validate(name: String) throws {
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hubName = "HubName"
        }
    }

    public struct DescribeHubResponse: AWSDecodableShape {
        /// The date and time that the hub was created.
        public let creationTime: Date
        /// The failure reason if importing hub content failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the hub.
        public let hubArn: String
        /// A description of the hub.
        public let hubDescription: String?
        /// The display name of the hub.
        public let hubDisplayName: String?
        /// The name of the hub.
        public let hubName: String
        /// The searchable keywords for the hub.
        public let hubSearchKeywords: [String]?
        /// The status of the hub.
        public let hubStatus: HubStatus
        /// The date and time that the hub was last modified.
        public let lastModifiedTime: Date
        /// The Amazon S3 storage configuration for the hub.
        public let s3StorageConfig: HubS3StorageConfig?

        public init(creationTime: Date, failureReason: String? = nil, hubArn: String, hubDescription: String? = nil, hubDisplayName: String? = nil, hubName: String, hubSearchKeywords: [String]? = nil, hubStatus: HubStatus, lastModifiedTime: Date, s3StorageConfig: HubS3StorageConfig? = nil) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.hubArn = hubArn
            self.hubDescription = hubDescription
            self.hubDisplayName = hubDisplayName
            self.hubName = hubName
            self.hubSearchKeywords = hubSearchKeywords
            self.hubStatus = hubStatus
            self.lastModifiedTime = lastModifiedTime
            self.s3StorageConfig = s3StorageConfig
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case hubArn = "HubArn"
            case hubDescription = "HubDescription"
            case hubDisplayName = "HubDisplayName"
            case hubName = "HubName"
            case hubSearchKeywords = "HubSearchKeywords"
            case hubStatus = "HubStatus"
            case lastModifiedTime = "LastModifiedTime"
            case s3StorageConfig = "S3StorageConfig"
        }
    }

    public struct DescribeHumanTaskUiRequest: AWSEncodableShape {
        /// The name of the human task user interface  (worker task template) you want information about.
        public let humanTaskUiName: String

        public init(humanTaskUiName: String) {
            self.humanTaskUiName = humanTaskUiName
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, max: 63)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, min: 1)
            try self.validate(self.humanTaskUiName, name: "humanTaskUiName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiName = "HumanTaskUiName"
        }
    }

    public struct DescribeHumanTaskUiResponse: AWSDecodableShape {
        /// The timestamp when the human task user interface was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the human task user interface (worker task template).
        public let humanTaskUiArn: String
        /// The name of the human task user interface (worker task template).
        public let humanTaskUiName: String
        /// The status of the human task user interface (worker task template). Valid values are listed below.
        public let humanTaskUiStatus: HumanTaskUiStatus?
        public let uiTemplate: UiTemplateInfo

        public init(creationTime: Date, humanTaskUiArn: String, humanTaskUiName: String, humanTaskUiStatus: HumanTaskUiStatus? = nil, uiTemplate: UiTemplateInfo) {
            self.creationTime = creationTime
            self.humanTaskUiArn = humanTaskUiArn
            self.humanTaskUiName = humanTaskUiName
            self.humanTaskUiStatus = humanTaskUiStatus
            self.uiTemplate = uiTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case humanTaskUiArn = "HumanTaskUiArn"
            case humanTaskUiName = "HumanTaskUiName"
            case humanTaskUiStatus = "HumanTaskUiStatus"
            case uiTemplate = "UiTemplate"
        }
    }

    public struct DescribeHyperParameterTuningJobRequest: AWSEncodableShape {
        /// The name of the tuning job.
        public let hyperParameterTuningJobName: String

        public init(hyperParameterTuningJobName: String) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, max: 32)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, min: 1)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public struct DescribeHyperParameterTuningJobResponse: AWSDecodableShape {
        /// A TrainingJobSummary object that describes the training job that completed with the best current HyperParameterTuningJobObjective.
        public let bestTrainingJob: HyperParameterTrainingJobSummary?
        /// The date and time that the tuning job started.
        public let creationTime: Date
        /// If the tuning job failed, the reason it failed.
        public let failureReason: String?
        /// The date and time that the tuning job ended.
        public let hyperParameterTuningEndTime: Date?
        /// The Amazon Resource Name (ARN) of the tuning job.
        public let hyperParameterTuningJobArn: String
        /// The HyperParameterTuningJobConfig object that specifies the configuration of the tuning job.
        public let hyperParameterTuningJobConfig: HyperParameterTuningJobConfig
        /// The name of the tuning job.
        public let hyperParameterTuningJobName: String
        /// The status of the tuning job: InProgress, Completed, Failed, Stopping, or Stopped.
        public let hyperParameterTuningJobStatus: HyperParameterTuningJobStatus
        /// The date and time that the status of the tuning job was modified.
        public let lastModifiedTime: Date?
        /// The ObjectiveStatusCounters object that specifies the number of training jobs, categorized by the status of their final objective metric, that this tuning job launched.
        public let objectiveStatusCounters: ObjectiveStatusCounters
        /// If the hyperparameter tuning job is an warm start tuning job with a WarmStartType of IDENTICAL_DATA_AND_ALGORITHM, this is the TrainingJobSummary for the training job with the best objective metric value of all training jobs launched by this tuning job and all parent jobs specified for the warm start tuning job.
        public let overallBestTrainingJob: HyperParameterTrainingJobSummary?
        /// The HyperParameterTrainingJobDefinition object that specifies the definition of the training jobs that this tuning job launches.
        public let trainingJobDefinition: HyperParameterTrainingJobDefinition?
        /// A list of the HyperParameterTrainingJobDefinition objects launched for this tuning job.
        public let trainingJobDefinitions: [HyperParameterTrainingJobDefinition]?
        /// The TrainingJobStatusCounters object that specifies the number of training jobs, categorized by status, that this tuning job launched.
        public let trainingJobStatusCounters: TrainingJobStatusCounters
        /// The configuration for starting the hyperparameter parameter tuning job using one or more previous tuning jobs as a starting point. The results of previous tuning jobs are used to inform which combinations of hyperparameters to search over in the new tuning job.
        public let warmStartConfig: HyperParameterTuningJobWarmStartConfig?

        public init(bestTrainingJob: HyperParameterTrainingJobSummary? = nil, creationTime: Date, failureReason: String? = nil, hyperParameterTuningEndTime: Date? = nil, hyperParameterTuningJobArn: String, hyperParameterTuningJobConfig: HyperParameterTuningJobConfig, hyperParameterTuningJobName: String, hyperParameterTuningJobStatus: HyperParameterTuningJobStatus, lastModifiedTime: Date? = nil, objectiveStatusCounters: ObjectiveStatusCounters, overallBestTrainingJob: HyperParameterTrainingJobSummary? = nil, trainingJobDefinition: HyperParameterTrainingJobDefinition? = nil, trainingJobDefinitions: [HyperParameterTrainingJobDefinition]? = nil, trainingJobStatusCounters: TrainingJobStatusCounters, warmStartConfig: HyperParameterTuningJobWarmStartConfig? = nil) {
            self.bestTrainingJob = bestTrainingJob
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.hyperParameterTuningEndTime = hyperParameterTuningEndTime
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
            self.hyperParameterTuningJobConfig = hyperParameterTuningJobConfig
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.hyperParameterTuningJobStatus = hyperParameterTuningJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.objectiveStatusCounters = objectiveStatusCounters
            self.overallBestTrainingJob = overallBestTrainingJob
            self.trainingJobDefinition = trainingJobDefinition
            self.trainingJobDefinitions = trainingJobDefinitions
            self.trainingJobStatusCounters = trainingJobStatusCounters
            self.warmStartConfig = warmStartConfig
        }

        private enum CodingKeys: String, CodingKey {
            case bestTrainingJob = "BestTrainingJob"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case hyperParameterTuningEndTime = "HyperParameterTuningEndTime"
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
            case hyperParameterTuningJobConfig = "HyperParameterTuningJobConfig"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case hyperParameterTuningJobStatus = "HyperParameterTuningJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case objectiveStatusCounters = "ObjectiveStatusCounters"
            case overallBestTrainingJob = "OverallBestTrainingJob"
            case trainingJobDefinition = "TrainingJobDefinition"
            case trainingJobDefinitions = "TrainingJobDefinitions"
            case trainingJobStatusCounters = "TrainingJobStatusCounters"
            case warmStartConfig = "WarmStartConfig"
        }
    }

    public struct DescribeImageRequest: AWSEncodableShape {
        /// The name of the image to describe.
        public let imageName: String

        public init(imageName: String) {
            self.imageName = imageName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageName = "ImageName"
        }
    }

    public struct DescribeImageResponse: AWSDecodableShape {
        /// When the image was created.
        public let creationTime: Date?
        /// The description of the image.
        public let description: String?
        /// The name of the image as displayed.
        public let displayName: String?
        /// When a create, update, or delete operation fails, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the image.
        public let imageArn: String?
        /// The name of the image.
        public let imageName: String?
        /// The status of the image.
        public let imageStatus: ImageStatus?
        /// When the image was last modified.
        public let lastModifiedTime: Date?
        /// The ARN of the IAM role that enables Amazon SageMaker to perform tasks on your behalf.
        public let roleArn: String?

        public init(creationTime: Date? = nil, description: String? = nil, displayName: String? = nil, failureReason: String? = nil, imageArn: String? = nil, imageName: String? = nil, imageStatus: ImageStatus? = nil, lastModifiedTime: Date? = nil, roleArn: String? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.displayName = displayName
            self.failureReason = failureReason
            self.imageArn = imageArn
            self.imageName = imageName
            self.imageStatus = imageStatus
            self.lastModifiedTime = lastModifiedTime
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case displayName = "DisplayName"
            case failureReason = "FailureReason"
            case imageArn = "ImageArn"
            case imageName = "ImageName"
            case imageStatus = "ImageStatus"
            case lastModifiedTime = "LastModifiedTime"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeImageVersionRequest: AWSEncodableShape {
        /// The alias of the image version.
        public let alias: String?
        /// The name of the image.
        public let imageName: String
        /// The version of the image. If not specified, the latest version is described.
        public let version: Int?

        public init(alias: String? = nil, imageName: String, version: Int? = nil) {
            self.alias = alias
            self.imageName = imageName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 128)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.version, name: "version", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case imageName = "ImageName"
            case version = "Version"
        }
    }

    public struct DescribeImageVersionResponse: AWSDecodableShape {
        /// The registry path of the container image on which this image version is based.
        public let baseImage: String?
        /// The registry path of the container image that contains this image version.
        public let containerImage: String?
        /// When the version was created.
        public let creationTime: Date?
        /// When a create or delete operation fails, the reason for the failure.
        public let failureReason: String?
        /// Indicates Horovod compatibility.
        public let horovod: Bool?
        /// The ARN of the image the version is based on.
        public let imageArn: String?
        /// The ARN of the version.
        public let imageVersionArn: String?
        /// The status of the version.
        public let imageVersionStatus: ImageVersionStatus?
        /// Indicates SageMaker job type compatibility.    TRAINING: The image version is compatible with SageMaker training jobs.    INFERENCE: The image version is compatible with SageMaker inference jobs.    NOTEBOOK_KERNEL: The image version is compatible with SageMaker notebook kernels.
        public let jobType: JobType?
        /// When the version was last modified.
        public let lastModifiedTime: Date?
        /// The machine learning framework vended in the image version.
        public let mlFramework: String?
        /// Indicates CPU or GPU compatibility.    CPU: The image version is compatible with CPU.    GPU: The image version is compatible with GPU.
        public let processor: Processor?
        /// The supported programming language and its version.
        public let programmingLang: String?
        /// The maintainer description of the image version.
        public let releaseNotes: String?
        /// The stability of the image version specified by the maintainer.    NOT_PROVIDED: The maintainers did not provide a status for image version stability.    STABLE: The image version is stable.    TO_BE_ARCHIVED: The image version is set to be archived. Custom image versions that are set to be archived are automatically archived after three months.    ARCHIVED: The image version is archived. Archived image versions are not searchable and are no longer actively supported.
        public let vendorGuidance: VendorGuidance?
        /// The version number.
        public let version: Int?

        public init(baseImage: String? = nil, containerImage: String? = nil, creationTime: Date? = nil, failureReason: String? = nil, horovod: Bool? = nil, imageArn: String? = nil, imageVersionArn: String? = nil, imageVersionStatus: ImageVersionStatus? = nil, jobType: JobType? = nil, lastModifiedTime: Date? = nil, mlFramework: String? = nil, processor: Processor? = nil, programmingLang: String? = nil, releaseNotes: String? = nil, vendorGuidance: VendorGuidance? = nil, version: Int? = nil) {
            self.baseImage = baseImage
            self.containerImage = containerImage
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.horovod = horovod
            self.imageArn = imageArn
            self.imageVersionArn = imageVersionArn
            self.imageVersionStatus = imageVersionStatus
            self.jobType = jobType
            self.lastModifiedTime = lastModifiedTime
            self.mlFramework = mlFramework
            self.processor = processor
            self.programmingLang = programmingLang
            self.releaseNotes = releaseNotes
            self.vendorGuidance = vendorGuidance
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case baseImage = "BaseImage"
            case containerImage = "ContainerImage"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case horovod = "Horovod"
            case imageArn = "ImageArn"
            case imageVersionArn = "ImageVersionArn"
            case imageVersionStatus = "ImageVersionStatus"
            case jobType = "JobType"
            case lastModifiedTime = "LastModifiedTime"
            case mlFramework = "MLFramework"
            case processor = "Processor"
            case programmingLang = "ProgrammingLang"
            case releaseNotes = "ReleaseNotes"
            case vendorGuidance = "VendorGuidance"
            case version = "Version"
        }
    }

    public struct DescribeInferenceExperimentRequest: AWSEncodableShape {
        /// The name of the inference experiment to describe.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DescribeInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN of the inference experiment being described.
        public let arn: String
        ///  The timestamp at which the inference experiment was completed.
        public let completionTime: Date?
        /// The timestamp at which you created the inference experiment.
        public let creationTime: Date?
        /// The Amazon S3 location and configuration for storing inference request and response data.
        public let dataStorageConfig: InferenceExperimentDataStorageConfig?
        /// The description of the inference experiment.
        public let description: String?
        /// The metadata of the endpoint on which the inference experiment ran.
        public let endpointMetadata: EndpointMetadata
        ///  The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. For more information, see CreateInferenceExperimentRequest$KmsKey.
        public let kmsKey: String?
        /// The timestamp at which you last modified the inference experiment.
        public let lastModifiedTime: Date?
        ///  An array of ModelVariantConfigSummary objects. There is one for each variant in the inference experiment. Each ModelVariantConfigSummary object in the array describes the infrastructure configuration for deploying the corresponding variant.
        public let modelVariants: [ModelVariantConfigSummary]
        /// The name of the inference experiment.
        public let name: String
        ///  The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and container images, and manage Amazon SageMaker Inference endpoints for model deployment.
        public let roleArn: String?
        /// The duration for which the inference experiment ran or will run.
        public let schedule: InferenceExperimentSchedule?
        ///  The configuration of ShadowMode inference experiment type, which shows the production variant that takes all the inference requests, and the shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant it also shows the percentage of requests that Amazon SageMaker replicates.
        public let shadowModeConfig: ShadowModeConfig?
        ///  The status of the inference experiment. The following are the possible statuses for an inference experiment:     Creating - Amazon SageMaker is creating your experiment.     Created - Amazon SageMaker has finished the creation of your experiment and will begin the experiment at the scheduled time.     Updating - When you make changes to your experiment, your experiment shows as updating.     Starting - Amazon SageMaker is beginning your experiment.     Running - Your experiment is in progress.     Stopping - Amazon SageMaker is stopping your experiment.     Completed - Your experiment has completed.     Cancelled - When you conclude your experiment early using the StopInferenceExperiment API, or if any operation fails with an unexpected error, it shows as cancelled.
        public let status: InferenceExperimentStatus
        ///  The error message or client-specified Reason from the StopInferenceExperiment API, that explains the status of the inference experiment.
        public let statusReason: String?
        /// The type of the inference experiment.
        public let type: InferenceExperimentType

        public init(arn: String, completionTime: Date? = nil, creationTime: Date? = nil, dataStorageConfig: InferenceExperimentDataStorageConfig? = nil, description: String? = nil, endpointMetadata: EndpointMetadata, kmsKey: String? = nil, lastModifiedTime: Date? = nil, modelVariants: [ModelVariantConfigSummary], name: String, roleArn: String? = nil, schedule: InferenceExperimentSchedule? = nil, shadowModeConfig: ShadowModeConfig? = nil, status: InferenceExperimentStatus, statusReason: String? = nil, type: InferenceExperimentType) {
            self.arn = arn
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.dataStorageConfig = dataStorageConfig
            self.description = description
            self.endpointMetadata = endpointMetadata
            self.kmsKey = kmsKey
            self.lastModifiedTime = lastModifiedTime
            self.modelVariants = modelVariants
            self.name = name
            self.roleArn = roleArn
            self.schedule = schedule
            self.shadowModeConfig = shadowModeConfig
            self.status = status
            self.statusReason = statusReason
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case dataStorageConfig = "DataStorageConfig"
            case description = "Description"
            case endpointMetadata = "EndpointMetadata"
            case kmsKey = "KmsKey"
            case lastModifiedTime = "LastModifiedTime"
            case modelVariants = "ModelVariants"
            case name = "Name"
            case roleArn = "RoleArn"
            case schedule = "Schedule"
            case shadowModeConfig = "ShadowModeConfig"
            case status = "Status"
            case statusReason = "StatusReason"
            case type = "Type"
        }
    }

    public struct DescribeInferenceRecommendationsJobRequest: AWSEncodableShape {
        /// The name of the job. The name must be unique within an  Amazon Web Services Region in the Amazon Web Services account.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DescribeInferenceRecommendationsJobResponse: AWSDecodableShape {
        /// A timestamp that shows when the job completed.
        public let completionTime: Date?
        /// A timestamp that shows when the job was created.
        public let creationTime: Date
        /// The performance results from running an Inference Recommender job on an existing endpoint.
        public let endpointPerformances: [EndpointPerformance]?
        /// If the job fails, provides information why the job failed.
        public let failureReason: String?
        /// The recommendations made by Inference Recommender.
        public let inferenceRecommendations: [InferenceRecommendation]?
        /// Returns information about the versioned model package Amazon Resource Name (ARN),  the traffic pattern, and endpoint configurations you provided when you initiated the job.
        public let inputConfig: RecommendationJobInputConfig
        /// The Amazon Resource Name (ARN) of the job.
        public let jobArn: String
        /// The job description that you provided when you initiated the job.
        public let jobDescription: String?
        /// The name of the job. The name must be unique within an  Amazon Web Services Region in the Amazon Web Services account.
        public let jobName: String
        /// The job type that you provided when you initiated the job.
        public let jobType: RecommendationJobType
        /// A timestamp that shows when the job was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the Amazon Web Services  Identity and Access Management (IAM) role you provided when you initiated the job.
        public let roleArn: String
        /// The status of the job.
        public let status: RecommendationJobStatus
        /// The stopping conditions that you provided when you initiated the job.
        public let stoppingConditions: RecommendationJobStoppingConditions?

        public init(completionTime: Date? = nil, creationTime: Date, endpointPerformances: [EndpointPerformance]? = nil, failureReason: String? = nil, inferenceRecommendations: [InferenceRecommendation]? = nil, inputConfig: RecommendationJobInputConfig, jobArn: String, jobDescription: String? = nil, jobName: String, jobType: RecommendationJobType, lastModifiedTime: Date, roleArn: String, status: RecommendationJobStatus, stoppingConditions: RecommendationJobStoppingConditions? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.endpointPerformances = endpointPerformances
            self.failureReason = failureReason
            self.inferenceRecommendations = inferenceRecommendations
            self.inputConfig = inputConfig
            self.jobArn = jobArn
            self.jobDescription = jobDescription
            self.jobName = jobName
            self.jobType = jobType
            self.lastModifiedTime = lastModifiedTime
            self.roleArn = roleArn
            self.status = status
            self.stoppingConditions = stoppingConditions
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case endpointPerformances = "EndpointPerformances"
            case failureReason = "FailureReason"
            case inferenceRecommendations = "InferenceRecommendations"
            case inputConfig = "InputConfig"
            case jobArn = "JobArn"
            case jobDescription = "JobDescription"
            case jobName = "JobName"
            case jobType = "JobType"
            case lastModifiedTime = "LastModifiedTime"
            case roleArn = "RoleArn"
            case status = "Status"
            case stoppingConditions = "StoppingConditions"
        }
    }

    public struct DescribeLabelingJobRequest: AWSEncodableShape {
        /// The name of the labeling job to return information for.
        public let labelingJobName: String

        public init(labelingJobName: String) {
            self.labelingJobName = labelingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, max: 63)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, min: 1)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobName = "LabelingJobName"
        }
    }

    public struct DescribeLabelingJobResponse: AWSDecodableShape {
        /// The date and time that the labeling job was created.
        public let creationTime: Date
        /// If the job failed, the reason that it failed.
        public let failureReason: String?
        /// Configuration information required for human workers to complete a labeling task.
        public let humanTaskConfig: HumanTaskConfig
        /// Input configuration information for the labeling job, such as the Amazon S3 location of the data objects and the location of the manifest file that describes the data objects.
        public let inputConfig: LabelingJobInputConfig
        /// A unique identifier for work done as part of a labeling job.
        public let jobReferenceCode: String
        /// The attribute used as the label in the output manifest file.
        public let labelAttributeName: String?
        /// The S3 location of the JSON file that defines the categories used to label data objects. Please note the following label-category limits:   Semantic segmentation labeling jobs using automated labeling: 20 labels   Box bounding labeling jobs (all): 10 labels   The file is a JSON structure in the following format:  {   "document-version": "2018-11-28"   "labels": [   {   "label": "label 1"   },   {   "label": "label 2"   },   ...   {   "label": "label n"   }   ]   }
        public let labelCategoryConfigS3Uri: String?
        /// Provides a breakdown of the number of data objects labeled by humans, the number of objects labeled by machine, the number of objects than couldn't be labeled, and the total number of objects labeled.
        public let labelCounters: LabelCounters
        /// Configuration information for automated data labeling.
        public let labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig?
        /// The Amazon Resource Name (ARN) of the labeling job.
        public let labelingJobArn: String
        /// The name assigned to the labeling job when it was created.
        public let labelingJobName: String
        /// The location of the output produced by the labeling job.
        public let labelingJobOutput: LabelingJobOutput?
        /// The processing status of the labeling job.
        public let labelingJobStatus: LabelingJobStatus
        /// The date and time that the labeling job was last updated.
        public let lastModifiedTime: Date
        /// The location of the job's output data and the Amazon Web Services Key Management Service key ID for the key used to encrypt the output data, if any.
        public let outputConfig: LabelingJobOutputConfig
        /// The Amazon Resource Name (ARN) that SageMaker assumes to perform tasks on your behalf during data labeling.
        public let roleArn: String
        /// A set of conditions for stopping a labeling job. If any of the conditions are met, the job is automatically stopped.
        public let stoppingConditions: LabelingJobStoppingConditions?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?

        public init(creationTime: Date, failureReason: String? = nil, humanTaskConfig: HumanTaskConfig, inputConfig: LabelingJobInputConfig, jobReferenceCode: String, labelAttributeName: String? = nil, labelCategoryConfigS3Uri: String? = nil, labelCounters: LabelCounters, labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig? = nil, labelingJobArn: String, labelingJobName: String, labelingJobOutput: LabelingJobOutput? = nil, labelingJobStatus: LabelingJobStatus, lastModifiedTime: Date, outputConfig: LabelingJobOutputConfig, roleArn: String, stoppingConditions: LabelingJobStoppingConditions? = nil, tags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.humanTaskConfig = humanTaskConfig
            self.inputConfig = inputConfig
            self.jobReferenceCode = jobReferenceCode
            self.labelAttributeName = labelAttributeName
            self.labelCategoryConfigS3Uri = labelCategoryConfigS3Uri
            self.labelCounters = labelCounters
            self.labelingJobAlgorithmsConfig = labelingJobAlgorithmsConfig
            self.labelingJobArn = labelingJobArn
            self.labelingJobName = labelingJobName
            self.labelingJobOutput = labelingJobOutput
            self.labelingJobStatus = labelingJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.outputConfig = outputConfig
            self.roleArn = roleArn
            self.stoppingConditions = stoppingConditions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case humanTaskConfig = "HumanTaskConfig"
            case inputConfig = "InputConfig"
            case jobReferenceCode = "JobReferenceCode"
            case labelAttributeName = "LabelAttributeName"
            case labelCategoryConfigS3Uri = "LabelCategoryConfigS3Uri"
            case labelCounters = "LabelCounters"
            case labelingJobAlgorithmsConfig = "LabelingJobAlgorithmsConfig"
            case labelingJobArn = "LabelingJobArn"
            case labelingJobName = "LabelingJobName"
            case labelingJobOutput = "LabelingJobOutput"
            case labelingJobStatus = "LabelingJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
            case stoppingConditions = "StoppingConditions"
            case tags = "Tags"
        }
    }

    public struct DescribeLineageGroupRequest: AWSEncodableShape {
        /// The name of the lineage group.
        public let lineageGroupName: String

        public init(lineageGroupName: String) {
            self.lineageGroupName = lineageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, max: 120)
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, min: 1)
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lineageGroupName = "LineageGroupName"
        }
    }

    public struct DescribeLineageGroupResponse: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The creation time of lineage group.
        public let creationTime: Date?
        /// The description of the lineage group.
        public let description: String?
        /// The display name of the lineage group.
        public let displayName: String?
        public let lastModifiedBy: UserContext?
        /// The last modified time of the lineage group.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        /// The name of the lineage group.
        public let lineageGroupName: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, description: String? = nil, displayName: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, lineageGroupName: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.displayName = displayName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.lineageGroupName = lineageGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case description = "Description"
            case displayName = "DisplayName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case lineageGroupName = "LineageGroupName"
        }
    }

    public struct DescribeModelBiasJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model bias job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DescribeModelBiasJobDefinitionResponse: AWSDecodableShape {
        /// The time at which the model bias job was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model bias job.
        public let jobDefinitionArn: String
        /// The name of the bias job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Configures the model bias job to run a specified Docker container image.
        public let modelBiasAppSpecification: ModelBiasAppSpecification
        /// The baseline configuration for a model bias job.
        public let modelBiasBaselineConfig: ModelBiasBaselineConfig?
        /// Inputs for the model bias job.
        public let modelBiasJobInput: ModelBiasJobInput
        public let modelBiasJobOutputConfig: MonitoringOutputConfig
        /// Networking options for a model bias job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that has read permission to the input data location and write permission to the output data location in Amazon S3.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?

        public init(creationTime: Date, jobDefinitionArn: String, jobDefinitionName: String, jobResources: MonitoringResources, modelBiasAppSpecification: ModelBiasAppSpecification, modelBiasBaselineConfig: ModelBiasBaselineConfig? = nil, modelBiasJobInput: ModelBiasJobInput, modelBiasJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil) {
            self.creationTime = creationTime
            self.jobDefinitionArn = jobDefinitionArn
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelBiasAppSpecification = modelBiasAppSpecification
            self.modelBiasBaselineConfig = modelBiasBaselineConfig
            self.modelBiasJobInput = modelBiasJobInput
            self.modelBiasJobOutputConfig = modelBiasJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jobDefinitionArn = "JobDefinitionArn"
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelBiasAppSpecification = "ModelBiasAppSpecification"
            case modelBiasBaselineConfig = "ModelBiasBaselineConfig"
            case modelBiasJobInput = "ModelBiasJobInput"
            case modelBiasJobOutputConfig = "ModelBiasJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct DescribeModelCardExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model card export job to describe.
        public let modelCardExportJobArn: String

        public init(modelCardExportJobArn: String) {
            self.modelCardExportJobArn = modelCardExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.modelCardExportJobArn, name: "modelCardExportJobArn", parent: name, max: 256)
            try self.validate(self.modelCardExportJobArn, name: "modelCardExportJobArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]{9,16}:[0-9]{12}:model-card/[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}/export-job/[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardExportJobArn = "ModelCardExportJobArn"
        }
    }

    public struct DescribeModelCardExportJobResponse: AWSDecodableShape {
        /// The date and time that the model export job was created.
        public let createdAt: Date
        /// The exported model card artifacts.
        public let exportArtifacts: ModelCardExportArtifacts?
        /// The failure reason if the model export job fails.
        public let failureReason: String?
        /// The date and time that the model export job was last modified.
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the model card export job.
        public let modelCardExportJobArn: String
        /// The name of the model card export job to describe.
        public let modelCardExportJobName: String
        /// The name of the model card that the model export job exports.
        public let modelCardName: String
        /// The version of the model card that the model export job exports.
        public let modelCardVersion: Int
        /// The export output details for the model card.
        public let outputConfig: ModelCardExportOutputConfig
        /// The completion status of the model card export job.    InProgress: The model card export job is in progress.    Completed: The model card export job is complete.    Failed: The model card export job failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeModelCardExportJob call.
        public let status: ModelCardExportJobStatus

        public init(createdAt: Date, exportArtifacts: ModelCardExportArtifacts? = nil, failureReason: String? = nil, lastModifiedAt: Date, modelCardExportJobArn: String, modelCardExportJobName: String, modelCardName: String, modelCardVersion: Int, outputConfig: ModelCardExportOutputConfig, status: ModelCardExportJobStatus) {
            self.createdAt = createdAt
            self.exportArtifacts = exportArtifacts
            self.failureReason = failureReason
            self.lastModifiedAt = lastModifiedAt
            self.modelCardExportJobArn = modelCardExportJobArn
            self.modelCardExportJobName = modelCardExportJobName
            self.modelCardName = modelCardName
            self.modelCardVersion = modelCardVersion
            self.outputConfig = outputConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case exportArtifacts = "ExportArtifacts"
            case failureReason = "FailureReason"
            case lastModifiedAt = "LastModifiedAt"
            case modelCardExportJobArn = "ModelCardExportJobArn"
            case modelCardExportJobName = "ModelCardExportJobName"
            case modelCardName = "ModelCardName"
            case modelCardVersion = "ModelCardVersion"
            case outputConfig = "OutputConfig"
            case status = "Status"
        }
    }

    public struct DescribeModelCardRequest: AWSEncodableShape {
        /// The name of the model card to describe.
        public let modelCardName: String
        /// The version of the model card to describe. If a version is not provided, then the latest version of the model card is described.
        public let modelCardVersion: Int?

        public init(modelCardName: String, modelCardVersion: Int? = nil) {
            self.modelCardName = modelCardName
            self.modelCardVersion = modelCardVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardName = "ModelCardName"
            case modelCardVersion = "ModelCardVersion"
        }
    }

    public struct DescribeModelCardResponse: AWSDecodableShape {
        /// The content of the model card.
        public let content: String
        public let createdBy: UserContext
        /// The date and time the model card was created.
        public let creationTime: Date
        public let lastModifiedBy: UserContext?
        /// The date and time the model card was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the model card.
        public let modelCardArn: String
        /// The name of the model card.
        public let modelCardName: String
        /// The processing status of model card deletion. The ModelCardProcessingStatus updates throughout the different deletion steps.    DeletePending: Model card deletion request received.    DeleteInProgress: Model card deletion is in progress.    ContentDeleted: Deleted model card content.    ExportJobsDeleted: Deleted all export jobs associated with the model card.    DeleteCompleted: Successfully deleted the model card.    DeleteFailed: The model card failed to delete.
        public let modelCardProcessingStatus: ModelCardProcessingStatus?
        /// The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus
        /// The version of the model card.
        public let modelCardVersion: Int
        /// The security configuration used to protect model card content.
        public let securityConfig: ModelCardSecurityConfig?

        public init(content: String, createdBy: UserContext, creationTime: Date, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, modelCardArn: String, modelCardName: String, modelCardProcessingStatus: ModelCardProcessingStatus? = nil, modelCardStatus: ModelCardStatus, modelCardVersion: Int, securityConfig: ModelCardSecurityConfig? = nil) {
            self.content = content
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.modelCardArn = modelCardArn
            self.modelCardName = modelCardName
            self.modelCardProcessingStatus = modelCardProcessingStatus
            self.modelCardStatus = modelCardStatus
            self.modelCardVersion = modelCardVersion
            self.securityConfig = securityConfig
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case modelCardArn = "ModelCardArn"
            case modelCardName = "ModelCardName"
            case modelCardProcessingStatus = "ModelCardProcessingStatus"
            case modelCardStatus = "ModelCardStatus"
            case modelCardVersion = "ModelCardVersion"
            case securityConfig = "SecurityConfig"
        }
    }

    public struct DescribeModelExplainabilityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model explainability job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DescribeModelExplainabilityJobDefinitionResponse: AWSDecodableShape {
        /// The time at which the model explainability job was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model explainability job.
        public let jobDefinitionArn: String
        /// The name of the explainability job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Configures the model explainability job to run a specified Docker container image.
        public let modelExplainabilityAppSpecification: ModelExplainabilityAppSpecification
        /// The baseline configuration for a model explainability job.
        public let modelExplainabilityBaselineConfig: ModelExplainabilityBaselineConfig?
        /// Inputs for the model explainability job.
        public let modelExplainabilityJobInput: ModelExplainabilityJobInput
        public let modelExplainabilityJobOutputConfig: MonitoringOutputConfig
        /// Networking options for a model explainability job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that has read permission to the input data location and write permission to the output data location in Amazon S3.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?

        public init(creationTime: Date, jobDefinitionArn: String, jobDefinitionName: String, jobResources: MonitoringResources, modelExplainabilityAppSpecification: ModelExplainabilityAppSpecification, modelExplainabilityBaselineConfig: ModelExplainabilityBaselineConfig? = nil, modelExplainabilityJobInput: ModelExplainabilityJobInput, modelExplainabilityJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil) {
            self.creationTime = creationTime
            self.jobDefinitionArn = jobDefinitionArn
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelExplainabilityAppSpecification = modelExplainabilityAppSpecification
            self.modelExplainabilityBaselineConfig = modelExplainabilityBaselineConfig
            self.modelExplainabilityJobInput = modelExplainabilityJobInput
            self.modelExplainabilityJobOutputConfig = modelExplainabilityJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jobDefinitionArn = "JobDefinitionArn"
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelExplainabilityAppSpecification = "ModelExplainabilityAppSpecification"
            case modelExplainabilityBaselineConfig = "ModelExplainabilityBaselineConfig"
            case modelExplainabilityJobInput = "ModelExplainabilityJobInput"
            case modelExplainabilityJobOutputConfig = "ModelExplainabilityJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct DescribeModelInput: AWSEncodableShape {
        /// The name of the model.
        public let modelName: String

        public init(modelName: String) {
            self.modelName = modelName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
        }
    }

    public struct DescribeModelOutput: AWSDecodableShape {
        /// The containers in the inference pipeline.
        public let containers: [ContainerDefinition]?
        /// A timestamp that shows when the model was created.
        public let creationTime: Date
        /// If True, no inbound or outbound network calls can be made to or from the model container.
        public let enableNetworkIsolation: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the model.
        public let executionRoleArn: String
        /// Specifies details of how containers in a multi-container endpoint are called.
        public let inferenceExecutionConfig: InferenceExecutionConfig?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String
        /// Name of the SageMaker model.
        public let modelName: String
        /// The location of the primary inference code, associated artifacts, and custom environment map that the inference code uses when it is deployed in production.
        public let primaryContainer: ContainerDefinition?
        /// A VpcConfig object that specifies the VPC that this model has access to. For more information, see Protect Endpoints by Using an Amazon Virtual Private Cloud
        public let vpcConfig: VpcConfig?

        public init(containers: [ContainerDefinition]? = nil, creationTime: Date, enableNetworkIsolation: Bool? = nil, executionRoleArn: String, inferenceExecutionConfig: InferenceExecutionConfig? = nil, modelArn: String, modelName: String, primaryContainer: ContainerDefinition? = nil, vpcConfig: VpcConfig? = nil) {
            self.containers = containers
            self.creationTime = creationTime
            self.enableNetworkIsolation = enableNetworkIsolation
            self.executionRoleArn = executionRoleArn
            self.inferenceExecutionConfig = inferenceExecutionConfig
            self.modelArn = modelArn
            self.modelName = modelName
            self.primaryContainer = primaryContainer
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case creationTime = "CreationTime"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case executionRoleArn = "ExecutionRoleArn"
            case inferenceExecutionConfig = "InferenceExecutionConfig"
            case modelArn = "ModelArn"
            case modelName = "ModelName"
            case primaryContainer = "PrimaryContainer"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct DescribeModelPackageGroupInput: AWSEncodableShape {
        /// The name of gthe model group to describe.
        public let modelPackageGroupName: String

        public init(modelPackageGroupName: String) {
            self.modelPackageGroupName = modelPackageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 170)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupName = "ModelPackageGroupName"
        }
    }

    public struct DescribeModelPackageGroupOutput: AWSDecodableShape {
        public let createdBy: UserContext
        /// The time that the model group was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model group.
        public let modelPackageGroupArn: String
        /// A description of the model group.
        public let modelPackageGroupDescription: String?
        /// The name of the model group.
        public let modelPackageGroupName: String
        /// The status of the model group.
        public let modelPackageGroupStatus: ModelPackageGroupStatus

        public init(createdBy: UserContext, creationTime: Date, modelPackageGroupArn: String, modelPackageGroupDescription: String? = nil, modelPackageGroupName: String, modelPackageGroupStatus: ModelPackageGroupStatus) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.modelPackageGroupArn = modelPackageGroupArn
            self.modelPackageGroupDescription = modelPackageGroupDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageGroupStatus = modelPackageGroupStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case modelPackageGroupArn = "ModelPackageGroupArn"
            case modelPackageGroupDescription = "ModelPackageGroupDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageGroupStatus = "ModelPackageGroupStatus"
        }
    }

    public struct DescribeModelPackageInput: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the model package to describe. When you specify a name, the name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let modelPackageName: String

        public init(modelPackageName: String) {
            self.modelPackageName = modelPackageName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, max: 176)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, min: 1)
            try self.validate(self.modelPackageName, name: "modelPackageName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)(\\/[0-9]{1,5})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageName = "ModelPackageName"
        }
    }

    public struct DescribeModelPackageOutput: AWSDecodableShape {
        /// An array of additional Inference Specification objects. Each additional  Inference Specification specifies artifacts based on this model package that can  be used on inference endpoints. Generally used with SageMaker Neo to store the compiled artifacts.
        public let additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]?
        /// A description provided for the model approval.
        public let approvalDescription: String?
        /// Whether the model package is certified for listing on Amazon Web Services Marketplace.
        public let certifyForMarketplace: Bool?
        public let createdBy: UserContext?
        /// A timestamp specifying when the model package was created.
        public let creationTime: Date
        /// The metadata properties associated with the model package versions.
        public let customerMetadataProperties: [String: String]?
        /// The machine learning domain of the model package you specified. Common machine  learning domains include computer vision and natural language processing.
        public let domain: String?
        /// Represents the drift check baselines that can be used when the model monitor is set using the model package.  For more information, see the topic on Drift Detection against Previous Baselines in SageMaker Pipelines in the Amazon SageMaker Developer Guide.
        public let driftCheckBaselines: DriftCheckBaselines?
        /// Details about inference jobs that can be run with models based on this model package.
        public let inferenceSpecification: InferenceSpecification?
        public let lastModifiedBy: UserContext?
        /// The last time that the model package was modified.
        public let lastModifiedTime: Date?
        public let metadataProperties: MetadataProperties?
        /// The approval status of the model package.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// Metrics for the model.
        public let modelMetrics: ModelMetrics?
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String
        /// A brief summary of the model package.
        public let modelPackageDescription: String?
        /// If the model is a versioned model, the name of the model group that the versioned model belongs to.
        public let modelPackageGroupName: String?
        /// The name of the model package being described.
        public let modelPackageName: String
        /// The current status of the model package.
        public let modelPackageStatus: ModelPackageStatus
        /// Details about the current status of the model package.
        public let modelPackageStatusDetails: ModelPackageStatusDetails
        /// The version of the model package.
        public let modelPackageVersion: Int?
        /// The Amazon Simple Storage Service (Amazon S3) path where the sample payload are stored. This path points to a single  gzip compressed tar archive (.tar.gz suffix).
        public let samplePayloadUrl: String?
        /// Details about the algorithm that was used to create the model package.
        public let sourceAlgorithmSpecification: SourceAlgorithmSpecification?
        /// The machine learning task you specified that your model package accomplishes.  Common machine learning tasks include object detection and image classification.
        public let task: String?
        /// Configurations for one or more transform jobs that SageMaker runs to test the model package.
        public let validationSpecification: ModelPackageValidationSpecification?

        public init(additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]? = nil, approvalDescription: String? = nil, certifyForMarketplace: Bool? = nil, createdBy: UserContext? = nil, creationTime: Date, customerMetadataProperties: [String: String]? = nil, domain: String? = nil, driftCheckBaselines: DriftCheckBaselines? = nil, inferenceSpecification: InferenceSpecification? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, metadataProperties: MetadataProperties? = nil, modelApprovalStatus: ModelApprovalStatus? = nil, modelMetrics: ModelMetrics? = nil, modelPackageArn: String, modelPackageDescription: String? = nil, modelPackageGroupName: String? = nil, modelPackageName: String, modelPackageStatus: ModelPackageStatus, modelPackageStatusDetails: ModelPackageStatusDetails, modelPackageVersion: Int? = nil, samplePayloadUrl: String? = nil, sourceAlgorithmSpecification: SourceAlgorithmSpecification? = nil, task: String? = nil, validationSpecification: ModelPackageValidationSpecification? = nil) {
            self.additionalInferenceSpecifications = additionalInferenceSpecifications
            self.approvalDescription = approvalDescription
            self.certifyForMarketplace = certifyForMarketplace
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.customerMetadataProperties = customerMetadataProperties
            self.domain = domain
            self.driftCheckBaselines = driftCheckBaselines
            self.inferenceSpecification = inferenceSpecification
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.metadataProperties = metadataProperties
            self.modelApprovalStatus = modelApprovalStatus
            self.modelMetrics = modelMetrics
            self.modelPackageArn = modelPackageArn
            self.modelPackageDescription = modelPackageDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageName = modelPackageName
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageStatusDetails = modelPackageStatusDetails
            self.modelPackageVersion = modelPackageVersion
            self.samplePayloadUrl = samplePayloadUrl
            self.sourceAlgorithmSpecification = sourceAlgorithmSpecification
            self.task = task
            self.validationSpecification = validationSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInferenceSpecifications = "AdditionalInferenceSpecifications"
            case approvalDescription = "ApprovalDescription"
            case certifyForMarketplace = "CertifyForMarketplace"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case customerMetadataProperties = "CustomerMetadataProperties"
            case domain = "Domain"
            case driftCheckBaselines = "DriftCheckBaselines"
            case inferenceSpecification = "InferenceSpecification"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case metadataProperties = "MetadataProperties"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelMetrics = "ModelMetrics"
            case modelPackageArn = "ModelPackageArn"
            case modelPackageDescription = "ModelPackageDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageName = "ModelPackageName"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageStatusDetails = "ModelPackageStatusDetails"
            case modelPackageVersion = "ModelPackageVersion"
            case samplePayloadUrl = "SamplePayloadUrl"
            case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
            case task = "Task"
            case validationSpecification = "ValidationSpecification"
        }
    }

    public struct DescribeModelQualityJobDefinitionRequest: AWSEncodableShape {
        /// The name of the model quality job. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String

        public init(jobDefinitionName: String) {
            self.jobDefinitionName = jobDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, max: 63)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, min: 1)
            try self.validate(self.jobDefinitionName, name: "jobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionName = "JobDefinitionName"
        }
    }

    public struct DescribeModelQualityJobDefinitionResponse: AWSDecodableShape {
        /// The time at which the model quality job was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model quality job.
        public let jobDefinitionArn: String
        /// The name of the quality job definition. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let jobDefinitionName: String
        public let jobResources: MonitoringResources
        /// Configures the model quality job to run a specified Docker container image.
        public let modelQualityAppSpecification: ModelQualityAppSpecification
        /// The baseline configuration for a model quality job.
        public let modelQualityBaselineConfig: ModelQualityBaselineConfig?
        /// Inputs for the model quality job.
        public let modelQualityJobInput: ModelQualityJobInput
        public let modelQualityJobOutputConfig: MonitoringOutputConfig
        /// Networking options for a model quality job.
        public let networkConfig: MonitoringNetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        public let stoppingCondition: MonitoringStoppingCondition?

        public init(creationTime: Date, jobDefinitionArn: String, jobDefinitionName: String, jobResources: MonitoringResources, modelQualityAppSpecification: ModelQualityAppSpecification, modelQualityBaselineConfig: ModelQualityBaselineConfig? = nil, modelQualityJobInput: ModelQualityJobInput, modelQualityJobOutputConfig: MonitoringOutputConfig, networkConfig: MonitoringNetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil) {
            self.creationTime = creationTime
            self.jobDefinitionArn = jobDefinitionArn
            self.jobDefinitionName = jobDefinitionName
            self.jobResources = jobResources
            self.modelQualityAppSpecification = modelQualityAppSpecification
            self.modelQualityBaselineConfig = modelQualityBaselineConfig
            self.modelQualityJobInput = modelQualityJobInput
            self.modelQualityJobOutputConfig = modelQualityJobOutputConfig
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jobDefinitionArn = "JobDefinitionArn"
            case jobDefinitionName = "JobDefinitionName"
            case jobResources = "JobResources"
            case modelQualityAppSpecification = "ModelQualityAppSpecification"
            case modelQualityBaselineConfig = "ModelQualityBaselineConfig"
            case modelQualityJobInput = "ModelQualityJobInput"
            case modelQualityJobOutputConfig = "ModelQualityJobOutputConfig"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct DescribeMonitoringScheduleRequest: AWSEncodableShape {
        /// Name of a previously created monitoring schedule.
        public let monitoringScheduleName: String

        public init(monitoringScheduleName: String) {
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct DescribeMonitoringScheduleResponse: AWSDecodableShape {
        /// The time at which the monitoring job was created.
        public let creationTime: Date
        ///  The name of the endpoint for the monitoring job.
        public let endpointName: String?
        /// A string, up to one KB in size, that contains the reason a monitoring job failed, if it failed.
        public let failureReason: String?
        /// The time at which the monitoring job was last modified.
        public let lastModifiedTime: Date
        /// Describes metadata on the last execution to run, if there was one.
        public let lastMonitoringExecutionSummary: MonitoringExecutionSummary?
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String
        /// The configuration object that specifies the monitoring schedule and defines the monitoring job.
        public let monitoringScheduleConfig: MonitoringScheduleConfig
        /// Name of the monitoring schedule.
        public let monitoringScheduleName: String
        /// The status of an monitoring job.
        public let monitoringScheduleStatus: ScheduleStatus
        /// The type of the monitoring job that this schedule runs. This is one of the following values.    DATA_QUALITY - The schedule is for a data quality monitoring job.    MODEL_QUALITY - The schedule is for a model quality monitoring job.    MODEL_BIAS - The schedule is for a bias monitoring job.    MODEL_EXPLAINABILITY - The schedule is for an explainability monitoring job.
        public let monitoringType: MonitoringType?

        public init(creationTime: Date, endpointName: String? = nil, failureReason: String? = nil, lastModifiedTime: Date, lastMonitoringExecutionSummary: MonitoringExecutionSummary? = nil, monitoringScheduleArn: String, monitoringScheduleConfig: MonitoringScheduleConfig, monitoringScheduleName: String, monitoringScheduleStatus: ScheduleStatus, monitoringType: MonitoringType? = nil) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.lastMonitoringExecutionSummary = lastMonitoringExecutionSummary
            self.monitoringScheduleArn = monitoringScheduleArn
            self.monitoringScheduleConfig = monitoringScheduleConfig
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringScheduleStatus = monitoringScheduleStatus
            self.monitoringType = monitoringType
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case lastMonitoringExecutionSummary = "LastMonitoringExecutionSummary"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case monitoringScheduleConfig = "MonitoringScheduleConfig"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringScheduleStatus = "MonitoringScheduleStatus"
            case monitoringType = "MonitoringType"
        }
    }

    public struct DescribeNotebookInstanceInput: AWSEncodableShape {
        /// The name of the notebook instance that you want information about.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct DescribeNotebookInstanceLifecycleConfigInput: AWSEncodableShape {
        /// The name of the lifecycle configuration to describe.
        public let notebookInstanceLifecycleConfigName: String

        public init(notebookInstanceLifecycleConfigName: String) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        }
    }

    public struct DescribeNotebookInstanceLifecycleConfigOutput: AWSDecodableShape {
        /// A timestamp that tells when the lifecycle configuration was created.
        public let creationTime: Date?
        /// A timestamp that tells when the lifecycle configuration was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String?
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String?
        /// The shell script that runs only once, when you create a notebook instance.
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// The shell script that runs every time you start a notebook instance, including when you create the notebook instance.
        public let onStart: [NotebookInstanceLifecycleHook]?

        public init(creationTime: Date? = nil, lastModifiedTime: Date? = nil, notebookInstanceLifecycleConfigArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.onCreate = onCreate
            self.onStart = onStart
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case onCreate = "OnCreate"
            case onStart = "OnStart"
        }
    }

    public struct DescribeNotebookInstanceOutput: AWSDecodableShape {
        /// A list of the Elastic Inference (EI) instance types associated with this notebook instance. Currently only one EI instance type can be associated with a notebook instance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        /// An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in Amazon Web Services CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// A timestamp. Use this parameter to return the time when the notebook instance was created
        public let creationTime: Date?
        /// The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in Amazon Web Services CodeCommit or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// Describes whether SageMaker provides internet access to the notebook instance. If this value is set to Disabled, the notebook instance does not have internet access, and cannot connect to SageMaker training and endpoint services. For more information, see Notebook Instances Are Internet-Enabled by Default.
        public let directInternetAccess: DirectInternetAccess?
        /// If status is Failed, the reason it failed.
        public let failureReason: String?
        /// Information on the IMDS configuration of the notebook instance
        public let instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration?
        /// The type of ML compute instance running on the notebook instance.
        public let instanceType: InstanceType?
        /// The Amazon Web Services KMS key ID SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance.
        public let kmsKeyId: String?
        /// A timestamp. Use this parameter to retrieve the time when the notebook instance was last modified.
        public let lastModifiedTime: Date?
        /// The network interface IDs that SageMaker created at the time of creating the instance.
        public let networkInterfaceId: String?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String?
        /// Returns the name of a notebook instance lifecycle configuration. For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance
        public let notebookInstanceLifecycleConfigName: String?
        /// The name of the SageMaker notebook instance.
        public let notebookInstanceName: String?
        /// The status of the notebook instance.
        public let notebookInstanceStatus: NotebookInstanceStatus?
        /// The platform identifier of the notebook instance runtime environment.
        public let platformIdentifier: String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the instance.
        public let roleArn: String?
        /// Whether root access is enabled or disabled for users of the notebook instance.  Lifecycle configurations need root access to be able to set up a notebook instance. Because of this, lifecycle configurations associated with a notebook instance always run with root access even if you disable root access for users.
        public let rootAccess: RootAccess?
        /// The IDs of the VPC security groups.
        public let securityGroups: [String]?
        /// The ID of the VPC subnet.
        public let subnetId: String?
        /// The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.
        public let url: String?
        /// The size, in GB, of the ML storage volume attached to the notebook instance.
        public let volumeSizeInGB: Int?

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, creationTime: Date? = nil, defaultCodeRepository: String? = nil, directInternetAccess: DirectInternetAccess? = nil, failureReason: String? = nil, instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration? = nil, instanceType: InstanceType? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date? = nil, networkInterfaceId: String? = nil, notebookInstanceArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String? = nil, notebookInstanceStatus: NotebookInstanceStatus? = nil, platformIdentifier: String? = nil, roleArn: String? = nil, rootAccess: RootAccess? = nil, securityGroups: [String]? = nil, subnetId: String? = nil, url: String? = nil, volumeSizeInGB: Int? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.creationTime = creationTime
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.failureReason = failureReason
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.networkInterfaceId = networkInterfaceId
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.url = url
            self.volumeSizeInGB = volumeSizeInGB
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case creationTime = "CreationTime"
            case defaultCodeRepository = "DefaultCodeRepository"
            case directInternetAccess = "DirectInternetAccess"
            case failureReason = "FailureReason"
            case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
            case instanceType = "InstanceType"
            case kmsKeyId = "KmsKeyId"
            case lastModifiedTime = "LastModifiedTime"
            case networkInterfaceId = "NetworkInterfaceId"
            case notebookInstanceArn = "NotebookInstanceArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case platformIdentifier = "PlatformIdentifier"
            case roleArn = "RoleArn"
            case rootAccess = "RootAccess"
            case securityGroups = "SecurityGroups"
            case subnetId = "SubnetId"
            case url = "Url"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct DescribePipelineDefinitionForExecutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String

        public init(pipelineExecutionArn: String) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct DescribePipelineDefinitionForExecutionResponse: AWSDecodableShape {
        /// The time when the pipeline was created.
        public let creationTime: Date?
        /// The JSON pipeline definition.
        public let pipelineDefinition: String?

        public init(creationTime: Date? = nil, pipelineDefinition: String? = nil) {
            self.creationTime = creationTime
            self.pipelineDefinition = pipelineDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case pipelineDefinition = "PipelineDefinition"
        }
    }

    public struct DescribePipelineExecutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String

        public init(pipelineExecutionArn: String) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct DescribePipelineExecutionResponse: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The time when the pipeline execution was created.
        public let creationTime: Date?
        /// If the execution failed, a message describing why.
        public let failureReason: String?
        public let lastModifiedBy: UserContext?
        /// The time when the pipeline execution was modified last.
        public let lastModifiedTime: Date?
        /// The parallelism configuration applied to the pipeline.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?
        /// The description of the pipeline execution.
        public let pipelineExecutionDescription: String?
        /// The display name of the pipeline execution.
        public let pipelineExecutionDisplayName: String?
        /// The status of the pipeline execution.
        public let pipelineExecutionStatus: PipelineExecutionStatus?
        public let pipelineExperimentConfig: PipelineExperimentConfig?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, failureReason: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, parallelismConfiguration: ParallelismConfiguration? = nil, pipelineArn: String? = nil, pipelineExecutionArn: String? = nil, pipelineExecutionDescription: String? = nil, pipelineExecutionDisplayName: String? = nil, pipelineExecutionStatus: PipelineExecutionStatus? = nil, pipelineExperimentConfig: PipelineExperimentConfig? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineArn = pipelineArn
            self.pipelineExecutionArn = pipelineExecutionArn
            self.pipelineExecutionDescription = pipelineExecutionDescription
            self.pipelineExecutionDisplayName = pipelineExecutionDisplayName
            self.pipelineExecutionStatus = pipelineExecutionStatus
            self.pipelineExperimentConfig = pipelineExperimentConfig
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineArn = "PipelineArn"
            case pipelineExecutionArn = "PipelineExecutionArn"
            case pipelineExecutionDescription = "PipelineExecutionDescription"
            case pipelineExecutionDisplayName = "PipelineExecutionDisplayName"
            case pipelineExecutionStatus = "PipelineExecutionStatus"
            case pipelineExperimentConfig = "PipelineExperimentConfig"
        }
    }

    public struct DescribePipelineRequest: AWSEncodableShape {
        /// The name of the pipeline to describe.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 2048)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline/.*)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineName = "PipelineName"
        }
    }

    public struct DescribePipelineResponse: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The time when the pipeline was created.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// The time when the pipeline was last modified.
        public let lastModifiedTime: Date?
        /// The time when the pipeline was last run.
        public let lastRunTime: Date?
        /// Lists the parallelism configuration applied to the pipeline.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The JSON pipeline definition.
        public let pipelineDefinition: String?
        /// The description of the pipeline.
        public let pipelineDescription: String?
        /// The display name of the pipeline.
        public let pipelineDisplayName: String?
        /// The name of the pipeline.
        public let pipelineName: String?
        /// The status of the pipeline execution.
        public let pipelineStatus: PipelineStatus?
        /// The Amazon Resource Name (ARN) that the pipeline uses to execute.
        public let roleArn: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lastRunTime: Date? = nil, parallelismConfiguration: ParallelismConfiguration? = nil, pipelineArn: String? = nil, pipelineDefinition: String? = nil, pipelineDescription: String? = nil, pipelineDisplayName: String? = nil, pipelineName: String? = nil, pipelineStatus: PipelineStatus? = nil, roleArn: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lastRunTime = lastRunTime
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineArn = pipelineArn
            self.pipelineDefinition = pipelineDefinition
            self.pipelineDescription = pipelineDescription
            self.pipelineDisplayName = pipelineDisplayName
            self.pipelineName = pipelineName
            self.pipelineStatus = pipelineStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lastRunTime = "LastRunTime"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineArn = "PipelineArn"
            case pipelineDefinition = "PipelineDefinition"
            case pipelineDescription = "PipelineDescription"
            case pipelineDisplayName = "PipelineDisplayName"
            case pipelineName = "PipelineName"
            case pipelineStatus = "PipelineStatus"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeProcessingJobRequest: AWSEncodableShape {
        /// The name of the processing job. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let processingJobName: String

        public init(processingJobName: String) {
            self.processingJobName = processingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, max: 63)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, min: 1)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case processingJobName = "ProcessingJobName"
        }
    }

    public struct DescribeProcessingJobResponse: AWSDecodableShape {
        /// Configures the processing job to run a specified container image.
        public let appSpecification: AppSpecification
        /// The ARN of an AutoML job associated with this processing job.
        public let autoMLJobArn: String?
        /// The time at which the processing job was created.
        public let creationTime: Date
        /// The environment variables set in the Docker container.
        public let environment: [String: String]?
        /// An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.
        public let exitMessage: String?
        /// The configuration information used to create an experiment.
        public let experimentConfig: ExperimentConfig?
        /// A string, up to one KB in size, that contains the reason a processing job failed, if it failed.
        public let failureReason: String?
        /// The time at which the processing job was last modified.
        public let lastModifiedTime: Date?
        /// The ARN of a monitoring schedule for an endpoint associated with this processing job.
        public let monitoringScheduleArn: String?
        /// Networking options for a processing job.
        public let networkConfig: NetworkConfig?
        /// The time at which the processing job completed.
        public let processingEndTime: Date?
        /// The inputs for a processing job.
        public let processingInputs: [ProcessingInput]?
        /// The Amazon Resource Name (ARN) of the processing job.
        public let processingJobArn: String
        /// The name of the processing job. The name must be unique within an Amazon Web Services Region in the Amazon Web Services account.
        public let processingJobName: String
        /// Provides the status of a processing job.
        public let processingJobStatus: ProcessingJobStatus
        /// Output configuration for the processing job.
        public let processingOutputConfig: ProcessingOutputConfig?
        /// Identifies the resources, ML compute instances, and ML storage volumes to deploy for a processing job. In distributed training, you specify more than one instance.
        public let processingResources: ProcessingResources
        /// The time at which the processing job started.
        public let processingStartTime: Date?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String?
        /// The time limit for how long the processing job is allowed to run.
        public let stoppingCondition: ProcessingStoppingCondition?
        /// The ARN of a training job associated with this processing job.
        public let trainingJobArn: String?

        public init(appSpecification: AppSpecification, autoMLJobArn: String? = nil, creationTime: Date, environment: [String: String]? = nil, exitMessage: String? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, lastModifiedTime: Date? = nil, monitoringScheduleArn: String? = nil, networkConfig: NetworkConfig? = nil, processingEndTime: Date? = nil, processingInputs: [ProcessingInput]? = nil, processingJobArn: String, processingJobName: String, processingJobStatus: ProcessingJobStatus, processingOutputConfig: ProcessingOutputConfig? = nil, processingResources: ProcessingResources, processingStartTime: Date? = nil, roleArn: String? = nil, stoppingCondition: ProcessingStoppingCondition? = nil, trainingJobArn: String? = nil) {
            self.appSpecification = appSpecification
            self.autoMLJobArn = autoMLJobArn
            self.creationTime = creationTime
            self.environment = environment
            self.exitMessage = exitMessage
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.monitoringScheduleArn = monitoringScheduleArn
            self.networkConfig = networkConfig
            self.processingEndTime = processingEndTime
            self.processingInputs = processingInputs
            self.processingJobArn = processingJobArn
            self.processingJobName = processingJobName
            self.processingJobStatus = processingJobStatus
            self.processingOutputConfig = processingOutputConfig
            self.processingResources = processingResources
            self.processingStartTime = processingStartTime
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.trainingJobArn = trainingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case appSpecification = "AppSpecification"
            case autoMLJobArn = "AutoMLJobArn"
            case creationTime = "CreationTime"
            case environment = "Environment"
            case exitMessage = "ExitMessage"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case networkConfig = "NetworkConfig"
            case processingEndTime = "ProcessingEndTime"
            case processingInputs = "ProcessingInputs"
            case processingJobArn = "ProcessingJobArn"
            case processingJobName = "ProcessingJobName"
            case processingJobStatus = "ProcessingJobStatus"
            case processingOutputConfig = "ProcessingOutputConfig"
            case processingResources = "ProcessingResources"
            case processingStartTime = "ProcessingStartTime"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case trainingJobArn = "TrainingJobArn"
        }
    }

    public struct DescribeProjectInput: AWSEncodableShape {
        /// The name of the project to describe.
        public let projectName: String

        public init(projectName: String) {
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.projectName, name: "projectName", parent: name, max: 32)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectName = "ProjectName"
        }
    }

    public struct DescribeProjectOutput: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The time when the project was created.
        public let creationTime: Date
        public let lastModifiedBy: UserContext?
        /// The timestamp when project was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String
        /// The description of the project.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The name of the project.
        public let projectName: String
        /// The status of the project.
        public let projectStatus: ProjectStatus
        /// Information about a provisioned service catalog product.
        public let serviceCatalogProvisionedProductDetails: ServiceCatalogProvisionedProductDetails?
        /// Information used to provision a service catalog product. For information, see What is Amazon Web Services Service Catalog.
        public let serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails

        public init(createdBy: UserContext? = nil, creationTime: Date, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, projectArn: String, projectDescription: String? = nil, projectId: String, projectName: String, projectStatus: ProjectStatus, serviceCatalogProvisionedProductDetails: ServiceCatalogProvisionedProductDetails? = nil, serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
            self.projectStatus = projectStatus
            self.serviceCatalogProvisionedProductDetails = serviceCatalogProvisionedProductDetails
            self.serviceCatalogProvisioningDetails = serviceCatalogProvisioningDetails
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case projectArn = "ProjectArn"
            case projectDescription = "ProjectDescription"
            case projectId = "ProjectId"
            case projectName = "ProjectName"
            case projectStatus = "ProjectStatus"
            case serviceCatalogProvisionedProductDetails = "ServiceCatalogProvisionedProductDetails"
            case serviceCatalogProvisioningDetails = "ServiceCatalogProvisioningDetails"
        }
    }

    public struct DescribeSpaceRequest: AWSEncodableShape {
        /// The ID of the associated Domain.
        public let domainId: String
        /// The name of the space.
        public let spaceName: String

        public init(domainId: String, spaceName: String) {
            self.domainId = domainId
            self.spaceName = spaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case spaceName = "SpaceName"
        }
    }

    public struct DescribeSpaceResponse: AWSDecodableShape {
        /// The creation time.
        public let creationTime: Date?
        /// The ID of the associated Domain.
        public let domainId: String?
        /// The failure reason.
        public let failureReason: String?
        /// The ID of the space's profile in the Amazon Elastic File System volume.
        public let homeEfsFileSystemUid: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The space's Amazon Resource Name (ARN).
        public let spaceArn: String?
        /// The name of the space.
        public let spaceName: String?
        /// A collection of space settings.
        public let spaceSettings: SpaceSettings?
        /// The status.
        public let status: SpaceStatus?

        public init(creationTime: Date? = nil, domainId: String? = nil, failureReason: String? = nil, homeEfsFileSystemUid: String? = nil, lastModifiedTime: Date? = nil, spaceArn: String? = nil, spaceName: String? = nil, spaceSettings: SpaceSettings? = nil, status: SpaceStatus? = nil) {
            self.creationTime = creationTime
            self.domainId = domainId
            self.failureReason = failureReason
            self.homeEfsFileSystemUid = homeEfsFileSystemUid
            self.lastModifiedTime = lastModifiedTime
            self.spaceArn = spaceArn
            self.spaceName = spaceName
            self.spaceSettings = spaceSettings
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case failureReason = "FailureReason"
            case homeEfsFileSystemUid = "HomeEfsFileSystemUid"
            case lastModifiedTime = "LastModifiedTime"
            case spaceArn = "SpaceArn"
            case spaceName = "SpaceName"
            case spaceSettings = "SpaceSettings"
            case status = "Status"
        }
    }

    public struct DescribeStudioLifecycleConfigRequest: AWSEncodableShape {
        /// The name of the Studio Lifecycle Configuration to describe.
        public let studioLifecycleConfigName: String

        public init(studioLifecycleConfigName: String) {
            self.studioLifecycleConfigName = studioLifecycleConfigName
        }

        public func validate(name: String) throws {
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.studioLifecycleConfigName, name: "studioLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case studioLifecycleConfigName = "StudioLifecycleConfigName"
        }
    }

    public struct DescribeStudioLifecycleConfigResponse: AWSDecodableShape {
        /// The creation time of the Studio Lifecycle Configuration.
        public let creationTime: Date?
        /// This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.
        public let lastModifiedTime: Date?
        /// The App type that the Lifecycle Configuration is attached to.
        public let studioLifecycleConfigAppType: StudioLifecycleConfigAppType?
        /// The ARN of the Lifecycle Configuration to describe.
        public let studioLifecycleConfigArn: String?
        /// The content of your Studio Lifecycle Configuration script.
        public let studioLifecycleConfigContent: String?
        /// The name of the Studio Lifecycle Configuration that is described.
        public let studioLifecycleConfigName: String?

        public init(creationTime: Date? = nil, lastModifiedTime: Date? = nil, studioLifecycleConfigAppType: StudioLifecycleConfigAppType? = nil, studioLifecycleConfigArn: String? = nil, studioLifecycleConfigContent: String? = nil, studioLifecycleConfigName: String? = nil) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.studioLifecycleConfigAppType = studioLifecycleConfigAppType
            self.studioLifecycleConfigArn = studioLifecycleConfigArn
            self.studioLifecycleConfigContent = studioLifecycleConfigContent
            self.studioLifecycleConfigName = studioLifecycleConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case studioLifecycleConfigAppType = "StudioLifecycleConfigAppType"
            case studioLifecycleConfigArn = "StudioLifecycleConfigArn"
            case studioLifecycleConfigContent = "StudioLifecycleConfigContent"
            case studioLifecycleConfigName = "StudioLifecycleConfigName"
        }
    }

    public struct DescribeSubscribedWorkteamRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the subscribed work team to describe.
        public let workteamArn: String

        public init(workteamArn: String) {
            self.workteamArn = workteamArn
        }

        public func validate(name: String) throws {
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, max: 256)
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:workteam/")
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
        }
    }

    public struct DescribeSubscribedWorkteamResponse: AWSDecodableShape {
        /// A Workteam instance that contains information about the work team.
        public let subscribedWorkteam: SubscribedWorkteam

        public init(subscribedWorkteam: SubscribedWorkteam) {
            self.subscribedWorkteam = subscribedWorkteam
        }

        private enum CodingKeys: String, CodingKey {
            case subscribedWorkteam = "SubscribedWorkteam"
        }
    }

    public struct DescribeTrainingJobRequest: AWSEncodableShape {
        /// The name of the training job.
        public let trainingJobName: String

        public init(trainingJobName: String) {
            self.trainingJobName = trainingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, max: 63)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, min: 1)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobName = "TrainingJobName"
        }
    }

    public struct DescribeTrainingJobResponse: AWSDecodableShape {
        /// Information about the algorithm used for training, and algorithm metadata.
        public let algorithmSpecification: AlgorithmSpecification
        /// The Amazon Resource Name (ARN) of an AutoML job.
        public let autoMLJobArn: String?
        /// The billable time in seconds. Billable time refers to the absolute wall-clock time. Multiply BillableTimeInSeconds by the number of instances (InstanceCount) in your training cluster to get the total compute time SageMaker bills you if you run distributed training. The formula is as follows: BillableTimeInSeconds * InstanceCount . You can calculate the savings from using managed spot training using the formula (1 - BillableTimeInSeconds / TrainingTimeInSeconds) * 100. For example, if BillableTimeInSeconds is 100 and TrainingTimeInSeconds is 500, the savings is 80%.
        public let billableTimeInSeconds: Int?
        public let checkpointConfig: CheckpointConfig?
        /// A timestamp that indicates when the training job was created.
        public let creationTime: Date
        public let debugHookConfig: DebugHookConfig?
        /// Configuration information for Amazon SageMaker Debugger rules for debugging output tensors.
        public let debugRuleConfigurations: [DebugRuleConfiguration]?
        /// Evaluation status of Amazon SageMaker Debugger rules for debugging on a training job.
        public let debugRuleEvaluationStatuses: [DebugRuleEvaluationStatus]?
        /// To encrypt all communications between ML compute instances in distributed training, choose True. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithms in distributed training.
        public let enableInterContainerTrafficEncryption: Bool?
        /// A Boolean indicating whether managed spot training is enabled (True) or not (False).
        public let enableManagedSpotTraining: Bool?
        /// If you want to allow inbound or outbound network calls, except for calls between peers within a training cluster for distributed training, choose True. If you enable network isolation for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.
        public let enableNetworkIsolation: Bool?
        /// The environment variables to set in the Docker container.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// If the training job failed, the reason it failed.
        public let failureReason: String?
        /// A collection of MetricData objects that specify the names, values, and dates and times that the training algorithm emitted to Amazon CloudWatch.
        public let finalMetricDataList: [MetricData]?
        /// Algorithm-specific parameters.
        public let hyperParameters: [String: String]?
        /// An array of Channel objects that describes each data input channel.
        public let inputDataConfig: [Channel]?
        /// The Amazon Resource Name (ARN) of the SageMaker Ground Truth labeling job that created the transform or training job.
        public let labelingJobArn: String?
        /// A timestamp that indicates when the status of the training job was last modified.
        public let lastModifiedTime: Date?
        /// Information about the Amazon S3 location that is configured for storing model artifacts.
        public let modelArtifacts: ModelArtifacts
        /// The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.
        public let outputDataConfig: OutputDataConfig?
        public let profilerConfig: ProfilerConfig?
        /// Configuration information for Amazon SageMaker Debugger rules for profiling system and framework metrics.
        public let profilerRuleConfigurations: [ProfilerRuleConfiguration]?
        /// Evaluation status of Amazon SageMaker Debugger rules for profiling on a training job.
        public let profilerRuleEvaluationStatuses: [ProfilerRuleEvaluationStatus]?
        /// Profiling status of a training job.
        public let profilingStatus: ProfilingStatus?
        /// Resources, including ML compute instances and ML storage volumes, that are configured for model training.
        public let resourceConfig: ResourceConfig
        /// The number of times to retry the job when the job fails due to an InternalServerError.
        public let retryStrategy: RetryStrategy?
        /// The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.
        public let roleArn: String?
        ///  Provides detailed information about the state of the training job. For detailed information on the secondary status of the training job, see StatusMessage under SecondaryStatusTransition. SageMaker provides primary statuses and secondary statuses that apply to each of them:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Interrupted - The job stopped because the managed spot training instances were interrupted.     Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    MaxWaitTimeExceeded - The job stopped because it exceeded the maximum allowed wait time.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.      Valid values for SecondaryStatus are subject to change.   We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTraining     DownloadingTrainingImage
        public let secondaryStatus: SecondaryStatus
        /// A history of all of the secondary statuses that the training job has transitioned through.
        public let secondaryStatusTransitions: [SecondaryStatusTransition]?
        /// Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs. To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost.
        public let stoppingCondition: StoppingCondition
        public let tensorBoardOutputConfig: TensorBoardOutputConfig?
        /// Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of TrainingStartTime and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.
        public let trainingEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        ///  Name of the model training job.
        public let trainingJobName: String
        /// The status of the training job. SageMaker provides the following training job statuses:    InProgress - The training is in progress.    Completed - The training job has completed.    Failed - The training job has failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeTrainingJobResponse call.    Stopping - The training job is stopping.    Stopped - The training job has stopped.   For more detailed information, see SecondaryStatus.
        public let trainingJobStatus: TrainingJobStatus
        /// Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of TrainingEndTime. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.
        public let trainingStartTime: Date?
        /// The training time in seconds.
        public let trainingTimeInSeconds: Int?
        /// The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.
        public let tuningJobArn: String?
        /// A VpcConfig object that specifies the VPC that this training job has access to. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// The status of the warm pool associated with the training job.
        public let warmPoolStatus: WarmPoolStatus?

        public init(algorithmSpecification: AlgorithmSpecification, autoMLJobArn: String? = nil, billableTimeInSeconds: Int? = nil, checkpointConfig: CheckpointConfig? = nil, creationTime: Date, debugHookConfig: DebugHookConfig? = nil, debugRuleConfigurations: [DebugRuleConfiguration]? = nil, debugRuleEvaluationStatuses: [DebugRuleEvaluationStatus]? = nil, enableInterContainerTrafficEncryption: Bool? = nil, enableManagedSpotTraining: Bool? = nil, enableNetworkIsolation: Bool? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, finalMetricDataList: [MetricData]? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, labelingJobArn: String? = nil, lastModifiedTime: Date? = nil, modelArtifacts: ModelArtifacts, outputDataConfig: OutputDataConfig? = nil, profilerConfig: ProfilerConfig? = nil, profilerRuleConfigurations: [ProfilerRuleConfiguration]? = nil, profilerRuleEvaluationStatuses: [ProfilerRuleEvaluationStatus]? = nil, profilingStatus: ProfilingStatus? = nil, resourceConfig: ResourceConfig, retryStrategy: RetryStrategy? = nil, roleArn: String? = nil, secondaryStatus: SecondaryStatus, secondaryStatusTransitions: [SecondaryStatusTransition]? = nil, stoppingCondition: StoppingCondition, tensorBoardOutputConfig: TensorBoardOutputConfig? = nil, trainingEndTime: Date? = nil, trainingJobArn: String, trainingJobName: String, trainingJobStatus: TrainingJobStatus, trainingStartTime: Date? = nil, trainingTimeInSeconds: Int? = nil, tuningJobArn: String? = nil, vpcConfig: VpcConfig? = nil, warmPoolStatus: WarmPoolStatus? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.autoMLJobArn = autoMLJobArn
            self.billableTimeInSeconds = billableTimeInSeconds
            self.checkpointConfig = checkpointConfig
            self.creationTime = creationTime
            self.debugHookConfig = debugHookConfig
            self.debugRuleConfigurations = debugRuleConfigurations
            self.debugRuleEvaluationStatuses = debugRuleEvaluationStatuses
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableManagedSpotTraining = enableManagedSpotTraining
            self.enableNetworkIsolation = enableNetworkIsolation
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.finalMetricDataList = finalMetricDataList
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.labelingJobArn = labelingJobArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArtifacts = modelArtifacts
            self.outputDataConfig = outputDataConfig
            self.profilerConfig = profilerConfig
            self.profilerRuleConfigurations = profilerRuleConfigurations
            self.profilerRuleEvaluationStatuses = profilerRuleEvaluationStatuses
            self.profilingStatus = profilingStatus
            self.resourceConfig = resourceConfig
            self.retryStrategy = retryStrategy
            self.roleArn = roleArn
            self.secondaryStatus = secondaryStatus
            self.secondaryStatusTransitions = secondaryStatusTransitions
            self.stoppingCondition = stoppingCondition
            self.tensorBoardOutputConfig = tensorBoardOutputConfig
            self.trainingEndTime = trainingEndTime
            self.trainingJobArn = trainingJobArn
            self.trainingJobName = trainingJobName
            self.trainingJobStatus = trainingJobStatus
            self.trainingStartTime = trainingStartTime
            self.trainingTimeInSeconds = trainingTimeInSeconds
            self.tuningJobArn = tuningJobArn
            self.vpcConfig = vpcConfig
            self.warmPoolStatus = warmPoolStatus
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "AlgorithmSpecification"
            case autoMLJobArn = "AutoMLJobArn"
            case billableTimeInSeconds = "BillableTimeInSeconds"
            case checkpointConfig = "CheckpointConfig"
            case creationTime = "CreationTime"
            case debugHookConfig = "DebugHookConfig"
            case debugRuleConfigurations = "DebugRuleConfigurations"
            case debugRuleEvaluationStatuses = "DebugRuleEvaluationStatuses"
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableManagedSpotTraining = "EnableManagedSpotTraining"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case finalMetricDataList = "FinalMetricDataList"
            case hyperParameters = "HyperParameters"
            case inputDataConfig = "InputDataConfig"
            case labelingJobArn = "LabelingJobArn"
            case lastModifiedTime = "LastModifiedTime"
            case modelArtifacts = "ModelArtifacts"
            case outputDataConfig = "OutputDataConfig"
            case profilerConfig = "ProfilerConfig"
            case profilerRuleConfigurations = "ProfilerRuleConfigurations"
            case profilerRuleEvaluationStatuses = "ProfilerRuleEvaluationStatuses"
            case profilingStatus = "ProfilingStatus"
            case resourceConfig = "ResourceConfig"
            case retryStrategy = "RetryStrategy"
            case roleArn = "RoleArn"
            case secondaryStatus = "SecondaryStatus"
            case secondaryStatusTransitions = "SecondaryStatusTransitions"
            case stoppingCondition = "StoppingCondition"
            case tensorBoardOutputConfig = "TensorBoardOutputConfig"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobArn = "TrainingJobArn"
            case trainingJobName = "TrainingJobName"
            case trainingJobStatus = "TrainingJobStatus"
            case trainingStartTime = "TrainingStartTime"
            case trainingTimeInSeconds = "TrainingTimeInSeconds"
            case tuningJobArn = "TuningJobArn"
            case vpcConfig = "VpcConfig"
            case warmPoolStatus = "WarmPoolStatus"
        }
    }

    public struct DescribeTransformJobRequest: AWSEncodableShape {
        /// The name of the transform job that you want to view details of.
        public let transformJobName: String

        public init(transformJobName: String) {
            self.transformJobName = transformJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, max: 63)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, min: 1)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobName = "TransformJobName"
        }
    }

    public struct DescribeTransformJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AutoML transform job.
        public let autoMLJobArn: String?
        /// Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.  To enable the batch strategy, you must set SplitType to Line, RecordIO, or TFRecord.
        public let batchStrategy: BatchStrategy?
        /// A timestamp that shows when the transform Job was created.
        public let creationTime: Date
        /// Configuration to control how SageMaker captures inference data.
        public let dataCaptureConfig: BatchDataCaptureConfig?
        public let dataProcessing: DataProcessing?
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// If the transform job failed, FailureReason describes why it failed. A transform job creates a log file, which includes error messages, and stores it as an Amazon S3 object. For more information, see Log Amazon SageMaker Events with Amazon CloudWatch.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the transform or training job.
        public let labelingJobArn: String?
        /// The maximum number of parallel requests on each instance node that can be launched in a transform job. The default value is 1.
        public let maxConcurrentTransforms: Int?
        /// The maximum payload size, in MB, used in the transform job.
        public let maxPayloadInMB: Int?
        /// The timeout and maximum number of retries for processing a transform job invocation.
        public let modelClientConfig: ModelClientConfig?
        /// The name of the model used in the transform job.
        public let modelName: String
        /// Indicates when the transform job has been  completed, or has stopped or failed. You are billed for the time interval between this time and the value of TransformStartTime.
        public let transformEndTime: Date?
        /// Describes the dataset to be transformed and the Amazon S3 location where it is stored.
        public let transformInput: TransformInput
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String
        /// The name of the transform job.
        public let transformJobName: String
        /// The status of the transform job. If the transform job failed, the reason is returned in the FailureReason field.
        public let transformJobStatus: TransformJobStatus
        /// Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        public let transformOutput: TransformOutput?
        /// Describes the resources, including ML instance types and ML instance count, to use for the transform job.
        public let transformResources: TransformResources
        /// Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of TransformEndTime.
        public let transformStartTime: Date?

        public init(autoMLJobArn: String? = nil, batchStrategy: BatchStrategy? = nil, creationTime: Date, dataCaptureConfig: BatchDataCaptureConfig? = nil, dataProcessing: DataProcessing? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, labelingJobArn: String? = nil, maxConcurrentTransforms: Int? = nil, maxPayloadInMB: Int? = nil, modelClientConfig: ModelClientConfig? = nil, modelName: String, transformEndTime: Date? = nil, transformInput: TransformInput, transformJobArn: String, transformJobName: String, transformJobStatus: TransformJobStatus, transformOutput: TransformOutput? = nil, transformResources: TransformResources, transformStartTime: Date? = nil) {
            self.autoMLJobArn = autoMLJobArn
            self.batchStrategy = batchStrategy
            self.creationTime = creationTime
            self.dataCaptureConfig = dataCaptureConfig
            self.dataProcessing = dataProcessing
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.labelingJobArn = labelingJobArn
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.maxPayloadInMB = maxPayloadInMB
            self.modelClientConfig = modelClientConfig
            self.modelName = modelName
            self.transformEndTime = transformEndTime
            self.transformInput = transformInput
            self.transformJobArn = transformJobArn
            self.transformJobName = transformJobName
            self.transformJobStatus = transformJobStatus
            self.transformOutput = transformOutput
            self.transformResources = transformResources
            self.transformStartTime = transformStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobArn = "AutoMLJobArn"
            case batchStrategy = "BatchStrategy"
            case creationTime = "CreationTime"
            case dataCaptureConfig = "DataCaptureConfig"
            case dataProcessing = "DataProcessing"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case labelingJobArn = "LabelingJobArn"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case maxPayloadInMB = "MaxPayloadInMB"
            case modelClientConfig = "ModelClientConfig"
            case modelName = "ModelName"
            case transformEndTime = "TransformEndTime"
            case transformInput = "TransformInput"
            case transformJobArn = "TransformJobArn"
            case transformJobName = "TransformJobName"
            case transformJobStatus = "TransformJobStatus"
            case transformOutput = "TransformOutput"
            case transformResources = "TransformResources"
            case transformStartTime = "TransformStartTime"
        }
    }

    public struct DescribeTrialComponentRequest: AWSEncodableShape {
        /// The name of the trial component to describe.
        public let trialComponentName: String

        public init(trialComponentName: String) {
            self.trialComponentName = trialComponentName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 256)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial|experiment-trial-component|artifact|action|context)\\/)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,119})$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct DescribeTrialComponentResponse: AWSDecodableShape {
        /// Who created the trial component.
        public let createdBy: UserContext?
        /// When the component was created.
        public let creationTime: Date?
        /// The name of the component as displayed. If DisplayName isn't specified, TrialComponentName is displayed.
        public let displayName: String?
        /// When the component ended.
        public let endTime: Date?
        /// The input artifacts of the component.
        public let inputArtifacts: [String: TrialComponentArtifact]?
        /// Who last modified the component.
        public let lastModifiedBy: UserContext?
        /// When the component was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        public let metadataProperties: MetadataProperties?
        /// The metrics for the component.
        public let metrics: [TrialComponentMetricSummary]?
        /// The output artifacts of the component.
        public let outputArtifacts: [String: TrialComponentArtifact]?
        /// The hyperparameters of the component.
        public let parameters: [String: TrialComponentParameterValue]?
        /// The Amazon Resource Name (ARN) of the source and, optionally, the job type.
        public let source: TrialComponentSource?
        /// A list of ARNs and, if applicable, job types for multiple sources of an experiment run.
        public let sources: [TrialComponentSource]?
        /// When the component started.
        public let startTime: Date?
        /// The status of the component. States include:   InProgress   Completed   Failed
        public let status: TrialComponentStatus?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?
        /// The name of the trial component.
        public let trialComponentName: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, displayName: String? = nil, endTime: Date? = nil, inputArtifacts: [String: TrialComponentArtifact]? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, metadataProperties: MetadataProperties? = nil, metrics: [TrialComponentMetricSummary]? = nil, outputArtifacts: [String: TrialComponentArtifact]? = nil, parameters: [String: TrialComponentParameterValue]? = nil, source: TrialComponentSource? = nil, sources: [TrialComponentSource]? = nil, startTime: Date? = nil, status: TrialComponentStatus? = nil, trialComponentArn: String? = nil, trialComponentName: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.displayName = displayName
            self.endTime = endTime
            self.inputArtifacts = inputArtifacts
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.metadataProperties = metadataProperties
            self.metrics = metrics
            self.outputArtifacts = outputArtifacts
            self.parameters = parameters
            self.source = source
            self.sources = sources
            self.startTime = startTime
            self.status = status
            self.trialComponentArn = trialComponentArn
            self.trialComponentName = trialComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case endTime = "EndTime"
            case inputArtifacts = "InputArtifacts"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case metadataProperties = "MetadataProperties"
            case metrics = "Metrics"
            case outputArtifacts = "OutputArtifacts"
            case parameters = "Parameters"
            case source = "Source"
            case sources = "Sources"
            case startTime = "StartTime"
            case status = "Status"
            case trialComponentArn = "TrialComponentArn"
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct DescribeTrialRequest: AWSEncodableShape {
        /// The name of the trial to describe.
        public let trialName: String

        public init(trialName: String) {
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialName = "TrialName"
        }
    }

    public struct DescribeTrialResponse: AWSDecodableShape {
        /// Who created the trial.
        public let createdBy: UserContext?
        /// When the trial was created.
        public let creationTime: Date?
        /// The name of the trial as displayed. If DisplayName isn't specified, TrialName is displayed.
        public let displayName: String?
        /// The name of the experiment the trial is part of.
        public let experimentName: String?
        /// Who last modified the trial.
        public let lastModifiedBy: UserContext?
        /// When the trial was last modified.
        public let lastModifiedTime: Date?
        public let metadataProperties: MetadataProperties?
        /// The Amazon Resource Name (ARN) of the source and, optionally, the job type.
        public let source: TrialSource?
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?
        /// The name of the trial.
        public let trialName: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, displayName: String? = nil, experimentName: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, metadataProperties: MetadataProperties? = nil, source: TrialSource? = nil, trialArn: String? = nil, trialName: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.displayName = displayName
            self.experimentName = experimentName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.metadataProperties = metadataProperties
            self.source = source
            self.trialArn = trialArn
            self.trialName = trialName
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case experimentName = "ExperimentName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case metadataProperties = "MetadataProperties"
            case source = "Source"
            case trialArn = "TrialArn"
            case trialName = "TrialName"
        }
    }

    public struct DescribeUserProfileRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String
        /// The user profile name. This value is not case sensitive.
        public let userProfileName: String

        public init(domainId: String, userProfileName: String) {
            self.domainId = domainId
            self.userProfileName = userProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case userProfileName = "UserProfileName"
        }
    }

    public struct DescribeUserProfileResponse: AWSDecodableShape {
        /// The creation time.
        public let creationTime: Date?
        /// The ID of the domain that contains the profile.
        public let domainId: String?
        /// The failure reason.
        public let failureReason: String?
        /// The ID of the user's profile in the Amazon Elastic File System (EFS) volume.
        public let homeEfsFileSystemUid: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The IAM Identity Center user identifier.
        public let singleSignOnUserIdentifier: String?
        /// The IAM Identity Center user value.
        public let singleSignOnUserValue: String?
        /// The status.
        public let status: UserProfileStatus?
        /// The user profile Amazon Resource Name (ARN).
        public let userProfileArn: String?
        /// The user profile name.
        public let userProfileName: String?
        /// A collection of settings.
        public let userSettings: UserSettings?

        public init(creationTime: Date? = nil, domainId: String? = nil, failureReason: String? = nil, homeEfsFileSystemUid: String? = nil, lastModifiedTime: Date? = nil, singleSignOnUserIdentifier: String? = nil, singleSignOnUserValue: String? = nil, status: UserProfileStatus? = nil, userProfileArn: String? = nil, userProfileName: String? = nil, userSettings: UserSettings? = nil) {
            self.creationTime = creationTime
            self.domainId = domainId
            self.failureReason = failureReason
            self.homeEfsFileSystemUid = homeEfsFileSystemUid
            self.lastModifiedTime = lastModifiedTime
            self.singleSignOnUserIdentifier = singleSignOnUserIdentifier
            self.singleSignOnUserValue = singleSignOnUserValue
            self.status = status
            self.userProfileArn = userProfileArn
            self.userProfileName = userProfileName
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case failureReason = "FailureReason"
            case homeEfsFileSystemUid = "HomeEfsFileSystemUid"
            case lastModifiedTime = "LastModifiedTime"
            case singleSignOnUserIdentifier = "SingleSignOnUserIdentifier"
            case singleSignOnUserValue = "SingleSignOnUserValue"
            case status = "Status"
            case userProfileArn = "UserProfileArn"
            case userProfileName = "UserProfileName"
            case userSettings = "UserSettings"
        }
    }

    public struct DescribeWorkforceRequest: AWSEncodableShape {
        /// The name of the private workforce whose access you want to restrict. WorkforceName is automatically set to default when a workforce is created and cannot be modified.
        public let workforceName: String

        public init(workforceName: String) {
            self.workforceName = workforceName
        }

        public func validate(name: String) throws {
            try self.validate(self.workforceName, name: "workforceName", parent: name, max: 63)
            try self.validate(self.workforceName, name: "workforceName", parent: name, min: 1)
            try self.validate(self.workforceName, name: "workforceName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workforceName = "WorkforceName"
        }
    }

    public struct DescribeWorkforceResponse: AWSDecodableShape {
        /// A single private workforce, which is automatically created when you create your first private work team. You can create one private work force in each Amazon Web Services Region. By default, any workforce-related API operation used in a specific region will apply to the workforce created in that region. To learn how to create a private workforce, see Create a Private Workforce.
        public let workforce: Workforce

        public init(workforce: Workforce) {
            self.workforce = workforce
        }

        private enum CodingKeys: String, CodingKey {
            case workforce = "Workforce"
        }
    }

    public struct DescribeWorkteamRequest: AWSEncodableShape {
        /// The name of the work team to return a description of.
        public let workteamName: String

        public init(workteamName: String) {
            self.workteamName = workteamName
        }

        public func validate(name: String) throws {
            try self.validate(self.workteamName, name: "workteamName", parent: name, max: 63)
            try self.validate(self.workteamName, name: "workteamName", parent: name, min: 1)
            try self.validate(self.workteamName, name: "workteamName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
        }
    }

    public struct DescribeWorkteamResponse: AWSDecodableShape {
        /// A Workteam instance that contains information about the work team.
        public let workteam: Workteam

        public init(workteam: Workteam) {
            self.workteam = workteam
        }

        private enum CodingKeys: String, CodingKey {
            case workteam = "Workteam"
        }
    }

    public struct DesiredWeightAndCapacity: AWSEncodableShape {
        /// The variant's capacity.
        public let desiredInstanceCount: Int?
        /// The variant's weight.
        public let desiredWeight: Float?
        /// The name of the variant to update.
        public let variantName: String

        public init(desiredInstanceCount: Int? = nil, desiredWeight: Float? = nil, variantName: String) {
            self.desiredInstanceCount = desiredInstanceCount
            self.desiredWeight = desiredWeight
            self.variantName = variantName
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredInstanceCount, name: "desiredInstanceCount", parent: name, min: 0)
            try self.validate(self.desiredWeight, name: "desiredWeight", parent: name, min: 0.0)
            try self.validate(self.variantName, name: "variantName", parent: name, max: 63)
            try self.validate(self.variantName, name: "variantName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredInstanceCount = "DesiredInstanceCount"
            case desiredWeight = "DesiredWeight"
            case variantName = "VariantName"
        }
    }

    public struct Device: AWSEncodableShape {
        /// Description of the device.
        public let description: String?
        /// The name of the device.
        public let deviceName: String
        /// Amazon Web Services Internet of Things (IoT) object name.
        public let iotThingName: String?

        public init(description: String? = nil, deviceName: String, iotThingName: String? = nil) {
            self.description = description
            self.deviceName = deviceName
            self.iotThingName = iotThingName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 40)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 63)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.iotThingName, name: "iotThingName", parent: name, max: 128)
            try self.validate(self.iotThingName, name: "iotThingName", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case deviceName = "DeviceName"
            case iotThingName = "IotThingName"
        }
    }

    public struct DeviceDeploymentSummary: AWSDecodableShape {
        /// The name of the deployed stage.
        public let deployedStageName: String?
        /// The time when the deployment on the device started.
        public let deploymentStartTime: Date?
        /// The description of the device.
        public let description: String?
        /// The ARN of the device.
        public let deviceArn: String
        /// The deployment status of the device.
        public let deviceDeploymentStatus: DeviceDeploymentStatus?
        /// The detailed error message for the deployoment status result.
        public let deviceDeploymentStatusMessage: String?
        /// The name of the fleet to which the device belongs to.
        public let deviceFleetName: String?
        /// The name of the device.
        public let deviceName: String
        /// The ARN of the edge deployment plan.
        public let edgeDeploymentPlanArn: String
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// The name of the stage in the edge deployment plan.
        public let stageName: String

        public init(deployedStageName: String? = nil, deploymentStartTime: Date? = nil, description: String? = nil, deviceArn: String, deviceDeploymentStatus: DeviceDeploymentStatus? = nil, deviceDeploymentStatusMessage: String? = nil, deviceFleetName: String? = nil, deviceName: String, edgeDeploymentPlanArn: String, edgeDeploymentPlanName: String, stageName: String) {
            self.deployedStageName = deployedStageName
            self.deploymentStartTime = deploymentStartTime
            self.description = description
            self.deviceArn = deviceArn
            self.deviceDeploymentStatus = deviceDeploymentStatus
            self.deviceDeploymentStatusMessage = deviceDeploymentStatusMessage
            self.deviceFleetName = deviceFleetName
            self.deviceName = deviceName
            self.edgeDeploymentPlanArn = edgeDeploymentPlanArn
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.stageName = stageName
        }

        private enum CodingKeys: String, CodingKey {
            case deployedStageName = "DeployedStageName"
            case deploymentStartTime = "DeploymentStartTime"
            case description = "Description"
            case deviceArn = "DeviceArn"
            case deviceDeploymentStatus = "DeviceDeploymentStatus"
            case deviceDeploymentStatusMessage = "DeviceDeploymentStatusMessage"
            case deviceFleetName = "DeviceFleetName"
            case deviceName = "DeviceName"
            case edgeDeploymentPlanArn = "EdgeDeploymentPlanArn"
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case stageName = "StageName"
        }
    }

    public struct DeviceFleetSummary: AWSDecodableShape {
        /// Timestamp of when the device fleet was created.
        public let creationTime: Date?
        /// Amazon Resource Name (ARN) of the device fleet.
        public let deviceFleetArn: String
        /// Name of the device fleet.
        public let deviceFleetName: String
        /// Timestamp of when the device fleet was last updated.
        public let lastModifiedTime: Date?

        public init(creationTime: Date? = nil, deviceFleetArn: String, deviceFleetName: String, lastModifiedTime: Date? = nil) {
            self.creationTime = creationTime
            self.deviceFleetArn = deviceFleetArn
            self.deviceFleetName = deviceFleetName
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deviceFleetArn = "DeviceFleetArn"
            case deviceFleetName = "DeviceFleetName"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct DeviceSelectionConfig: AWSEncodableShape & AWSDecodableShape {
        /// A filter to select devices with names containing this name.
        public let deviceNameContains: String?
        /// List of devices chosen to deploy.
        public let deviceNames: [String]?
        /// Type of device subsets to deploy to the current stage.
        public let deviceSubsetType: DeviceSubsetType
        /// Percentage of devices in the fleet to deploy to the current stage.
        public let percentage: Int?

        public init(deviceNameContains: String? = nil, deviceNames: [String]? = nil, deviceSubsetType: DeviceSubsetType, percentage: Int? = nil) {
            self.deviceNameContains = deviceNameContains
            self.deviceNames = deviceNames
            self.deviceSubsetType = deviceSubsetType
            self.percentage = percentage
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceNameContains, name: "deviceNameContains", parent: name, max: 63)
            try self.validate(self.deviceNameContains, name: "deviceNameContains", parent: name, min: 1)
            try self.validate(self.deviceNameContains, name: "deviceNameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.deviceNames?.forEach {
                try validate($0, name: "deviceNames[]", parent: name, max: 63)
                try validate($0, name: "deviceNames[]", parent: name, min: 1)
                try validate($0, name: "deviceNames[]", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            }
            try self.validate(self.percentage, name: "percentage", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceNameContains = "DeviceNameContains"
            case deviceNames = "DeviceNames"
            case deviceSubsetType = "DeviceSubsetType"
            case percentage = "Percentage"
        }
    }

    public struct DeviceStats: AWSDecodableShape {
        /// The number of devices connected with a heartbeat.
        public let connectedDeviceCount: Int64
        /// The number of registered devices.
        public let registeredDeviceCount: Int64

        public init(connectedDeviceCount: Int64, registeredDeviceCount: Int64) {
            self.connectedDeviceCount = connectedDeviceCount
            self.registeredDeviceCount = registeredDeviceCount
        }

        private enum CodingKeys: String, CodingKey {
            case connectedDeviceCount = "ConnectedDeviceCount"
            case registeredDeviceCount = "RegisteredDeviceCount"
        }
    }

    public struct DeviceSummary: AWSDecodableShape {
        /// Edge Manager agent version.
        public let agentVersion: String?
        /// A description of the device.
        public let description: String?
        /// Amazon Resource Name (ARN) of the device.
        public let deviceArn: String
        /// The name of the fleet the device belongs to.
        public let deviceFleetName: String?
        /// The unique identifier of the device.
        public let deviceName: String
        /// The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..
        public let iotThingName: String?
        /// The last heartbeat received from the device.
        public let latestHeartbeat: Date?
        /// Models on the device.
        public let models: [EdgeModelSummary]?
        /// The timestamp of the last registration or de-reregistration.
        public let registrationTime: Date?

        public init(agentVersion: String? = nil, description: String? = nil, deviceArn: String, deviceFleetName: String? = nil, deviceName: String, iotThingName: String? = nil, latestHeartbeat: Date? = nil, models: [EdgeModelSummary]? = nil, registrationTime: Date? = nil) {
            self.agentVersion = agentVersion
            self.description = description
            self.deviceArn = deviceArn
            self.deviceFleetName = deviceFleetName
            self.deviceName = deviceName
            self.iotThingName = iotThingName
            self.latestHeartbeat = latestHeartbeat
            self.models = models
            self.registrationTime = registrationTime
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "AgentVersion"
            case description = "Description"
            case deviceArn = "DeviceArn"
            case deviceFleetName = "DeviceFleetName"
            case deviceName = "DeviceName"
            case iotThingName = "IotThingName"
            case latestHeartbeat = "LatestHeartbeat"
            case models = "Models"
            case registrationTime = "RegistrationTime"
        }
    }

    public struct DisableSagemakerServicecatalogPortfolioInput: AWSEncodableShape {
        public init() {}
    }

    public struct DisableSagemakerServicecatalogPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateTrialComponentRequest: AWSEncodableShape {
        /// The name of the component to disassociate from the trial.
        public let trialComponentName: String
        /// The name of the trial to disassociate from.
        public let trialName: String

        public init(trialComponentName: String, trialName: String) {
            self.trialComponentName = trialComponentName
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentName = "TrialComponentName"
            case trialName = "TrialName"
        }
    }

    public struct DisassociateTrialComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?

        public init(trialArn: String? = nil, trialComponentArn: String? = nil) {
            self.trialArn = trialArn
            self.trialComponentArn = trialComponentArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialArn = "TrialArn"
            case trialComponentArn = "TrialComponentArn"
        }
    }

    public struct DomainDetails: AWSDecodableShape {
        /// The creation time.
        public let creationTime: Date?
        /// The domain's Amazon Resource Name (ARN).
        public let domainArn: String?
        /// The domain ID.
        public let domainId: String?
        /// The domain name.
        public let domainName: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The status.
        public let status: DomainStatus?
        /// The domain's URL.
        public let url: String?

        public init(creationTime: Date? = nil, domainArn: String? = nil, domainId: String? = nil, domainName: String? = nil, lastModifiedTime: Date? = nil, status: DomainStatus? = nil, url: String? = nil) {
            self.creationTime = creationTime
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainName = domainName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case domainArn = "DomainArn"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case lastModifiedTime = "LastModifiedTime"
            case status = "Status"
            case url = "Url"
        }
    }

    public struct DomainSettings: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key.
        public let executionRoleIdentityConfig: ExecutionRoleIdentityConfig?
        /// A collection of settings that configure the RStudioServerPro Domain-level app.
        public let rStudioServerProDomainSettings: RStudioServerProDomainSettings?
        /// The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
        public let securityGroupIds: [String]?

        public init(executionRoleIdentityConfig: ExecutionRoleIdentityConfig? = nil, rStudioServerProDomainSettings: RStudioServerProDomainSettings? = nil, securityGroupIds: [String]? = nil) {
            self.executionRoleIdentityConfig = executionRoleIdentityConfig
            self.rStudioServerProDomainSettings = rStudioServerProDomainSettings
            self.securityGroupIds = securityGroupIds
        }

        public func validate(name: String) throws {
            try self.rStudioServerProDomainSettings?.validate(name: "\(name).rStudioServerProDomainSettings")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleIdentityConfig = "ExecutionRoleIdentityConfig"
            case rStudioServerProDomainSettings = "RStudioServerProDomainSettings"
            case securityGroupIds = "SecurityGroupIds"
        }
    }

    public struct DomainSettingsForUpdate: AWSEncodableShape {
        /// The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key. This configuration can only be modified if there are no apps in the InService or Pending state.
        public let executionRoleIdentityConfig: ExecutionRoleIdentityConfig?
        /// A collection of RStudioServerPro Domain-level app settings to update.
        public let rStudioServerProDomainSettingsForUpdate: RStudioServerProDomainSettingsForUpdate?
        /// The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
        public let securityGroupIds: [String]?

        public init(executionRoleIdentityConfig: ExecutionRoleIdentityConfig? = nil, rStudioServerProDomainSettingsForUpdate: RStudioServerProDomainSettingsForUpdate? = nil, securityGroupIds: [String]? = nil) {
            self.executionRoleIdentityConfig = executionRoleIdentityConfig
            self.rStudioServerProDomainSettingsForUpdate = rStudioServerProDomainSettingsForUpdate
            self.securityGroupIds = securityGroupIds
        }

        public func validate(name: String) throws {
            try self.rStudioServerProDomainSettingsForUpdate?.validate(name: "\(name).rStudioServerProDomainSettingsForUpdate")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleIdentityConfig = "ExecutionRoleIdentityConfig"
            case rStudioServerProDomainSettingsForUpdate = "RStudioServerProDomainSettingsForUpdate"
            case securityGroupIds = "SecurityGroupIds"
        }
    }

    public struct DriftCheckBaselines: AWSEncodableShape & AWSDecodableShape {
        /// Represents the drift check bias baselines that can be used when the model monitor is set using the model  package.
        public let bias: DriftCheckBias?
        /// Represents the drift check explainability baselines that can be used when the model monitor is set using  the model package.
        public let explainability: DriftCheckExplainability?
        /// Represents the drift check model data quality baselines that can be used when the model monitor is set  using the model package.
        public let modelDataQuality: DriftCheckModelDataQuality?
        /// Represents the drift check model quality baselines that can be used when the model monitor is set using  the model package.
        public let modelQuality: DriftCheckModelQuality?

        public init(bias: DriftCheckBias? = nil, explainability: DriftCheckExplainability? = nil, modelDataQuality: DriftCheckModelDataQuality? = nil, modelQuality: DriftCheckModelQuality? = nil) {
            self.bias = bias
            self.explainability = explainability
            self.modelDataQuality = modelDataQuality
            self.modelQuality = modelQuality
        }

        public func validate(name: String) throws {
            try self.bias?.validate(name: "\(name).bias")
            try self.explainability?.validate(name: "\(name).explainability")
            try self.modelDataQuality?.validate(name: "\(name).modelDataQuality")
            try self.modelQuality?.validate(name: "\(name).modelQuality")
        }

        private enum CodingKeys: String, CodingKey {
            case bias = "Bias"
            case explainability = "Explainability"
            case modelDataQuality = "ModelDataQuality"
            case modelQuality = "ModelQuality"
        }
    }

    public struct DriftCheckBias: AWSEncodableShape & AWSDecodableShape {
        /// The bias config file for a model.
        public let configFile: FileSource?
        /// The post-training constraints.
        public let postTrainingConstraints: MetricsSource?
        /// The pre-training constraints.
        public let preTrainingConstraints: MetricsSource?

        public init(configFile: FileSource? = nil, postTrainingConstraints: MetricsSource? = nil, preTrainingConstraints: MetricsSource? = nil) {
            self.configFile = configFile
            self.postTrainingConstraints = postTrainingConstraints
            self.preTrainingConstraints = preTrainingConstraints
        }

        public func validate(name: String) throws {
            try self.configFile?.validate(name: "\(name).configFile")
            try self.postTrainingConstraints?.validate(name: "\(name).postTrainingConstraints")
            try self.preTrainingConstraints?.validate(name: "\(name).preTrainingConstraints")
        }

        private enum CodingKeys: String, CodingKey {
            case configFile = "ConfigFile"
            case postTrainingConstraints = "PostTrainingConstraints"
            case preTrainingConstraints = "PreTrainingConstraints"
        }
    }

    public struct DriftCheckExplainability: AWSEncodableShape & AWSDecodableShape {
        /// The explainability config file for the model.
        public let configFile: FileSource?
        /// The drift check explainability constraints.
        public let constraints: MetricsSource?

        public init(configFile: FileSource? = nil, constraints: MetricsSource? = nil) {
            self.configFile = configFile
            self.constraints = constraints
        }

        public func validate(name: String) throws {
            try self.configFile?.validate(name: "\(name).configFile")
            try self.constraints?.validate(name: "\(name).constraints")
        }

        private enum CodingKeys: String, CodingKey {
            case configFile = "ConfigFile"
            case constraints = "Constraints"
        }
    }

    public struct DriftCheckModelDataQuality: AWSEncodableShape & AWSDecodableShape {
        /// The drift check model data quality constraints.
        public let constraints: MetricsSource?
        /// The drift check model data quality statistics.
        public let statistics: MetricsSource?

        public init(constraints: MetricsSource? = nil, statistics: MetricsSource? = nil) {
            self.constraints = constraints
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.statistics?.validate(name: "\(name).statistics")
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case statistics = "Statistics"
        }
    }

    public struct DriftCheckModelQuality: AWSEncodableShape & AWSDecodableShape {
        /// The drift check model quality constraints.
        public let constraints: MetricsSource?
        /// The drift check model quality statistics.
        public let statistics: MetricsSource?

        public init(constraints: MetricsSource? = nil, statistics: MetricsSource? = nil) {
            self.constraints = constraints
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.statistics?.validate(name: "\(name).statistics")
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case statistics = "Statistics"
        }
    }

    public struct EMRStepMetadata: AWSDecodableShape {
        /// The identifier of the EMR cluster.
        public let clusterId: String?
        /// The path to the log file where the cluster step's failure root cause  is recorded.
        public let logFilePath: String?
        /// The identifier of the EMR cluster step.
        public let stepId: String?
        /// The name of the EMR cluster step.
        public let stepName: String?

        public init(clusterId: String? = nil, logFilePath: String? = nil, stepId: String? = nil, stepName: String? = nil) {
            self.clusterId = clusterId
            self.logFilePath = logFilePath
            self.stepId = stepId
            self.stepName = stepName
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case logFilePath = "LogFilePath"
            case stepId = "StepId"
            case stepName = "StepName"
        }
    }

    public struct Edge: AWSDecodableShape {
        /// The type of the Association(Edge) between the source and destination. For example ContributedTo,  Produced, or DerivedFrom.
        public let associationType: AssociationEdgeType?
        /// The Amazon Resource Name (ARN) of the destination lineage entity of the directed edge.
        public let destinationArn: String?
        /// The Amazon Resource Name (ARN) of the source lineage entity of the directed edge.
        public let sourceArn: String?

        public init(associationType: AssociationEdgeType? = nil, destinationArn: String? = nil, sourceArn: String? = nil) {
            self.associationType = associationType
            self.destinationArn = destinationArn
            self.sourceArn = sourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "AssociationType"
            case destinationArn = "DestinationArn"
            case sourceArn = "SourceArn"
        }
    }

    public struct EdgeDeploymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Toggle that determines whether to rollback to previous configuration if the current deployment fails. By default this is turned on. You may turn this off if you want to investigate the errors yourself.
        public let failureHandlingPolicy: FailureHandlingPolicy

        public init(failureHandlingPolicy: FailureHandlingPolicy) {
            self.failureHandlingPolicy = failureHandlingPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case failureHandlingPolicy = "FailureHandlingPolicy"
        }
    }

    public struct EdgeDeploymentModelConfig: AWSEncodableShape & AWSDecodableShape {
        /// The edge packaging job associated with this deployment.
        public let edgePackagingJobName: String
        /// The name the device application uses to reference this model.
        public let modelHandle: String

        public init(edgePackagingJobName: String, modelHandle: String) {
            self.edgePackagingJobName = edgePackagingJobName
            self.modelHandle = modelHandle
        }

        public func validate(name: String) throws {
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, max: 63)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, min: 1)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelHandle, name: "modelHandle", parent: name, max: 63)
            try self.validate(self.modelHandle, name: "modelHandle", parent: name, min: 1)
            try self.validate(self.modelHandle, name: "modelHandle", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgePackagingJobName = "EdgePackagingJobName"
            case modelHandle = "ModelHandle"
        }
    }

    public struct EdgeDeploymentPlanSummary: AWSDecodableShape {
        /// The time when the edge deployment plan was created.
        public let creationTime: Date?
        /// The name of the device fleet used for the deployment.
        public let deviceFleetName: String
        /// The number of edge devices that failed the deployment.
        public let edgeDeploymentFailed: Int
        /// The number of edge devices yet to pick up the deployment, or in progress.
        public let edgeDeploymentPending: Int
        /// The ARN of the edge deployment plan.
        public let edgeDeploymentPlanArn: String
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// The number of edge devices with the successful deployment.
        public let edgeDeploymentSuccess: Int
        /// The time when the edge deployment plan was last updated.
        public let lastModifiedTime: Date?

        public init(creationTime: Date? = nil, deviceFleetName: String, edgeDeploymentFailed: Int, edgeDeploymentPending: Int, edgeDeploymentPlanArn: String, edgeDeploymentPlanName: String, edgeDeploymentSuccess: Int, lastModifiedTime: Date? = nil) {
            self.creationTime = creationTime
            self.deviceFleetName = deviceFleetName
            self.edgeDeploymentFailed = edgeDeploymentFailed
            self.edgeDeploymentPending = edgeDeploymentPending
            self.edgeDeploymentPlanArn = edgeDeploymentPlanArn
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.edgeDeploymentSuccess = edgeDeploymentSuccess
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deviceFleetName = "DeviceFleetName"
            case edgeDeploymentFailed = "EdgeDeploymentFailed"
            case edgeDeploymentPending = "EdgeDeploymentPending"
            case edgeDeploymentPlanArn = "EdgeDeploymentPlanArn"
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case edgeDeploymentSuccess = "EdgeDeploymentSuccess"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct EdgeDeploymentStatus: AWSDecodableShape {
        /// The number of edge devices that failed the deployment in current stage.
        public let edgeDeploymentFailedInStage: Int
        /// The number of edge devices yet to pick up the deployment in current stage, or in progress.
        public let edgeDeploymentPendingInStage: Int
        /// The time when the deployment API started.
        public let edgeDeploymentStageStartTime: Date?
        /// A detailed message about deployment status in current stage.
        public let edgeDeploymentStatusMessage: String?
        /// The number of edge devices with the successful deployment in the current stage.
        public let edgeDeploymentSuccessInStage: Int
        /// The general status of the current stage.
        public let stageStatus: StageStatus

        public init(edgeDeploymentFailedInStage: Int, edgeDeploymentPendingInStage: Int, edgeDeploymentStageStartTime: Date? = nil, edgeDeploymentStatusMessage: String? = nil, edgeDeploymentSuccessInStage: Int, stageStatus: StageStatus) {
            self.edgeDeploymentFailedInStage = edgeDeploymentFailedInStage
            self.edgeDeploymentPendingInStage = edgeDeploymentPendingInStage
            self.edgeDeploymentStageStartTime = edgeDeploymentStageStartTime
            self.edgeDeploymentStatusMessage = edgeDeploymentStatusMessage
            self.edgeDeploymentSuccessInStage = edgeDeploymentSuccessInStage
            self.stageStatus = stageStatus
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentFailedInStage = "EdgeDeploymentFailedInStage"
            case edgeDeploymentPendingInStage = "EdgeDeploymentPendingInStage"
            case edgeDeploymentStageStartTime = "EdgeDeploymentStageStartTime"
            case edgeDeploymentStatusMessage = "EdgeDeploymentStatusMessage"
            case edgeDeploymentSuccessInStage = "EdgeDeploymentSuccessInStage"
            case stageStatus = "StageStatus"
        }
    }

    public struct EdgeModel: AWSDecodableShape {
        /// The timestamp of the last inference that was made.
        public let latestInference: Date?
        /// The timestamp of the last data sample taken.
        public let latestSampleTime: Date?
        /// The name of the model.
        public let modelName: String
        /// The model version.
        public let modelVersion: String

        public init(latestInference: Date? = nil, latestSampleTime: Date? = nil, modelName: String, modelVersion: String) {
            self.latestInference = latestInference
            self.latestSampleTime = latestSampleTime
            self.modelName = modelName
            self.modelVersion = modelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case latestInference = "LatestInference"
            case latestSampleTime = "LatestSampleTime"
            case modelName = "ModelName"
            case modelVersion = "ModelVersion"
        }
    }

    public struct EdgeModelStat: AWSDecodableShape {
        /// The number of devices that have this model version, a heart beat, and are currently running.
        public let activeDeviceCount: Int64
        /// The number of devices that have this model version and have a heart beat.
        public let connectedDeviceCount: Int64
        /// The name of the model.
        public let modelName: String
        /// The model version.
        public let modelVersion: String
        /// The number of devices that have this model version and do not have a heart beat.
        public let offlineDeviceCount: Int64
        /// The number of devices with this model version and are producing sample data.
        public let samplingDeviceCount: Int64

        public init(activeDeviceCount: Int64, connectedDeviceCount: Int64, modelName: String, modelVersion: String, offlineDeviceCount: Int64, samplingDeviceCount: Int64) {
            self.activeDeviceCount = activeDeviceCount
            self.connectedDeviceCount = connectedDeviceCount
            self.modelName = modelName
            self.modelVersion = modelVersion
            self.offlineDeviceCount = offlineDeviceCount
            self.samplingDeviceCount = samplingDeviceCount
        }

        private enum CodingKeys: String, CodingKey {
            case activeDeviceCount = "ActiveDeviceCount"
            case connectedDeviceCount = "ConnectedDeviceCount"
            case modelName = "ModelName"
            case modelVersion = "ModelVersion"
            case offlineDeviceCount = "OfflineDeviceCount"
            case samplingDeviceCount = "SamplingDeviceCount"
        }
    }

    public struct EdgeModelSummary: AWSDecodableShape {
        /// The name of the model.
        public let modelName: String
        /// The version model.
        public let modelVersion: String

        public init(modelName: String, modelVersion: String) {
            self.modelName = modelName
            self.modelVersion = modelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
            case modelVersion = "ModelVersion"
        }
    }

    public struct EdgeOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job.  If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
        public let kmsKeyId: String?
        /// The configuration used to create deployment artifacts.  Specify configuration options with a JSON string. The available configuration options for each type are:    ComponentName (optional) - Name of the GreenGrass V2 component. If not specified, the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager packaging job.    ComponentDescription (optional) - Description of the component.    ComponentVersion (optional) - The version of the component.  Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a major.minor.patch number system. For example, version 1.0.0 represents the first major release for a component. For more information, see the semantic version specification.     PlatformOS (optional) - The name of the operating system for the platform. Supported platforms include Windows and Linux.    PlatformArchitecture (optional) - The processor architecture for the platform.  Supported architectures Windows include: Windows32_x86, Windows64_x64. Supported architectures for Linux include: Linux x86_64, Linux ARMV8.
        public let presetDeploymentConfig: String?
        /// The deployment type SageMaker Edge Manager will create.  Currently only supports Amazon Web Services IoT Greengrass Version 2 components.
        public let presetDeploymentType: EdgePresetDeploymentType?
        /// The Amazon Simple Storage (S3) bucker URI.
        public let s3OutputLocation: String

        public init(kmsKeyId: String? = nil, presetDeploymentConfig: String? = nil, presetDeploymentType: EdgePresetDeploymentType? = nil, s3OutputLocation: String) {
            self.kmsKeyId = kmsKeyId
            self.presetDeploymentConfig = presetDeploymentConfig
            self.presetDeploymentType = presetDeploymentType
            self.s3OutputLocation = s3OutputLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputLocation, name: "s3OutputLocation", parent: name, max: 1024)
            try self.validate(self.s3OutputLocation, name: "s3OutputLocation", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case presetDeploymentConfig = "PresetDeploymentConfig"
            case presetDeploymentType = "PresetDeploymentType"
            case s3OutputLocation = "S3OutputLocation"
        }
    }

    public struct EdgePackagingJobSummary: AWSDecodableShape {
        /// The name of the SageMaker Neo compilation job.
        public let compilationJobName: String?
        /// The timestamp of when the job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the edge packaging job.
        public let edgePackagingJobArn: String
        /// The name of the edge packaging job.
        public let edgePackagingJobName: String
        /// The status of the edge packaging job.
        public let edgePackagingJobStatus: EdgePackagingJobStatus
        /// The timestamp of when the edge packaging job was last updated.
        public let lastModifiedTime: Date?
        /// The name of the model.
        public let modelName: String?
        /// The version of the model.
        public let modelVersion: String?

        public init(compilationJobName: String? = nil, creationTime: Date? = nil, edgePackagingJobArn: String, edgePackagingJobName: String, edgePackagingJobStatus: EdgePackagingJobStatus, lastModifiedTime: Date? = nil, modelName: String? = nil, modelVersion: String? = nil) {
            self.compilationJobName = compilationJobName
            self.creationTime = creationTime
            self.edgePackagingJobArn = edgePackagingJobArn
            self.edgePackagingJobName = edgePackagingJobName
            self.edgePackagingJobStatus = edgePackagingJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.modelName = modelName
            self.modelVersion = modelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case creationTime = "CreationTime"
            case edgePackagingJobArn = "EdgePackagingJobArn"
            case edgePackagingJobName = "EdgePackagingJobName"
            case edgePackagingJobStatus = "EdgePackagingJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case modelName = "ModelName"
            case modelVersion = "ModelVersion"
        }
    }

    public struct EdgePresetDeploymentOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the generated deployable resource.
        public let artifact: String?
        /// The status of the deployable resource.
        public let status: EdgePresetDeploymentStatus?
        /// Returns a message describing the status of the deployed resource.
        public let statusMessage: String?
        /// The deployment type created by SageMaker Edge Manager. Currently only  supports Amazon Web Services IoT Greengrass Version 2 components.
        public let type: EdgePresetDeploymentType

        public init(artifact: String? = nil, status: EdgePresetDeploymentStatus? = nil, statusMessage: String? = nil, type: EdgePresetDeploymentType) {
            self.artifact = artifact
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case artifact = "Artifact"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case type = "Type"
        }
    }

    public struct EnableSagemakerServicecatalogPortfolioInput: AWSEncodableShape {
        public init() {}
    }

    public struct EnableSagemakerServicecatalogPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Endpoint: AWSDecodableShape {
        /// The time that the endpoint was created.
        public let creationTime: Date
        public let dataCaptureConfig: DataCaptureConfigSummary?
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The endpoint configuration associated with the endpoint.
        public let endpointConfigName: String
        /// The name of the endpoint.
        public let endpointName: String
        /// The status of the endpoint.
        public let endpointStatus: EndpointStatus
        /// If the endpoint failed, the reason it failed.
        public let failureReason: String?
        /// The last time the endpoint was modified.
        public let lastModifiedTime: Date
        /// A list of monitoring schedules for the endpoint. For information about model monitoring, see Amazon SageMaker Model Monitor.
        public let monitoringSchedules: [MonitoringSchedule]?
        /// A list of the production variants hosted on the endpoint. Each production variant is a model.
        public let productionVariants: [ProductionVariantSummary]?
        /// A list of the shadow variants hosted on the endpoint. Each shadow variant is a model in shadow mode with production traffic replicated from the proudction variant.
        public let shadowProductionVariants: [ProductionVariantSummary]?
        /// A list of the tags associated with the endpoint. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        public init(creationTime: Date, dataCaptureConfig: DataCaptureConfigSummary? = nil, endpointArn: String, endpointConfigName: String, endpointName: String, endpointStatus: EndpointStatus, failureReason: String? = nil, lastModifiedTime: Date, monitoringSchedules: [MonitoringSchedule]? = nil, productionVariants: [ProductionVariantSummary]? = nil, shadowProductionVariants: [ProductionVariantSummary]? = nil, tags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.dataCaptureConfig = dataCaptureConfig
            self.endpointArn = endpointArn
            self.endpointConfigName = endpointConfigName
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.monitoringSchedules = monitoringSchedules
            self.productionVariants = productionVariants
            self.shadowProductionVariants = shadowProductionVariants
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataCaptureConfig = "DataCaptureConfig"
            case endpointArn = "EndpointArn"
            case endpointConfigName = "EndpointConfigName"
            case endpointName = "EndpointName"
            case endpointStatus = "EndpointStatus"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringSchedules = "MonitoringSchedules"
            case productionVariants = "ProductionVariants"
            case shadowProductionVariants = "ShadowProductionVariants"
            case tags = "Tags"
        }
    }

    public struct EndpointConfigSummary: AWSDecodableShape {
        /// A timestamp that shows when the endpoint configuration was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the endpoint configuration.
        public let endpointConfigArn: String
        /// The name of the endpoint configuration.
        public let endpointConfigName: String

        public init(creationTime: Date, endpointConfigArn: String, endpointConfigName: String) {
            self.creationTime = creationTime
            self.endpointConfigArn = endpointConfigArn
            self.endpointConfigName = endpointConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointConfigArn = "EndpointConfigArn"
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct EndpointInfo: AWSEncodableShape & AWSDecodableShape {
        /// The name of a customer's endpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct EndpointInput: AWSEncodableShape & AWSDecodableShape {
        /// An endpoint in customer's account which has enabled DataCaptureConfig enabled.
        public let endpointName: String
        /// If specified, monitoring jobs substract this time from the end time. For information about using offsets for scheduling monitoring jobs, see Schedule Model Quality Monitoring Jobs.
        public let endTimeOffset: String?
        /// The attributes of the input data that are the input features.
        public let featuresAttribute: String?
        /// The attribute of the input data that represents the ground truth label.
        public let inferenceAttribute: String?
        /// Path to the filesystem where the endpoint data is available to the container.
        public let localPath: String
        /// In a classification problem, the attribute that represents the class probability.
        public let probabilityAttribute: String?
        /// The threshold for the class probability to be evaluated as a positive result.
        public let probabilityThresholdAttribute: Double?
        /// Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to FullyReplicated
        public let s3DataDistributionType: ProcessingS3DataDistributionType?
        /// Whether the Pipe or File is used as the input mode for transferring data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        public let s3InputMode: ProcessingS3InputMode?
        /// If specified, monitoring jobs substract this time from the start time. For information about using offsets for scheduling monitoring jobs, see Schedule Model Quality Monitoring Jobs.
        public let startTimeOffset: String?

        public init(endpointName: String, endTimeOffset: String? = nil, featuresAttribute: String? = nil, inferenceAttribute: String? = nil, localPath: String, probabilityAttribute: String? = nil, probabilityThresholdAttribute: Double? = nil, s3DataDistributionType: ProcessingS3DataDistributionType? = nil, s3InputMode: ProcessingS3InputMode? = nil, startTimeOffset: String? = nil) {
            self.endpointName = endpointName
            self.endTimeOffset = endTimeOffset
            self.featuresAttribute = featuresAttribute
            self.inferenceAttribute = inferenceAttribute
            self.localPath = localPath
            self.probabilityAttribute = probabilityAttribute
            self.probabilityThresholdAttribute = probabilityThresholdAttribute
            self.s3DataDistributionType = s3DataDistributionType
            self.s3InputMode = s3InputMode
            self.startTimeOffset = startTimeOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, max: 15)
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, min: 1)
            try self.validate(self.endTimeOffset, name: "endTimeOffset", parent: name, pattern: "^.?P")
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, max: 15)
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, min: 1)
            try self.validate(self.startTimeOffset, name: "startTimeOffset", parent: name, pattern: "^.?P")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case endTimeOffset = "EndTimeOffset"
            case featuresAttribute = "FeaturesAttribute"
            case inferenceAttribute = "InferenceAttribute"
            case localPath = "LocalPath"
            case probabilityAttribute = "ProbabilityAttribute"
            case probabilityThresholdAttribute = "ProbabilityThresholdAttribute"
            case s3DataDistributionType = "S3DataDistributionType"
            case s3InputMode = "S3InputMode"
            case startTimeOffset = "StartTimeOffset"
        }
    }

    public struct EndpointInputConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The parameter you want to benchmark against.
        public let environmentParameterRanges: EnvironmentParameterRanges?
        /// The inference specification name in the model package version.
        public let inferenceSpecificationName: String?
        /// The instance types to use for the load test.
        public let instanceType: ProductionVariantInstanceType

        public init(environmentParameterRanges: EnvironmentParameterRanges? = nil, inferenceSpecificationName: String? = nil, instanceType: ProductionVariantInstanceType) {
            self.environmentParameterRanges = environmentParameterRanges
            self.inferenceSpecificationName = inferenceSpecificationName
            self.instanceType = instanceType
        }

        public func validate(name: String) throws {
            try self.environmentParameterRanges?.validate(name: "\(name).environmentParameterRanges")
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, max: 63)
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, min: 1)
            try self.validate(self.inferenceSpecificationName, name: "inferenceSpecificationName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentParameterRanges = "EnvironmentParameterRanges"
            case inferenceSpecificationName = "InferenceSpecificationName"
            case instanceType = "InstanceType"
        }
    }

    public struct EndpointMetadata: AWSDecodableShape {
        /// The name of the endpoint configuration.
        public let endpointConfigName: String?
        /// The name of the endpoint.
        public let endpointName: String
        ///  The status of the endpoint. For possible values of the status of an endpoint, see EndpointSummary$EndpointStatus.
        public let endpointStatus: EndpointStatus?
        ///  If the status of the endpoint is Failed, or the status is InService but update operation fails, this provides the reason why it failed.
        public let failureReason: String?

        public init(endpointConfigName: String? = nil, endpointName: String, endpointStatus: EndpointStatus? = nil, failureReason: String? = nil) {
            self.endpointConfigName = endpointConfigName
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
            case endpointName = "EndpointName"
            case endpointStatus = "EndpointStatus"
            case failureReason = "FailureReason"
        }
    }

    public struct EndpointOutputConfiguration: AWSDecodableShape {
        /// The name of the endpoint made during a recommendation job.
        public let endpointName: String
        /// The number of instances recommended to launch initially.
        public let initialInstanceCount: Int
        /// The instance type recommended by Amazon SageMaker Inference Recommender.
        public let instanceType: ProductionVariantInstanceType
        /// The name of the production variant (deployed model) made during a recommendation job.
        public let variantName: String

        public init(endpointName: String, initialInstanceCount: Int, instanceType: ProductionVariantInstanceType, variantName: String) {
            self.endpointName = endpointName
            self.initialInstanceCount = initialInstanceCount
            self.instanceType = instanceType
            self.variantName = variantName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case initialInstanceCount = "InitialInstanceCount"
            case instanceType = "InstanceType"
            case variantName = "VariantName"
        }
    }

    public struct EndpointPerformance: AWSDecodableShape {
        public let endpointInfo: EndpointInfo
        /// The metrics for an existing endpoint.
        public let metrics: InferenceMetrics

        public init(endpointInfo: EndpointInfo, metrics: InferenceMetrics) {
            self.endpointInfo = endpointInfo
            self.metrics = metrics
        }

        private enum CodingKeys: String, CodingKey {
            case endpointInfo = "EndpointInfo"
            case metrics = "Metrics"
        }
    }

    public struct EndpointSummary: AWSDecodableShape {
        /// A timestamp that shows when the endpoint was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The name of the endpoint.
        public let endpointName: String
        /// The status of the endpoint.    OutOfService: Endpoint is not available to take incoming requests.    Creating: CreateEndpoint is executing.    Updating: UpdateEndpoint or UpdateEndpointWeightsAndCapacities is executing.    SystemUpdating: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.    RollingBack: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an InService status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an UpdateEndpointWeightsAndCapacities call or when the UpdateEndpointWeightsAndCapacities operation is called explicitly.    InService: Endpoint is available to process incoming requests.    Deleting: DeleteEndpoint is executing.    Failed: Endpoint could not be created, updated, or re-scaled. Use DescribeEndpointOutput$FailureReason for information about the failure. DeleteEndpoint is the only operation that can be performed on a failed endpoint.   To get a list of endpoints with a specified status, use the ListEndpointsInput$StatusEquals filter.
        public let endpointStatus: EndpointStatus
        /// A timestamp that shows when the endpoint was last modified.
        public let lastModifiedTime: Date

        public init(creationTime: Date, endpointArn: String, endpointName: String, endpointStatus: EndpointStatus, lastModifiedTime: Date) {
            self.creationTime = creationTime
            self.endpointArn = endpointArn
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointArn = "EndpointArn"
            case endpointName = "EndpointName"
            case endpointStatus = "EndpointStatus"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct EnvironmentParameter: AWSDecodableShape {
        /// The environment key suggested by the Amazon SageMaker Inference Recommender.
        public let key: String
        /// The value suggested by the Amazon SageMaker Inference Recommender.
        public let value: String
        /// The value type suggested by the Amazon SageMaker Inference Recommender.
        public let valueType: String

        public init(key: String, value: String, valueType: String) {
            self.key = key
            self.value = value
            self.valueType = valueType
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
            case valueType = "ValueType"
        }
    }

    public struct EnvironmentParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// Specified a list of parameters for each category.
        public let categoricalParameterRanges: [CategoricalParameter]?

        public init(categoricalParameterRanges: [CategoricalParameter]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalParameterRanges[]")
            }
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, max: 5)
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
        }
    }

    public struct Experiment: AWSDecodableShape {
        /// Who created the experiment.
        public let createdBy: UserContext?
        /// When the experiment was created.
        public let creationTime: Date?
        /// The description of the experiment.
        public let description: String?
        /// The name of the experiment as displayed. If DisplayName isn't specified, ExperimentName is displayed.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the experiment.
        public let experimentArn: String?
        /// The name of the experiment.
        public let experimentName: String?
        public let lastModifiedBy: UserContext?
        /// When the experiment was last modified.
        public let lastModifiedTime: Date?
        public let source: ExperimentSource?
        /// The list of tags that are associated with the experiment. You can use Search API to search on the tags.
        public let tags: [Tag]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, description: String? = nil, displayName: String? = nil, experimentArn: String? = nil, experimentName: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, source: ExperimentSource? = nil, tags: [Tag]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.displayName = displayName
            self.experimentArn = experimentArn
            self.experimentName = experimentName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case description = "Description"
            case displayName = "DisplayName"
            case experimentArn = "ExperimentArn"
            case experimentName = "ExperimentName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct ExperimentConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of an existing experiment to associate with the trial component.
        public let experimentName: String?
        /// The name of the experiment run to associate with the trial component.
        public let runName: String?
        /// The display name for the trial component. If this key isn't specified, the display name is the trial component name.
        public let trialComponentDisplayName: String?
        /// The name of an existing trial to associate the trial component with. If not specified, a new trial is created.
        public let trialName: String?

        public init(experimentName: String? = nil, runName: String? = nil, trialComponentDisplayName: String? = nil, trialName: String? = nil) {
            self.experimentName = experimentName
            self.runName = runName
            self.trialComponentDisplayName = trialComponentDisplayName
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.runName, name: "runName", parent: name, max: 120)
            try self.validate(self.runName, name: "runName", parent: name, min: 1)
            try self.validate(self.runName, name: "runName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.trialComponentDisplayName, name: "trialComponentDisplayName", parent: name, max: 120)
            try self.validate(self.trialComponentDisplayName, name: "trialComponentDisplayName", parent: name, min: 1)
            try self.validate(self.trialComponentDisplayName, name: "trialComponentDisplayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case experimentName = "ExperimentName"
            case runName = "RunName"
            case trialComponentDisplayName = "TrialComponentDisplayName"
            case trialName = "TrialName"
        }
    }

    public struct ExperimentSource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the source.
        public let sourceArn: String
        /// The source type.
        public let sourceType: String?

        public init(sourceArn: String, sourceType: String? = nil) {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct ExperimentSummary: AWSDecodableShape {
        /// When the experiment was created.
        public let creationTime: Date?
        /// The name of the experiment as displayed. If DisplayName isn't specified, ExperimentName is displayed.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the experiment.
        public let experimentArn: String?
        /// The name of the experiment.
        public let experimentName: String?
        public let experimentSource: ExperimentSource?
        /// When the experiment was last modified.
        public let lastModifiedTime: Date?

        public init(creationTime: Date? = nil, displayName: String? = nil, experimentArn: String? = nil, experimentName: String? = nil, experimentSource: ExperimentSource? = nil, lastModifiedTime: Date? = nil) {
            self.creationTime = creationTime
            self.displayName = displayName
            self.experimentArn = experimentArn
            self.experimentName = experimentName
            self.experimentSource = experimentSource
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case experimentArn = "ExperimentArn"
            case experimentName = "ExperimentName"
            case experimentSource = "ExperimentSource"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct Explainability: AWSEncodableShape & AWSDecodableShape {
        /// The explainability report for a model.
        public let report: MetricsSource?

        public init(report: MetricsSource? = nil) {
            self.report = report
        }

        public func validate(name: String) throws {
            try self.report?.validate(name: "\(name).report")
        }

        private enum CodingKeys: String, CodingKey {
            case report = "Report"
        }
    }

    public struct ExplainerConfig: AWSEncodableShape & AWSDecodableShape {
        /// A member of ExplainerConfig that contains configuration parameters for the SageMaker Clarify explainer.
        public let clarifyExplainerConfig: ClarifyExplainerConfig?

        public init(clarifyExplainerConfig: ClarifyExplainerConfig? = nil) {
            self.clarifyExplainerConfig = clarifyExplainerConfig
        }

        public func validate(name: String) throws {
            try self.clarifyExplainerConfig?.validate(name: "\(name).clarifyExplainerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clarifyExplainerConfig = "ClarifyExplainerConfig"
        }
    }

    public struct FailStepMetadata: AWSDecodableShape {
        /// A message that you define and then is processed and rendered by  the Fail step when the error occurs.
        public let errorMessage: String?

        public init(errorMessage: String? = nil) {
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
        }
    }

    public struct FeatureDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name of a feature. The type must be a string. FeatureName cannot be any of the following: is_deleted, write_time, api_invocation_time.
        public let featureName: String?
        /// The value type of a feature. Valid values are Integral, Fractional, or String.
        public let featureType: FeatureType?

        public init(featureName: String? = nil, featureType: FeatureType? = nil) {
            self.featureName = featureName
            self.featureType = featureType
        }

        public func validate(name: String) throws {
            try self.validate(self.featureName, name: "featureName", parent: name, max: 64)
            try self.validate(self.featureName, name: "featureName", parent: name, min: 1)
            try self.validate(self.featureName, name: "featureName", parent: name, pattern: "^[a-zA-Z0-9]([-_]*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case featureType = "FeatureType"
        }
    }

    public struct FeatureGroup: AWSDecodableShape {
        /// The time a FeatureGroup was created.
        public let creationTime: Date?
        /// A free form description of a FeatureGroup.
        public let description: String?
        /// The name of the feature that stores the EventTime of a Record in a FeatureGroup. A EventTime is point in time when a new event occurs that corresponds to the creation or update of a Record in FeatureGroup. All Records in the FeatureGroup must have a corresponding EventTime.
        public let eventTimeFeatureName: String?
        /// The reason that the FeatureGroup failed to  be replicated in the OfflineStore. This is  failure may be due to a failure to create a FeatureGroup in or delete a FeatureGroup from the OfflineStore.
        public let failureReason: String?
        /// A list of Features. Each Feature must include a FeatureName and a FeatureType.  Valid FeatureTypes are Integral, Fractional and String.   FeatureNames cannot be any of the following: is_deleted, write_time, api_invocation_time. You can create up to 2,500 FeatureDefinitions per FeatureGroup.
        public let featureDefinitions: [FeatureDefinition]?
        /// The Amazon Resource Name (ARN) of a FeatureGroup.
        public let featureGroupArn: String?
        /// The name of the FeatureGroup.
        public let featureGroupName: String?
        /// A FeatureGroup status.
        public let featureGroupStatus: FeatureGroupStatus?
        /// A timestamp indicating the last time you updated the feature group.
        public let lastModifiedTime: Date?
        /// A value that indicates whether the feature group was updated successfully.
        public let lastUpdateStatus: LastUpdateStatus?
        public let offlineStoreConfig: OfflineStoreConfig?
        public let offlineStoreStatus: OfflineStoreStatus?
        public let onlineStoreConfig: OnlineStoreConfig?
        /// The name of the Feature whose value uniquely identifies a Record defined in the FeatureGroup FeatureDefinitions.
        public let recordIdentifierFeatureName: String?
        /// The Amazon Resource Name (ARN) of the IAM execution role used to create the feature group.
        public let roleArn: String?
        /// Tags used to define a FeatureGroup.
        public let tags: [Tag]?

        public init(creationTime: Date? = nil, description: String? = nil, eventTimeFeatureName: String? = nil, failureReason: String? = nil, featureDefinitions: [FeatureDefinition]? = nil, featureGroupArn: String? = nil, featureGroupName: String? = nil, featureGroupStatus: FeatureGroupStatus? = nil, lastModifiedTime: Date? = nil, lastUpdateStatus: LastUpdateStatus? = nil, offlineStoreConfig: OfflineStoreConfig? = nil, offlineStoreStatus: OfflineStoreStatus? = nil, onlineStoreConfig: OnlineStoreConfig? = nil, recordIdentifierFeatureName: String? = nil, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.eventTimeFeatureName = eventTimeFeatureName
            self.failureReason = failureReason
            self.featureDefinitions = featureDefinitions
            self.featureGroupArn = featureGroupArn
            self.featureGroupName = featureGroupName
            self.featureGroupStatus = featureGroupStatus
            self.lastModifiedTime = lastModifiedTime
            self.lastUpdateStatus = lastUpdateStatus
            self.offlineStoreConfig = offlineStoreConfig
            self.offlineStoreStatus = offlineStoreStatus
            self.onlineStoreConfig = onlineStoreConfig
            self.recordIdentifierFeatureName = recordIdentifierFeatureName
            self.roleArn = roleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case eventTimeFeatureName = "EventTimeFeatureName"
            case failureReason = "FailureReason"
            case featureDefinitions = "FeatureDefinitions"
            case featureGroupArn = "FeatureGroupArn"
            case featureGroupName = "FeatureGroupName"
            case featureGroupStatus = "FeatureGroupStatus"
            case lastModifiedTime = "LastModifiedTime"
            case lastUpdateStatus = "LastUpdateStatus"
            case offlineStoreConfig = "OfflineStoreConfig"
            case offlineStoreStatus = "OfflineStoreStatus"
            case onlineStoreConfig = "OnlineStoreConfig"
            case recordIdentifierFeatureName = "RecordIdentifierFeatureName"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct FeatureGroupSummary: AWSDecodableShape {
        /// A timestamp indicating the time of creation time of the FeatureGroup.
        public let creationTime: Date
        /// Unique identifier for the FeatureGroup.
        public let featureGroupArn: String
        /// The name of FeatureGroup.
        public let featureGroupName: String
        /// The status of a FeatureGroup. The status can be any of the following: Creating, Created, CreateFail, Deleting or DetailFail.
        public let featureGroupStatus: FeatureGroupStatus?
        /// Notifies you if replicating data into the OfflineStore has failed. Returns either: Active or Blocked.
        public let offlineStoreStatus: OfflineStoreStatus?

        public init(creationTime: Date, featureGroupArn: String, featureGroupName: String, featureGroupStatus: FeatureGroupStatus? = nil, offlineStoreStatus: OfflineStoreStatus? = nil) {
            self.creationTime = creationTime
            self.featureGroupArn = featureGroupArn
            self.featureGroupName = featureGroupName
            self.featureGroupStatus = featureGroupStatus
            self.offlineStoreStatus = offlineStoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case featureGroupArn = "FeatureGroupArn"
            case featureGroupName = "FeatureGroupName"
            case featureGroupStatus = "FeatureGroupStatus"
            case offlineStoreStatus = "OfflineStoreStatus"
        }
    }

    public struct FeatureMetadata: AWSDecodableShape {
        /// A timestamp indicating when the feature was created.
        public let creationTime: Date?
        /// An optional description that you specify to better describe the feature.
        public let description: String?
        /// The Amazon Resource Number (ARN) of the feature group.
        public let featureGroupArn: String?
        /// The name of the feature group containing the feature.
        public let featureGroupName: String?
        /// The name of feature.
        public let featureName: String?
        /// The data type of the feature.
        public let featureType: FeatureType?
        /// A timestamp indicating when the feature was last modified.
        public let lastModifiedTime: Date?
        /// Optional key-value pairs that you specify to better describe the feature.
        public let parameters: [FeatureParameter]?

        public init(creationTime: Date? = nil, description: String? = nil, featureGroupArn: String? = nil, featureGroupName: String? = nil, featureName: String? = nil, featureType: FeatureType? = nil, lastModifiedTime: Date? = nil, parameters: [FeatureParameter]? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.featureGroupArn = featureGroupArn
            self.featureGroupName = featureGroupName
            self.featureName = featureName
            self.featureType = featureType
            self.lastModifiedTime = lastModifiedTime
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case featureGroupArn = "FeatureGroupArn"
            case featureGroupName = "FeatureGroupName"
            case featureName = "FeatureName"
            case featureType = "FeatureType"
            case lastModifiedTime = "LastModifiedTime"
            case parameters = "Parameters"
        }
    }

    public struct FeatureParameter: AWSEncodableShape & AWSDecodableShape {
        /// A key that must contain a value to describe the feature.
        public let key: String?
        /// The value that belongs to a key.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 255)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 255)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct FileSource: AWSEncodableShape & AWSDecodableShape {
        /// The digest of the file source.
        public let contentDigest: String?
        /// The type of content stored in the file source.
        public let contentType: String?
        /// The Amazon S3 URI for the file source.
        public let s3Uri: String

        public init(contentDigest: String? = nil, contentType: String? = nil, s3Uri: String) {
            self.contentDigest = contentDigest
            self.contentType = contentType
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.contentDigest, name: "contentDigest", parent: name, max: 72)
            try self.validate(self.contentDigest, name: "contentDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentDigest = "ContentDigest"
            case contentType = "ContentType"
            case s3Uri = "S3Uri"
        }
    }

    public struct FileSystemConfig: AWSEncodableShape & AWSDecodableShape {
        /// The default POSIX group ID (GID). If not specified, defaults to 100.
        public let defaultGid: Int?
        /// The default POSIX user ID (UID). If not specified, defaults to 1000.
        public let defaultUid: Int?
        /// The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
        public let mountPath: String?

        public init(defaultGid: Int? = nil, defaultUid: Int? = nil, mountPath: String? = nil) {
            self.defaultGid = defaultGid
            self.defaultUid = defaultUid
            self.mountPath = mountPath
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultGid, name: "defaultGid", parent: name, max: 65535)
            try self.validate(self.defaultGid, name: "defaultGid", parent: name, min: 0)
            try self.validate(self.defaultUid, name: "defaultUid", parent: name, max: 65535)
            try self.validate(self.defaultUid, name: "defaultUid", parent: name, min: 0)
            try self.validate(self.mountPath, name: "mountPath", parent: name, max: 1024)
            try self.validate(self.mountPath, name: "mountPath", parent: name, pattern: "^\\/")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultGid = "DefaultGid"
            case defaultUid = "DefaultUid"
            case mountPath = "MountPath"
        }
    }

    public struct FileSystemDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The full path to the directory to associate with the channel.
        public let directoryPath: String
        /// The access mode of the mount of the directory associated with the channel. A directory can be mounted either in ro (read-only) or rw (read-write) mode.
        public let fileSystemAccessMode: FileSystemAccessMode
        /// The file system id.
        public let fileSystemId: String
        /// The file system type.
        public let fileSystemType: FileSystemType

        public init(directoryPath: String, fileSystemAccessMode: FileSystemAccessMode, fileSystemId: String, fileSystemType: FileSystemType) {
            self.directoryPath = directoryPath
            self.fileSystemAccessMode = fileSystemAccessMode
            self.fileSystemId = fileSystemId
            self.fileSystemType = fileSystemType
        }

        public func validate(name: String) throws {
            try self.validate(self.directoryPath, name: "directoryPath", parent: name, max: 4096)
            try self.validate(self.directoryPath, name: "directoryPath", parent: name, pattern: ".*")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, min: 11)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case directoryPath = "DirectoryPath"
            case fileSystemAccessMode = "FileSystemAccessMode"
            case fileSystemId = "FileSystemId"
            case fileSystemType = "FileSystemType"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// A resource property name. For example, TrainingJobName. For valid property names, see SearchRecord. You must specify a valid property for the resource.
        public let name: String
        /// A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:  Equals  The value of Name equals Value.  NotEquals  The value of Name doesn't equal Value.  Exists  The Name property exists.  NotExists  The Name property does not exist.  GreaterThan  The value of Name is greater than Value. Not supported for text properties.  GreaterThanOrEqualTo  The value of Name is greater than or equal to Value. Not supported for text properties.  LessThan  The value of Name is less than Value. Not supported for text properties.  LessThanOrEqualTo  The value of Name is less than or equal to Value. Not supported for text properties.  In  The value of Name is one of the comma delimited strings in Value. Only supported for text properties.  Contains  The value of Name contains the string Value. Only supported for text properties. A SearchExpression can include the Contains operator multiple times when the value of Name is one of the following:    Experiment.DisplayName     Experiment.ExperimentName     Experiment.Tags     Trial.DisplayName     Trial.TrialName     Trial.Tags     TrialComponent.DisplayName     TrialComponent.TrialComponentName     TrialComponent.Tags     TrialComponent.InputArtifacts     TrialComponent.OutputArtifacts    A SearchExpression can include only one Contains operator for all other values of Name. In these cases, if you include multiple Contains operators in the SearchExpression, the result is the following error message: "'CONTAINS' operator usage limit of 1 exceeded."
        public let `operator`: Operator?
        /// A value used with Name and Operator to determine which resources satisfy the filter's condition. For numerical properties, Value must be an integer or floating-point decimal. For timestamp properties, Value must be an ISO 8601 date-time string of the following format: YYYY-mm-dd'T'HH:MM:SS.
        public let value: String?

        public init(name: String, operator: Operator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.+$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct FinalAutoMLJobObjectiveMetric: AWSDecodableShape {
        /// The name of the metric with the best result. For a description of the possible objective metrics, see AutoMLJobObjective$MetricName.
        public let metricName: AutoMLMetricEnum
        /// The type of metric with the best result.
        public let type: AutoMLJobObjectiveType?
        /// The value of the metric with the best result.
        public let value: Float

        public init(metricName: AutoMLMetricEnum, type: AutoMLJobObjectiveType? = nil, value: Float) {
            self.metricName = metricName
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct FinalHyperParameterTuningJobObjectiveMetric: AWSDecodableShape {
        /// The name of the objective metric.
        public let metricName: String
        /// Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.
        public let type: HyperParameterTuningJobObjectiveType?
        /// The value of the objective metric.
        public let value: Float

        public init(metricName: String, type: HyperParameterTuningJobObjectiveType? = nil, value: Float) {
            self.metricName = metricName
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct FlowDefinitionOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The Amazon S3 path where the object containing human output will be made available. To learn more about the format of Amazon A2I output data, see Amazon A2I Output Data.
        public let s3OutputPath: String

        public init(kmsKeyId: String? = nil, s3OutputPath: String) {
            self.kmsKeyId = kmsKeyId
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct FlowDefinitionSummary: AWSDecodableShape {
        /// The timestamp when SageMaker created the flow definition.
        public let creationTime: Date
        /// The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is Failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the flow definition.
        public let flowDefinitionArn: String
        /// The name of the flow definition.
        public let flowDefinitionName: String
        /// The status of the flow definition. Valid values:
        public let flowDefinitionStatus: FlowDefinitionStatus

        public init(creationTime: Date, failureReason: String? = nil, flowDefinitionArn: String, flowDefinitionName: String, flowDefinitionStatus: FlowDefinitionStatus) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.flowDefinitionName = flowDefinitionName
            self.flowDefinitionStatus = flowDefinitionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case flowDefinitionArn = "FlowDefinitionArn"
            case flowDefinitionName = "FlowDefinitionName"
            case flowDefinitionStatus = "FlowDefinitionStatus"
        }
    }

    public struct GetDeviceFleetReportRequest: AWSEncodableShape {
        /// The name of the fleet.
        public let deviceFleetName: String

        public init(deviceFleetName: String) {
            self.deviceFleetName = deviceFleetName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
        }
    }

    public struct GetDeviceFleetReportResponse: AWSDecodableShape {
        /// The versions of Edge Manager agent deployed on the fleet.
        public let agentVersions: [AgentVersion]?
        /// Description of the fleet.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the device.
        public let deviceFleetArn: String
        /// The name of the fleet.
        public let deviceFleetName: String
        /// Status of devices.
        public let deviceStats: DeviceStats?
        /// Status of model on device.
        public let modelStats: [EdgeModelStat]?
        /// The output configuration for storing sample data collected by the fleet.
        public let outputConfig: EdgeOutputConfig?
        /// Timestamp of when the report was generated.
        public let reportGenerated: Date?

        public init(agentVersions: [AgentVersion]? = nil, description: String? = nil, deviceFleetArn: String, deviceFleetName: String, deviceStats: DeviceStats? = nil, modelStats: [EdgeModelStat]? = nil, outputConfig: EdgeOutputConfig? = nil, reportGenerated: Date? = nil) {
            self.agentVersions = agentVersions
            self.description = description
            self.deviceFleetArn = deviceFleetArn
            self.deviceFleetName = deviceFleetName
            self.deviceStats = deviceStats
            self.modelStats = modelStats
            self.outputConfig = outputConfig
            self.reportGenerated = reportGenerated
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersions = "AgentVersions"
            case description = "Description"
            case deviceFleetArn = "DeviceFleetArn"
            case deviceFleetName = "DeviceFleetName"
            case deviceStats = "DeviceStats"
            case modelStats = "ModelStats"
            case outputConfig = "OutputConfig"
            case reportGenerated = "ReportGenerated"
        }
    }

    public struct GetLineageGroupPolicyRequest: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupName: String

        public init(lineageGroupName: String) {
            self.lineageGroupName = lineageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, max: 256)
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, min: 1)
            try self.validate(self.lineageGroupName, name: "lineageGroupName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:lineage-group\\/)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,119})$")
        }

        private enum CodingKeys: String, CodingKey {
            case lineageGroupName = "LineageGroupName"
        }
    }

    public struct GetLineageGroupPolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupArn: String?
        /// The resource policy that gives access to the lineage group in another account.
        public let resourcePolicy: String?

        public init(lineageGroupArn: String? = nil, resourcePolicy: String? = nil) {
            self.lineageGroupArn = lineageGroupArn
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case lineageGroupArn = "LineageGroupArn"
            case resourcePolicy = "ResourcePolicy"
        }
    }

    public struct GetModelPackageGroupPolicyInput: AWSEncodableShape {
        /// The name of the model group for which to get the resource policy.
        public let modelPackageGroupName: String

        public init(modelPackageGroupName: String) {
            self.modelPackageGroupName = modelPackageGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 63)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupName = "ModelPackageGroupName"
        }
    }

    public struct GetModelPackageGroupPolicyOutput: AWSDecodableShape {
        /// The resource policy for the model group.
        public let resourcePolicy: String

        public init(resourcePolicy: String) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "ResourcePolicy"
        }
    }

    public struct GetSagemakerServicecatalogPortfolioStatusInput: AWSEncodableShape {
        public init() {}
    }

    public struct GetSagemakerServicecatalogPortfolioStatusOutput: AWSDecodableShape {
        /// Whether Service Catalog is enabled or disabled in SageMaker.
        public let status: SagemakerServicecatalogStatus?

        public init(status: SagemakerServicecatalogStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct GetSearchSuggestionsRequest: AWSEncodableShape {
        /// The name of the Amazon SageMaker resource to search for.
        public let resource: ResourceType
        /// Limits the property names that are included in the response.
        public let suggestionQuery: SuggestionQuery?

        public init(resource: ResourceType, suggestionQuery: SuggestionQuery? = nil) {
            self.resource = resource
            self.suggestionQuery = suggestionQuery
        }

        public func validate(name: String) throws {
            try self.suggestionQuery?.validate(name: "\(name).suggestionQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "Resource"
            case suggestionQuery = "SuggestionQuery"
        }
    }

    public struct GetSearchSuggestionsResponse: AWSDecodableShape {
        /// A list of property names for a Resource that match a SuggestionQuery.
        public let propertyNameSuggestions: [PropertyNameSuggestion]?

        public init(propertyNameSuggestions: [PropertyNameSuggestion]? = nil) {
            self.propertyNameSuggestions = propertyNameSuggestions
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameSuggestions = "PropertyNameSuggestions"
        }
    }

    public struct GitConfig: AWSEncodableShape & AWSDecodableShape {
        /// The default branch for the Git repository.
        public let branch: String?
        /// The URL where the Git repository is located.
        public let repositoryUrl: String
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password}
        public let secretArn: String?

        public init(branch: String? = nil, repositoryUrl: String, secretArn: String? = nil) {
            self.branch = branch
            self.repositoryUrl = repositoryUrl
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.branch, name: "branch", parent: name, max: 1024)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.branch, name: "branch", parent: name, pattern: "^[^ ~^:?*\\[]+$")
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, pattern: "^https://([^/]+)/?(.*)$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 1)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:aws[a-z\\-]*:secretsmanager:[a-z0-9\\-]*:[0-9]{12}:secret:")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "Branch"
            case repositoryUrl = "RepositoryUrl"
            case secretArn = "SecretArn"
        }
    }

    public struct GitConfigForUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password}
        public let secretArn: String?

        public init(secretArn: String? = nil) {
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 1)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:aws[a-z\\-]*:secretsmanager:[a-z0-9\\-]*:[0-9]{12}:secret:")
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "SecretArn"
        }
    }

    public struct HubContentDependency: AWSDecodableShape {
        /// The hub content dependency copy path.
        public let dependencyCopyPath: String?
        /// The hub content dependency origin path.
        public let dependencyOriginPath: String?

        public init(dependencyCopyPath: String? = nil, dependencyOriginPath: String? = nil) {
            self.dependencyCopyPath = dependencyCopyPath
            self.dependencyOriginPath = dependencyOriginPath
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyCopyPath = "DependencyCopyPath"
            case dependencyOriginPath = "DependencyOriginPath"
        }
    }

    public struct HubContentInfo: AWSDecodableShape {
        /// The date and time that the hub content was created.
        public let creationTime: Date
        /// The version of the hub content document schema.
        public let documentSchemaVersion: String
        /// The Amazon Resource Name (ARN) of the hub content.
        public let hubContentArn: String
        /// A description of the hub content.
        public let hubContentDescription: String?
        /// The display name of the hub content.
        public let hubContentDisplayName: String?
        /// The name of the hub content.
        public let hubContentName: String
        /// The searchable keywords for the hub content.
        public let hubContentSearchKeywords: [String]?
        /// The status of the hub content.
        public let hubContentStatus: HubContentStatus
        /// The type of hub content.
        public let hubContentType: HubContentType
        /// The version of the hub content.
        public let hubContentVersion: String

        public init(creationTime: Date, documentSchemaVersion: String, hubContentArn: String, hubContentDescription: String? = nil, hubContentDisplayName: String? = nil, hubContentName: String, hubContentSearchKeywords: [String]? = nil, hubContentStatus: HubContentStatus, hubContentType: HubContentType, hubContentVersion: String) {
            self.creationTime = creationTime
            self.documentSchemaVersion = documentSchemaVersion
            self.hubContentArn = hubContentArn
            self.hubContentDescription = hubContentDescription
            self.hubContentDisplayName = hubContentDisplayName
            self.hubContentName = hubContentName
            self.hubContentSearchKeywords = hubContentSearchKeywords
            self.hubContentStatus = hubContentStatus
            self.hubContentType = hubContentType
            self.hubContentVersion = hubContentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case documentSchemaVersion = "DocumentSchemaVersion"
            case hubContentArn = "HubContentArn"
            case hubContentDescription = "HubContentDescription"
            case hubContentDisplayName = "HubContentDisplayName"
            case hubContentName = "HubContentName"
            case hubContentSearchKeywords = "HubContentSearchKeywords"
            case hubContentStatus = "HubContentStatus"
            case hubContentType = "HubContentType"
            case hubContentVersion = "HubContentVersion"
        }
    }

    public struct HubInfo: AWSDecodableShape {
        /// The date and time that the hub was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the hub.
        public let hubArn: String
        /// A description of the hub.
        public let hubDescription: String?
        /// The display name of the hub.
        public let hubDisplayName: String?
        /// The name of the hub.
        public let hubName: String
        /// The searchable keywords for the hub.
        public let hubSearchKeywords: [String]?
        /// The status of the hub.
        public let hubStatus: HubStatus
        /// The date and time that the hub was last modified.
        public let lastModifiedTime: Date

        public init(creationTime: Date, hubArn: String, hubDescription: String? = nil, hubDisplayName: String? = nil, hubName: String, hubSearchKeywords: [String]? = nil, hubStatus: HubStatus, lastModifiedTime: Date) {
            self.creationTime = creationTime
            self.hubArn = hubArn
            self.hubDescription = hubDescription
            self.hubDisplayName = hubDisplayName
            self.hubName = hubName
            self.hubSearchKeywords = hubSearchKeywords
            self.hubStatus = hubStatus
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case hubArn = "HubArn"
            case hubDescription = "HubDescription"
            case hubDisplayName = "HubDisplayName"
            case hubName = "HubName"
            case hubSearchKeywords = "HubSearchKeywords"
            case hubStatus = "HubStatus"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct HubS3StorageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 output path for the hub.
        public let s3OutputPath: String?

        public init(s3OutputPath: String? = nil) {
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct HumanLoopActivationConditionsConfig: AWSEncodableShape & AWSDecodableShape {
        /// JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team.  The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see  JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI  in the Amazon SageMaker Developer Guide.
        public let humanLoopActivationConditions: String

        public init(humanLoopActivationConditions: String) {
            self.humanLoopActivationConditions = humanLoopActivationConditions
        }

        public func validate(name: String) throws {
            try self.validate(self.humanLoopActivationConditions, name: "humanLoopActivationConditions", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case humanLoopActivationConditions = "HumanLoopActivationConditions"
        }
    }

    public struct HumanLoopActivationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Container structure for defining under what conditions SageMaker creates a human loop.
        public let humanLoopActivationConditionsConfig: HumanLoopActivationConditionsConfig

        public init(humanLoopActivationConditionsConfig: HumanLoopActivationConditionsConfig) {
            self.humanLoopActivationConditionsConfig = humanLoopActivationConditionsConfig
        }

        public func validate(name: String) throws {
            try self.humanLoopActivationConditionsConfig.validate(name: "\(name).humanLoopActivationConditionsConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case humanLoopActivationConditionsConfig = "HumanLoopActivationConditionsConfig"
        }
    }

    public struct HumanLoopConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the human task user interface. You can use standard HTML and Crowd HTML Elements to create a custom worker task template. You use this template to create a human task UI. To learn how to create a custom HTML template, see Create Custom Worker Task Template. To learn how to create a human task UI, which is a worker task template that can be used in a flow definition, see Create and Delete a Worker Task Templates.
        public let humanTaskUiArn: String
        public let publicWorkforceTaskPrice: PublicWorkforceTaskPrice?
        /// The length of time that a task remains available for review by human workers.
        public let taskAvailabilityLifetimeInSeconds: Int?
        /// The number of distinct workers who will perform the same task on each object. For example, if TaskCount is set to 3 for an image classification  labeling job, three workers will classify each input image.  Increasing TaskCount can improve label accuracy.
        public let taskCount: Int
        /// A description for the human worker task.
        public let taskDescription: String
        /// Keywords used to describe the task so that workers can discover the task.
        public let taskKeywords: [String]?
        /// The amount of time that a worker has to complete a task. The default value is 3,600 seconds (1 hour).
        public let taskTimeLimitInSeconds: Int?
        /// A title for the human worker task.
        public let taskTitle: String
        /// Amazon Resource Name (ARN) of a team of workers. To learn more about the types of workforces and work teams you can create and use with Amazon A2I, see Create and Manage Workforces.
        public let workteamArn: String

        public init(humanTaskUiArn: String, publicWorkforceTaskPrice: PublicWorkforceTaskPrice? = nil, taskAvailabilityLifetimeInSeconds: Int? = nil, taskCount: Int, taskDescription: String, taskKeywords: [String]? = nil, taskTimeLimitInSeconds: Int? = nil, taskTitle: String, workteamArn: String) {
            self.humanTaskUiArn = humanTaskUiArn
            self.publicWorkforceTaskPrice = publicWorkforceTaskPrice
            self.taskAvailabilityLifetimeInSeconds = taskAvailabilityLifetimeInSeconds
            self.taskCount = taskCount
            self.taskDescription = taskDescription
            self.taskKeywords = taskKeywords
            self.taskTimeLimitInSeconds = taskTimeLimitInSeconds
            self.taskTitle = taskTitle
            self.workteamArn = workteamArn
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, max: 1024)
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:human-task-ui/")
            try self.publicWorkforceTaskPrice?.validate(name: "\(name).publicWorkforceTaskPrice")
            try self.validate(self.taskAvailabilityLifetimeInSeconds, name: "taskAvailabilityLifetimeInSeconds", parent: name, max: 864_000)
            try self.validate(self.taskAvailabilityLifetimeInSeconds, name: "taskAvailabilityLifetimeInSeconds", parent: name, min: 1)
            try self.validate(self.taskCount, name: "taskCount", parent: name, max: 3)
            try self.validate(self.taskCount, name: "taskCount", parent: name, min: 1)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, max: 255)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, min: 1)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, pattern: "^.+$")
            try self.taskKeywords?.forEach {
                try validate($0, name: "taskKeywords[]", parent: name, max: 30)
                try validate($0, name: "taskKeywords[]", parent: name, min: 1)
                try validate($0, name: "taskKeywords[]", parent: name, pattern: "^[A-Za-z0-9]+( [A-Za-z0-9]+)*$")
            }
            try self.validate(self.taskKeywords, name: "taskKeywords", parent: name, max: 5)
            try self.validate(self.taskKeywords, name: "taskKeywords", parent: name, min: 1)
            try self.validate(self.taskTimeLimitInSeconds, name: "taskTimeLimitInSeconds", parent: name, max: 28800)
            try self.validate(self.taskTimeLimitInSeconds, name: "taskTimeLimitInSeconds", parent: name, min: 30)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, max: 128)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, min: 1)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, pattern: "^[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]*$")
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, max: 256)
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:workteam/")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiArn = "HumanTaskUiArn"
            case publicWorkforceTaskPrice = "PublicWorkforceTaskPrice"
            case taskAvailabilityLifetimeInSeconds = "TaskAvailabilityLifetimeInSeconds"
            case taskCount = "TaskCount"
            case taskDescription = "TaskDescription"
            case taskKeywords = "TaskKeywords"
            case taskTimeLimitInSeconds = "TaskTimeLimitInSeconds"
            case taskTitle = "TaskTitle"
            case workteamArn = "WorkteamArn"
        }
    }

    public struct HumanLoopRequestSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source.  The default field settings and JSON parsing rules are different based on the integration source. Valid values:
        public let awsManagedHumanLoopRequestSource: AwsManagedHumanLoopRequestSource

        public init(awsManagedHumanLoopRequestSource: AwsManagedHumanLoopRequestSource) {
            self.awsManagedHumanLoopRequestSource = awsManagedHumanLoopRequestSource
        }

        private enum CodingKeys: String, CodingKey {
            case awsManagedHumanLoopRequestSource = "AwsManagedHumanLoopRequestSource"
        }
    }

    public struct HumanTaskConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configures how labels are consolidated across human workers.
        public let annotationConsolidationConfig: AnnotationConsolidationConfig
        /// Defines the maximum number of data objects that can be labeled by human workers at the same time. Also referred to as batch size. Each object may have more than one worker at one time. The default value is 1000 objects. To increase the maximum value to 5000 objects, contact Amazon Web Services Support.
        public let maxConcurrentTaskCount: Int?
        /// The number of human workers that will label an object.
        public let numberOfHumanWorkersPerDataObject: Int
        /// The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job. For built-in task types, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for PreHumanTaskLambdaArn. For custom labeling workflows, see Pre-annotation Lambda.   Bounding box - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.    arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox     arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox     arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox     Image classification - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass     arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass     arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass     Multi-label image classification - Uses a variant of the Expectation Maximization approach to estimate the true classes of an image based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel     Semantic segmentation - Treats each pixel in an image as a multi-class classification and treats pixel annotations from workers as "votes" for the correct label.    arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation     Text classification - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass     arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass     arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass     Multi-label text classification - Uses a variant of the Expectation Maximization approach to estimate the true classes of text based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel     Named entity recognition - Groups similar selections and calculates aggregate boundaries, resolving to most-assigned label.    arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition     arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition     arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition     arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition     arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition     arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition     arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition     arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition     Video Classification - Use this task type when you need workers to classify videos using predefined labels that you specify. Workers are shown videos and are asked to choose one label for each video.    arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass     arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass     arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass     arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass     arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass     arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass     arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass     arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass     Video Frame Object Detection - Use this task type to have workers identify and locate objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to identify and localize various objects in a series of video frames, such as cars, bikes, and pedestrians.    arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection     Video Frame Object Tracking - Use this task type to have workers track the movement of objects in a sequence of video frames (images extracted from a video) using bounding boxes. For example, you can use this task to ask workers to track the movement of objects, such as cars, bikes, and pedestrians.     arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking     3D Point Cloud Modalities  Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks. See 3D Point Cloud Task types to learn more.   3D Point Cloud Object Detection -  Use this task type when you want workers to classify objects in a 3D point cloud by  drawing 3D cuboids around objects. For example, you can use this task type to ask workers  to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.    arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection     3D Point Cloud Object Tracking -  Use this task type when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D point cloud frames.  For example, you can use this task type to ask workers to track  the movement of vehicles across multiple point cloud frames.     arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking     3D Point Cloud Semantic Segmentation -  Use this task type when you want workers to create a point-level semantic segmentation masks by  painting objects in a 3D point cloud using different colors where each color is assigned to one of  the classes you specify.    arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation     Use the following ARNs for Label Verification and Adjustment Jobs  Use label verification and adjustment jobs to review and adjust labels. To learn more, see Verify and Adjust Labels .  Bounding box verification - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgement for bounding box labels based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox     arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox     arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox     Bounding box adjustment - Finds the most similar boxes from different workers based on the Jaccard index of the adjusted annotations.    arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox     Semantic segmentation verification - Uses a variant of the Expectation Maximization approach to estimate the true class of verification judgment for semantic segmentation labels based on annotations from individual workers.    arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation     Semantic segmentation adjustment - Treats each pixel in an image as a multi-class classification and treats pixel adjusted annotations from workers as "votes" for the correct label.    arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation     Video Frame Object Detection Adjustment -  Use this task type when you want workers to adjust bounding boxes that workers have added  to video frames to classify and localize objects in a sequence of video frames.    arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection     Video Frame Object Tracking Adjustment -  Use this task type when you want workers to adjust bounding boxes that workers have added  to video frames to track object movement across a sequence of video frames.    arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking     3D point cloud object detection adjustment - Adjust 3D cuboids in a point cloud frame.     arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection     arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection     3D point cloud object tracking adjustment - Adjust 3D cuboids across a sequence of point cloud frames.     arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking     arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking     3D point cloud semantic segmentation adjustment - Adjust semantic segmentation masks in a 3D point cloud.     arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation     arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation
        public let preHumanTaskLambdaArn: String
        /// The price that you pay for each task performed by an Amazon Mechanical Turk worker.
        public let publicWorkforceTaskPrice: PublicWorkforceTaskPrice?
        /// The length of time that a task remains available for labeling by human workers. The default and maximum values for this parameter depend on the type of workforce you use.   If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds). The default is 6 hours (21,600 seconds).   If you choose a private or vendor workforce, the default value is 30 days (2592,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.
        public let taskAvailabilityLifetimeInSeconds: Int?
        /// A description of the task for your human workers.
        public let taskDescription: String
        /// Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.
        public let taskKeywords: [String]?
        /// The amount of time that a worker has to complete a task.  If you create a custom labeling job, the maximum value for this parameter is 8 hours (28,800 seconds). If you create a labeling job using a built-in task type the maximum for this parameter depends on the task type you use:   For image and  text labeling jobs, the maximum is 8 hours (28,800 seconds).   For 3D point cloud and video frame labeling jobs, the maximum is 30 days (2952,000 seconds) for non-AL mode. For most users, the maximum is also 30 days.
        public let taskTimeLimitInSeconds: Int
        /// A title for the task for your human workers.
        public let taskTitle: String
        /// Information about the user interface that workers use to complete the labeling task.
        public let uiConfig: UiConfig
        /// The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.
        public let workteamArn: String

        public init(annotationConsolidationConfig: AnnotationConsolidationConfig, maxConcurrentTaskCount: Int? = nil, numberOfHumanWorkersPerDataObject: Int, preHumanTaskLambdaArn: String, publicWorkforceTaskPrice: PublicWorkforceTaskPrice? = nil, taskAvailabilityLifetimeInSeconds: Int? = nil, taskDescription: String, taskKeywords: [String]? = nil, taskTimeLimitInSeconds: Int, taskTitle: String, uiConfig: UiConfig, workteamArn: String) {
            self.annotationConsolidationConfig = annotationConsolidationConfig
            self.maxConcurrentTaskCount = maxConcurrentTaskCount
            self.numberOfHumanWorkersPerDataObject = numberOfHumanWorkersPerDataObject
            self.preHumanTaskLambdaArn = preHumanTaskLambdaArn
            self.publicWorkforceTaskPrice = publicWorkforceTaskPrice
            self.taskAvailabilityLifetimeInSeconds = taskAvailabilityLifetimeInSeconds
            self.taskDescription = taskDescription
            self.taskKeywords = taskKeywords
            self.taskTimeLimitInSeconds = taskTimeLimitInSeconds
            self.taskTitle = taskTitle
            self.uiConfig = uiConfig
            self.workteamArn = workteamArn
        }

        public func validate(name: String) throws {
            try self.annotationConsolidationConfig.validate(name: "\(name).annotationConsolidationConfig")
            try self.validate(self.maxConcurrentTaskCount, name: "maxConcurrentTaskCount", parent: name, max: 5000)
            try self.validate(self.maxConcurrentTaskCount, name: "maxConcurrentTaskCount", parent: name, min: 1)
            try self.validate(self.numberOfHumanWorkersPerDataObject, name: "numberOfHumanWorkersPerDataObject", parent: name, max: 9)
            try self.validate(self.numberOfHumanWorkersPerDataObject, name: "numberOfHumanWorkersPerDataObject", parent: name, min: 1)
            try self.validate(self.preHumanTaskLambdaArn, name: "preHumanTaskLambdaArn", parent: name, max: 2048)
            try self.validate(self.preHumanTaskLambdaArn, name: "preHumanTaskLambdaArn", parent: name, pattern: "^arn:aws[a-z\\-]*:lambda:[a-z0-9\\-]*:[0-9]{12}:function:")
            try self.publicWorkforceTaskPrice?.validate(name: "\(name).publicWorkforceTaskPrice")
            try self.validate(self.taskAvailabilityLifetimeInSeconds, name: "taskAvailabilityLifetimeInSeconds", parent: name, min: 60)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, max: 255)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, min: 1)
            try self.validate(self.taskDescription, name: "taskDescription", parent: name, pattern: "^.+$")
            try self.taskKeywords?.forEach {
                try validate($0, name: "taskKeywords[]", parent: name, max: 30)
                try validate($0, name: "taskKeywords[]", parent: name, min: 1)
                try validate($0, name: "taskKeywords[]", parent: name, pattern: "^[A-Za-z0-9]+( [A-Za-z0-9]+)*$")
            }
            try self.validate(self.taskKeywords, name: "taskKeywords", parent: name, max: 5)
            try self.validate(self.taskKeywords, name: "taskKeywords", parent: name, min: 1)
            try self.validate(self.taskTimeLimitInSeconds, name: "taskTimeLimitInSeconds", parent: name, min: 30)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, max: 128)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, min: 1)
            try self.validate(self.taskTitle, name: "taskTitle", parent: name, pattern: "^[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]*$")
            try self.uiConfig.validate(name: "\(name).uiConfig")
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, max: 256)
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:workteam/")
        }

        private enum CodingKeys: String, CodingKey {
            case annotationConsolidationConfig = "AnnotationConsolidationConfig"
            case maxConcurrentTaskCount = "MaxConcurrentTaskCount"
            case numberOfHumanWorkersPerDataObject = "NumberOfHumanWorkersPerDataObject"
            case preHumanTaskLambdaArn = "PreHumanTaskLambdaArn"
            case publicWorkforceTaskPrice = "PublicWorkforceTaskPrice"
            case taskAvailabilityLifetimeInSeconds = "TaskAvailabilityLifetimeInSeconds"
            case taskDescription = "TaskDescription"
            case taskKeywords = "TaskKeywords"
            case taskTimeLimitInSeconds = "TaskTimeLimitInSeconds"
            case taskTitle = "TaskTitle"
            case uiConfig = "UiConfig"
            case workteamArn = "WorkteamArn"
        }
    }

    public struct HumanTaskUiSummary: AWSDecodableShape {
        /// A timestamp when SageMaker created the human task user interface.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the human task user interface.
        public let humanTaskUiArn: String
        /// The name of the human task user interface.
        public let humanTaskUiName: String

        public init(creationTime: Date, humanTaskUiArn: String, humanTaskUiName: String) {
            self.creationTime = creationTime
            self.humanTaskUiArn = humanTaskUiArn
            self.humanTaskUiName = humanTaskUiName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case humanTaskUiArn = "HumanTaskUiArn"
            case humanTaskUiName = "HumanTaskUiName"
        }
    }

    public struct HyperParameterAlgorithmSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for TrainingImage.
        public let algorithmName: String?
        /// An array of MetricDefinition objects that specify the metrics that the algorithm emits.
        public let metricDefinitions: [MetricDefinition]?
        ///  The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see Algorithms Provided by Amazon SageMaker: Common Parameters. SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information, see Using Your Own Algorithms with Amazon SageMaker.
        public let trainingImage: String?
        public let trainingInputMode: TrainingInputMode

        public init(algorithmName: String? = nil, metricDefinitions: [MetricDefinition]? = nil, trainingImage: String? = nil, trainingInputMode: TrainingInputMode) {
            self.algorithmName = algorithmName
            self.metricDefinitions = metricDefinitions
            self.trainingImage = trainingImage
            self.trainingInputMode = trainingInputMode
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 170)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
            try self.metricDefinitions?.forEach {
                try $0.validate(name: "\(name).metricDefinitions[]")
            }
            try self.validate(self.metricDefinitions, name: "metricDefinitions", parent: name, max: 40)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, max: 255)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case metricDefinitions = "MetricDefinitions"
            case trainingImage = "TrainingImage"
            case trainingInputMode = "TrainingInputMode"
        }
    }

    public struct HyperParameterSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.
        public let defaultValue: String?
        /// A brief description of the hyperparameter.
        public let description: String?
        /// Indicates whether this hyperparameter is required.
        public let isRequired: Bool?
        /// Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.
        public let isTunable: Bool?
        /// The name of this hyperparameter. The name must be unique.
        public let name: String
        /// The allowed range for this hyperparameter.
        public let range: ParameterRange?
        /// The type of this hyperparameter. The valid types are Integer, Continuous, Categorical, and FreeText.
        public let type: ParameterType

        public init(defaultValue: String? = nil, description: String? = nil, isRequired: Bool? = nil, isTunable: Bool? = nil, name: String, range: ParameterRange? = nil, type: ParameterType) {
            self.defaultValue = defaultValue
            self.description = description
            self.isRequired = isRequired
            self.isTunable = isTunable
            self.name = name
            self.range = range
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 2500)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.range?.validate(name: "\(name).range")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case description = "Description"
            case isRequired = "IsRequired"
            case isTunable = "IsTunable"
            case name = "Name"
            case range = "Range"
            case type = "Type"
        }
    }

    public struct HyperParameterTrainingJobDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The HyperParameterAlgorithmSpecification object that specifies the resource algorithm to use for the training jobs that the tuning job launches.
        public let algorithmSpecification: HyperParameterAlgorithmSpecification
        public let checkpointConfig: CheckpointConfig?
        /// The job definition name.
        public let definitionName: String?
        /// To encrypt all communications between ML compute instances in distributed training, choose True. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.
        public let enableInterContainerTrafficEncryption: Bool?
        /// A Boolean indicating whether managed spot training is enabled (True) or not (False).
        public let enableManagedSpotTraining: Bool?
        /// Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, SageMaker downloads and uploads customer data and model artifacts through the specified VPC, but the training container does not have network access.
        public let enableNetworkIsolation: Bool?
        public let hyperParameterRanges: ParameterRanges?
        /// The configuration for the hyperparameter tuning resources, including the compute instances and storage volumes, used for training jobs launched by the tuning job. By default, storage volumes hold model artifacts and incremental states. Choose File for TrainingInputMode in the AlgorithmSpecification parameter to additionally store training data in the storage volume (optional).
        public let hyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig?
        /// An array of Channel objects that specify the input for the training jobs that the tuning job launches.
        public let inputDataConfig: [Channel]?
        /// Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.
        public let outputDataConfig: OutputDataConfig
        /// The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches. Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want SageMaker to use the storage volume to store the training data, choose File as the TrainingInputMode in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.  If you want to use hyperparameter optimization with instance type flexibility, use HyperParameterTuningResourceConfig instead.
        public let resourceConfig: ResourceConfig?
        /// The number of times to retry the job when the job fails due to an InternalServerError.
        public let retryStrategy: RetryStrategy?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.
        public let roleArn: String
        /// Specifies the values of hyperparameters that do not change for the tuning job.
        public let staticHyperParameters: [String: String]?
        /// Specifies a limit to how long a model hyperparameter training job can run. It also specifies how long a managed spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs.
        public let stoppingCondition: StoppingCondition
        public let tuningObjective: HyperParameterTuningJobObjective?
        /// The VpcConfig object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?

        public init(algorithmSpecification: HyperParameterAlgorithmSpecification, checkpointConfig: CheckpointConfig? = nil, definitionName: String? = nil, enableInterContainerTrafficEncryption: Bool? = nil, enableManagedSpotTraining: Bool? = nil, enableNetworkIsolation: Bool? = nil, hyperParameterRanges: ParameterRanges? = nil, hyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig? = nil, inputDataConfig: [Channel]? = nil, outputDataConfig: OutputDataConfig, resourceConfig: ResourceConfig? = nil, retryStrategy: RetryStrategy? = nil, roleArn: String, staticHyperParameters: [String: String]? = nil, stoppingCondition: StoppingCondition, tuningObjective: HyperParameterTuningJobObjective? = nil, vpcConfig: VpcConfig? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.checkpointConfig = checkpointConfig
            self.definitionName = definitionName
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableManagedSpotTraining = enableManagedSpotTraining
            self.enableNetworkIsolation = enableNetworkIsolation
            self.hyperParameterRanges = hyperParameterRanges
            self.hyperParameterTuningResourceConfig = hyperParameterTuningResourceConfig
            self.inputDataConfig = inputDataConfig
            self.outputDataConfig = outputDataConfig
            self.resourceConfig = resourceConfig
            self.retryStrategy = retryStrategy
            self.roleArn = roleArn
            self.staticHyperParameters = staticHyperParameters
            self.stoppingCondition = stoppingCondition
            self.tuningObjective = tuningObjective
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.algorithmSpecification.validate(name: "\(name).algorithmSpecification")
            try self.checkpointConfig?.validate(name: "\(name).checkpointConfig")
            try self.validate(self.definitionName, name: "definitionName", parent: name, max: 64)
            try self.validate(self.definitionName, name: "definitionName", parent: name, min: 1)
            try self.validate(self.definitionName, name: "definitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.hyperParameterRanges?.validate(name: "\(name).hyperParameterRanges")
            try self.hyperParameterTuningResourceConfig?.validate(name: "\(name).hyperParameterTuningResourceConfig")
            try self.inputDataConfig?.forEach {
                try $0.validate(name: "\(name).inputDataConfig[]")
            }
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, max: 20)
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, min: 1)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.resourceConfig?.validate(name: "\(name).resourceConfig")
            try self.retryStrategy?.validate(name: "\(name).retryStrategy")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.staticHyperParameters?.forEach {
                try validate($0.key, name: "staticHyperParameters.key", parent: name, max: 256)
                try validate($0.key, name: "staticHyperParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "staticHyperParameters[\"\($0.key)\"]", parent: name, max: 2500)
                try validate($0.value, name: "staticHyperParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.staticHyperParameters, name: "staticHyperParameters", parent: name, max: 100)
            try self.stoppingCondition.validate(name: "\(name).stoppingCondition")
            try self.tuningObjective?.validate(name: "\(name).tuningObjective")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "AlgorithmSpecification"
            case checkpointConfig = "CheckpointConfig"
            case definitionName = "DefinitionName"
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableManagedSpotTraining = "EnableManagedSpotTraining"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case hyperParameterRanges = "HyperParameterRanges"
            case hyperParameterTuningResourceConfig = "HyperParameterTuningResourceConfig"
            case inputDataConfig = "InputDataConfig"
            case outputDataConfig = "OutputDataConfig"
            case resourceConfig = "ResourceConfig"
            case retryStrategy = "RetryStrategy"
            case roleArn = "RoleArn"
            case staticHyperParameters = "StaticHyperParameters"
            case stoppingCondition = "StoppingCondition"
            case tuningObjective = "TuningObjective"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct HyperParameterTrainingJobSummary: AWSDecodableShape {
        /// The date and time that the training job was created.
        public let creationTime: Date
        /// The reason that the training job failed.
        public let failureReason: String?
        /// The FinalHyperParameterTuningJobObjectiveMetric object that specifies the value of the objective metric of the tuning job that launched this training job.
        public let finalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric?
        /// The status of the objective metric for the training job:   Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.     Pending: The training job is in progress and evaluation of its final objective metric is pending.     Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.
        public let objectiveStatus: ObjectiveStatus?
        /// Specifies the time when the training job ends on training instances. You are billed for the time interval between the value of TrainingStartTime and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.
        public let trainingEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        /// The training job definition name.
        public let trainingJobDefinitionName: String?
        /// The name of the training job.
        public let trainingJobName: String
        /// The status of the training job.
        public let trainingJobStatus: TrainingJobStatus
        /// The date and time that the training job started.
        public let trainingStartTime: Date?
        /// A list of the hyperparameters for which you specified ranges to search.
        public let tunedHyperParameters: [String: String]
        /// The HyperParameter tuning job that launched the training job.
        public let tuningJobName: String?

        public init(creationTime: Date, failureReason: String? = nil, finalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric? = nil, objectiveStatus: ObjectiveStatus? = nil, trainingEndTime: Date? = nil, trainingJobArn: String, trainingJobDefinitionName: String? = nil, trainingJobName: String, trainingJobStatus: TrainingJobStatus, trainingStartTime: Date? = nil, tunedHyperParameters: [String: String], tuningJobName: String? = nil) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.finalHyperParameterTuningJobObjectiveMetric = finalHyperParameterTuningJobObjectiveMetric
            self.objectiveStatus = objectiveStatus
            self.trainingEndTime = trainingEndTime
            self.trainingJobArn = trainingJobArn
            self.trainingJobDefinitionName = trainingJobDefinitionName
            self.trainingJobName = trainingJobName
            self.trainingJobStatus = trainingJobStatus
            self.trainingStartTime = trainingStartTime
            self.tunedHyperParameters = tunedHyperParameters
            self.tuningJobName = tuningJobName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case finalHyperParameterTuningJobObjectiveMetric = "FinalHyperParameterTuningJobObjectiveMetric"
            case objectiveStatus = "ObjectiveStatus"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobArn = "TrainingJobArn"
            case trainingJobDefinitionName = "TrainingJobDefinitionName"
            case trainingJobName = "TrainingJobName"
            case trainingJobStatus = "TrainingJobStatus"
            case trainingStartTime = "TrainingStartTime"
            case tunedHyperParameters = "TunedHyperParameters"
            case tuningJobName = "TuningJobName"
        }
    }

    public struct HyperParameterTuningInstanceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances of the type specified by InstanceType. Choose an instance count larger than 1 for distributed training algorithms. See SageMaker distributed training jobs for more informcration.
        public let instanceCount: Int
        /// The instance type used for processing of hyperparameter optimization jobs. Choose from general purpose (no GPUs) instance types: ml.m5.xlarge, ml.m5.2xlarge, and ml.m5.4xlarge or compute optimized (no GPUs) instance types: ml.c5.xlarge and ml.c5.2xlarge. For more information about instance types, see instance type descriptions.
        public let instanceType: TrainingInstanceType
        /// The volume size in GB of the data to be processed for hyperparameter optimization (optional).
        public let volumeSizeInGB: Int

        public init(instanceCount: Int, instanceType: TrainingInstanceType, volumeSizeInGB: Int) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 0)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct HyperParameterTuningJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// The HyperParameterTuningJobObjective specifies the objective metric used to evaluate the performance of training jobs launched by this tuning job.
        public let hyperParameterTuningJobObjective: HyperParameterTuningJobObjective?
        /// The ParameterRanges object that specifies the ranges of hyperparameters that this tuning job searches over to find the optimal configuration for the highest model performance against your chosen objective metric.
        public let parameterRanges: ParameterRanges?
        /// A value used to initialize a pseudo-random number generator. Setting a random seed and using the same seed later for the same tuning job will allow hyperparameter optimization to find more a consistent hyperparameter configuration between the two runs.
        public let randomSeed: Int?
        /// The ResourceLimits object that specifies the maximum number of training and parallel training jobs that can be used for this hyperparameter tuning job.
        public let resourceLimits: ResourceLimits
        /// Specifies how hyperparameter tuning chooses the combinations of hyperparameter values to use for the training job it launches. For information about search strategies, see How Hyperparameter Tuning Works.
        public let strategy: HyperParameterTuningJobStrategyType
        /// The configuration for the Hyperband optimization strategy. This parameter should be provided only if Hyperband is selected as the strategy for HyperParameterTuningJobConfig.
        public let strategyConfig: HyperParameterTuningJobStrategyConfig?
        /// Specifies whether to use early stopping for training jobs launched by the hyperparameter tuning job. Because the Hyperband strategy has its own advanced internal early stopping mechanism, TrainingJobEarlyStoppingType must be OFF to use Hyperband. This parameter can take on one of the following values (the default value is OFF):  OFF  Training jobs launched by the hyperparameter tuning job do not use early stopping.  AUTO  SageMaker stops training jobs launched by the hyperparameter tuning job when they are unlikely to perform better than previously completed training jobs. For more information, see Stop Training Jobs Early.
        public let trainingJobEarlyStoppingType: TrainingJobEarlyStoppingType?
        /// The tuning job's completion criteria.
        public let tuningJobCompletionCriteria: TuningJobCompletionCriteria?

        public init(hyperParameterTuningJobObjective: HyperParameterTuningJobObjective? = nil, parameterRanges: ParameterRanges? = nil, randomSeed: Int? = nil, resourceLimits: ResourceLimits, strategy: HyperParameterTuningJobStrategyType, strategyConfig: HyperParameterTuningJobStrategyConfig? = nil, trainingJobEarlyStoppingType: TrainingJobEarlyStoppingType? = nil, tuningJobCompletionCriteria: TuningJobCompletionCriteria? = nil) {
            self.hyperParameterTuningJobObjective = hyperParameterTuningJobObjective
            self.parameterRanges = parameterRanges
            self.randomSeed = randomSeed
            self.resourceLimits = resourceLimits
            self.strategy = strategy
            self.strategyConfig = strategyConfig
            self.trainingJobEarlyStoppingType = trainingJobEarlyStoppingType
            self.tuningJobCompletionCriteria = tuningJobCompletionCriteria
        }

        public func validate(name: String) throws {
            try self.hyperParameterTuningJobObjective?.validate(name: "\(name).hyperParameterTuningJobObjective")
            try self.parameterRanges?.validate(name: "\(name).parameterRanges")
            try self.validate(self.randomSeed, name: "randomSeed", parent: name, min: 0)
            try self.resourceLimits.validate(name: "\(name).resourceLimits")
            try self.strategyConfig?.validate(name: "\(name).strategyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobObjective = "HyperParameterTuningJobObjective"
            case parameterRanges = "ParameterRanges"
            case randomSeed = "RandomSeed"
            case resourceLimits = "ResourceLimits"
            case strategy = "Strategy"
            case strategyConfig = "StrategyConfig"
            case trainingJobEarlyStoppingType = "TrainingJobEarlyStoppingType"
            case tuningJobCompletionCriteria = "TuningJobCompletionCriteria"
        }
    }

    public struct HyperParameterTuningJobObjective: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric to use for the objective metric.
        public let metricName: String
        /// Whether to minimize or maximize the objective metric.
        public let type: HyperParameterTuningJobObjectiveType

        public init(metricName: String, type: HyperParameterTuningJobObjectiveType) {
            self.metricName = metricName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 255)
            try self.validate(self.metricName, name: "metricName", parent: name, min: 1)
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case type = "Type"
        }
    }

    public struct HyperParameterTuningJobSearchEntity: AWSDecodableShape {
        public let bestTrainingJob: HyperParameterTrainingJobSummary?
        /// The time that a hyperparameter tuning job was created.
        public let creationTime: Date?
        /// The error that was created when a hyperparameter tuning job failed.
        public let failureReason: String?
        /// The time that a hyperparameter tuning job ended.
        public let hyperParameterTuningEndTime: Date?
        /// The Amazon Resource Name (ARN) of a hyperparameter tuning job.
        public let hyperParameterTuningJobArn: String?
        public let hyperParameterTuningJobConfig: HyperParameterTuningJobConfig?
        /// The name of a hyperparameter tuning job.
        public let hyperParameterTuningJobName: String?
        /// The status of a hyperparameter tuning job.
        public let hyperParameterTuningJobStatus: HyperParameterTuningJobStatus?
        /// The time that a hyperparameter tuning job was last modified.
        public let lastModifiedTime: Date?
        public let objectiveStatusCounters: ObjectiveStatusCounters?
        public let overallBestTrainingJob: HyperParameterTrainingJobSummary?
        /// The tags associated with a hyperparameter tuning job. For more information see Tagging Amazon Web Services resources.
        public let tags: [Tag]?
        public let trainingJobDefinition: HyperParameterTrainingJobDefinition?
        /// The job definitions included in a hyperparameter tuning job.
        public let trainingJobDefinitions: [HyperParameterTrainingJobDefinition]?
        public let trainingJobStatusCounters: TrainingJobStatusCounters?
        public let warmStartConfig: HyperParameterTuningJobWarmStartConfig?

        public init(bestTrainingJob: HyperParameterTrainingJobSummary? = nil, creationTime: Date? = nil, failureReason: String? = nil, hyperParameterTuningEndTime: Date? = nil, hyperParameterTuningJobArn: String? = nil, hyperParameterTuningJobConfig: HyperParameterTuningJobConfig? = nil, hyperParameterTuningJobName: String? = nil, hyperParameterTuningJobStatus: HyperParameterTuningJobStatus? = nil, lastModifiedTime: Date? = nil, objectiveStatusCounters: ObjectiveStatusCounters? = nil, overallBestTrainingJob: HyperParameterTrainingJobSummary? = nil, tags: [Tag]? = nil, trainingJobDefinition: HyperParameterTrainingJobDefinition? = nil, trainingJobDefinitions: [HyperParameterTrainingJobDefinition]? = nil, trainingJobStatusCounters: TrainingJobStatusCounters? = nil, warmStartConfig: HyperParameterTuningJobWarmStartConfig? = nil) {
            self.bestTrainingJob = bestTrainingJob
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.hyperParameterTuningEndTime = hyperParameterTuningEndTime
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
            self.hyperParameterTuningJobConfig = hyperParameterTuningJobConfig
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.hyperParameterTuningJobStatus = hyperParameterTuningJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.objectiveStatusCounters = objectiveStatusCounters
            self.overallBestTrainingJob = overallBestTrainingJob
            self.tags = tags
            self.trainingJobDefinition = trainingJobDefinition
            self.trainingJobDefinitions = trainingJobDefinitions
            self.trainingJobStatusCounters = trainingJobStatusCounters
            self.warmStartConfig = warmStartConfig
        }

        private enum CodingKeys: String, CodingKey {
            case bestTrainingJob = "BestTrainingJob"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case hyperParameterTuningEndTime = "HyperParameterTuningEndTime"
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
            case hyperParameterTuningJobConfig = "HyperParameterTuningJobConfig"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case hyperParameterTuningJobStatus = "HyperParameterTuningJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case objectiveStatusCounters = "ObjectiveStatusCounters"
            case overallBestTrainingJob = "OverallBestTrainingJob"
            case tags = "Tags"
            case trainingJobDefinition = "TrainingJobDefinition"
            case trainingJobDefinitions = "TrainingJobDefinitions"
            case trainingJobStatusCounters = "TrainingJobStatusCounters"
            case warmStartConfig = "WarmStartConfig"
        }
    }

    public struct HyperParameterTuningJobStrategyConfig: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the object that specifies the Hyperband strategy. This parameter is only supported for the Hyperband selection for Strategy within the HyperParameterTuningJobConfig API.
        public let hyperbandStrategyConfig: HyperbandStrategyConfig?

        public init(hyperbandStrategyConfig: HyperbandStrategyConfig? = nil) {
            self.hyperbandStrategyConfig = hyperbandStrategyConfig
        }

        public func validate(name: String) throws {
            try self.hyperbandStrategyConfig?.validate(name: "\(name).hyperbandStrategyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperbandStrategyConfig = "HyperbandStrategyConfig"
        }
    }

    public struct HyperParameterTuningJobSummary: AWSDecodableShape {
        /// The date and time that the tuning job was created.
        public let creationTime: Date
        /// The date and time that the tuning job ended.
        public let hyperParameterTuningEndTime: Date?
        /// The Amazon Resource Name (ARN) of the tuning job.
        public let hyperParameterTuningJobArn: String
        /// The name of the tuning job.
        public let hyperParameterTuningJobName: String
        /// The status of the tuning job.
        public let hyperParameterTuningJobStatus: HyperParameterTuningJobStatus
        /// The date and time that the tuning job was modified.
        public let lastModifiedTime: Date?
        /// The ObjectiveStatusCounters object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.
        public let objectiveStatusCounters: ObjectiveStatusCounters
        /// The ResourceLimits object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.
        public let resourceLimits: ResourceLimits?
        /// Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to evaluate at each iteration.
        public let strategy: HyperParameterTuningJobStrategyType
        /// The TrainingJobStatusCounters object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.
        public let trainingJobStatusCounters: TrainingJobStatusCounters

        public init(creationTime: Date, hyperParameterTuningEndTime: Date? = nil, hyperParameterTuningJobArn: String, hyperParameterTuningJobName: String, hyperParameterTuningJobStatus: HyperParameterTuningJobStatus, lastModifiedTime: Date? = nil, objectiveStatusCounters: ObjectiveStatusCounters, resourceLimits: ResourceLimits? = nil, strategy: HyperParameterTuningJobStrategyType, trainingJobStatusCounters: TrainingJobStatusCounters) {
            self.creationTime = creationTime
            self.hyperParameterTuningEndTime = hyperParameterTuningEndTime
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.hyperParameterTuningJobStatus = hyperParameterTuningJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.objectiveStatusCounters = objectiveStatusCounters
            self.resourceLimits = resourceLimits
            self.strategy = strategy
            self.trainingJobStatusCounters = trainingJobStatusCounters
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case hyperParameterTuningEndTime = "HyperParameterTuningEndTime"
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case hyperParameterTuningJobStatus = "HyperParameterTuningJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case objectiveStatusCounters = "ObjectiveStatusCounters"
            case resourceLimits = "ResourceLimits"
            case strategy = "Strategy"
            case trainingJobStatusCounters = "TrainingJobStatusCounters"
        }
    }

    public struct HyperParameterTuningJobWarmStartConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see Using a Previous Hyperparameter Tuning Job as a Starting Point. Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.
        public let parentHyperParameterTuningJobs: [ParentHyperParameterTuningJob]
        /// Specifies one of the following:  IDENTICAL_DATA_AND_ALGORITHM  The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.  TRANSFER_LEARNING  The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.
        public let warmStartType: HyperParameterTuningJobWarmStartType

        public init(parentHyperParameterTuningJobs: [ParentHyperParameterTuningJob], warmStartType: HyperParameterTuningJobWarmStartType) {
            self.parentHyperParameterTuningJobs = parentHyperParameterTuningJobs
            self.warmStartType = warmStartType
        }

        public func validate(name: String) throws {
            try self.parentHyperParameterTuningJobs.forEach {
                try $0.validate(name: "\(name).parentHyperParameterTuningJobs[]")
            }
            try self.validate(self.parentHyperParameterTuningJobs, name: "parentHyperParameterTuningJobs", parent: name, max: 5)
            try self.validate(self.parentHyperParameterTuningJobs, name: "parentHyperParameterTuningJobs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parentHyperParameterTuningJobs = "ParentHyperParameterTuningJobs"
            case warmStartType = "WarmStartType"
        }
    }

    public struct HyperParameterTuningResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The strategy that determines the order of preference for resources specified in InstanceConfigs used in hyperparameter optimization.
        public let allocationStrategy: HyperParameterTuningAllocationStrategy?
        /// A list containing the configuration(s) for one or more resources for processing hyperparameter jobs. These resources include compute instances and storage volumes to use in model training jobs launched by hyperparameter tuning jobs. The AllocationStrategy controls the order in which multiple configurations provided in InstanceConfigs are used.  If you only want to use a single instance configuration inside the HyperParameterTuningResourceConfig API, do not provide a value for InstanceConfigs. Instead, use InstanceType, VolumeSizeInGB and InstanceCount. If you use InstanceConfigs, do not provide values for InstanceType, VolumeSizeInGB or InstanceCount.
        public let instanceConfigs: [HyperParameterTuningInstanceConfig]?
        /// The number of compute instances of type InstanceType to use. For distributed training, select a value greater than 1.
        public let instanceCount: Int?
        /// The instance type used to run hyperparameter optimization tuning jobs. See  descriptions of instance types for more information.
        public let instanceType: TrainingInstanceType?
        /// A key used by Amazon Web Services Key Management Service to encrypt data on the storage volume attached to the compute instances used to run the training job. You can use either of the following formats to specify a key. KMS Key ID:  "1234abcd-12ab-34cd-56ef-1234567890ab"  Amazon Resource Name (ARN) of a KMS key:  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"  Some instances use local storage, which use a hardware module to encrypt storage volumes. If you choose one of these instance types, you cannot request a VolumeKmsKeyId. For a list of instance types that use local storage, see instance store volumes. For more information about Amazon Web Services Key Management Service, see KMS encryption for more information.
        public let volumeKmsKeyId: String?
        /// The volume size in GB for the storage volume to be used in processing hyperparameter optimization jobs (optional). These volumes store model artifacts, incremental states and optionally, scratch space for training algorithms. Do not provide a value for this parameter if a value for InstanceConfigs is also specified. Some instance types have a fixed total local storage size. If you select one of these instances for training, VolumeSizeInGB cannot be greater than this total size. For a list of instance types with local instance storage and their sizes, see instance store volumes.  SageMaker supports only the General Purpose SSD (gp2) storage volume type.
        public let volumeSizeInGB: Int?

        public init(allocationStrategy: HyperParameterTuningAllocationStrategy? = nil, instanceConfigs: [HyperParameterTuningInstanceConfig]? = nil, instanceCount: Int? = nil, instanceType: TrainingInstanceType? = nil, volumeKmsKeyId: String? = nil, volumeSizeInGB: Int? = nil) {
            self.allocationStrategy = allocationStrategy
            self.instanceConfigs = instanceConfigs
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeKmsKeyId = volumeKmsKeyId
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.instanceConfigs?.forEach {
                try $0.validate(name: "\(name).instanceConfigs[]")
            }
            try self.validate(self.instanceConfigs, name: "instanceConfigs", parent: name, max: 6)
            try self.validate(self.instanceConfigs, name: "instanceConfigs", parent: name, min: 1)
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 0)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case allocationStrategy = "AllocationStrategy"
            case instanceConfigs = "InstanceConfigs"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct HyperbandStrategyConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of resources (such as epochs) that can be used by a training job launched by a hyperparameter tuning job. Once a job reaches the MaxResource value, it is stopped. If a value for MaxResource is not provided, and Hyperband is selected as the hyperparameter tuning strategy, HyperbandTrainingJ attempts to infer MaxResource from the following keys (if present) in StaticsHyperParameters:    epochs     numepochs     n-epochs     n_epochs     num_epochs    If HyperbandStrategyConfig is unable to infer a value for MaxResource, it generates a validation error. The maximum value is 20,000 epochs. All metrics that correspond to an objective metric are used to derive early stopping decisions. For distributive training jobs, ensure that duplicate metrics are not printed in the logs across the individual nodes in a training job. If multiple nodes are publishing duplicate or incorrect metrics, training jobs may make an incorrect stopping decision and stop the job prematurely.
        public let maxResource: Int?
        /// The minimum number of resources (such as epochs) that can be used by a training job launched by a hyperparameter tuning job. If the value for MinResource has not been reached, the training job will not be stopped by Hyperband.
        public let minResource: Int?

        public init(maxResource: Int? = nil, minResource: Int? = nil) {
            self.maxResource = maxResource
            self.minResource = minResource
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResource, name: "maxResource", parent: name, min: 1)
            try self.validate(self.minResource, name: "minResource", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResource = "MaxResource"
            case minResource = "MinResource"
        }
    }

    public struct Image: AWSDecodableShape {
        /// When the image was created.
        public let creationTime: Date
        /// The description of the image.
        public let description: String?
        /// The name of the image as displayed.
        public let displayName: String?
        /// When a create, update, or delete operation fails, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the image.
        public let imageArn: String
        /// The name of the image.
        public let imageName: String
        /// The status of the image.
        public let imageStatus: ImageStatus
        /// When the image was last modified.
        public let lastModifiedTime: Date

        public init(creationTime: Date, description: String? = nil, displayName: String? = nil, failureReason: String? = nil, imageArn: String, imageName: String, imageStatus: ImageStatus, lastModifiedTime: Date) {
            self.creationTime = creationTime
            self.description = description
            self.displayName = displayName
            self.failureReason = failureReason
            self.imageArn = imageArn
            self.imageName = imageName
            self.imageStatus = imageStatus
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case displayName = "DisplayName"
            case failureReason = "FailureReason"
            case imageArn = "ImageArn"
            case imageName = "ImageName"
            case imageStatus = "ImageStatus"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct ImageConfig: AWSEncodableShape & AWSDecodableShape {
        /// Set this to one of the following values:    Platform - The model image is hosted in Amazon ECR.    Vpc - The model image is hosted in a private Docker registry in your VPC.
        public let repositoryAccessMode: RepositoryAccessMode
        /// (Optional) Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication.
        public let repositoryAuthConfig: RepositoryAuthConfig?

        public init(repositoryAccessMode: RepositoryAccessMode, repositoryAuthConfig: RepositoryAuthConfig? = nil) {
            self.repositoryAccessMode = repositoryAccessMode
            self.repositoryAuthConfig = repositoryAuthConfig
        }

        public func validate(name: String) throws {
            try self.repositoryAuthConfig?.validate(name: "\(name).repositoryAuthConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryAccessMode = "RepositoryAccessMode"
            case repositoryAuthConfig = "RepositoryAuthConfig"
        }
    }

    public struct ImageVersion: AWSDecodableShape {
        /// When the version was created.
        public let creationTime: Date
        /// When a create or delete operation fails, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the image the version is based on.
        public let imageArn: String
        /// The ARN of the version.
        public let imageVersionArn: String
        /// The status of the version.
        public let imageVersionStatus: ImageVersionStatus
        /// When the version was last modified.
        public let lastModifiedTime: Date
        /// The version number.
        public let version: Int

        public init(creationTime: Date, failureReason: String? = nil, imageArn: String, imageVersionArn: String, imageVersionStatus: ImageVersionStatus, lastModifiedTime: Date, version: Int) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.imageArn = imageArn
            self.imageVersionArn = imageVersionArn
            self.imageVersionStatus = imageVersionStatus
            self.lastModifiedTime = lastModifiedTime
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case imageArn = "ImageArn"
            case imageVersionArn = "ImageVersionArn"
            case imageVersionStatus = "ImageVersionStatus"
            case lastModifiedTime = "LastModifiedTime"
            case version = "Version"
        }
    }

    public struct ImportHubContentRequest: AWSEncodableShape {
        /// The version of the hub content schema to import.
        public let documentSchemaVersion: String
        /// A description of the hub content to import.
        public let hubContentDescription: String?
        /// The display name of the hub content to import.
        public let hubContentDisplayName: String?
        /// The hub content document that describes information about the hub content such as type, associated containers, scripts, and more.
        public let hubContentDocument: String
        /// Markdown files associated with the hub content to import.
        public let hubContentMarkdown: String?
        /// The name of the hub content to import.
        public let hubContentName: String
        /// The searchable keywords of the hub content.
        public let hubContentSearchKeywords: [String]?
        /// The type of hub content to import.
        public let hubContentType: HubContentType
        /// The version of the hub content to import.
        public let hubContentVersion: String?
        /// The name of the hub to import content into.
        public let hubName: String
        /// Any tags associated with the hub content.
        public let tags: [Tag]?

        public init(documentSchemaVersion: String, hubContentDescription: String? = nil, hubContentDisplayName: String? = nil, hubContentDocument: String, hubContentMarkdown: String? = nil, hubContentName: String, hubContentSearchKeywords: [String]? = nil, hubContentType: HubContentType, hubContentVersion: String? = nil, hubName: String, tags: [Tag]? = nil) {
            self.documentSchemaVersion = documentSchemaVersion
            self.hubContentDescription = hubContentDescription
            self.hubContentDisplayName = hubContentDisplayName
            self.hubContentDocument = hubContentDocument
            self.hubContentMarkdown = hubContentMarkdown
            self.hubContentName = hubContentName
            self.hubContentSearchKeywords = hubContentSearchKeywords
            self.hubContentType = hubContentType
            self.hubContentVersion = hubContentVersion
            self.hubName = hubName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.documentSchemaVersion, name: "documentSchemaVersion", parent: name, max: 14)
            try self.validate(self.documentSchemaVersion, name: "documentSchemaVersion", parent: name, min: 5)
            try self.validate(self.documentSchemaVersion, name: "documentSchemaVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.hubContentDescription, name: "hubContentDescription", parent: name, max: 1023)
            try self.validate(self.hubContentDescription, name: "hubContentDescription", parent: name, pattern: ".*")
            try self.validate(self.hubContentDisplayName, name: "hubContentDisplayName", parent: name, max: 255)
            try self.validate(self.hubContentDisplayName, name: "hubContentDisplayName", parent: name, pattern: ".*")
            try self.validate(self.hubContentDocument, name: "hubContentDocument", parent: name, max: 65535)
            try self.validate(self.hubContentDocument, name: "hubContentDocument", parent: name, pattern: ".*")
            try self.validate(self.hubContentMarkdown, name: "hubContentMarkdown", parent: name, max: 65535)
            try self.validate(self.hubContentMarkdown, name: "hubContentMarkdown", parent: name, pattern: ".*")
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, max: 63)
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.hubContentSearchKeywords?.forEach {
                try validate($0, name: "hubContentSearchKeywords[]", parent: name, max: 255)
                try validate($0, name: "hubContentSearchKeywords[]", parent: name, pattern: "^[^A-Z]*$")
            }
            try self.validate(self.hubContentSearchKeywords, name: "hubContentSearchKeywords", parent: name, max: 50)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, max: 14)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, min: 5)
            try self.validate(self.hubContentVersion, name: "hubContentVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case documentSchemaVersion = "DocumentSchemaVersion"
            case hubContentDescription = "HubContentDescription"
            case hubContentDisplayName = "HubContentDisplayName"
            case hubContentDocument = "HubContentDocument"
            case hubContentMarkdown = "HubContentMarkdown"
            case hubContentName = "HubContentName"
            case hubContentSearchKeywords = "HubContentSearchKeywords"
            case hubContentType = "HubContentType"
            case hubContentVersion = "HubContentVersion"
            case hubName = "HubName"
            case tags = "Tags"
        }
    }

    public struct ImportHubContentResponse: AWSDecodableShape {
        /// The ARN of the hub that the content was imported into.
        public let hubArn: String
        /// The ARN of the hub content that was imported.
        public let hubContentArn: String

        public init(hubArn: String, hubContentArn: String) {
            self.hubArn = hubArn
            self.hubContentArn = hubContentArn
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
            case hubContentArn = "HubContentArn"
        }
    }

    public struct InferenceExecutionConfig: AWSEncodableShape & AWSDecodableShape {
        /// How containers in a multi-container are run. The following values are valid.    SERIAL - Containers run as a serial pipeline.    DIRECT - Only the individual container that you specify is run.
        public let mode: InferenceExecutionMode

        public init(mode: InferenceExecutionMode) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct InferenceExperimentDataStorageConfig: AWSEncodableShape & AWSDecodableShape {
        public let contentType: CaptureContentTypeHeader?
        /// The Amazon S3 bucket where the inference request and response data is stored.
        public let destination: String
        ///  The Amazon Web Services Key Management Service key that Amazon SageMaker uses to encrypt captured data at rest using Amazon S3 server-side encryption.
        public let kmsKey: String?

        public init(contentType: CaptureContentTypeHeader? = nil, destination: String, kmsKey: String? = nil) {
            self.contentType = contentType
            self.destination = destination
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.contentType?.validate(name: "\(name).contentType")
            try self.validate(self.destination, name: "destination", parent: name, max: 512)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^(https|s3)://([^/])/?(.*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case destination = "Destination"
            case kmsKey = "KmsKey"
        }
    }

    public struct InferenceExperimentSchedule: AWSEncodableShape & AWSDecodableShape {
        /// The timestamp at which the inference experiment ended or will end.
        public let endTime: Date?
        /// The timestamp at which the inference experiment started or will start.
        public let startTime: Date?

        public init(endTime: Date? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct InferenceExperimentSummary: AWSDecodableShape {
        /// The timestamp at which the inference experiment was completed.
        public let completionTime: Date?
        /// The timestamp at which the inference experiment was created.
        public let creationTime: Date
        /// The description of the inference experiment.
        public let description: String?
        /// The timestamp when you last modified the inference experiment.
        public let lastModifiedTime: Date
        /// The name of the inference experiment.
        public let name: String
        ///  The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and container images, and manage Amazon SageMaker Inference endpoints for model deployment.
        public let roleArn: String?
        /// The duration for which the inference experiment ran or will run. The maximum duration that you can set for an inference experiment is 30 days.
        public let schedule: InferenceExperimentSchedule?
        /// The status of the inference experiment.
        public let status: InferenceExperimentStatus
        /// The error message for the inference experiment status result.
        public let statusReason: String?
        /// The type of the inference experiment.
        public let type: InferenceExperimentType

        public init(completionTime: Date? = nil, creationTime: Date, description: String? = nil, lastModifiedTime: Date, name: String, roleArn: String? = nil, schedule: InferenceExperimentSchedule? = nil, status: InferenceExperimentStatus, statusReason: String? = nil, type: InferenceExperimentType) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.roleArn = roleArn
            self.schedule = schedule
            self.status = status
            self.statusReason = statusReason
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case roleArn = "RoleArn"
            case schedule = "Schedule"
            case status = "Status"
            case statusReason = "StatusReason"
            case type = "Type"
        }
    }

    public struct InferenceMetrics: AWSDecodableShape {
        /// The expected maximum number of requests per minute for the instance.
        public let maxInvocations: Int
        /// The expected model latency at maximum invocations per minute for the instance.
        public let modelLatency: Int

        public init(maxInvocations: Int, modelLatency: Int) {
            self.maxInvocations = maxInvocations
            self.modelLatency = modelLatency
        }

        private enum CodingKeys: String, CodingKey {
            case maxInvocations = "MaxInvocations"
            case modelLatency = "ModelLatency"
        }
    }

    public struct InferenceRecommendation: AWSDecodableShape {
        /// Defines the endpoint configuration parameters.
        public let endpointConfiguration: EndpointOutputConfiguration
        /// The metrics used to decide what recommendation to make.
        public let metrics: RecommendationMetrics
        /// Defines the model configuration.
        public let modelConfiguration: ModelConfiguration

        public init(endpointConfiguration: EndpointOutputConfiguration, metrics: RecommendationMetrics, modelConfiguration: ModelConfiguration) {
            self.endpointConfiguration = endpointConfiguration
            self.metrics = metrics
            self.modelConfiguration = modelConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfiguration = "EndpointConfiguration"
            case metrics = "Metrics"
            case modelConfiguration = "ModelConfiguration"
        }
    }

    public struct InferenceRecommendationsJob: AWSDecodableShape {
        /// A timestamp that shows when the job completed.
        public let completionTime: Date?
        /// A timestamp that shows when the job was created.
        public let creationTime: Date
        /// If the job fails, provides information why the job failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the recommendation job.
        public let jobArn: String
        /// The job description.
        public let jobDescription: String
        /// The name of the job.
        public let jobName: String
        /// The recommendation job type.
        public let jobType: RecommendationJobType
        /// A timestamp that shows when the job was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker  to perform tasks on your behalf.
        public let roleArn: String
        /// The status of the job.
        public let status: RecommendationJobStatus

        public init(completionTime: Date? = nil, creationTime: Date, failureReason: String? = nil, jobArn: String, jobDescription: String, jobName: String, jobType: RecommendationJobType, lastModifiedTime: Date, roleArn: String, status: RecommendationJobStatus) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.jobArn = jobArn
            self.jobDescription = jobDescription
            self.jobName = jobName
            self.jobType = jobType
            self.lastModifiedTime = lastModifiedTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case jobArn = "JobArn"
            case jobDescription = "JobDescription"
            case jobName = "JobName"
            case jobType = "JobType"
            case lastModifiedTime = "LastModifiedTime"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct InferenceRecommendationsJobStep: AWSDecodableShape {
        /// The details for a specific benchmark.
        public let inferenceBenchmark: RecommendationJobInferenceBenchmark?
        /// The name of the Inference Recommender job.
        public let jobName: String
        /// The current status of the benchmark.
        public let status: RecommendationJobStatus
        /// The type of the subtask.  BENCHMARK: Evaluate the performance of your model on different instance types.
        public let stepType: RecommendationStepType

        public init(inferenceBenchmark: RecommendationJobInferenceBenchmark? = nil, jobName: String, status: RecommendationJobStatus, stepType: RecommendationStepType) {
            self.inferenceBenchmark = inferenceBenchmark
            self.jobName = jobName
            self.status = status
            self.stepType = stepType
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceBenchmark = "InferenceBenchmark"
            case jobName = "JobName"
            case status = "Status"
            case stepType = "StepType"
        }
    }

    public struct InferenceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon ECR registry path of the Docker image that contains the inference code.
        public let containers: [ModelPackageContainerDefinition]
        /// The supported MIME types for the input data.
        public let supportedContentTypes: [String]
        /// A list of the instance types that are used to generate inferences in real-time. This parameter is required for unversioned models, and optional for versioned models.
        public let supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType]?
        /// The supported MIME types for the output data.
        public let supportedResponseMIMETypes: [String]
        /// A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed. This parameter is required for unversioned models, and optional for versioned models.
        public let supportedTransformInstanceTypes: [TransformInstanceType]?

        public init(containers: [ModelPackageContainerDefinition], supportedContentTypes: [String], supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType]? = nil, supportedResponseMIMETypes: [String], supportedTransformInstanceTypes: [TransformInstanceType]? = nil) {
            self.containers = containers
            self.supportedContentTypes = supportedContentTypes
            self.supportedRealtimeInferenceInstanceTypes = supportedRealtimeInferenceInstanceTypes
            self.supportedResponseMIMETypes = supportedResponseMIMETypes
            self.supportedTransformInstanceTypes = supportedTransformInstanceTypes
        }

        public func validate(name: String) throws {
            try self.containers.forEach {
                try $0.validate(name: "\(name).containers[]")
            }
            try self.validate(self.containers, name: "containers", parent: name, max: 15)
            try self.validate(self.containers, name: "containers", parent: name, min: 1)
            try self.supportedContentTypes.forEach {
                try validate($0, name: "supportedContentTypes[]", parent: name, max: 256)
                try validate($0, name: "supportedContentTypes[]", parent: name, pattern: ".*")
            }
            try self.supportedResponseMIMETypes.forEach {
                try validate($0, name: "supportedResponseMIMETypes[]", parent: name, max: 1024)
                try validate($0, name: "supportedResponseMIMETypes[]", parent: name, pattern: "^[-\\w]+\\/.+$")
            }
            try self.validate(self.supportedTransformInstanceTypes, name: "supportedTransformInstanceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case supportedContentTypes = "SupportedContentTypes"
            case supportedRealtimeInferenceInstanceTypes = "SupportedRealtimeInferenceInstanceTypes"
            case supportedResponseMIMETypes = "SupportedResponseMIMETypes"
            case supportedTransformInstanceTypes = "SupportedTransformInstanceTypes"
        }
    }

    public struct InputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are InputConfig$Framework specific.     TensorFlow: You must specify the name and shape (NHWC format) of the expected data inputs using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.   Examples for one input:   If using the console, {"input":[1,1024,1024,3]}    If using the CLI, {\"input\":[1,1024,1024,3]}      Examples for two inputs:   If using the console, {"data1": [1,28,28,1], "data2":[1,28,28,1]}    If using the CLI, {\"data1\": [1,28,28,1], \"data2\":[1,28,28,1]}         KERAS: You must specify the name and shape (NCHW format) of expected data inputs using a dictionary format for your trained model. Note that while Keras model artifacts should be uploaded in NHWC (channel-last) format, DataInputConfig should be specified in NCHW (channel-first) format. The dictionary formats required for the console and CLI are different.   Examples for one input:   If using the console, {"input_1":[1,3,224,224]}    If using the CLI, {\"input_1\":[1,3,224,224]}      Examples for two inputs:   If using the console, {"input_1": [1,3,224,224], "input_2":[1,3,224,224]}     If using the CLI, {\"input_1\": [1,3,224,224], \"input_2\":[1,3,224,224]}         MXNET/ONNX/DARKNET: You must specify the name and shape (NCHW format) of the expected data inputs in order using a dictionary format for your trained model. The dictionary formats required for the console and CLI are different.   Examples for one input:   If using the console, {"data":[1,3,1024,1024]}    If using the CLI, {\"data\":[1,3,1024,1024]}      Examples for two inputs:   If using the console, {"var1": [1,1,28,28], "var2":[1,1,28,28]}     If using the CLI, {\"var1\": [1,1,28,28], \"var2\":[1,1,28,28]}         PyTorch: You can either specify the name and shape (NCHW format) of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format. The dictionary formats required for the console and CLI are different. The list formats for the console and CLI are the same.   Examples for one input in dictionary format:   If using the console, {"input0":[1,3,224,224]}    If using the CLI, {\"input0\":[1,3,224,224]}      Example for one input in list format: [[1,3,224,224]]    Examples for two inputs in dictionary format:   If using the console, {"input0":[1,3,224,224], "input1":[1,3,224,224]}    If using the CLI, {\"input0\":[1,3,224,224], \"input1\":[1,3,224,224]}       Example for two inputs in list format: [[1,3,224,224], [1,3,224,224]]       XGBOOST: input data name and shape are not needed.    DataInputConfig supports the following parameters for CoreML OutputConfig$TargetDevice (ML Model format):    shape: Input shape, for example {"input_1": {"shape": [1,224,224,3]}}. In addition to static input shapes, CoreML converter supports Flexible input shapes:   Range Dimension. You can use the Range Dimension feature if you know the input shape will be within some specific interval in that dimension, for example: {"input_1": {"shape": ["1..10", 224, 224, 3]}}    Enumerated shapes. Sometimes, the models are trained to work only on a select set of inputs. You can enumerate all supported input shapes, for example: {"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}       default_shape: Default input shape. You can set a default shape during conversion for both Range Dimension and Enumerated Shapes. For example {"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}     type: Input type. Allowed values: Image and Tensor. By default, the converter generates an ML Model with inputs of type Tensor (MultiArray). User can set input type to be Image. Image input type requires additional input parameters such as bias and scale.    bias: If the input type is an Image, you need to provide the bias vector.    scale: If the input type is an Image, you need to provide a scale factor.   CoreML ClassifierConfig parameters can be specified using OutputConfig$CompilerOptions. CoreML converter supports Tensorflow and PyTorch models. CoreML conversion examples:   Tensor type input:    "DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3]}}      Tensor type input without input name (PyTorch):    "DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224]}]      Image type input:    "DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape": [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}     "CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}      Image type input without input name (PyTorch):    "DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape": [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]     "CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}      Depending on the model format, DataInputConfig requires the following parameters for  ml_eia2 OutputConfig:TargetDevice.   For TensorFlow models saved in the SavedModel format, specify the input names  from signature_def_key and the input model shapes for DataInputConfig.   Specify the signature_def_key in   OutputConfig:CompilerOptions if  the model does not use TensorFlow's default signature def key. For example:    "DataInputConfig": {"inputs": [1, 224, 224, 3]}     "CompilerOptions": {"signature_def_key": "serving_custom"}      For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes   in DataInputConfig and the output tensor names for output_names in   OutputConfig:CompilerOptions . For example:    "DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}     "CompilerOptions": {"output_names": ["output_tensor:0"]}
        public let dataInputConfig: String
        /// Identifies the framework in which the model was trained. For example: TENSORFLOW.
        public let framework: Framework
        /// Specifies the framework version to use. This API field is only supported for the MXNet,
        /// 	    PyTorch, TensorFlow and TensorFlow Lite frameworks. For information about framework versions supported for cloud targets and edge devices, see  Cloud Supported Instance Types and Frameworks and  Edge Supported Frameworks.
        public let frameworkVersion: String?
        /// The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        public let s3Uri: String

        public init(dataInputConfig: String, framework: Framework, frameworkVersion: String? = nil, s3Uri: String) {
            self.dataInputConfig = dataInputConfig
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, max: 1024)
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, min: 1)
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, max: 10)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, min: 3)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, pattern: "^[0-9]\\.[A-Za-z0-9.]+$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataInputConfig = "DataInputConfig"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case s3Uri = "S3Uri"
        }
    }

    public struct InstanceGroup: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of instances of the instance group.
        public let instanceCount: Int
        /// Specifies the name of the instance group.
        public let instanceGroupName: String
        /// Specifies the instance type of the instance group.
        public let instanceType: TrainingInstanceType

        public init(instanceCount: Int, instanceGroupName: String, instanceType: TrainingInstanceType) {
            self.instanceCount = instanceCount
            self.instanceGroupName = instanceGroupName
            self.instanceType = instanceType
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 0)
            try self.validate(self.instanceGroupName, name: "instanceGroupName", parent: name, max: 64)
            try self.validate(self.instanceGroupName, name: "instanceGroupName", parent: name, min: 1)
            try self.validate(self.instanceGroupName, name: "instanceGroupName", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceGroupName = "InstanceGroupName"
            case instanceType = "InstanceType"
        }
    }

    public struct InstanceMetadataServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the minimum IMDS version that the notebook instance supports. When passed as part of CreateNotebookInstance, if no value is selected, then it defaults to IMDSv1. This means that both IMDSv1 and IMDSv2 are supported. If passed as part of UpdateNotebookInstance, there is no default.
        public let minimumInstanceMetadataServiceVersion: String

        public init(minimumInstanceMetadataServiceVersion: String) {
            self.minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.minimumInstanceMetadataServiceVersion, name: "minimumInstanceMetadataServiceVersion", parent: name, max: 1)
            try self.validate(self.minimumInstanceMetadataServiceVersion, name: "minimumInstanceMetadataServiceVersion", parent: name, pattern: "^1|2$")
        }

        private enum CodingKeys: String, CodingKey {
            case minimumInstanceMetadataServiceVersion = "MinimumInstanceMetadataServiceVersion"
        }
    }

    public struct IntegerParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum value of the hyperparameter to search.
        public let maxValue: String
        /// The minimum value of the hyperparameter to search.
        public let minValue: String
        /// The name of the hyperparameter to search.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:  Auto  SageMaker hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have only values greater than 0.
        public let scalingType: HyperParameterScalingType?

        public init(maxValue: String, minValue: String, name: String, scalingType: HyperParameterScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 256)
            try self.validate(self.maxValue, name: "maxValue", parent: name, pattern: ".*")
            try self.validate(self.minValue, name: "minValue", parent: name, max: 256)
            try self.validate(self.minValue, name: "minValue", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct IntegerParameterRangeSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The maximum integer value allowed.
        public let maxValue: String
        /// The minimum integer value allowed.
        public let minValue: String

        public init(maxValue: String, minValue: String) {
            self.maxValue = maxValue
            self.minValue = minValue
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 256)
            try self.validate(self.maxValue, name: "maxValue", parent: name, pattern: ".*")
            try self.validate(self.minValue, name: "minValue", parent: name, max: 256)
            try self.validate(self.minValue, name: "minValue", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public struct JupyterServerAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application.
        public let codeRepositories: [CodeRepository]?
        /// The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the LifecycleConfigArns parameter, then this parameter is also required.
        public let defaultResourceSpec: ResourceSpec?
        ///  The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the JupyterServerApp. If you use this parameter, the DefaultResourceSpec parameter is also required.  To remove a Lifecycle Config, you must set LifecycleConfigArns to an empty list.
        public let lifecycleConfigArns: [String]?

        public init(codeRepositories: [CodeRepository]? = nil, defaultResourceSpec: ResourceSpec? = nil, lifecycleConfigArns: [String]? = nil) {
            self.codeRepositories = codeRepositories
            self.defaultResourceSpec = defaultResourceSpec
            self.lifecycleConfigArns = lifecycleConfigArns
        }

        public func validate(name: String) throws {
            try self.codeRepositories?.forEach {
                try $0.validate(name: "\(name).codeRepositories[]")
            }
            try self.validate(self.codeRepositories, name: "codeRepositories", parent: name, max: 10)
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
            try self.lifecycleConfigArns?.forEach {
                try validate($0, name: "lifecycleConfigArns[]", parent: name, max: 256)
                try validate($0, name: "lifecycleConfigArns[]", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:studio-lifecycle-config/")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositories = "CodeRepositories"
            case defaultResourceSpec = "DefaultResourceSpec"
            case lifecycleConfigArns = "LifecycleConfigArns"
        }
    }

    public struct KernelGatewayAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// A list of custom SageMaker images that are configured to run as a KernelGateway app.
        public let customImages: [CustomImage]?
        /// The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.  The Amazon SageMaker Studio UI does not use the default instance type value set here. The default instance type set here is used when Apps are created using the Amazon Web Services Command Line Interface or Amazon Web Services CloudFormation and the instance type parameter value is not passed.
        public let defaultResourceSpec: ResourceSpec?
        ///  The Amazon Resource Name (ARN) of the Lifecycle Configurations attached to the the user profile or domain.  To remove a Lifecycle Config, you must set LifecycleConfigArns to an empty list.
        public let lifecycleConfigArns: [String]?

        public init(customImages: [CustomImage]? = nil, defaultResourceSpec: ResourceSpec? = nil, lifecycleConfigArns: [String]? = nil) {
            self.customImages = customImages
            self.defaultResourceSpec = defaultResourceSpec
            self.lifecycleConfigArns = lifecycleConfigArns
        }

        public func validate(name: String) throws {
            try self.customImages?.forEach {
                try $0.validate(name: "\(name).customImages[]")
            }
            try self.validate(self.customImages, name: "customImages", parent: name, max: 200)
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
            try self.lifecycleConfigArns?.forEach {
                try validate($0, name: "lifecycleConfigArns[]", parent: name, max: 256)
                try validate($0, name: "lifecycleConfigArns[]", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:studio-lifecycle-config/")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customImages = "CustomImages"
            case defaultResourceSpec = "DefaultResourceSpec"
            case lifecycleConfigArns = "LifecycleConfigArns"
        }
    }

    public struct KernelGatewayImageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        public let fileSystemConfig: FileSystemConfig?
        /// The specification of the Jupyter kernels in the image.
        public let kernelSpecs: [KernelSpec]

        public init(fileSystemConfig: FileSystemConfig? = nil, kernelSpecs: [KernelSpec]) {
            self.fileSystemConfig = fileSystemConfig
            self.kernelSpecs = kernelSpecs
        }

        public func validate(name: String) throws {
            try self.fileSystemConfig?.validate(name: "\(name).fileSystemConfig")
            try self.kernelSpecs.forEach {
                try $0.validate(name: "\(name).kernelSpecs[]")
            }
            try self.validate(self.kernelSpecs, name: "kernelSpecs", parent: name, max: 1)
            try self.validate(self.kernelSpecs, name: "kernelSpecs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemConfig = "FileSystemConfig"
            case kernelSpecs = "KernelSpecs"
        }
    }

    public struct KernelSpec: AWSEncodableShape & AWSDecodableShape {
        /// The display name of the kernel.
        public let displayName: String?
        /// The name of the Jupyter kernel in the image. This value is case sensitive.
        public let name: String

        public init(displayName: String? = nil, name: String) {
            self.displayName = displayName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case name = "Name"
        }
    }

    public struct LabelCounters: AWSDecodableShape {
        /// The total number of objects that could not be labeled due to an error.
        public let failedNonRetryableError: Int?
        /// The total number of objects labeled by a human worker.
        public let humanLabeled: Int?
        /// The total number of objects labeled by automated data labeling.
        public let machineLabeled: Int?
        /// The total number of objects labeled.
        public let totalLabeled: Int?
        /// The total number of objects not yet labeled.
        public let unlabeled: Int?

        public init(failedNonRetryableError: Int? = nil, humanLabeled: Int? = nil, machineLabeled: Int? = nil, totalLabeled: Int? = nil, unlabeled: Int? = nil) {
            self.failedNonRetryableError = failedNonRetryableError
            self.humanLabeled = humanLabeled
            self.machineLabeled = machineLabeled
            self.totalLabeled = totalLabeled
            self.unlabeled = unlabeled
        }

        private enum CodingKeys: String, CodingKey {
            case failedNonRetryableError = "FailedNonRetryableError"
            case humanLabeled = "HumanLabeled"
            case machineLabeled = "MachineLabeled"
            case totalLabeled = "TotalLabeled"
            case unlabeled = "Unlabeled"
        }
    }

    public struct LabelCountersForWorkteam: AWSDecodableShape {
        /// The total number of data objects labeled by a human worker.
        public let humanLabeled: Int?
        /// The total number of data objects that need to be labeled by a human worker.
        public let pendingHuman: Int?
        /// The total number of tasks in the labeling job.
        public let total: Int?

        public init(humanLabeled: Int? = nil, pendingHuman: Int? = nil, total: Int? = nil) {
            self.humanLabeled = humanLabeled
            self.pendingHuman = pendingHuman
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case humanLabeled = "HumanLabeled"
            case pendingHuman = "PendingHuman"
            case total = "Total"
        }
    }

    public struct LabelingJobAlgorithmsConfig: AWSEncodableShape & AWSDecodableShape {
        /// At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here.
        public let initialActiveLearningModelArn: String?
        /// Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:    Image classification   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/image-classification     Text classification   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/text-classification     Object detection   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/object-detection     Semantic Segmentation   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/semantic-segmentation
        public let labelingJobAlgorithmSpecificationArn: String
        /// Provides configuration information for a labeling job.
        public let labelingJobResourceConfig: LabelingJobResourceConfig?

        public init(initialActiveLearningModelArn: String? = nil, labelingJobAlgorithmSpecificationArn: String, labelingJobResourceConfig: LabelingJobResourceConfig? = nil) {
            self.initialActiveLearningModelArn = initialActiveLearningModelArn
            self.labelingJobAlgorithmSpecificationArn = labelingJobAlgorithmSpecificationArn
            self.labelingJobResourceConfig = labelingJobResourceConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.initialActiveLearningModelArn, name: "initialActiveLearningModelArn", parent: name, max: 2048)
            try self.validate(self.initialActiveLearningModelArn, name: "initialActiveLearningModelArn", parent: name, min: 20)
            try self.validate(self.initialActiveLearningModelArn, name: "initialActiveLearningModelArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:model/")
            try self.validate(self.labelingJobAlgorithmSpecificationArn, name: "labelingJobAlgorithmSpecificationArn", parent: name, max: 2048)
            try self.validate(self.labelingJobAlgorithmSpecificationArn, name: "labelingJobAlgorithmSpecificationArn", parent: name, pattern: "^arn:")
            try self.labelingJobResourceConfig?.validate(name: "\(name).labelingJobResourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case initialActiveLearningModelArn = "InitialActiveLearningModelArn"
            case labelingJobAlgorithmSpecificationArn = "LabelingJobAlgorithmSpecificationArn"
            case labelingJobResourceConfig = "LabelingJobResourceConfig"
        }
    }

    public struct LabelingJobDataAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Declares that your content is free of personally identifiable information or adult content. SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.
        public let contentClassifiers: [ContentClassifier]?

        public init(contentClassifiers: [ContentClassifier]? = nil) {
            self.contentClassifiers = contentClassifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.contentClassifiers, name: "contentClassifiers", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case contentClassifiers = "ContentClassifiers"
        }
    }

    public struct LabelingJobDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location of the input data objects.
        public let s3DataSource: LabelingJobS3DataSource?
        /// An Amazon SNS data source used for streaming labeling jobs. To learn more, see Send Data to a Streaming Labeling Job.
        public let snsDataSource: LabelingJobSnsDataSource?

        public init(s3DataSource: LabelingJobS3DataSource? = nil, snsDataSource: LabelingJobSnsDataSource? = nil) {
            self.s3DataSource = s3DataSource
            self.snsDataSource = snsDataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource?.validate(name: "\(name).s3DataSource")
            try self.snsDataSource?.validate(name: "\(name).snsDataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
            case snsDataSource = "SnsDataSource"
        }
    }

    public struct LabelingJobForWorkteamSummary: AWSDecodableShape {
        /// The date and time that the labeling job was created.
        public let creationTime: Date
        /// A unique identifier for a labeling job. You can use this to refer to a specific labeling job.
        public let jobReferenceCode: String
        /// Provides information about the progress of a labeling job.
        public let labelCounters: LabelCountersForWorkteam?
        /// The name of the labeling job that the work team is assigned to.
        public let labelingJobName: String?
        /// The configured number of workers per data object.
        public let numberOfHumanWorkersPerDataObject: Int?
        /// The Amazon Web Services account ID of the account used to start the labeling job.
        public let workRequesterAccountId: String

        public init(creationTime: Date, jobReferenceCode: String, labelCounters: LabelCountersForWorkteam? = nil, labelingJobName: String? = nil, numberOfHumanWorkersPerDataObject: Int? = nil, workRequesterAccountId: String) {
            self.creationTime = creationTime
            self.jobReferenceCode = jobReferenceCode
            self.labelCounters = labelCounters
            self.labelingJobName = labelingJobName
            self.numberOfHumanWorkersPerDataObject = numberOfHumanWorkersPerDataObject
            self.workRequesterAccountId = workRequesterAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jobReferenceCode = "JobReferenceCode"
            case labelCounters = "LabelCounters"
            case labelingJobName = "LabelingJobName"
            case numberOfHumanWorkersPerDataObject = "NumberOfHumanWorkersPerDataObject"
            case workRequesterAccountId = "WorkRequesterAccountId"
        }
    }

    public struct LabelingJobInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Attributes of the data specified by the customer.
        public let dataAttributes: LabelingJobDataAttributes?
        /// The location of the input data.
        public let dataSource: LabelingJobDataSource

        public init(dataAttributes: LabelingJobDataAttributes? = nil, dataSource: LabelingJobDataSource) {
            self.dataAttributes = dataAttributes
            self.dataSource = dataSource
        }

        public func validate(name: String) throws {
            try self.dataAttributes?.validate(name: "\(name).dataAttributes")
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case dataAttributes = "DataAttributes"
            case dataSource = "DataSource"
        }
    }

    public struct LabelingJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the most recent SageMaker model trained as part of automated data labeling.
        public let finalActiveLearningModelArn: String?
        /// The Amazon S3 bucket location of the manifest file for labeled data.
        public let outputDatasetS3Uri: String

        public init(finalActiveLearningModelArn: String? = nil, outputDatasetS3Uri: String) {
            self.finalActiveLearningModelArn = finalActiveLearningModelArn
            self.outputDatasetS3Uri = outputDatasetS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case finalActiveLearningModelArn = "FinalActiveLearningModelArn"
            case outputDatasetS3Uri = "OutputDatasetS3Uri"
        }
    }

    public struct LabelingJobOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any. If you provide your own KMS key ID, you must add the required permissions to your KMS key described in Encrypt Output Data and Storage Volume with Amazon Web Services KMS. If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your role's account to encrypt your output data. If you use a bucket policy with an s3:PutObject permission that only allows objects with server-side encryption, set the condition key of s3:x-amz-server-side-encryption to "aws:kms". For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.
        public let kmsKeyId: String?
        /// The Amazon S3 location to write output data.
        public let s3OutputPath: String
        /// An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a SnsTopicArn if you want to do real time chaining to another streaming job and receive an Amazon SNS notifications each time a data object is submitted by a worker. If you provide an SnsTopicArn in OutputConfig, when workers complete labeling tasks, Ground Truth will send labeling task output data to the SNS output topic you specify here.  To learn more, see Receive Output Data from a Streaming Labeling Job.
        public let snsTopicArn: String?

        public init(kmsKeyId: String? = nil, s3OutputPath: String, snsTopicArn: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.s3OutputPath = s3OutputPath
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 2048)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sns:[a-z0-9\\-]*:[0-9]{12}:[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3OutputPath = "S3OutputPath"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct LabelingJobResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training and inference jobs used for automated data labeling.  You can only specify a VolumeKmsKeyId when you create a labeling job with automated data labeling enabled using the API operation CreateLabelingJob. You cannot specify an Amazon Web Services KMS key to encrypt the storage volume used for automated data labeling model training and inference when you create a labeling job using the console. To learn more, see Output Data and Storage Volume Encryption. The VolumeKmsKeyId can be any of the following formats:   KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"
        public let volumeKmsKeyId: String?
        public let vpcConfig: VpcConfig?

        public init(volumeKmsKeyId: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.volumeKmsKeyId = volumeKmsKeyId
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct LabelingJobS3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location of the manifest file that describes the input data objects.  The input manifest file referenced in ManifestS3Uri must contain one of the following keys: source-ref or source. The value of the keys are interpreted as follows:    source-ref: The source of the object is the Amazon S3 object specified in the value. Use this value when the object is a binary object, such as an image.    source: The source of the object is the value. Use this value when the object is a text value.   If you are a new user of Ground Truth, it is recommended you review Use an Input Manifest File  in the Amazon SageMaker Developer Guide to learn how to create an input manifest file.
        public let manifestS3Uri: String

        public init(manifestS3Uri: String) {
            self.manifestS3Uri = manifestS3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.manifestS3Uri, name: "manifestS3Uri", parent: name, max: 1024)
            try self.validate(self.manifestS3Uri, name: "manifestS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestS3Uri = "ManifestS3Uri"
        }
    }

    public struct LabelingJobSnsDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic you will use to send new data objects to a streaming labeling job.
        public let snsTopicArn: String

        public init(snsTopicArn: String) {
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 2048)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sns:[a-z0-9\\-]*:[0-9]{12}:[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct LabelingJobStoppingConditions: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of objects that can be labeled by human workers.
        public let maxHumanLabeledObjectCount: Int?
        /// The maximum number of input data objects that should be labeled.
        public let maxPercentageOfInputDatasetLabeled: Int?

        public init(maxHumanLabeledObjectCount: Int? = nil, maxPercentageOfInputDatasetLabeled: Int? = nil) {
            self.maxHumanLabeledObjectCount = maxHumanLabeledObjectCount
            self.maxPercentageOfInputDatasetLabeled = maxPercentageOfInputDatasetLabeled
        }

        public func validate(name: String) throws {
            try self.validate(self.maxHumanLabeledObjectCount, name: "maxHumanLabeledObjectCount", parent: name, min: 1)
            try self.validate(self.maxPercentageOfInputDatasetLabeled, name: "maxPercentageOfInputDatasetLabeled", parent: name, max: 100)
            try self.validate(self.maxPercentageOfInputDatasetLabeled, name: "maxPercentageOfInputDatasetLabeled", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxHumanLabeledObjectCount = "MaxHumanLabeledObjectCount"
            case maxPercentageOfInputDatasetLabeled = "MaxPercentageOfInputDatasetLabeled"
        }
    }

    public struct LabelingJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see Annotation Consolidation.
        public let annotationConsolidationLambdaArn: String?
        /// The date and time that the job was created (timestamp).
        public let creationTime: Date
        /// If the LabelingJobStatus field is Failed, this field contains a description of the error.
        public let failureReason: String?
        /// Input configuration for the labeling job.
        public let inputConfig: LabelingJobInputConfig?
        /// Counts showing the progress of the labeling job.
        public let labelCounters: LabelCounters
        /// The Amazon Resource Name (ARN) assigned to the labeling job when it was created.
        public let labelingJobArn: String
        /// The name of the labeling job.
        public let labelingJobName: String
        /// The location of the output produced by the labeling job.
        public let labelingJobOutput: LabelingJobOutput?
        /// The current status of the labeling job.
        public let labelingJobStatus: LabelingJobStatus
        /// The date and time that the job was last modified (timestamp).
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.
        public let preHumanTaskLambdaArn: String
        /// The Amazon Resource Name (ARN) of the work team assigned to the job.
        public let workteamArn: String

        public init(annotationConsolidationLambdaArn: String? = nil, creationTime: Date, failureReason: String? = nil, inputConfig: LabelingJobInputConfig? = nil, labelCounters: LabelCounters, labelingJobArn: String, labelingJobName: String, labelingJobOutput: LabelingJobOutput? = nil, labelingJobStatus: LabelingJobStatus, lastModifiedTime: Date, preHumanTaskLambdaArn: String, workteamArn: String) {
            self.annotationConsolidationLambdaArn = annotationConsolidationLambdaArn
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.inputConfig = inputConfig
            self.labelCounters = labelCounters
            self.labelingJobArn = labelingJobArn
            self.labelingJobName = labelingJobName
            self.labelingJobOutput = labelingJobOutput
            self.labelingJobStatus = labelingJobStatus
            self.lastModifiedTime = lastModifiedTime
            self.preHumanTaskLambdaArn = preHumanTaskLambdaArn
            self.workteamArn = workteamArn
        }

        private enum CodingKeys: String, CodingKey {
            case annotationConsolidationLambdaArn = "AnnotationConsolidationLambdaArn"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case inputConfig = "InputConfig"
            case labelCounters = "LabelCounters"
            case labelingJobArn = "LabelingJobArn"
            case labelingJobName = "LabelingJobName"
            case labelingJobOutput = "LabelingJobOutput"
            case labelingJobStatus = "LabelingJobStatus"
            case lastModifiedTime = "LastModifiedTime"
            case preHumanTaskLambdaArn = "PreHumanTaskLambdaArn"
            case workteamArn = "WorkteamArn"
        }
    }

    public struct LambdaStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution.
        public let arn: String?
        /// A list of the output parameters of the Lambda step.
        public let outputParameters: [OutputParameter]?

        public init(arn: String? = nil, outputParameters: [OutputParameter]? = nil) {
            self.arn = arn
            self.outputParameters = outputParameters
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case outputParameters = "OutputParameters"
        }
    }

    public struct LastUpdateStatus: AWSDecodableShape {
        /// If the update wasn't successful, indicates the reason why it failed.
        public let failureReason: String?
        /// A value that indicates whether the update was made successful.
        public let status: LastUpdateStatusValue

        public init(failureReason: String? = nil, status: LastUpdateStatusValue) {
            self.failureReason = failureReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
        }
    }

    public struct LineageGroupSummary: AWSDecodableShape {
        /// The creation time of the lineage group summary.
        public let creationTime: Date?
        /// The display name of the lineage group summary.
        public let displayName: String?
        /// The last modified time of the lineage group summary.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group resource.
        public let lineageGroupArn: String?
        /// The name or Amazon Resource Name (ARN) of the lineage group.
        public let lineageGroupName: String?

        public init(creationTime: Date? = nil, displayName: String? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, lineageGroupName: String? = nil) {
            self.creationTime = creationTime
            self.displayName = displayName
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.lineageGroupName = lineageGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case lineageGroupName = "LineageGroupName"
        }
    }

    public struct ListActionsRequest: AWSEncodableShape {
        /// A filter that returns only actions of the specified type.
        public let actionType: String?
        /// A filter that returns only actions created on or after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only actions created on or before the specified time.
        public let createdBefore: Date?
        /// The maximum number of actions to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListActions didn't return the full set of actions, the call returns a token for getting the next set of actions.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortActionsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only actions with the specified source URI.
        public let sourceUri: String?

        public init(actionType: String? = nil, createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortActionsBy? = nil, sortOrder: SortOrder? = nil, sourceUri: String? = nil) {
            self.actionType = actionType
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.validate(self.actionType, name: "actionType", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case sourceUri = "SourceUri"
        }
    }

    public struct ListActionsResponse: AWSDecodableShape {
        /// A list of actions and their properties.
        public let actionSummaries: [ActionSummary]?
        /// A token for getting the next set of actions, if there are any.
        public let nextToken: String?

        public init(actionSummaries: [ActionSummary]? = nil, nextToken: String? = nil) {
            self.actionSummaries = actionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionSummaries = "ActionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListAlgorithmsInput: AWSEncodableShape {
        /// A filter that returns only algorithms created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only algorithms created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// The maximum number of algorithms to return in the response.
        public let maxResults: Int?
        /// A string in the algorithm name. This filter returns only algorithms whose name contains the specified string.
        public let nameContains: String?
        /// If the response to a previous ListAlgorithms request was truncated, the response includes a NextToken. To retrieve the next set of algorithms, use the token in the next request.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: AlgorithmSortBy?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: AlgorithmSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListAlgorithmsOutput: AWSDecodableShape {
        /// >An array of AlgorithmSummary objects, each of which lists an algorithm.
        public let algorithmSummaryList: [AlgorithmSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of algorithms, use it in the subsequent request.
        public let nextToken: String?

        public init(algorithmSummaryList: [AlgorithmSummary], nextToken: String? = nil) {
            self.algorithmSummaryList = algorithmSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSummaryList = "AlgorithmSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAliasesRequest: AWSEncodableShape {
        /// The alias of the image version.
        public let alias: String?
        /// The name of the image.
        public let imageName: String
        /// The maximum number of aliases to return.
        public let maxResults: Int?
        /// If the previous call to ListAliases didn't return the full set of aliases, the call returns a token for retrieving the next set of aliases.
        public let nextToken: String?
        /// The version of the image. If image version is not specified, the aliases of all versions of the image are listed.
        public let version: Int?

        public init(alias: String? = nil, imageName: String, maxResults: Int? = nil, nextToken: String? = nil, version: Int? = nil) {
            self.alias = alias
            self.imageName = imageName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 128)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.version, name: "version", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case imageName = "ImageName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct ListAliasesResponse: AWSDecodableShape {
        /// A token for getting the next set of aliases, if more aliases exist.
        public let nextToken: String?
        /// A list of SageMaker image version aliases.
        public let sageMakerImageVersionAliases: [String]?

        public init(nextToken: String? = nil, sageMakerImageVersionAliases: [String]? = nil) {
            self.nextToken = nextToken
            self.sageMakerImageVersionAliases = sageMakerImageVersionAliases
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sageMakerImageVersionAliases = "SageMakerImageVersionAliases"
        }
    }

    public struct ListAppImageConfigsRequest: AWSEncodableShape {
        /// A filter that returns only AppImageConfigs created on or after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only AppImageConfigs created on or before the specified time.
        public let creationTimeBefore: Date?
        /// The maximum number of AppImageConfigs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// A filter that returns only AppImageConfigs modified on or after the specified time.
        public let modifiedTimeAfter: Date?
        /// A filter that returns only AppImageConfigs modified on or before the specified time.
        public let modifiedTimeBefore: Date?
        /// A filter that returns only AppImageConfigs whose name contains the specified string.
        public let nameContains: String?
        /// If the previous call to ListImages didn't return the full set of AppImageConfigs, the call returns a token for getting the next set of AppImageConfigs.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: AppImageConfigSortKey?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modifiedTimeAfter: Date? = nil, modifiedTimeBefore: Date? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: AppImageConfigSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modifiedTimeAfter = modifiedTimeAfter
            self.modifiedTimeBefore = modifiedTimeBefore
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modifiedTimeAfter = "ModifiedTimeAfter"
            case modifiedTimeBefore = "ModifiedTimeBefore"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListAppImageConfigsResponse: AWSDecodableShape {
        /// A list of AppImageConfigs and their properties.
        public let appImageConfigs: [AppImageConfigDetails]?
        /// A token for getting the next set of AppImageConfigs, if there are any.
        public let nextToken: String?

        public init(appImageConfigs: [AppImageConfigDetails]? = nil, nextToken: String? = nil) {
            self.appImageConfigs = appImageConfigs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigs = "AppImageConfigs"
            case nextToken = "NextToken"
        }
    }

    public struct ListAppsRequest: AWSEncodableShape {
        /// A parameter to search for the domain ID.
        public let domainIdEquals: String?
        /// Returns a list up to a specified limit.
        public let maxResults: Int?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: AppSortKey?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A parameter to search by space name. If UserProfileNameEquals is set, then this value cannot be set.
        public let spaceNameEquals: String?
        /// A parameter to search by user profile name. If SpaceNameEquals is set, then this value cannot be set.
        public let userProfileNameEquals: String?

        public init(domainIdEquals: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: AppSortKey? = nil, sortOrder: SortOrder? = nil, spaceNameEquals: String? = nil, userProfileNameEquals: String? = nil) {
            self.domainIdEquals = domainIdEquals
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.spaceNameEquals = spaceNameEquals
            self.userProfileNameEquals = userProfileNameEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdEquals, name: "domainIdEquals", parent: name, max: 63)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.spaceNameEquals, name: "spaceNameEquals", parent: name, max: 63)
            try self.validate(self.spaceNameEquals, name: "spaceNameEquals", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.userProfileNameEquals, name: "userProfileNameEquals", parent: name, max: 63)
            try self.validate(self.userProfileNameEquals, name: "userProfileNameEquals", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainIdEquals = "DomainIdEquals"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case spaceNameEquals = "SpaceNameEquals"
            case userProfileNameEquals = "UserProfileNameEquals"
        }
    }

    public struct ListAppsResponse: AWSDecodableShape {
        /// The list of apps.
        public let apps: [AppDetails]?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(apps: [AppDetails]? = nil, nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "Apps"
            case nextToken = "NextToken"
        }
    }

    public struct ListArtifactsRequest: AWSEncodableShape {
        /// A filter that returns only artifacts of the specified type.
        public let artifactType: String?
        /// A filter that returns only artifacts created on or after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only artifacts created on or before the specified time.
        public let createdBefore: Date?
        /// The maximum number of artifacts to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListArtifacts didn't return the full set of artifacts, the call returns a token for getting the next set of artifacts.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortArtifactsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only artifacts with the specified source URI.
        public let sourceUri: String?

        public init(artifactType: String? = nil, createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortArtifactsBy? = nil, sortOrder: SortOrder? = nil, sourceUri: String? = nil) {
            self.artifactType = artifactType
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactType, name: "artifactType", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactType = "ArtifactType"
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case sourceUri = "SourceUri"
        }
    }

    public struct ListArtifactsResponse: AWSDecodableShape {
        /// A list of artifacts and their properties.
        public let artifactSummaries: [ArtifactSummary]?
        /// A token for getting the next set of artifacts, if there are any.
        public let nextToken: String?

        public init(artifactSummaries: [ArtifactSummary]? = nil, nextToken: String? = nil) {
            self.artifactSummaries = artifactSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifactSummaries = "ArtifactSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListAssociationsRequest: AWSEncodableShape {
        /// A filter that returns only associations of the specified type.
        public let associationType: AssociationEdgeType?
        /// A filter that returns only associations created on or after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only associations created on or before the specified time.
        public let createdBefore: Date?
        /// A filter that returns only associations with the specified destination Amazon Resource Name (ARN).
        public let destinationArn: String?
        /// A filter that returns only associations with the specified destination type.
        public let destinationType: String?
        /// The maximum number of associations to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListAssociations didn't return the full set of associations, the call returns a token for getting the next set of associations.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortAssociationsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only associations with the specified source ARN.
        public let sourceArn: String?
        /// A filter that returns only associations with the specified source type.
        public let sourceType: String?

        public init(associationType: AssociationEdgeType? = nil, createdAfter: Date? = nil, createdBefore: Date? = nil, destinationArn: String? = nil, destinationType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortAssociationsBy? = nil, sortOrder: SortOrder? = nil, sourceArn: String? = nil, sourceType: String? = nil) {
            self.associationType = associationType
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.destinationArn = destinationArn
            self.destinationType = destinationType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 256)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
            try self.validate(self.destinationType, name: "destinationType", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 256)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
            try self.validate(self.sourceType, name: "sourceType", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "AssociationType"
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case destinationArn = "DestinationArn"
            case destinationType = "DestinationType"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct ListAssociationsResponse: AWSDecodableShape {
        /// A list of associations and their properties.
        public let associationSummaries: [AssociationSummary]?
        /// A token for getting the next set of associations, if there are any.
        public let nextToken: String?

        public init(associationSummaries: [AssociationSummary]? = nil, nextToken: String? = nil) {
            self.associationSummaries = associationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case associationSummaries = "AssociationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListAutoMLJobsRequest: AWSEncodableShape {
        /// Request a list of jobs, using a filter for time.
        public let creationTimeAfter: Date?
        /// Request a list of jobs, using a filter for time.
        public let creationTimeBefore: Date?
        /// Request a list of jobs, using a filter for time.
        public let lastModifiedTimeAfter: Date?
        /// Request a list of jobs, using a filter for time.
        public let lastModifiedTimeBefore: Date?
        /// Request a list of jobs up to a specified limit.
        public let maxResults: Int?
        /// Request a list of jobs, using a search filter for name.
        public let nameContains: String?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is Name.
        public let sortBy: AutoMLSortBy?
        /// The sort order for the results. The default is Descending.
        public let sortOrder: AutoMLSortOrder?
        /// Request a list of jobs, using a filter for status.
        public let statusEquals: AutoMLJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: AutoMLSortBy? = nil, sortOrder: AutoMLSortOrder? = nil, statusEquals: AutoMLJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListAutoMLJobsResponse: AWSDecodableShape {
        /// Returns a summary list of jobs.
        public let autoMLJobSummaries: [AutoMLJobSummary]
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(autoMLJobSummaries: [AutoMLJobSummary], nextToken: String? = nil) {
            self.autoMLJobSummaries = autoMLJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobSummaries = "AutoMLJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListCandidatesForAutoMLJobRequest: AWSEncodableShape {
        /// List the candidates created for the job by providing the job's name.
        public let autoMLJobName: String
        /// List the candidates for the job and filter by candidate name.
        public let candidateNameEquals: String?
        /// List the job's candidates up to a specified limit.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is Descending.
        public let sortBy: CandidateSortBy?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: AutoMLSortOrder?
        /// List the candidates for the job and filter by status.
        public let statusEquals: CandidateStatus?

        public init(autoMLJobName: String, candidateNameEquals: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: CandidateSortBy? = nil, sortOrder: AutoMLSortOrder? = nil, statusEquals: CandidateStatus? = nil) {
            self.autoMLJobName = autoMLJobName
            self.candidateNameEquals = candidateNameEquals
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, max: 32)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, min: 1)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.validate(self.candidateNameEquals, name: "candidateNameEquals", parent: name, max: 64)
            try self.validate(self.candidateNameEquals, name: "candidateNameEquals", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobName = "AutoMLJobName"
            case candidateNameEquals = "CandidateNameEquals"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListCandidatesForAutoMLJobResponse: AWSDecodableShape {
        /// Summaries about the AutoMLCandidates.
        public let candidates: [AutoMLCandidate]
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(candidates: [AutoMLCandidate], nextToken: String? = nil) {
            self.candidates = candidates
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case candidates = "Candidates"
            case nextToken = "NextToken"
        }
    }

    public struct ListCodeRepositoriesInput: AWSEncodableShape {
        /// A filter that returns only Git repositories that were created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only Git repositories that were created before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only Git repositories that were last modified after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only Git repositories that were last modified before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of Git repositories to return in the response.
        public let maxResults: Int?
        /// A string in the Git repositories name. This filter returns only repositories whose name contains the specified string.
        public let nameContains: String?
        /// If the result of a ListCodeRepositoriesOutput request was truncated, the response includes a NextToken. To get the next set of Git repositories, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is Name.
        public let sortBy: CodeRepositorySortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: CodeRepositorySortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: CodeRepositorySortBy? = nil, sortOrder: CodeRepositorySortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListCodeRepositoriesOutput: AWSDecodableShape {
        /// Gets a list of summaries of the Git repositories. Each summary specifies the following values for the repository:    Name   Amazon Resource Name (ARN)   Creation time   Last modified time   Configuration information, including the URL location of the repository and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository.
        public let codeRepositorySummaryList: [CodeRepositorySummary]
        /// If the result of a ListCodeRepositoriesOutput request was truncated, the response includes a NextToken. To get the next set of Git repositories, use the token in the next request.
        public let nextToken: String?

        public init(codeRepositorySummaryList: [CodeRepositorySummary], nextToken: String? = nil) {
            self.codeRepositorySummaryList = codeRepositorySummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositorySummaryList = "CodeRepositorySummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListCompilationJobsRequest: AWSEncodableShape {
        /// A filter that returns the model compilation jobs that were created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns the model compilation jobs that were created before a specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns the model compilation jobs that were modified after a specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns the model compilation jobs that were modified before a specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of model compilation jobs to return in the response.
        public let maxResults: Int?
        /// A filter that returns the model compilation jobs whose name contains a specified string.
        public let nameContains: String?
        /// If the result of the previous ListCompilationJobs request was truncated, the response includes a NextToken. To retrieve the next set of model compilation jobs, use the token in the next request.
        public let nextToken: String?
        /// The field by which to sort results. The default is CreationTime.
        public let sortBy: ListCompilationJobsSortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves model compilation jobs with a specific DescribeCompilationJobResponse$CompilationJobStatus status.
        public let statusEquals: CompilationJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListCompilationJobsSortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: CompilationJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListCompilationJobsResponse: AWSDecodableShape {
        /// An array of CompilationJobSummary objects, each describing a model compilation job.
        public let compilationJobSummaries: [CompilationJobSummary]
        /// If the response is truncated, Amazon SageMaker returns this NextToken. To retrieve the next set of model compilation jobs, use this token in the next request.
        public let nextToken: String?

        public init(compilationJobSummaries: [CompilationJobSummary], nextToken: String? = nil) {
            self.compilationJobSummaries = compilationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobSummaries = "CompilationJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListContextsRequest: AWSEncodableShape {
        /// A filter that returns only contexts of the specified type.
        public let contextType: String?
        /// A filter that returns only contexts created on or after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only contexts created on or before the specified time.
        public let createdBefore: Date?
        /// The maximum number of contexts to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListContexts didn't return the full set of contexts, the call returns a token for getting the next set of contexts.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortContextsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only contexts with the specified source URI.
        public let sourceUri: String?

        public init(contextType: String? = nil, createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortContextsBy? = nil, sortOrder: SortOrder? = nil, sourceUri: String? = nil) {
            self.contextType = contextType
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceUri = sourceUri
        }

        public func validate(name: String) throws {
            try self.validate(self.contextType, name: "contextType", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, max: 2048)
            try self.validate(self.sourceUri, name: "sourceUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case contextType = "ContextType"
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case sourceUri = "SourceUri"
        }
    }

    public struct ListContextsResponse: AWSDecodableShape {
        /// A list of contexts and their properties.
        public let contextSummaries: [ContextSummary]?
        /// A token for getting the next set of contexts, if there are any.
        public let nextToken: String?

        public init(contextSummaries: [ContextSummary]? = nil, nextToken: String? = nil) {
            self.contextSummaries = contextSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contextSummaries = "ContextSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityJobDefinitionsRequest: AWSEncodableShape {
        /// A filter that returns only data quality monitoring job definitions created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only data quality monitoring job definitions created before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that lists the data quality job definitions associated with the specified endpoint.
        public let endpointName: String?
        /// The maximum number of data quality monitoring job definitions to return in the response.
        public let maxResults: Int?
        /// A string in the data quality monitoring job definition name. This filter returns only data quality monitoring job definitions whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListDataQualityJobDefinitions request was truncated, the response includes a NextToken. To retrieve the next set of transform jobs, use the token in the next request.>
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: MonitoringJobDefinitionSortKey?
        /// The sort order for results. The default is Descending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: MonitoringJobDefinitionSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListDataQualityJobDefinitionsResponse: AWSDecodableShape {
        /// A list of data quality monitoring job definitions.
        public let jobDefinitionSummaries: [MonitoringJobDefinitionSummary]
        /// If the result of the previous ListDataQualityJobDefinitions request was truncated, the response includes a NextToken. To retrieve the next set of data quality monitoring job definitions, use the token in the next request.
        public let nextToken: String?

        public init(jobDefinitionSummaries: [MonitoringJobDefinitionSummary], nextToken: String? = nil) {
            self.jobDefinitionSummaries = jobDefinitionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionSummaries = "JobDefinitionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceFleetsRequest: AWSEncodableShape {
        /// Filter fleets where packaging job was created after specified time.
        public let creationTimeAfter: Date?
        /// Filter fleets where the edge packaging job was created before specified time.
        public let creationTimeBefore: Date?
        /// Select fleets where the job was updated after X
        public let lastModifiedTimeAfter: Date?
        /// Select fleets where the job was updated before X
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of results to select.
        public let maxResults: Int?
        /// Filter for fleets containing this name in their fleet device name.
        public let nameContains: String?
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?
        /// The column to sort by.
        public let sortBy: ListDeviceFleetsSortBy?
        /// What direction to sort in.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListDeviceFleetsSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListDeviceFleetsResponse: AWSDecodableShape {
        /// Summary of the device fleet.
        public let deviceFleetSummaries: [DeviceFleetSummary]
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?

        public init(deviceFleetSummaries: [DeviceFleetSummary], nextToken: String? = nil) {
            self.deviceFleetSummaries = deviceFleetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetSummaries = "DeviceFleetSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicesRequest: AWSEncodableShape {
        /// Filter for fleets containing this name in their device fleet name.
        public let deviceFleetName: String?
        /// Select fleets where the job was updated after X
        public let latestHeartbeatAfter: Date?
        /// Maximum number of results to select.
        public let maxResults: Int?
        /// A filter that searches devices that contains this name in any of their models.
        public let modelName: String?
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?

        public init(deviceFleetName: String? = nil, latestHeartbeatAfter: Date? = nil, maxResults: Int? = nil, modelName: String? = nil, nextToken: String? = nil) {
            self.deviceFleetName = deviceFleetName
            self.latestHeartbeatAfter = latestHeartbeatAfter
            self.maxResults = maxResults
            self.modelName = modelName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, min: 1)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case latestHeartbeatAfter = "LatestHeartbeatAfter"
            case maxResults = "MaxResults"
            case modelName = "ModelName"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicesResponse: AWSDecodableShape {
        /// Summary of devices.
        public let deviceSummaries: [DeviceSummary]
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?

        public init(deviceSummaries: [DeviceSummary], nextToken: String? = nil) {
            self.deviceSummaries = deviceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceSummaries = "DeviceSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// Returns a list up to a specified limit.
        public let maxResults: Int?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The list of domains.
        public let domains: [DomainDetails]?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(domains: [DomainDetails]? = nil, nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "Domains"
            case nextToken = "NextToken"
        }
    }

    public struct ListEdgeDeploymentPlansRequest: AWSEncodableShape {
        /// Selects edge deployment plans created after this time.
        public let creationTimeAfter: Date?
        /// Selects edge deployment plans created before this time.
        public let creationTimeBefore: Date?
        /// Selects edge deployment plans with a device fleet name containing this name.
        public let deviceFleetNameContains: String?
        /// Selects edge deployment plans that were last updated after this time.
        public let lastModifiedTimeAfter: Date?
        /// Selects edge deployment plans that were last updated before this time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of results to select (50 by default).
        public let maxResults: Int?
        /// Selects edge deployment plans with names containing this name.
        public let nameContains: String?
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?
        /// The column by which to sort the edge deployment plans. Can be one of NAME, DEVICEFLEETNAME, CREATIONTIME, LASTMODIFIEDTIME.
        public let sortBy: ListEdgeDeploymentPlansSortBy?
        /// The direction of the sorting (ascending or descending).
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, deviceFleetNameContains: String? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListEdgeDeploymentPlansSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.deviceFleetNameContains = deviceFleetNameContains
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetNameContains, name: "deviceFleetNameContains", parent: name, max: 63)
            try self.validate(self.deviceFleetNameContains, name: "deviceFleetNameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case deviceFleetNameContains = "DeviceFleetNameContains"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListEdgeDeploymentPlansResponse: AWSDecodableShape {
        /// List of summaries of edge deployment plans.
        public let edgeDeploymentPlanSummaries: [EdgeDeploymentPlanSummary]
        /// The token to use when calling the next page of results.
        public let nextToken: String?

        public init(edgeDeploymentPlanSummaries: [EdgeDeploymentPlanSummary], nextToken: String? = nil) {
            self.edgeDeploymentPlanSummaries = edgeDeploymentPlanSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanSummaries = "EdgeDeploymentPlanSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListEdgePackagingJobsRequest: AWSEncodableShape {
        /// Select jobs where the job was created after specified time.
        public let creationTimeAfter: Date?
        /// Select jobs where the job was created before specified time.
        public let creationTimeBefore: Date?
        /// Select jobs where the job was updated after specified time.
        public let lastModifiedTimeAfter: Date?
        /// Select jobs where the job was updated before specified time.
        public let lastModifiedTimeBefore: Date?
        /// Maximum number of results to select.
        public let maxResults: Int?
        /// Filter for jobs where the model name contains this string.
        public let modelNameContains: String?
        /// Filter for jobs containing this name in their packaging job name.
        public let nameContains: String?
        /// The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?
        /// Use to specify what column to sort by.
        public let sortBy: ListEdgePackagingJobsSortBy?
        /// What direction to sort by.
        public let sortOrder: SortOrder?
        /// The job status to filter for.
        public let statusEquals: EdgePackagingJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, modelNameContains: String? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListEdgePackagingJobsSortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: EdgePackagingJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.modelNameContains = modelNameContains
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.modelNameContains, name: "modelNameContains", parent: name, max: 63)
            try self.validate(self.modelNameContains, name: "modelNameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case modelNameContains = "ModelNameContains"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListEdgePackagingJobsResponse: AWSDecodableShape {
        /// Summaries of edge packaging jobs.
        public let edgePackagingJobSummaries: [EdgePackagingJobSummary]
        /// Token to use when calling the next page of results.
        public let nextToken: String?

        public init(edgePackagingJobSummaries: [EdgePackagingJobSummary], nextToken: String? = nil) {
            self.edgePackagingJobSummaries = edgePackagingJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case edgePackagingJobSummaries = "EdgePackagingJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListEndpointConfigsInput: AWSEncodableShape {
        /// A filter that returns only endpoint configurations with a creation time greater than or equal to the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only endpoint configurations created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// The maximum number of training jobs to return in the response.
        public let maxResults: Int?
        /// A string in the endpoint configuration name. This filter returns only endpoint configurations whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListEndpointConfig request was truncated, the response includes a NextToken. To retrieve the next set of endpoint configurations, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: EndpointConfigSortKey?
        /// The sort order for results. The default is Descending.
        public let sortOrder: OrderKey?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: EndpointConfigSortKey? = nil, sortOrder: OrderKey? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListEndpointConfigsOutput: AWSDecodableShape {
        /// An array of endpoint configurations.
        public let endpointConfigs: [EndpointConfigSummary]
        ///  If the response is truncated, SageMaker returns this token. To retrieve the next set of endpoint configurations, use it in the subsequent request
        public let nextToken: String?

        public init(endpointConfigs: [EndpointConfigSummary], nextToken: String? = nil) {
            self.endpointConfigs = endpointConfigs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigs = "EndpointConfigs"
            case nextToken = "NextToken"
        }
    }

    public struct ListEndpointsInput: AWSEncodableShape {
        /// A filter that returns only endpoints with a creation time greater than or equal to the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only endpoints that were created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        ///  A filter that returns only endpoints that were modified after the specified timestamp.
        public let lastModifiedTimeAfter: Date?
        ///  A filter that returns only endpoints that were modified before the specified timestamp.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of endpoints to return in the response. This value defaults to 10.
        public let maxResults: Int?
        /// A string in endpoint names. This filter returns only endpoints whose name contains the specified string.
        public let nameContains: String?
        /// If the result of a ListEndpoints request was truncated, the response includes a NextToken. To retrieve the next set of endpoints, use the token in the next request.
        public let nextToken: String?
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: EndpointSortKey?
        /// The sort order for results. The default is Descending.
        public let sortOrder: OrderKey?
        ///  A filter that returns only endpoints with the specified status.
        public let statusEquals: EndpointStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: EndpointSortKey? = nil, sortOrder: OrderKey? = nil, statusEquals: EndpointStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListEndpointsOutput: AWSDecodableShape {
        ///  An array or endpoint objects.
        public let endpoints: [EndpointSummary]
        ///  If the response is truncated, SageMaker returns this token. To retrieve the next set of training jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(endpoints: [EndpointSummary], nextToken: String? = nil) {
            self.endpoints = endpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
            case nextToken = "NextToken"
        }
    }

    public struct ListExperimentsRequest: AWSEncodableShape {
        /// A filter that returns only experiments created after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only experiments created before the specified time.
        public let createdBefore: Date?
        /// The maximum number of experiments to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListExperiments didn't return the full set of experiments, the call returns a token for getting the next set of experiments.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortExperimentsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortExperimentsBy? = nil, sortOrder: SortOrder? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListExperimentsResponse: AWSDecodableShape {
        /// A list of the summaries of your experiments.
        public let experimentSummaries: [ExperimentSummary]?
        /// A token for getting the next set of experiments, if there are any.
        public let nextToken: String?

        public init(experimentSummaries: [ExperimentSummary]? = nil, nextToken: String? = nil) {
            self.experimentSummaries = experimentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case experimentSummaries = "ExperimentSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListFeatureGroupsRequest: AWSEncodableShape {
        /// Use this parameter to search for FeatureGroupss created after a specific date and time.
        public let creationTimeAfter: Date?
        /// Use this parameter to search for FeatureGroupss created before a specific date and time.
        public let creationTimeBefore: Date?
        /// A FeatureGroup status. Filters by FeatureGroup status.
        public let featureGroupStatusEquals: FeatureGroupStatus?
        /// The maximum number of results returned by ListFeatureGroups.
        public let maxResults: Int?
        /// A string that partially matches one or more FeatureGroups names. Filters FeatureGroups by name.
        public let nameContains: String?
        /// A token to resume pagination of ListFeatureGroups results.
        public let nextToken: String?
        /// An OfflineStore status. Filters by OfflineStore status.
        public let offlineStoreStatusEquals: OfflineStoreStatusValue?
        /// The value on which the feature group list is sorted.
        public let sortBy: FeatureGroupSortBy?
        /// The order in which feature groups are listed.
        public let sortOrder: FeatureGroupSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, featureGroupStatusEquals: FeatureGroupStatus? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, offlineStoreStatusEquals: OfflineStoreStatusValue? = nil, sortBy: FeatureGroupSortBy? = nil, sortOrder: FeatureGroupSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.featureGroupStatusEquals = featureGroupStatusEquals
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.offlineStoreStatusEquals = offlineStoreStatusEquals
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 64)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case featureGroupStatusEquals = "FeatureGroupStatusEquals"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case offlineStoreStatusEquals = "OfflineStoreStatusEquals"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListFeatureGroupsResponse: AWSDecodableShape {
        /// A summary of feature groups.
        public let featureGroupSummaries: [FeatureGroupSummary]
        /// A token to resume pagination of ListFeatureGroups results.
        public let nextToken: String?

        public init(featureGroupSummaries: [FeatureGroupSummary], nextToken: String? = nil) {
            self.featureGroupSummaries = featureGroupSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupSummaries = "FeatureGroupSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListFlowDefinitionsRequest: AWSEncodableShape {
        /// A filter that returns only flow definitions with a creation time greater than or equal to the specified timestamp.
        public let creationTimeAfter: Date?
        /// A filter that returns only flow definitions that were created before the specified timestamp.
        public let creationTimeBefore: Date?
        /// The total number of items to return. If the total number of available items is more than the value specified in MaxResults, then a NextToken will be provided in the output that you can use to resume pagination.
        public let maxResults: Int?
        /// A token to resume pagination.
        public let nextToken: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListFlowDefinitionsResponse: AWSDecodableShape {
        /// An array of objects describing the flow definitions.
        public let flowDefinitionSummaries: [FlowDefinitionSummary]
        /// A token to resume pagination.
        public let nextToken: String?

        public init(flowDefinitionSummaries: [FlowDefinitionSummary], nextToken: String? = nil) {
            self.flowDefinitionSummaries = flowDefinitionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionSummaries = "FlowDefinitionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListHubContentVersionsRequest: AWSEncodableShape {
        /// Only list hub content versions that were created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list hub content versions that were created before the time specified.
        public let creationTimeBefore: Date?
        /// The name of the hub content.
        public let hubContentName: String
        /// The type of hub content to list versions of.
        public let hubContentType: HubContentType
        /// The name of the hub to list the content versions of.
        public let hubName: String
        /// The maximum number of hub content versions to list.
        public let maxResults: Int?
        /// The upper bound of the hub content schema version.
        public let maxSchemaVersion: String?
        /// The lower bound of the hub content versions to list.
        public let minVersion: String?
        /// If the response to a previous ListHubContentVersions request was truncated, the response includes a NextToken. To retrieve the next set of hub content versions, use the token in the next request.
        public let nextToken: String?
        /// Sort hub content versions by either name or creation time.
        public let sortBy: HubContentSortBy?
        /// Sort hub content versions by ascending or descending order.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, hubContentName: String, hubContentType: HubContentType, hubName: String, maxResults: Int? = nil, maxSchemaVersion: String? = nil, minVersion: String? = nil, nextToken: String? = nil, sortBy: HubContentSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.hubContentName = hubContentName
            self.hubContentType = hubContentType
            self.hubName = hubName
            self.maxResults = maxResults
            self.maxSchemaVersion = maxSchemaVersion
            self.minVersion = minVersion
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, max: 63)
            try self.validate(self.hubContentName, name: "hubContentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, max: 14)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, min: 5)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.minVersion, name: "minVersion", parent: name, max: 14)
            try self.validate(self.minVersion, name: "minVersion", parent: name, min: 5)
            try self.validate(self.minVersion, name: "minVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case hubContentName = "HubContentName"
            case hubContentType = "HubContentType"
            case hubName = "HubName"
            case maxResults = "MaxResults"
            case maxSchemaVersion = "MaxSchemaVersion"
            case minVersion = "MinVersion"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListHubContentVersionsResponse: AWSDecodableShape {
        /// The summaries of the listed hub content versions.
        public let hubContentSummaries: [HubContentInfo]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of hub content versions, use it in the subsequent request.
        public let nextToken: String?

        public init(hubContentSummaries: [HubContentInfo], nextToken: String? = nil) {
            self.hubContentSummaries = hubContentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hubContentSummaries = "HubContentSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListHubContentsRequest: AWSEncodableShape {
        /// Only list hub content that was created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list hub content that was created before the time specified.
        public let creationTimeBefore: Date?
        /// The type of hub content to list.
        public let hubContentType: HubContentType
        /// The name of the hub to list the contents of.
        public let hubName: String
        /// The maximum amount of hub content to list.
        public let maxResults: Int?
        /// The upper bound of the hub content schema verion.
        public let maxSchemaVersion: String?
        /// Only list hub content if the name contains the specified string.
        public let nameContains: String?
        /// If the response to a previous ListHubContents request was truncated, the response includes a NextToken. To retrieve the next set of hub content, use the token in the next request.
        public let nextToken: String?
        /// Sort hub content versions by either name or creation time.
        public let sortBy: HubContentSortBy?
        /// Sort hubs by ascending or descending order.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, hubContentType: HubContentType, hubName: String, maxResults: Int? = nil, maxSchemaVersion: String? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: HubContentSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.hubContentType = hubContentType
            self.hubName = hubName
            self.maxResults = maxResults
            self.maxSchemaVersion = maxSchemaVersion
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, max: 14)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, min: 5)
            try self.validate(self.maxSchemaVersion, name: "maxSchemaVersion", parent: name, pattern: "^\\d{1,4}.\\d{1,4}.\\d{1,4}$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case hubContentType = "HubContentType"
            case hubName = "HubName"
            case maxResults = "MaxResults"
            case maxSchemaVersion = "MaxSchemaVersion"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListHubContentsResponse: AWSDecodableShape {
        /// The summaries of the listed hub content.
        public let hubContentSummaries: [HubContentInfo]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of hub content, use it in the subsequent request.
        public let nextToken: String?

        public init(hubContentSummaries: [HubContentInfo], nextToken: String? = nil) {
            self.hubContentSummaries = hubContentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hubContentSummaries = "HubContentSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListHubsRequest: AWSEncodableShape {
        /// Only list hubs that were created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list hubs that were created before the time specified.
        public let creationTimeBefore: Date?
        /// Only list hubs that were last modified after the time specified.
        public let lastModifiedTimeAfter: Date?
        /// Only list hubs that were last modified before the time specified.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of hubs to list.
        public let maxResults: Int?
        /// Only list hubs with names that contain the specified string.
        public let nameContains: String?
        /// If the response to a previous ListHubs request was truncated, the response includes a NextToken. To retrieve the next set of hubs, use the token in the next request.
        public let nextToken: String?
        /// Sort hubs by either name or creation time.
        public let sortBy: HubSortBy?
        /// Sort hubs by ascending or descending order.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: HubSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListHubsResponse: AWSDecodableShape {
        /// The summaries of the listed hubs.
        public let hubSummaries: [HubInfo]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of hubs, use it in the subsequent request.
        public let nextToken: String?

        public init(hubSummaries: [HubInfo], nextToken: String? = nil) {
            self.hubSummaries = hubSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hubSummaries = "HubSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListHumanTaskUisRequest: AWSEncodableShape {
        /// A filter that returns only human task user interfaces with a creation time greater than or equal to the specified timestamp.
        public let creationTimeAfter: Date?
        /// A filter that returns only human task user interfaces that were created before the specified timestamp.
        public let creationTimeBefore: Date?
        /// The total number of items to return. If the total number of available items is more than the value specified in MaxResults, then a NextToken will be provided in the output that you can use to resume pagination.
        public let maxResults: Int?
        /// A token to resume pagination.
        public let nextToken: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListHumanTaskUisResponse: AWSDecodableShape {
        /// An array of objects describing the human task user interfaces.
        public let humanTaskUiSummaries: [HumanTaskUiSummary]
        /// A token to resume pagination.
        public let nextToken: String?

        public init(humanTaskUiSummaries: [HumanTaskUiSummary], nextToken: String? = nil) {
            self.humanTaskUiSummaries = humanTaskUiSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiSummaries = "HumanTaskUiSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListHyperParameterTuningJobsRequest: AWSEncodableShape {
        /// A filter that returns only tuning jobs that were created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only tuning jobs that were created before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only tuning jobs that were modified after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only tuning jobs that were modified before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of tuning jobs to return. The default value is 10.
        public let maxResults: Int?
        /// A string in the tuning job name. This filter returns only tuning jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListHyperParameterTuningJobs request was truncated, the response includes a NextToken. To retrieve the next set of tuning jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is Name.
        public let sortBy: HyperParameterTuningJobSortByOptions?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that returns only tuning jobs with the specified status.
        public let statusEquals: HyperParameterTuningJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: HyperParameterTuningJobSortByOptions? = nil, sortOrder: SortOrder? = nil, statusEquals: HyperParameterTuningJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListHyperParameterTuningJobsResponse: AWSDecodableShape {
        /// A list of HyperParameterTuningJobSummary objects that describe the tuning jobs that the ListHyperParameterTuningJobs request returned.
        public let hyperParameterTuningJobSummaries: [HyperParameterTuningJobSummary]
        /// If the result of this ListHyperParameterTuningJobs request was truncated, the response includes a NextToken. To retrieve the next set of tuning jobs, use the token in the next request.
        public let nextToken: String?

        public init(hyperParameterTuningJobSummaries: [HyperParameterTuningJobSummary], nextToken: String? = nil) {
            self.hyperParameterTuningJobSummaries = hyperParameterTuningJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobSummaries = "HyperParameterTuningJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListImageVersionsRequest: AWSEncodableShape {
        /// A filter that returns only versions created on or after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only versions created on or before the specified time.
        public let creationTimeBefore: Date?
        /// The name of the image to list the versions of.
        public let imageName: String
        /// A filter that returns only versions modified on or after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only versions modified on or before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of versions to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListImageVersions didn't return the full set of versions, the call returns a token for getting the next set of versions.
        public let nextToken: String?
        /// The property used to sort results. The default value is CREATION_TIME.
        public let sortBy: ImageVersionSortBy?
        /// The sort order. The default value is DESCENDING.
        public let sortOrder: ImageVersionSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, imageName: String, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ImageVersionSortBy? = nil, sortOrder: ImageVersionSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.imageName = imageName
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case imageName = "ImageName"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListImageVersionsResponse: AWSDecodableShape {
        /// A list of versions and their properties.
        public let imageVersions: [ImageVersion]?
        /// A token for getting the next set of versions, if there are any.
        public let nextToken: String?

        public init(imageVersions: [ImageVersion]? = nil, nextToken: String? = nil) {
            self.imageVersions = imageVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersions = "ImageVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// A filter that returns only images created on or after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only images created on or before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only images modified on or after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only images modified on or before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of images to return in the response. The default value is 10.
        public let maxResults: Int?
        /// A filter that returns only images whose name contains the specified string.
        public let nameContains: String?
        /// If the previous call to ListImages didn't return the full set of images, the call returns a token for getting the next set of images.
        public let nextToken: String?
        /// The property used to sort results. The default value is CREATION_TIME.
        public let sortBy: ImageSortBy?
        /// The sort order. The default value is DESCENDING.
        public let sortOrder: ImageSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ImageSortBy? = nil, sortOrder: ImageSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-.]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// A list of images and their properties.
        public let images: [Image]?
        /// A token for getting the next set of images, if there are any.
        public let nextToken: String?

        public init(images: [Image]? = nil, nextToken: String? = nil) {
            self.images = images
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case images = "Images"
            case nextToken = "NextToken"
        }
    }

    public struct ListInferenceExperimentsRequest: AWSEncodableShape {
        /// Selects inference experiments which were created after this timestamp.
        public let creationTimeAfter: Date?
        /// Selects inference experiments which were created before this timestamp.
        public let creationTimeBefore: Date?
        /// Selects inference experiments which were last modified after this timestamp.
        public let lastModifiedTimeAfter: Date?
        /// Selects inference experiments which were last modified before this timestamp.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of results to select.
        public let maxResults: Int?
        /// Selects inference experiments whose names contain this name.
        public let nameContains: String?
        ///  The response from the last list when returning a list large enough to need tokening.
        public let nextToken: String?
        /// The column by which to sort the listed inference experiments.
        public let sortBy: SortInferenceExperimentsBy?
        /// The direction of sorting (ascending or descending).
        public let sortOrder: SortOrder?
        ///  Selects inference experiments which are in this status. For the possible statuses, see DescribeInferenceExperimentResponse$Status.
        public let statusEquals: InferenceExperimentStatus?
        ///  Selects inference experiments of this type. For the possible types of inference experiments, see CreateInferenceExperimentRequest$Type.
        public let type: InferenceExperimentType?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortInferenceExperimentsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: InferenceExperimentStatus? = nil, type: InferenceExperimentType? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
            case type = "Type"
        }
    }

    public struct ListInferenceExperimentsResponse: AWSDecodableShape {
        /// List of inference experiments.
        public let inferenceExperiments: [InferenceExperimentSummary]?
        /// The token to use when calling the next page of results.
        public let nextToken: String?

        public init(inferenceExperiments: [InferenceExperimentSummary]? = nil, nextToken: String? = nil) {
            self.inferenceExperiments = inferenceExperiments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperiments = "InferenceExperiments"
            case nextToken = "NextToken"
        }
    }

    public struct ListInferenceRecommendationsJobStepsRequest: AWSEncodableShape {
        /// The name for the Inference Recommender job.
        public let jobName: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A token that you can specify to return more results from the list. Specify this field if you have a token that was returned from a previous request.
        public let nextToken: String?
        /// A filter to return benchmarks of a specified status. If this field is left empty, then all benchmarks are returned.
        public let status: RecommendationJobStatus?
        /// A filter to return details about the specified type of subtask.  BENCHMARK: Evaluate the performance of your model on different instance types.
        public let stepType: RecommendationStepType?

        public init(jobName: String, maxResults: Int? = nil, nextToken: String? = nil, status: RecommendationJobStatus? = nil, stepType: RecommendationStepType? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
            self.stepType = stepType
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case status = "Status"
            case stepType = "StepType"
        }
    }

    public struct ListInferenceRecommendationsJobStepsResponse: AWSDecodableShape {
        /// A token that you can specify in your next request to return more results from the list.
        public let nextToken: String?
        /// A list of all subtask details in Inference Recommender.
        public let steps: [InferenceRecommendationsJobStep]?

        public init(nextToken: String? = nil, steps: [InferenceRecommendationsJobStep]? = nil) {
            self.nextToken = nextToken
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case steps = "Steps"
        }
    }

    public struct ListInferenceRecommendationsJobsRequest: AWSEncodableShape {
        /// A filter that returns only jobs created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only jobs created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A filter that returns only jobs that were last modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only jobs that were last modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of recommendations to return in the response.
        public let maxResults: Int?
        /// A string in the job name. This filter returns only recommendations whose name contains the specified string.
        public let nameContains: String?
        /// If the response to a previous ListInferenceRecommendationsJobsRequest request  was truncated, the response includes a NextToken. To retrieve the next set  of recommendations, use the token in the next request.
        public let nextToken: String?
        /// The parameter by which to sort the results.
        public let sortBy: ListInferenceRecommendationsJobsSortBy?
        /// The sort order for the results.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only inference recommendations jobs with a specific status.
        public let statusEquals: RecommendationJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListInferenceRecommendationsJobsSortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: RecommendationJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListInferenceRecommendationsJobsResponse: AWSDecodableShape {
        /// The recommendations created from the Amazon SageMaker Inference Recommender job.
        public let inferenceRecommendationsJobs: [InferenceRecommendationsJob]
        /// A token for getting the next set of recommendations, if there are any.
        public let nextToken: String?

        public init(inferenceRecommendationsJobs: [InferenceRecommendationsJob], nextToken: String? = nil) {
            self.inferenceRecommendationsJobs = inferenceRecommendationsJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceRecommendationsJobs = "InferenceRecommendationsJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListLabelingJobsForWorkteamRequest: AWSEncodableShape {
        /// A filter that returns only labeling jobs created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only labeling jobs created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A filter the limits jobs to only the ones whose job reference code contains the specified string.
        public let jobReferenceCodeContains: String?
        /// The maximum number of labeling jobs to return in each page of the response.
        public let maxResults: Int?
        /// If the result of the previous ListLabelingJobsForWorkteam request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: ListLabelingJobsForWorkteamSortByOptions?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// The Amazon Resource Name (ARN) of the work team for which you want to see labeling jobs for.
        public let workteamArn: String

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, jobReferenceCodeContains: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ListLabelingJobsForWorkteamSortByOptions? = nil, sortOrder: SortOrder? = nil, workteamArn: String) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.jobReferenceCodeContains = jobReferenceCodeContains
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.workteamArn = workteamArn
        }

        public func validate(name: String) throws {
            try self.validate(self.jobReferenceCodeContains, name: "jobReferenceCodeContains", parent: name, max: 255)
            try self.validate(self.jobReferenceCodeContains, name: "jobReferenceCodeContains", parent: name, min: 1)
            try self.validate(self.jobReferenceCodeContains, name: "jobReferenceCodeContains", parent: name, pattern: "^.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, max: 256)
            try self.validate(self.workteamArn, name: "workteamArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:workteam/")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case jobReferenceCodeContains = "JobReferenceCodeContains"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case workteamArn = "WorkteamArn"
        }
    }

    public struct ListLabelingJobsForWorkteamResponse: AWSDecodableShape {
        /// An array of LabelingJobSummary objects, each describing a labeling job.
        public let labelingJobSummaryList: [LabelingJobForWorkteamSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of labeling jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(labelingJobSummaryList: [LabelingJobForWorkteamSummary], nextToken: String? = nil) {
            self.labelingJobSummaryList = labelingJobSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobSummaryList = "LabelingJobSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLabelingJobsRequest: AWSEncodableShape {
        /// A filter that returns only labeling jobs created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only labeling jobs created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A filter that returns only labeling jobs modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only labeling jobs modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of labeling jobs to return in each page of the response.
        public let maxResults: Int?
        /// A string in the labeling job name. This filter returns only labeling jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListLabelingJobs request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only labeling jobs with a specific status.
        public let statusEquals: LabelingJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: LabelingJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListLabelingJobsResponse: AWSDecodableShape {
        /// An array of LabelingJobSummary objects, each describing a labeling job.
        public let labelingJobSummaryList: [LabelingJobSummary]?
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of labeling jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(labelingJobSummaryList: [LabelingJobSummary]? = nil, nextToken: String? = nil) {
            self.labelingJobSummaryList = labelingJobSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobSummaryList = "LabelingJobSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLineageGroupsRequest: AWSEncodableShape {
        /// A timestamp to filter against lineage groups created after a certain point in time.
        public let createdAfter: Date?
        /// A timestamp to filter against lineage groups created before a certain point in time.
        public let createdBefore: Date?
        /// The maximum number of endpoints to return in the response. This value defaults to 10.
        public let maxResults: Int?
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of algorithms, use it in the subsequent request.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: SortLineageGroupsBy?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortLineageGroupsBy? = nil, sortOrder: SortOrder? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListLineageGroupsResponse: AWSDecodableShape {
        /// A list of lineage groups and their properties.
        public let lineageGroupSummaries: [LineageGroupSummary]?
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of algorithms, use it in the subsequent request.
        public let nextToken: String?

        public init(lineageGroupSummaries: [LineageGroupSummary]? = nil, nextToken: String? = nil) {
            self.lineageGroupSummaries = lineageGroupSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lineageGroupSummaries = "LineageGroupSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelBiasJobDefinitionsRequest: AWSEncodableShape {
        /// A filter that returns only model bias jobs created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only model bias jobs created before a specified time.
        public let creationTimeBefore: Date?
        /// Name of the endpoint to monitor for model bias.
        public let endpointName: String?
        /// The maximum number of model bias jobs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// Filter for model bias jobs whose name contains a specified string.
        public let nameContains: String?
        /// The token returned if the response is truncated. To retrieve the next set of job executions, use it in the next request.
        public let nextToken: String?
        /// Whether to sort results by the Name or CreationTime field. The default is CreationTime.
        public let sortBy: MonitoringJobDefinitionSortKey?
        /// Whether to sort the results in Ascending or Descending order. The default is Descending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: MonitoringJobDefinitionSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelBiasJobDefinitionsResponse: AWSDecodableShape {
        /// A JSON array in which each element is a summary for a model bias jobs.
        public let jobDefinitionSummaries: [MonitoringJobDefinitionSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(jobDefinitionSummaries: [MonitoringJobDefinitionSummary], nextToken: String? = nil) {
            self.jobDefinitionSummaries = jobDefinitionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionSummaries = "JobDefinitionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelCardExportJobsRequest: AWSEncodableShape {
        /// Only list model card export jobs that were created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list model card export jobs that were created before the time specified.
        public let creationTimeBefore: Date?
        /// The maximum number of model card export jobs to list.
        public let maxResults: Int?
        /// Only list model card export jobs with names that contain the specified string.
        public let modelCardExportJobNameContains: String?
        /// List export jobs for the model card with the specified name.
        public let modelCardName: String
        /// List export jobs for the model card with the specified version.
        public let modelCardVersion: Int?
        /// If the response to a previous ListModelCardExportJobs request was truncated, the response includes a NextToken. To retrieve the next set of model card export jobs, use the token in the next request.
        public let nextToken: String?
        /// Sort model card export jobs by either name or creation time. Sorts by creation time by default.
        public let sortBy: ModelCardExportJobSortBy?
        /// Sort model card export jobs by ascending or descending order.
        public let sortOrder: ModelCardExportJobSortOrder?
        /// Only list model card export jobs with the specified status.
        public let statusEquals: ModelCardExportJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelCardExportJobNameContains: String? = nil, modelCardName: String, modelCardVersion: Int? = nil, nextToken: String? = nil, sortBy: ModelCardExportJobSortBy? = nil, sortOrder: ModelCardExportJobSortOrder? = nil, statusEquals: ModelCardExportJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelCardExportJobNameContains = modelCardExportJobNameContains
            self.modelCardName = modelCardName
            self.modelCardVersion = modelCardVersion
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelCardExportJobNameContains, name: "modelCardExportJobNameContains", parent: name, max: 63)
            try self.validate(self.modelCardExportJobNameContains, name: "modelCardExportJobNameContains", parent: name, min: 1)
            try self.validate(self.modelCardExportJobNameContains, name: "modelCardExportJobNameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modelCardExportJobNameContains = "ModelCardExportJobNameContains"
            case modelCardName = "ModelCardName"
            case modelCardVersion = "ModelCardVersion"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListModelCardExportJobsResponse: AWSDecodableShape {
        /// The summaries of the listed model card export jobs.
        public let modelCardExportJobSummaries: [ModelCardExportJobSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of model card export jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(modelCardExportJobSummaries: [ModelCardExportJobSummary], nextToken: String? = nil) {
            self.modelCardExportJobSummaries = modelCardExportJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardExportJobSummaries = "ModelCardExportJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelCardVersionsRequest: AWSEncodableShape {
        /// Only list model card versions that were created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list model card versions that were created before the time specified.
        public let creationTimeBefore: Date?
        /// The maximum number of model card versions to list.
        public let maxResults: Int?
        /// List model card versions for the model card with the specified name.
        public let modelCardName: String
        /// Only list model card versions with the specified approval status.
        public let modelCardStatus: ModelCardStatus?
        /// If the response to a previous ListModelCardVersions request was truncated, the response includes a NextToken. To retrieve the next set of model card versions, use the token in the next request.
        public let nextToken: String?
        /// Sort listed model card versions by version. Sorts by version by default.
        public let sortBy: ModelCardVersionSortBy?
        /// Sort model card versions by ascending or descending order.
        public let sortOrder: ModelCardSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelCardName: String, modelCardStatus: ModelCardStatus? = nil, nextToken: String? = nil, sortBy: ModelCardVersionSortBy? = nil, sortOrder: ModelCardSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelCardVersionsResponse: AWSDecodableShape {
        /// The summaries of the listed versions of the model card.
        public let modelCardVersionSummaryList: [ModelCardVersionSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of model card versions, use it in the subsequent request.
        public let nextToken: String?

        public init(modelCardVersionSummaryList: [ModelCardVersionSummary], nextToken: String? = nil) {
            self.modelCardVersionSummaryList = modelCardVersionSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardVersionSummaryList = "ModelCardVersionSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelCardsRequest: AWSEncodableShape {
        /// Only list model cards that were created after the time specified.
        public let creationTimeAfter: Date?
        /// Only list model cards that were created before the time specified.
        public let creationTimeBefore: Date?
        /// The maximum number of model cards to list.
        public let maxResults: Int?
        /// Only list model cards with the specified approval status.
        public let modelCardStatus: ModelCardStatus?
        /// Only list model cards with names that contain the specified string.
        public let nameContains: String?
        /// If the response to a previous ListModelCards request was truncated, the response includes a NextToken. To retrieve the next set of model cards, use the token in the next request.
        public let nextToken: String?
        /// Sort model cards by either name or creation time. Sorts by creation time by default.
        public let sortBy: ModelCardSortBy?
        /// Sort model cards by ascending or descending order.
        public let sortOrder: ModelCardSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelCardStatus: ModelCardStatus? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelCardSortBy? = nil, sortOrder: ModelCardSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelCardStatus = modelCardStatus
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modelCardStatus = "ModelCardStatus"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelCardsResponse: AWSDecodableShape {
        /// The summaries of the listed model cards.
        public let modelCardSummaries: [ModelCardSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of model cards, use it in the subsequent request.
        public let nextToken: String?

        public init(modelCardSummaries: [ModelCardSummary], nextToken: String? = nil) {
            self.modelCardSummaries = modelCardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardSummaries = "ModelCardSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelExplainabilityJobDefinitionsRequest: AWSEncodableShape {
        /// A filter that returns only model explainability jobs created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only model explainability jobs created before a specified time.
        public let creationTimeBefore: Date?
        /// Name of the endpoint to monitor for model explainability.
        public let endpointName: String?
        /// The maximum number of jobs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// Filter for model explainability jobs whose name contains a specified string.
        public let nameContains: String?
        /// The token returned if the response is truncated. To retrieve the next set of job executions, use it in the next request.
        public let nextToken: String?
        /// Whether to sort results by the Name or CreationTime field. The default is CreationTime.
        public let sortBy: MonitoringJobDefinitionSortKey?
        /// Whether to sort the results in Ascending or Descending order. The default is Descending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: MonitoringJobDefinitionSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelExplainabilityJobDefinitionsResponse: AWSDecodableShape {
        /// A JSON array in which each element is a summary for a explainability bias jobs.
        public let jobDefinitionSummaries: [MonitoringJobDefinitionSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(jobDefinitionSummaries: [MonitoringJobDefinitionSummary], nextToken: String? = nil) {
            self.jobDefinitionSummaries = jobDefinitionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionSummaries = "JobDefinitionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelMetadataRequest: AWSEncodableShape {
        /// The maximum number of models to return in the response.
        public let maxResults: Int?
        /// If the response to a previous ListModelMetadataResponse request was truncated,  the response includes a NextToken. To retrieve the next set of model metadata,  use the token in the next request.
        public let nextToken: String?
        /// One or more filters that searches for the specified resource or resources  in a search. All resource objects that satisfy the expression's condition are  included in the search results. Specify the  Framework, FrameworkVersion, Domain  or Task to filter supported. Filter names and values are case-sensitive.
        public let searchExpression: ModelMetadataSearchExpression?

        public init(maxResults: Int? = nil, nextToken: String? = nil, searchExpression: ModelMetadataSearchExpression? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.searchExpression?.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchExpression = "SearchExpression"
        }
    }

    public struct ListModelMetadataResponse: AWSDecodableShape {
        /// A structure that holds model metadata.
        public let modelMetadataSummaries: [ModelMetadataSummary]
        /// A token for getting the next set of recommendations, if there are any.
        public let nextToken: String?

        public init(modelMetadataSummaries: [ModelMetadataSummary], nextToken: String? = nil) {
            self.modelMetadataSummaries = modelMetadataSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelMetadataSummaries = "ModelMetadataSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelPackageGroupsInput: AWSEncodableShape {
        /// A filter that returns only model groups created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only model groups created before the specified time.
        public let creationTimeBefore: Date?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A string in the model group name. This filter returns only model groups whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListModelPackageGroups request was truncated, the response includes a NextToken. To retrieve the next set of model groups, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: ModelPackageGroupSortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelPackageGroupSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelPackageGroupsOutput: AWSDecodableShape {
        /// A list of summaries of the model groups in your Amazon Web Services account.
        public let modelPackageGroupSummaryList: [ModelPackageGroupSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of model groups, use it in the subsequent request.
        public let nextToken: String?

        public init(modelPackageGroupSummaryList: [ModelPackageGroupSummary], nextToken: String? = nil) {
            self.modelPackageGroupSummaryList = modelPackageGroupSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupSummaryList = "ModelPackageGroupSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelPackagesInput: AWSEncodableShape {
        /// A filter that returns only model packages created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only model packages created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// The maximum number of model packages to return in the response.
        public let maxResults: Int?
        /// A filter that returns only the model packages with the specified approval status.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// A filter that returns only model versions that belong to the specified model group.
        public let modelPackageGroupName: String?
        /// A filter that returns only the model packages of the specified type. This can be one of the following values.    UNVERSIONED - List only unversioined models.  This is the default value if no ModelPackageType is specified.    VERSIONED - List only versioned models.    BOTH - List both versioned and unversioned models.
        public let modelPackageType: ModelPackageType?
        /// A string in the model package name. This filter returns only model packages whose name contains the specified string.
        public let nameContains: String?
        /// If the response to a previous ListModelPackages request was truncated, the response includes a NextToken. To retrieve the next set of model packages, use the token in the next request.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: ModelPackageSortBy?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelApprovalStatus: ModelApprovalStatus? = nil, modelPackageGroupName: String? = nil, modelPackageType: ModelPackageType? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelPackageSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelApprovalStatus = modelApprovalStatus
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageType = modelPackageType
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 170)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageType = "ModelPackageType"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelPackagesOutput: AWSDecodableShape {
        /// An array of ModelPackageSummary objects, each of which lists a model package.
        public let modelPackageSummaryList: [ModelPackageSummary]
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of model packages, use it in the subsequent request.
        public let nextToken: String?

        public init(modelPackageSummaryList: [ModelPackageSummary], nextToken: String? = nil) {
            self.modelPackageSummaryList = modelPackageSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageSummaryList = "ModelPackageSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelQualityJobDefinitionsRequest: AWSEncodableShape {
        /// A filter that returns only model quality monitoring job definitions created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only model quality monitoring job definitions created before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only model quality monitoring job definitions that are associated with the specified endpoint.
        public let endpointName: String?
        /// The maximum number of results to return in a call to ListModelQualityJobDefinitions.
        public let maxResults: Int?
        /// A string in the transform job name. This filter returns only model quality monitoring job definitions whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListModelQualityJobDefinitions request was truncated, the response includes a NextToken. To retrieve the next set of model quality monitoring job definitions, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: MonitoringJobDefinitionSortKey?
        /// The sort order for results. The default is Descending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: MonitoringJobDefinitionSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelQualityJobDefinitionsResponse: AWSDecodableShape {
        /// A list of summaries of model quality monitoring job definitions.
        public let jobDefinitionSummaries: [MonitoringJobDefinitionSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of model quality monitoring job definitions, use it in the next request.
        public let nextToken: String?

        public init(jobDefinitionSummaries: [MonitoringJobDefinitionSummary], nextToken: String? = nil) {
            self.jobDefinitionSummaries = jobDefinitionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobDefinitionSummaries = "JobDefinitionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelsInput: AWSEncodableShape {
        /// A filter that returns only models with a creation time greater than or equal to the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only models created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// The maximum number of models to return in the response.
        public let maxResults: Int?
        /// A string in the model name. This filter returns only models whose name contains the specified string.
        public let nameContains: String?
        /// If the response to a previous ListModels request was truncated, the response includes a NextToken. To retrieve the next set of models, use the token in the next request.
        public let nextToken: String?
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: ModelSortKey?
        /// The sort order for results. The default is Descending.
        public let sortOrder: OrderKey?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelSortKey? = nil, sortOrder: OrderKey? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListModelsOutput: AWSDecodableShape {
        /// An array of ModelSummary objects, each of which lists a model.
        public let models: [ModelSummary]
        ///  If the response is truncated, SageMaker returns this token. To retrieve the next set of models, use it in the subsequent request.
        public let nextToken: String?

        public init(models: [ModelSummary], nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models = "Models"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoringAlertHistoryRequest: AWSEncodableShape {
        /// A filter that returns only alerts created on or after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only alerts created on or before the specified time.
        public let creationTimeBefore: Date?
        /// The maximum number of results to display. The default is 100.
        public let maxResults: Int?
        /// The name of a monitoring alert.
        public let monitoringAlertName: String?
        /// The name of a monitoring schedule.
        public let monitoringScheduleName: String?
        /// If the result of the previous ListMonitoringAlertHistory request was truncated, the response includes a NextToken. To retrieve the next set of alerts in the history, use the token in the next request.
        public let nextToken: String?
        /// The field used to sort results. The default is CreationTime.
        public let sortBy: MonitoringAlertHistorySortKey?
        /// The sort order, whether Ascending or Descending, of the alert history. The default is Descending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only alerts with a specific status.
        public let statusEquals: MonitoringAlertStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, monitoringAlertName: String? = nil, monitoringScheduleName: String? = nil, nextToken: String? = nil, sortBy: MonitoringAlertHistorySortKey? = nil, sortOrder: SortOrder? = nil, statusEquals: MonitoringAlertStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.monitoringAlertName = monitoringAlertName
            self.monitoringScheduleName = monitoringScheduleName
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, max: 63)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, min: 1)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case monitoringAlertName = "MonitoringAlertName"
            case monitoringScheduleName = "MonitoringScheduleName"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListMonitoringAlertHistoryResponse: AWSDecodableShape {
        /// An alert history for a model monitoring schedule.
        public let monitoringAlertHistory: [MonitoringAlertHistorySummary]?
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of alerts, use it in the subsequent request.
        public let nextToken: String?

        public init(monitoringAlertHistory: [MonitoringAlertHistorySummary]? = nil, nextToken: String? = nil) {
            self.monitoringAlertHistory = monitoringAlertHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringAlertHistory = "MonitoringAlertHistory"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoringAlertsRequest: AWSEncodableShape {
        /// The maximum number of results to display. The default is 100.
        public let maxResults: Int?
        /// The name of a monitoring schedule.
        public let monitoringScheduleName: String
        /// If the result of the previous ListMonitoringAlerts request was truncated, the response includes a NextToken. To retrieve the next set of alerts in the history, use the token in the next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, monitoringScheduleName: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.monitoringScheduleName = monitoringScheduleName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case monitoringScheduleName = "MonitoringScheduleName"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoringAlertsResponse: AWSDecodableShape {
        /// A JSON array where each element is a summary for a monitoring alert.
        public let monitoringAlertSummaries: [MonitoringAlertSummary]?
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of alerts, use it in the subsequent request.
        public let nextToken: String?

        public init(monitoringAlertSummaries: [MonitoringAlertSummary]? = nil, nextToken: String? = nil) {
            self.monitoringAlertSummaries = monitoringAlertSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringAlertSummaries = "MonitoringAlertSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoringExecutionsRequest: AWSEncodableShape {
        /// A filter that returns only jobs created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only jobs created before a specified time.
        public let creationTimeBefore: Date?
        /// Name of a specific endpoint to fetch jobs for.
        public let endpointName: String?
        /// A filter that returns only jobs modified before a specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only jobs modified after a specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of jobs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// Gets a list of the monitoring job runs of the specified monitoring job definitions.
        public let monitoringJobDefinitionName: String?
        /// Name of a specific schedule to fetch jobs for.
        public let monitoringScheduleName: String?
        /// A filter that returns only the monitoring job runs of the specified monitoring type.
        public let monitoringTypeEquals: MonitoringType?
        /// The token returned if the response is truncated. To retrieve the next set of job executions, use it in the next request.
        public let nextToken: String?
        /// Filter for jobs scheduled after a specified time.
        public let scheduledTimeAfter: Date?
        /// Filter for jobs scheduled before a specified time.
        public let scheduledTimeBefore: Date?
        /// Whether to sort results by Status, CreationTime, ScheduledTime field. The default is CreationTime.
        public let sortBy: MonitoringExecutionSortKey?
        /// Whether to sort the results in Ascending or Descending order. The default is Descending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only jobs with a specific status.
        public let statusEquals: ExecutionStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, monitoringJobDefinitionName: String? = nil, monitoringScheduleName: String? = nil, monitoringTypeEquals: MonitoringType? = nil, nextToken: String? = nil, scheduledTimeAfter: Date? = nil, scheduledTimeBefore: Date? = nil, sortBy: MonitoringExecutionSortKey? = nil, sortOrder: SortOrder? = nil, statusEquals: ExecutionStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringTypeEquals = monitoringTypeEquals
            self.nextToken = nextToken
            self.scheduledTimeAfter = scheduledTimeAfter
            self.scheduledTimeBefore = scheduledTimeBefore
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, max: 63)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, min: 1)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringTypeEquals = "MonitoringTypeEquals"
            case nextToken = "NextToken"
            case scheduledTimeAfter = "ScheduledTimeAfter"
            case scheduledTimeBefore = "ScheduledTimeBefore"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListMonitoringExecutionsResponse: AWSDecodableShape {
        /// A JSON array in which each element is a summary for a monitoring execution.
        public let monitoringExecutionSummaries: [MonitoringExecutionSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs, use it in the subsequent reques
        public let nextToken: String?

        public init(monitoringExecutionSummaries: [MonitoringExecutionSummary], nextToken: String? = nil) {
            self.monitoringExecutionSummaries = monitoringExecutionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringExecutionSummaries = "MonitoringExecutionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoringSchedulesRequest: AWSEncodableShape {
        /// A filter that returns only monitoring schedules created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only monitoring schedules created before a specified time.
        public let creationTimeBefore: Date?
        /// Name of a specific endpoint to fetch schedules for.
        public let endpointName: String?
        /// A filter that returns only monitoring schedules modified after a specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only monitoring schedules modified before a specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of jobs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// Gets a list of the monitoring schedules for the specified monitoring job definition.
        public let monitoringJobDefinitionName: String?
        /// A filter that returns only the monitoring schedules for the specified monitoring type.
        public let monitoringTypeEquals: MonitoringType?
        /// Filter for monitoring schedules whose name contains a specified string.
        public let nameContains: String?
        /// The token returned if the response is truncated. To retrieve the next set of job executions, use it in the next request.
        public let nextToken: String?
        /// Whether to sort results by Status, CreationTime, ScheduledTime field. The default is CreationTime.
        public let sortBy: MonitoringScheduleSortKey?
        /// Whether to sort the results in Ascending or Descending order. The default is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only monitoring schedules modified before a specified time.
        public let statusEquals: ScheduleStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endpointName: String? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, monitoringJobDefinitionName: String? = nil, monitoringTypeEquals: MonitoringType? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: MonitoringScheduleSortKey? = nil, sortOrder: SortOrder? = nil, statusEquals: ScheduleStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endpointName = endpointName
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
            self.monitoringTypeEquals = monitoringTypeEquals
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, max: 63)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, min: 1)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case endpointName = "EndpointName"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
            case monitoringTypeEquals = "MonitoringTypeEquals"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListMonitoringSchedulesResponse: AWSDecodableShape {
        /// A JSON array in which each element is a summary for a monitoring schedule.
        public let monitoringScheduleSummaries: [MonitoringScheduleSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of jobs, use it in the subsequent request.
        public let nextToken: String?

        public init(monitoringScheduleSummaries: [MonitoringScheduleSummary], nextToken: String? = nil) {
            self.monitoringScheduleSummaries = monitoringScheduleSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleSummaries = "MonitoringScheduleSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListNotebookInstanceLifecycleConfigsInput: AWSEncodableShape {
        /// A filter that returns only lifecycle configurations that were created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only lifecycle configurations that were created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A filter that returns only lifecycle configurations that were modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only lifecycle configurations that were modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of lifecycle configurations to return in the response.
        public let maxResults: Int?
        /// A string in the lifecycle configuration name. This filter returns only lifecycle configurations whose name contains the specified string.
        public let nameContains: String?
        /// If the result of a ListNotebookInstanceLifecycleConfigs request was truncated, the response includes a NextToken. To get the next set of lifecycle configurations, use the token in the next request.
        public let nextToken: String?
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: NotebookInstanceLifecycleConfigSortKey?
        /// The sort order for results.
        public let sortOrder: NotebookInstanceLifecycleConfigSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: NotebookInstanceLifecycleConfigSortKey? = nil, sortOrder: NotebookInstanceLifecycleConfigSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListNotebookInstanceLifecycleConfigsOutput: AWSDecodableShape {
        /// If the response is truncated, SageMaker returns this token. To get the next set of lifecycle configurations, use it in the next request.
        public let nextToken: String?
        /// An array of NotebookInstanceLifecycleConfiguration objects, each listing a lifecycle configuration.
        public let notebookInstanceLifecycleConfigs: [NotebookInstanceLifecycleConfigSummary]?

        public init(nextToken: String? = nil, notebookInstanceLifecycleConfigs: [NotebookInstanceLifecycleConfigSummary]? = nil) {
            self.nextToken = nextToken
            self.notebookInstanceLifecycleConfigs = notebookInstanceLifecycleConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notebookInstanceLifecycleConfigs = "NotebookInstanceLifecycleConfigs"
        }
    }

    public struct ListNotebookInstancesInput: AWSEncodableShape {
        /// A filter that returns only notebook instances with associated with the specified git repository.
        public let additionalCodeRepositoryEquals: String?
        /// A filter that returns only notebook instances that were created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only notebook instances that were created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A string in the name or URL of a Git repository associated with this notebook instance. This filter returns only notebook instances associated with a git repository with a name that contains the specified string.
        public let defaultCodeRepositoryContains: String?
        /// A filter that returns only notebook instances that were modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only notebook instances that were modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of notebook instances to return.
        public let maxResults: Int?
        /// A string in the notebook instances' name. This filter returns only notebook instances whose name contains the specified string.
        public let nameContains: String?
        ///  If the previous call to the ListNotebookInstances is truncated, the response includes a NextToken. You can use this token in your subsequent ListNotebookInstances request to fetch the next set of notebook instances.   You might specify a filter or a sort order in your request. When response is truncated, you must use the same values for the filer and sort order in the next request.
        public let nextToken: String?
        /// A string in the name of a notebook instances lifecycle configuration associated with this notebook instance. This filter returns only notebook instances associated with a lifecycle configuration with a name that contains the specified string.
        public let notebookInstanceLifecycleConfigNameContains: String?
        /// The field to sort results by. The default is Name.
        public let sortBy: NotebookInstanceSortKey?
        /// The sort order for results.
        public let sortOrder: NotebookInstanceSortOrder?
        /// A filter that returns only notebook instances with the specified status.
        public let statusEquals: NotebookInstanceStatus?

        public init(additionalCodeRepositoryEquals: String? = nil, creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, defaultCodeRepositoryContains: String? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, notebookInstanceLifecycleConfigNameContains: String? = nil, sortBy: NotebookInstanceSortKey? = nil, sortOrder: NotebookInstanceSortOrder? = nil, statusEquals: NotebookInstanceStatus? = nil) {
            self.additionalCodeRepositoryEquals = additionalCodeRepositoryEquals
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.defaultCodeRepositoryContains = defaultCodeRepositoryContains
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.notebookInstanceLifecycleConfigNameContains = notebookInstanceLifecycleConfigNameContains
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalCodeRepositoryEquals, name: "additionalCodeRepositoryEquals", parent: name, max: 1024)
            try self.validate(self.additionalCodeRepositoryEquals, name: "additionalCodeRepositoryEquals", parent: name, min: 1)
            try self.validate(self.additionalCodeRepositoryEquals, name: "additionalCodeRepositoryEquals", parent: name, pattern: "^https://([^/]+)/?(.*)$|^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.defaultCodeRepositoryContains, name: "defaultCodeRepositoryContains", parent: name, max: 1024)
            try self.validate(self.defaultCodeRepositoryContains, name: "defaultCodeRepositoryContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.notebookInstanceLifecycleConfigNameContains, name: "notebookInstanceLifecycleConfigNameContains", parent: name, max: 63)
            try self.validate(self.notebookInstanceLifecycleConfigNameContains, name: "notebookInstanceLifecycleConfigNameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalCodeRepositoryEquals = "AdditionalCodeRepositoryEquals"
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case defaultCodeRepositoryContains = "DefaultCodeRepositoryContains"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case notebookInstanceLifecycleConfigNameContains = "NotebookInstanceLifecycleConfigNameContains"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListNotebookInstancesOutput: AWSDecodableShape {
        /// If the response to the previous ListNotebookInstances request was truncated, SageMaker returns this token. To retrieve the next set of notebook instances, use the token in the next request.
        public let nextToken: String?
        /// An array of NotebookInstanceSummary objects, one for each notebook instance.
        public let notebookInstances: [NotebookInstanceSummary]?

        public init(nextToken: String? = nil, notebookInstances: [NotebookInstanceSummary]? = nil) {
            self.nextToken = nextToken
            self.notebookInstances = notebookInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notebookInstances = "NotebookInstances"
        }
    }

    public struct ListPipelineExecutionStepsRequest: AWSEncodableShape {
        /// The maximum number of pipeline execution steps to return in the response.
        public let maxResults: Int?
        /// If the result of the previous ListPipelineExecutionSteps request was truncated, the response includes a NextToken. To retrieve the next set of pipeline execution steps, use the token in the next request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?
        /// The field by which to sort results. The default is CreatedTime.
        public let sortOrder: SortOrder?

        public init(maxResults: Int? = nil, nextToken: String? = nil, pipelineExecutionArn: String? = nil, sortOrder: SortOrder? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pipelineExecutionArn = pipelineExecutionArn
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pipelineExecutionArn = "PipelineExecutionArn"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListPipelineExecutionStepsResponse: AWSDecodableShape {
        /// If the result of the previous ListPipelineExecutionSteps request was truncated, the response includes a NextToken. To retrieve the next set of pipeline execution steps, use the token in the next request.
        public let nextToken: String?
        /// A list of PipeLineExecutionStep objects. Each PipeLineExecutionStep consists of StepName, StartTime, EndTime, StepStatus, and Metadata. Metadata is an object with properties for each job that contains relevant information about the job created by the step.
        public let pipelineExecutionSteps: [PipelineExecutionStep]?

        public init(nextToken: String? = nil, pipelineExecutionSteps: [PipelineExecutionStep]? = nil) {
            self.nextToken = nextToken
            self.pipelineExecutionSteps = pipelineExecutionSteps
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelineExecutionSteps = "PipelineExecutionSteps"
        }
    }

    public struct ListPipelineExecutionsRequest: AWSEncodableShape {
        /// A filter that returns the pipeline executions that were created after a specified time.
        public let createdAfter: Date?
        /// A filter that returns the pipeline executions that were created before a specified time.
        public let createdBefore: Date?
        /// The maximum number of pipeline executions to return in the response.
        public let maxResults: Int?
        /// If the result of the previous ListPipelineExecutions request was truncated, the response includes a NextToken. To retrieve the next set of pipeline executions, use the token in the next request.
        public let nextToken: String?
        /// The name of the pipeline.
        public let pipelineName: String
        /// The field by which to sort results. The default is CreatedTime.
        public let sortBy: SortPipelineExecutionsBy?
        /// The sort order for results.
        public let sortOrder: SortOrder?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, pipelineName: String, sortBy: SortPipelineExecutionsBy? = nil, sortOrder: SortOrder? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pipelineName = pipelineName
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 2048)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline/.*)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pipelineName = "PipelineName"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListPipelineExecutionsResponse: AWSDecodableShape {
        /// If the result of the previous ListPipelineExecutions request was truncated, the response includes a NextToken. To retrieve the next set of pipeline executions, use the token in the next request.
        public let nextToken: String?
        /// Contains a sorted list of pipeline execution summary objects matching the specified filters. Each run summary includes the Amazon Resource Name (ARN) of the pipeline execution, the run date, and the status. This list can be empty.
        public let pipelineExecutionSummaries: [PipelineExecutionSummary]?

        public init(nextToken: String? = nil, pipelineExecutionSummaries: [PipelineExecutionSummary]? = nil) {
            self.nextToken = nextToken
            self.pipelineExecutionSummaries = pipelineExecutionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelineExecutionSummaries = "PipelineExecutionSummaries"
        }
    }

    public struct ListPipelineParametersForExecutionRequest: AWSEncodableShape {
        /// The maximum number of parameters to return in the response.
        public let maxResults: Int?
        /// If the result of the previous ListPipelineParametersForExecution request was truncated, the response includes a NextToken. To retrieve the next set of parameters, use the token in the next request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, pipelineExecutionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct ListPipelineParametersForExecutionResponse: AWSDecodableShape {
        /// If the result of the previous ListPipelineParametersForExecution request was truncated, the response includes a NextToken. To retrieve the next set of parameters, use the token in the next request.
        public let nextToken: String?
        /// Contains a list of pipeline parameters. This list can be empty.
        public let pipelineParameters: [Parameter]?

        public init(nextToken: String? = nil, pipelineParameters: [Parameter]? = nil) {
            self.nextToken = nextToken
            self.pipelineParameters = pipelineParameters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelineParameters = "PipelineParameters"
        }
    }

    public struct ListPipelinesRequest: AWSEncodableShape {
        /// A filter that returns the pipelines that were created after a specified time.
        public let createdAfter: Date?
        /// A filter that returns the pipelines that were created before a specified time.
        public let createdBefore: Date?
        /// The maximum number of pipelines to return in the response.
        public let maxResults: Int?
        /// If the result of the previous ListPipelines request was truncated, the response includes a NextToken. To retrieve the next set of pipelines, use the token in the next request.
        public let nextToken: String?
        /// The prefix of the pipeline name.
        public let pipelineNamePrefix: String?
        /// The field by which to sort results. The default is CreatedTime.
        public let sortBy: SortPipelinesBy?
        /// The sort order for results.
        public let sortOrder: SortOrder?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, pipelineNamePrefix: String? = nil, sortBy: SortPipelinesBy? = nil, sortOrder: SortOrder? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pipelineNamePrefix = pipelineNamePrefix
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.pipelineNamePrefix, name: "pipelineNamePrefix", parent: name, max: 256)
            try self.validate(self.pipelineNamePrefix, name: "pipelineNamePrefix", parent: name, min: 1)
            try self.validate(self.pipelineNamePrefix, name: "pipelineNamePrefix", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pipelineNamePrefix = "PipelineNamePrefix"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListPipelinesResponse: AWSDecodableShape {
        /// If the result of the previous ListPipelines request was truncated, the response includes a NextToken. To retrieve the next set of pipelines, use the token in the next request.
        public let nextToken: String?
        /// Contains a sorted list of PipelineSummary objects matching the specified filters. Each PipelineSummary consists of PipelineArn, PipelineName, ExperimentName, PipelineDescription, CreationTime, LastModifiedTime, LastRunTime, and RoleArn. This list can be empty.
        public let pipelineSummaries: [PipelineSummary]?

        public init(nextToken: String? = nil, pipelineSummaries: [PipelineSummary]? = nil) {
            self.nextToken = nextToken
            self.pipelineSummaries = pipelineSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelineSummaries = "PipelineSummaries"
        }
    }

    public struct ListProcessingJobsRequest: AWSEncodableShape {
        /// A filter that returns only processing jobs created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only processing jobs created after the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only processing jobs modified after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only processing jobs modified before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of processing jobs to return in the response.
        public let maxResults: Int?
        /// A string in the processing job name. This filter returns only processing jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListProcessingJobs request was truncated, the response includes a NextToken. To retrieve the next set of processing jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only processing jobs with a specific status.
        public let statusEquals: ProcessingJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: ProcessingJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListProcessingJobsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of processing jobs, use it in the subsequent request.
        public let nextToken: String?
        /// An array of ProcessingJobSummary objects, each listing a processing job.
        public let processingJobSummaries: [ProcessingJobSummary]

        public init(nextToken: String? = nil, processingJobSummaries: [ProcessingJobSummary]) {
            self.nextToken = nextToken
            self.processingJobSummaries = processingJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case processingJobSummaries = "ProcessingJobSummaries"
        }
    }

    public struct ListProjectsInput: AWSEncodableShape {
        /// A filter that returns the projects that were created after a specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns the projects that were created before a specified time.
        public let creationTimeBefore: Date?
        /// The maximum number of projects to return in the response.
        public let maxResults: Int?
        /// A filter that returns the projects whose name contains a specified string.
        public let nameContains: String?
        /// If the result of the previous ListProjects request was truncated, the response includes a NextToken. To retrieve the next set of projects, use the token in the next request.
        public let nextToken: String?
        /// The field by which to sort results. The default is CreationTime.
        public let sortBy: ProjectSortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: ProjectSortOrder?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ProjectSortBy? = nil, sortOrder: ProjectSortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 32)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListProjectsOutput: AWSDecodableShape {
        /// If the result of the previous ListCompilationJobs request was truncated, the response includes a NextToken. To retrieve the next set of model compilation jobs, use the token in the next request.
        public let nextToken: String?
        /// A list of summaries of projects.
        public let projectSummaryList: [ProjectSummary]

        public init(nextToken: String? = nil, projectSummaryList: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaryList = projectSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projectSummaryList = "ProjectSummaryList"
        }
    }

    public struct ListSpacesRequest: AWSEncodableShape {
        /// A parameter to search for the Domain ID.
        public let domainIdEquals: String?
        /// Returns a list up to a specified limit.
        public let maxResults: Int?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: SpaceSortKey?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A parameter by which to filter the results.
        public let spaceNameContains: String?

        public init(domainIdEquals: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SpaceSortKey? = nil, sortOrder: SortOrder? = nil, spaceNameContains: String? = nil) {
            self.domainIdEquals = domainIdEquals
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.spaceNameContains = spaceNameContains
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdEquals, name: "domainIdEquals", parent: name, max: 63)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.spaceNameContains, name: "spaceNameContains", parent: name, max: 63)
            try self.validate(self.spaceNameContains, name: "spaceNameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainIdEquals = "DomainIdEquals"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case spaceNameContains = "SpaceNameContains"
        }
    }

    public struct ListSpacesResponse: AWSDecodableShape {
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The list of spaces.
        public let spaces: [SpaceDetails]?

        public init(nextToken: String? = nil, spaces: [SpaceDetails]? = nil) {
            self.nextToken = nextToken
            self.spaces = spaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case spaces = "Spaces"
        }
    }

    public struct ListStageDevicesRequest: AWSEncodableShape {
        /// The name of the edge deployment plan.
        public let edgeDeploymentPlanName: String
        /// Toggle for excluding devices deployed in other stages.
        public let excludeDevicesDeployedInOtherStage: Bool?
        /// The maximum number of requests to select.
        public let maxResults: Int?
        /// The response from the last list when returning a list large enough to neeed tokening.
        public let nextToken: String?
        /// The name of the stage in the deployment.
        public let stageName: String

        public init(edgeDeploymentPlanName: String, excludeDevicesDeployedInOtherStage: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, stageName: String) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.excludeDevicesDeployedInOtherStage = excludeDevicesDeployedInOtherStage
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 63)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case excludeDevicesDeployedInOtherStage = "ExcludeDevicesDeployedInOtherStage"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case stageName = "StageName"
        }
    }

    public struct ListStageDevicesResponse: AWSDecodableShape {
        /// List of summaries of devices allocated to the stage.
        public let deviceDeploymentSummaries: [DeviceDeploymentSummary]
        /// The token to use when calling the next page of results.
        public let nextToken: String?

        public init(deviceDeploymentSummaries: [DeviceDeploymentSummary], nextToken: String? = nil) {
            self.deviceDeploymentSummaries = deviceDeploymentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceDeploymentSummaries = "DeviceDeploymentSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListStudioLifecycleConfigsRequest: AWSEncodableShape {
        /// A parameter to search for the App Type to which the Lifecycle Configuration is attached.
        public let appTypeEquals: StudioLifecycleConfigAppType?
        /// A filter that returns only Lifecycle Configurations created on or after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only Lifecycle Configurations created on or before the specified time.
        public let creationTimeBefore: Date?
        /// The maximum number of Studio Lifecycle Configurations to return in the response. The default value is 10.
        public let maxResults: Int?
        /// A filter that returns only Lifecycle Configurations modified after the specified time.
        public let modifiedTimeAfter: Date?
        /// A filter that returns only Lifecycle Configurations modified before the specified time.
        public let modifiedTimeBefore: Date?
        /// A string in the Lifecycle Configuration name. This filter returns only Lifecycle Configurations whose name contains the specified string.
        public let nameContains: String?
        /// If the previous call to ListStudioLifecycleConfigs didn't return the full set of Lifecycle Configurations, the call returns a token for getting the next set of Lifecycle Configurations.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: StudioLifecycleConfigSortKey?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?

        public init(appTypeEquals: StudioLifecycleConfigAppType? = nil, creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modifiedTimeAfter: Date? = nil, modifiedTimeBefore: Date? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: StudioLifecycleConfigSortKey? = nil, sortOrder: SortOrder? = nil) {
            self.appTypeEquals = appTypeEquals
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modifiedTimeAfter = modifiedTimeAfter
            self.modifiedTimeBefore = modifiedTimeBefore
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case appTypeEquals = "AppTypeEquals"
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case modifiedTimeAfter = "ModifiedTimeAfter"
            case modifiedTimeBefore = "ModifiedTimeBefore"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListStudioLifecycleConfigsResponse: AWSDecodableShape {
        /// A token for getting the next set of actions, if there are any.
        public let nextToken: String?
        /// A list of Lifecycle Configurations and their properties.
        public let studioLifecycleConfigs: [StudioLifecycleConfigDetails]?

        public init(nextToken: String? = nil, studioLifecycleConfigs: [StudioLifecycleConfigDetails]? = nil) {
            self.nextToken = nextToken
            self.studioLifecycleConfigs = studioLifecycleConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case studioLifecycleConfigs = "StudioLifecycleConfigs"
        }
    }

    public struct ListSubscribedWorkteamsRequest: AWSEncodableShape {
        /// The maximum number of work teams to return in each page of the response.
        public let maxResults: Int?
        /// A string in the work team name. This filter returns only work teams whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListSubscribedWorkteams request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
        }
    }

    public struct ListSubscribedWorkteamsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of work teams, use it in the subsequent request.
        public let nextToken: String?
        /// An array of Workteam objects, each describing a work team.
        public let subscribedWorkteams: [SubscribedWorkteam]

        public init(nextToken: String? = nil, subscribedWorkteams: [SubscribedWorkteam]) {
            self.nextToken = nextToken
            self.subscribedWorkteams = subscribedWorkteams
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case subscribedWorkteams = "SubscribedWorkteams"
        }
    }

    public struct ListTagsInput: AWSEncodableShape {
        /// Maximum number of tags to return.
        public let maxResults: Int?
        ///  If the response to the previous ListTags request is truncated, SageMaker returns this token. To retrieve the next set of tags, use it in the subsequent request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z-]*:sagemaker:[a-z0-9-]*:[0-9]{12}:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsOutput: AWSDecodableShape {
        ///  If response is truncated, SageMaker includes a token in the response. You can use this token in your subsequent request to fetch next set of tokens.
        public let nextToken: String?
        /// An array of Tag objects, each with a tag key and a value.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListTrainingJobsForHyperParameterTuningJobRequest: AWSEncodableShape {
        /// The name of the tuning job whose training jobs you want to list.
        public let hyperParameterTuningJobName: String
        /// The maximum number of training jobs to return. The default value is 10.
        public let maxResults: Int?
        /// If the result of the previous ListTrainingJobsForHyperParameterTuningJob request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is Name. If the value of this field is FinalObjectiveMetricValue, any training jobs that did not return an objective metric are not listed.
        public let sortBy: TrainingJobSortByOptions?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that returns only training jobs with the specified status.
        public let statusEquals: TrainingJobStatus?

        public init(hyperParameterTuningJobName: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: TrainingJobSortByOptions? = nil, sortOrder: SortOrder? = nil, statusEquals: TrainingJobStatus? = nil) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, max: 32)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, min: 1)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListTrainingJobsForHyperParameterTuningJobResponse: AWSDecodableShape {
        /// If the result of this ListTrainingJobsForHyperParameterTuningJob request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request.
        public let nextToken: String?
        /// A list of TrainingJobSummary objects that describe the training jobs that the ListTrainingJobsForHyperParameterTuningJob request returned.
        public let trainingJobSummaries: [HyperParameterTrainingJobSummary]

        public init(nextToken: String? = nil, trainingJobSummaries: [HyperParameterTrainingJobSummary]) {
            self.nextToken = nextToken
            self.trainingJobSummaries = trainingJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trainingJobSummaries = "TrainingJobSummaries"
        }
    }

    public struct ListTrainingJobsRequest: AWSEncodableShape {
        /// A filter that returns only training jobs created after the specified time (timestamp).
        public let creationTimeAfter: Date?
        /// A filter that returns only training jobs created before the specified time (timestamp).
        public let creationTimeBefore: Date?
        /// A filter that returns only training jobs modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only training jobs modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of training jobs to return in the response.
        public let maxResults: Int?
        /// A string in the training job name. This filter returns only training jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListTrainingJobs request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only training jobs with a specific status.
        public let statusEquals: TrainingJobStatus?
        /// A filter that retrieves only training jobs with a specific warm pool status.
        public let warmPoolStatusEquals: WarmPoolResourceStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: TrainingJobStatus? = nil, warmPoolStatusEquals: WarmPoolResourceStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
            self.warmPoolStatusEquals = warmPoolStatusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
            case warmPoolStatusEquals = "WarmPoolStatusEquals"
        }
    }

    public struct ListTrainingJobsResponse: AWSDecodableShape {
        /// If the response is truncated, SageMaker returns this token. To retrieve the next set of training jobs, use it in the subsequent request.
        public let nextToken: String?
        /// An array of TrainingJobSummary objects, each listing a training job.
        public let trainingJobSummaries: [TrainingJobSummary]

        public init(nextToken: String? = nil, trainingJobSummaries: [TrainingJobSummary]) {
            self.nextToken = nextToken
            self.trainingJobSummaries = trainingJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trainingJobSummaries = "TrainingJobSummaries"
        }
    }

    public struct ListTransformJobsRequest: AWSEncodableShape {
        /// A filter that returns only transform jobs created after the specified time.
        public let creationTimeAfter: Date?
        /// A filter that returns only transform jobs created before the specified time.
        public let creationTimeBefore: Date?
        /// A filter that returns only transform jobs modified after the specified time.
        public let lastModifiedTimeAfter: Date?
        /// A filter that returns only transform jobs modified before the specified time.
        public let lastModifiedTimeBefore: Date?
        /// The maximum number of transform jobs to return in the response. The default value is 10.
        public let maxResults: Int?
        /// A string in the transform job name. This filter returns only transform jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListTransformJobs request was truncated, the response includes a NextToken. To retrieve the next set of transform jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// The sort order for results. The default is Descending.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only transform jobs with a specific status.
        public let statusEquals: TransformJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, lastModifiedTimeAfter: Date? = nil, lastModifiedTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: TransformJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter = "CreationTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListTransformJobsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of transform jobs, use it in the next request.
        public let nextToken: String?
        /// An array of TransformJobSummary objects.
        public let transformJobSummaries: [TransformJobSummary]

        public init(nextToken: String? = nil, transformJobSummaries: [TransformJobSummary]) {
            self.nextToken = nextToken
            self.transformJobSummaries = transformJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transformJobSummaries = "TransformJobSummaries"
        }
    }

    public struct ListTrialComponentsRequest: AWSEncodableShape {
        /// A filter that returns only components created after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only components created before the specified time.
        public let createdBefore: Date?
        /// A filter that returns only components that are part of the specified experiment. If you specify ExperimentName, you can't filter by SourceArn or TrialName.
        public let experimentName: String?
        /// The maximum number of components to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListTrialComponents didn't return the full set of components, the call returns a token for getting the next set of components.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortTrialComponentsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only components that have the specified source Amazon Resource Name (ARN).  If you specify SourceArn, you can't filter by ExperimentName or TrialName.
        public let sourceArn: String?
        /// A filter that returns only components that are part of the specified trial. If you specify TrialName, you can't filter by ExperimentName or SourceArn.
        public let trialName: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, experimentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortTrialComponentsBy? = nil, sortOrder: SortOrder? = nil, sourceArn: String? = nil, trialName: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.experimentName = experimentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceArn = sourceArn
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 256)
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case experimentName = "ExperimentName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case sourceArn = "SourceArn"
            case trialName = "TrialName"
        }
    }

    public struct ListTrialComponentsResponse: AWSDecodableShape {
        /// A token for getting the next set of components, if there are any.
        public let nextToken: String?
        /// A list of the summaries of your trial components.
        public let trialComponentSummaries: [TrialComponentSummary]?

        public init(nextToken: String? = nil, trialComponentSummaries: [TrialComponentSummary]? = nil) {
            self.nextToken = nextToken
            self.trialComponentSummaries = trialComponentSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trialComponentSummaries = "TrialComponentSummaries"
        }
    }

    public struct ListTrialsRequest: AWSEncodableShape {
        /// A filter that returns only trials created after the specified time.
        public let createdAfter: Date?
        /// A filter that returns only trials created before the specified time.
        public let createdBefore: Date?
        /// A filter that returns only trials that are part of the specified experiment.
        public let experimentName: String?
        /// The maximum number of trials to return in the response. The default value is 10.
        public let maxResults: Int?
        /// If the previous call to ListTrials didn't return the full set of trials, the call returns a token for getting the next set of trials.
        public let nextToken: String?
        /// The property used to sort results. The default value is CreationTime.
        public let sortBy: SortTrialsBy?
        /// The sort order. The default value is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only trials that are associated with the specified trial component.
        public let trialComponentName: String?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, experimentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortTrialsBy? = nil, sortOrder: SortOrder? = nil, trialComponentName: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.experimentName = experimentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.trialComponentName = trialComponentName
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case experimentName = "ExperimentName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct ListTrialsResponse: AWSDecodableShape {
        /// A token for getting the next set of trials, if there are any.
        public let nextToken: String?
        /// A list of the summaries of your trials.
        public let trialSummaries: [TrialSummary]?

        public init(nextToken: String? = nil, trialSummaries: [TrialSummary]? = nil) {
            self.nextToken = nextToken
            self.trialSummaries = trialSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trialSummaries = "TrialSummaries"
        }
    }

    public struct ListUserProfilesRequest: AWSEncodableShape {
        /// A parameter by which to filter the results.
        public let domainIdEquals: String?
        /// Returns a list up to a specified limit.
        public let maxResults: Int?
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: UserProfileSortKey?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A parameter by which to filter the results.
        public let userProfileNameContains: String?

        public init(domainIdEquals: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: UserProfileSortKey? = nil, sortOrder: SortOrder? = nil, userProfileNameContains: String? = nil) {
            self.domainIdEquals = domainIdEquals
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.userProfileNameContains = userProfileNameContains
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdEquals, name: "domainIdEquals", parent: name, max: 63)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.userProfileNameContains, name: "userProfileNameContains", parent: name, max: 63)
            try self.validate(self.userProfileNameContains, name: "userProfileNameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainIdEquals = "DomainIdEquals"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case userProfileNameContains = "UserProfileNameContains"
        }
    }

    public struct ListUserProfilesResponse: AWSDecodableShape {
        /// If the previous response was truncated, you will receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The list of user profiles.
        public let userProfiles: [UserProfileDetails]?

        public init(nextToken: String? = nil, userProfiles: [UserProfileDetails]? = nil) {
            self.nextToken = nextToken
            self.userProfiles = userProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userProfiles = "UserProfiles"
        }
    }

    public struct ListWorkforcesRequest: AWSEncodableShape {
        /// The maximum number of workforces returned in the response.
        public let maxResults: Int?
        /// A filter you can use to search for workforces using part of the workforce name.
        public let nameContains: String?
        /// A token to resume pagination.
        public let nextToken: String?
        /// Sort workforces using the workforce name or creation date.
        public let sortBy: ListWorkforcesSortByOptions?
        /// Sort workforces in ascending or descending order.
        public let sortOrder: SortOrder?

        public init(maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListWorkforcesSortByOptions? = nil, sortOrder: SortOrder? = nil) {
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListWorkforcesResponse: AWSDecodableShape {
        /// A token to resume pagination.
        public let nextToken: String?
        /// A list containing information about your workforce.
        public let workforces: [Workforce]

        public init(nextToken: String? = nil, workforces: [Workforce]) {
            self.nextToken = nextToken
            self.workforces = workforces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workforces = "Workforces"
        }
    }

    public struct ListWorkteamsRequest: AWSEncodableShape {
        /// The maximum number of work teams to return in each page of the response.
        public let maxResults: Int?
        /// A string in the work team's name. This filter returns only work teams whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListWorkteams request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: ListWorkteamsSortByOptions?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListWorkteamsSortByOptions? = nil, sortOrder: SortOrder? = nil) {
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListWorkteamsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of work teams, use it in the subsequent request.
        public let nextToken: String?
        /// An array of Workteam objects, each describing a work team.
        public let workteams: [Workteam]

        public init(nextToken: String? = nil, workteams: [Workteam]) {
            self.nextToken = nextToken
            self.workteams = workteams
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workteams = "Workteams"
        }
    }

    public struct MemberDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Cognito user group that is part of the work team.
        public let cognitoMemberDefinition: CognitoMemberDefinition?
        /// A list user groups that exist in your OIDC Identity Provider (IdP).  One to ten groups can be used to create a single private work team.  When you add a user group to the list of Groups, you can add that user group to one or more private work teams. If you add a user group to a private work team, all workers in that user group  are added to the work team.
        public let oidcMemberDefinition: OidcMemberDefinition?

        public init(cognitoMemberDefinition: CognitoMemberDefinition? = nil, oidcMemberDefinition: OidcMemberDefinition? = nil) {
            self.cognitoMemberDefinition = cognitoMemberDefinition
            self.oidcMemberDefinition = oidcMemberDefinition
        }

        public func validate(name: String) throws {
            try self.cognitoMemberDefinition?.validate(name: "\(name).cognitoMemberDefinition")
            try self.oidcMemberDefinition?.validate(name: "\(name).oidcMemberDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case cognitoMemberDefinition = "CognitoMemberDefinition"
            case oidcMemberDefinition = "OidcMemberDefinition"
        }
    }

    public struct MetadataProperties: AWSEncodableShape & AWSDecodableShape {
        /// The commit ID.
        public let commitId: String?
        /// The entity this entity was generated by.
        public let generatedBy: String?
        /// The project ID.
        public let projectId: String?
        /// The repository.
        public let repository: String?

        public init(commitId: String? = nil, generatedBy: String? = nil, projectId: String? = nil, repository: String? = nil) {
            self.commitId = commitId
            self.generatedBy = generatedBy
            self.projectId = projectId
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.commitId, name: "commitId", parent: name, max: 1024)
            try self.validate(self.commitId, name: "commitId", parent: name, pattern: ".*")
            try self.validate(self.generatedBy, name: "generatedBy", parent: name, max: 1024)
            try self.validate(self.generatedBy, name: "generatedBy", parent: name, pattern: ".*")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 1024)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: ".*")
            try self.validate(self.repository, name: "repository", parent: name, max: 1024)
            try self.validate(self.repository, name: "repository", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case commitId = "CommitId"
            case generatedBy = "GeneratedBy"
            case projectId = "ProjectId"
            case repository = "Repository"
        }
    }

    public struct MetricData: AWSDecodableShape {
        /// The name of the metric.
        public let metricName: String?
        /// The date and time that the algorithm emitted the metric.
        public let timestamp: Date?
        /// The value of the metric.
        public let value: Float?

        public init(metricName: String? = nil, timestamp: Date? = nil, value: Float? = nil) {
            self.metricName = metricName
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case timestamp = "Timestamp"
            case value = "Value"
        }
    }

    public struct MetricDatum: AWSDecodableShape {
        /// The name of the metric.
        public let metricName: AutoMLMetricEnum?
        /// The dataset split from which the AutoML job produced the metric.
        public let set: MetricSetSource?
        /// The name of the standard metric.   For definitions of the standard metrics, see  Autopilot candidate metrics .
        public let standardMetricName: AutoMLMetricExtendedEnum?
        /// The value of the metric.
        public let value: Float?

        public init(metricName: AutoMLMetricEnum? = nil, set: MetricSetSource? = nil, standardMetricName: AutoMLMetricExtendedEnum? = nil, value: Float? = nil) {
            self.metricName = metricName
            self.set = set
            self.standardMetricName = standardMetricName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case set = "Set"
            case standardMetricName = "StandardMetricName"
            case value = "Value"
        }
    }

    public struct MetricDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let name: String
        /// A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see Defining Objective Metrics.
        public let regex: String

        public init(name: String, regex: String) {
            self.name = name
            self.regex = regex
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.+$")
            try self.validate(self.regex, name: "regex", parent: name, max: 500)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case regex = "Regex"
        }
    }

    public struct MetricsSource: AWSEncodableShape & AWSDecodableShape {
        /// The hash key used for the metrics source.
        public let contentDigest: String?
        /// The metric source content type.
        public let contentType: String
        /// The S3 URI for the metrics source.
        public let s3Uri: String

        public init(contentDigest: String? = nil, contentType: String, s3Uri: String) {
            self.contentDigest = contentDigest
            self.contentType = contentType
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.contentDigest, name: "contentDigest", parent: name, max: 72)
            try self.validate(self.contentDigest, name: "contentDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentDigest = "ContentDigest"
            case contentType = "ContentType"
            case s3Uri = "S3Uri"
        }
    }

    public struct Model: AWSDecodableShape {
        /// The containers in the inference pipeline.
        public let containers: [ContainerDefinition]?
        /// A timestamp that indicates when the model was created.
        public let creationTime: Date?
        /// Isolates the model container. No inbound or outbound network calls can be made to or from the model container.
        public let enableNetworkIsolation: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the model.
        public let executionRoleArn: String?
        public let inferenceExecutionConfig: InferenceExecutionConfig?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?
        /// The name of the model.
        public let modelName: String?
        public let primaryContainer: ContainerDefinition?
        /// A list of key-value pairs associated with the model. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?
        public let vpcConfig: VpcConfig?

        public init(containers: [ContainerDefinition]? = nil, creationTime: Date? = nil, enableNetworkIsolation: Bool? = nil, executionRoleArn: String? = nil, inferenceExecutionConfig: InferenceExecutionConfig? = nil, modelArn: String? = nil, modelName: String? = nil, primaryContainer: ContainerDefinition? = nil, tags: [Tag]? = nil, vpcConfig: VpcConfig? = nil) {
            self.containers = containers
            self.creationTime = creationTime
            self.enableNetworkIsolation = enableNetworkIsolation
            self.executionRoleArn = executionRoleArn
            self.inferenceExecutionConfig = inferenceExecutionConfig
            self.modelArn = modelArn
            self.modelName = modelName
            self.primaryContainer = primaryContainer
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case creationTime = "CreationTime"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case executionRoleArn = "ExecutionRoleArn"
            case inferenceExecutionConfig = "InferenceExecutionConfig"
            case modelArn = "ModelArn"
            case modelName = "ModelName"
            case primaryContainer = "PrimaryContainer"
            case tags = "Tags"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct ModelArtifacts: AWSDecodableShape {
        /// The path of the S3 object that contains the model artifacts. For example, s3://bucket-name/keynameprefix/model.tar.gz.
        public let s3ModelArtifacts: String

        public init(s3ModelArtifacts: String) {
            self.s3ModelArtifacts = s3ModelArtifacts
        }

        private enum CodingKeys: String, CodingKey {
            case s3ModelArtifacts = "S3ModelArtifacts"
        }
    }

    public struct ModelBiasAppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// JSON formatted S3 file that defines bias parameters. For more information on this JSON configuration file, see Configure bias parameters.
        public let configUri: String
        /// Sets the environment variables in the Docker container.
        public let environment: [String: String]?
        /// The container image to be run by the model bias job.
        public let imageUri: String

        public init(configUri: String, environment: [String: String]? = nil, imageUri: String) {
            self.configUri = configUri
            self.environment = environment
            self.imageUri = imageUri
        }

        public func validate(name: String) throws {
            try self.validate(self.configUri, name: "configUri", parent: name, max: 1024)
            try self.validate(self.configUri, name: "configUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 50)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case configUri = "ConfigUri"
            case environment = "Environment"
            case imageUri = "ImageUri"
        }
    }

    public struct ModelBiasBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the baseline model bias job.
        public let baseliningJobName: String?
        public let constraintsResource: MonitoringConstraintsResource?

        public init(baseliningJobName: String? = nil, constraintsResource: MonitoringConstraintsResource? = nil) {
            self.baseliningJobName = baseliningJobName
            self.constraintsResource = constraintsResource
        }

        public func validate(name: String) throws {
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, max: 63)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, min: 1)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.constraintsResource?.validate(name: "\(name).constraintsResource")
        }

        private enum CodingKeys: String, CodingKey {
            case baseliningJobName = "BaseliningJobName"
            case constraintsResource = "ConstraintsResource"
        }
    }

    public struct ModelBiasJobInput: AWSEncodableShape & AWSDecodableShape {
        /// Input object for the batch transform job.
        public let batchTransformInput: BatchTransformInput?
        public let endpointInput: EndpointInput?
        /// Location of ground truth labels to use in model bias job.
        public let groundTruthS3Input: MonitoringGroundTruthS3Input

        public init(batchTransformInput: BatchTransformInput? = nil, endpointInput: EndpointInput? = nil, groundTruthS3Input: MonitoringGroundTruthS3Input) {
            self.batchTransformInput = batchTransformInput
            self.endpointInput = endpointInput
            self.groundTruthS3Input = groundTruthS3Input
        }

        public func validate(name: String) throws {
            try self.batchTransformInput?.validate(name: "\(name).batchTransformInput")
            try self.endpointInput?.validate(name: "\(name).endpointInput")
            try self.groundTruthS3Input.validate(name: "\(name).groundTruthS3Input")
        }

        private enum CodingKeys: String, CodingKey {
            case batchTransformInput = "BatchTransformInput"
            case endpointInput = "EndpointInput"
            case groundTruthS3Input = "GroundTruthS3Input"
        }
    }

    public struct ModelCard: AWSDecodableShape {
        /// The content of the model card. Content uses the model card JSON schema and provided as a string.
        public let content: String?
        public let createdBy: UserContext?
        /// The date and time that the model card was created.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// The date and time that the model card was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the model card.
        public let modelCardArn: String?
        /// The unique name of the model card.
        public let modelCardName: String?
        /// The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus?
        /// The version of the model card.
        public let modelCardVersion: Int?
        /// The unique name (ID) of the model.
        public let modelId: String?
        /// The risk rating of the model. Different organizations might have different criteria for model card risk ratings. For more information, see Risk ratings.
        public let riskRating: String?
        /// The security configuration used to protect model card data.
        public let securityConfig: ModelCardSecurityConfig?
        /// Key-value pairs used to manage metadata for the model card.
        public let tags: [Tag]?

        public init(content: String? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, modelCardArn: String? = nil, modelCardName: String? = nil, modelCardStatus: ModelCardStatus? = nil, modelCardVersion: Int? = nil, modelId: String? = nil, riskRating: String? = nil, securityConfig: ModelCardSecurityConfig? = nil, tags: [Tag]? = nil) {
            self.content = content
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.modelCardArn = modelCardArn
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
            self.modelCardVersion = modelCardVersion
            self.modelId = modelId
            self.riskRating = riskRating
            self.securityConfig = securityConfig
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case modelCardArn = "ModelCardArn"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
            case modelCardVersion = "ModelCardVersion"
            case modelId = "ModelId"
            case riskRating = "RiskRating"
            case securityConfig = "SecurityConfig"
            case tags = "Tags"
        }
    }

    public struct ModelCardExportArtifacts: AWSDecodableShape {
        /// The Amazon S3 URI of the exported model artifacts.
        public let s3ExportArtifacts: String

        public init(s3ExportArtifacts: String) {
            self.s3ExportArtifacts = s3ExportArtifacts
        }

        private enum CodingKeys: String, CodingKey {
            case s3ExportArtifacts = "S3ExportArtifacts"
        }
    }

    public struct ModelCardExportJobSummary: AWSDecodableShape {
        /// The date and time that the model card export job was created.
        public let createdAt: Date
        /// The date and time that the model card export job was last modified..
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the model card export job.
        public let modelCardExportJobArn: String
        /// The name of the model card export job.
        public let modelCardExportJobName: String
        /// The name of the model card that the export job exports.
        public let modelCardName: String
        /// The version of the model card that the export job exports.
        public let modelCardVersion: Int
        /// The completion status of the model card export job.
        public let status: ModelCardExportJobStatus

        public init(createdAt: Date, lastModifiedAt: Date, modelCardExportJobArn: String, modelCardExportJobName: String, modelCardName: String, modelCardVersion: Int, status: ModelCardExportJobStatus) {
            self.createdAt = createdAt
            self.lastModifiedAt = lastModifiedAt
            self.modelCardExportJobArn = modelCardExportJobArn
            self.modelCardExportJobName = modelCardExportJobName
            self.modelCardName = modelCardName
            self.modelCardVersion = modelCardVersion
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case lastModifiedAt = "LastModifiedAt"
            case modelCardExportJobArn = "ModelCardExportJobArn"
            case modelCardExportJobName = "ModelCardExportJobName"
            case modelCardName = "ModelCardName"
            case modelCardVersion = "ModelCardVersion"
            case status = "Status"
        }
    }

    public struct ModelCardExportOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 output path to export your model card PDF.
        public let s3OutputPath: String

        public init(s3OutputPath: String) {
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct ModelCardSecurityConfig: AWSEncodableShape & AWSDecodableShape {
        /// A Key Management Service key ID to use for encrypting a model card.
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ModelCardSummary: AWSDecodableShape {
        /// The date and time that the model card was created.
        public let creationTime: Date
        /// The date and time that the model card was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the model card.
        public let modelCardArn: String
        /// The name of the model card.
        public let modelCardName: String
        /// The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus

        public init(creationTime: Date, lastModifiedTime: Date? = nil, modelCardArn: String, modelCardName: String, modelCardStatus: ModelCardStatus) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.modelCardArn = modelCardArn
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case modelCardArn = "ModelCardArn"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
        }
    }

    public struct ModelCardVersionSummary: AWSDecodableShape {
        /// The date and time that the model card version was created.
        public let creationTime: Date
        /// The time date and time that the model card version was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the model card.
        public let modelCardArn: String
        /// The name of the model card.
        public let modelCardName: String
        /// The approval status of the model card version within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus
        /// A version of the model card.
        public let modelCardVersion: Int

        public init(creationTime: Date, lastModifiedTime: Date? = nil, modelCardArn: String, modelCardName: String, modelCardStatus: ModelCardStatus, modelCardVersion: Int) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.modelCardArn = modelCardArn
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
            self.modelCardVersion = modelCardVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case modelCardArn = "ModelCardArn"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
            case modelCardVersion = "ModelCardVersion"
        }
    }

    public struct ModelClientConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of retries when invocation requests are failing. The default value is 3.
        public let invocationsMaxRetries: Int?
        /// The timeout value in seconds for an invocation request. The default value is 600.
        public let invocationsTimeoutInSeconds: Int?

        public init(invocationsMaxRetries: Int? = nil, invocationsTimeoutInSeconds: Int? = nil) {
            self.invocationsMaxRetries = invocationsMaxRetries
            self.invocationsTimeoutInSeconds = invocationsTimeoutInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationsMaxRetries, name: "invocationsMaxRetries", parent: name, max: 3)
            try self.validate(self.invocationsMaxRetries, name: "invocationsMaxRetries", parent: name, min: 0)
            try self.validate(self.invocationsTimeoutInSeconds, name: "invocationsTimeoutInSeconds", parent: name, max: 3600)
            try self.validate(self.invocationsTimeoutInSeconds, name: "invocationsTimeoutInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invocationsMaxRetries = "InvocationsMaxRetries"
            case invocationsTimeoutInSeconds = "InvocationsTimeoutInSeconds"
        }
    }

    public struct ModelConfiguration: AWSDecodableShape {
        /// Defines the environment parameters that includes key, value types, and values.
        public let environmentParameters: [EnvironmentParameter]?
        /// The inference specification name in the model package version.
        public let inferenceSpecificationName: String?

        public init(environmentParameters: [EnvironmentParameter]? = nil, inferenceSpecificationName: String? = nil) {
            self.environmentParameters = environmentParameters
            self.inferenceSpecificationName = inferenceSpecificationName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentParameters = "EnvironmentParameters"
            case inferenceSpecificationName = "InferenceSpecificationName"
        }
    }

    public struct ModelDashboardEndpoint: AWSDecodableShape {
        /// A timestamp that indicates when the endpoint was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The endpoint name.
        public let endpointName: String
        /// The endpoint status.
        public let endpointStatus: EndpointStatus
        /// The last time the endpoint was modified.
        public let lastModifiedTime: Date

        public init(creationTime: Date, endpointArn: String, endpointName: String, endpointStatus: EndpointStatus, lastModifiedTime: Date) {
            self.creationTime = creationTime
            self.endpointArn = endpointArn
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointArn = "EndpointArn"
            case endpointName = "EndpointName"
            case endpointStatus = "EndpointStatus"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct ModelDashboardIndicatorAction: AWSDecodableShape {
        /// Indicates whether the alert action is turned on.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct ModelDashboardModel: AWSDecodableShape {
        /// The endpoints that host a model.
        public let endpoints: [ModelDashboardEndpoint]?
        public let lastBatchTransformJob: TransformJob?
        /// A model displayed in the Model Dashboard.
        public let model: Model?
        /// The model card for a model.
        public let modelCard: ModelDashboardModelCard?
        /// The monitoring schedules for a model.
        public let monitoringSchedules: [ModelDashboardMonitoringSchedule]?

        public init(endpoints: [ModelDashboardEndpoint]? = nil, lastBatchTransformJob: TransformJob? = nil, model: Model? = nil, modelCard: ModelDashboardModelCard? = nil, monitoringSchedules: [ModelDashboardMonitoringSchedule]? = nil) {
            self.endpoints = endpoints
            self.lastBatchTransformJob = lastBatchTransformJob
            self.model = model
            self.modelCard = modelCard
            self.monitoringSchedules = monitoringSchedules
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
            case lastBatchTransformJob = "LastBatchTransformJob"
            case model = "Model"
            case modelCard = "ModelCard"
            case monitoringSchedules = "MonitoringSchedules"
        }
    }

    public struct ModelDashboardModelCard: AWSDecodableShape {
        public let createdBy: UserContext?
        /// A timestamp that indicates when the model card was created.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// A timestamp that indicates when the model card was last updated.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) for a model card.
        public let modelCardArn: String?
        /// The name of a model card.
        public let modelCardName: String?
        /// The model card status.
        public let modelCardStatus: ModelCardStatus?
        /// The model card version.
        public let modelCardVersion: Int?
        /// For models created in SageMaker, this is the model ARN. For models created outside of SageMaker, this is a user-customized string.
        public let modelId: String?
        /// A model card's risk rating. Can be low, medium, or high.
        public let riskRating: String?
        /// The KMS Key ID (KMSKeyId) for encryption of model card information.
        public let securityConfig: ModelCardSecurityConfig?
        /// The tags associated with a model card.
        public let tags: [Tag]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, modelCardArn: String? = nil, modelCardName: String? = nil, modelCardStatus: ModelCardStatus? = nil, modelCardVersion: Int? = nil, modelId: String? = nil, riskRating: String? = nil, securityConfig: ModelCardSecurityConfig? = nil, tags: [Tag]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.modelCardArn = modelCardArn
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
            self.modelCardVersion = modelCardVersion
            self.modelId = modelId
            self.riskRating = riskRating
            self.securityConfig = securityConfig
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case modelCardArn = "ModelCardArn"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
            case modelCardVersion = "ModelCardVersion"
            case modelId = "ModelId"
            case riskRating = "RiskRating"
            case securityConfig = "SecurityConfig"
            case tags = "Tags"
        }
    }

    public struct ModelDashboardMonitoringSchedule: AWSDecodableShape {
        /// A timestamp that indicates when the monitoring schedule was created.
        public let creationTime: Date?
        /// The endpoint which is monitored.
        public let endpointName: String?
        /// If a monitoring job failed, provides the reason.
        public let failureReason: String?
        /// A timestamp that indicates when the monitoring schedule was last updated.
        public let lastModifiedTime: Date?
        public let lastMonitoringExecutionSummary: MonitoringExecutionSummary?
        /// A JSON array where each element is a summary for a monitoring alert.
        public let monitoringAlertSummaries: [MonitoringAlertSummary]?
        /// The Amazon Resource Name (ARN) of a monitoring schedule.
        public let monitoringScheduleArn: String?
        public let monitoringScheduleConfig: MonitoringScheduleConfig?
        /// The name of a monitoring schedule.
        public let monitoringScheduleName: String?
        /// The status of the monitoring schedule.
        public let monitoringScheduleStatus: ScheduleStatus?
        /// The monitor type of a model monitor.
        public let monitoringType: MonitoringType?

        public init(creationTime: Date? = nil, endpointName: String? = nil, failureReason: String? = nil, lastModifiedTime: Date? = nil, lastMonitoringExecutionSummary: MonitoringExecutionSummary? = nil, monitoringAlertSummaries: [MonitoringAlertSummary]? = nil, monitoringScheduleArn: String? = nil, monitoringScheduleConfig: MonitoringScheduleConfig? = nil, monitoringScheduleName: String? = nil, monitoringScheduleStatus: ScheduleStatus? = nil, monitoringType: MonitoringType? = nil) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.lastMonitoringExecutionSummary = lastMonitoringExecutionSummary
            self.monitoringAlertSummaries = monitoringAlertSummaries
            self.monitoringScheduleArn = monitoringScheduleArn
            self.monitoringScheduleConfig = monitoringScheduleConfig
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringScheduleStatus = monitoringScheduleStatus
            self.monitoringType = monitoringType
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case lastMonitoringExecutionSummary = "LastMonitoringExecutionSummary"
            case monitoringAlertSummaries = "MonitoringAlertSummaries"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case monitoringScheduleConfig = "MonitoringScheduleConfig"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringScheduleStatus = "MonitoringScheduleStatus"
            case monitoringType = "MonitoringType"
        }
    }

    public struct ModelDataQuality: AWSEncodableShape & AWSDecodableShape {
        /// Data quality constraints for a model.
        public let constraints: MetricsSource?
        /// Data quality statistics for a model.
        public let statistics: MetricsSource?

        public init(constraints: MetricsSource? = nil, statistics: MetricsSource? = nil) {
            self.constraints = constraints
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.statistics?.validate(name: "\(name).statistics")
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case statistics = "Statistics"
        }
    }

    public struct ModelDeployConfig: AWSEncodableShape & AWSDecodableShape {
        /// Set to True to automatically generate an endpoint name for a one-click Autopilot model deployment; set to False otherwise. The default value is False.  If you set AutoGenerateEndpointName to True, do not specify the EndpointName; otherwise a 400 error is thrown.
        public let autoGenerateEndpointName: Bool?
        /// Specifies the endpoint name to use for a one-click Autopilot model deployment if the endpoint name is not generated automatically.  Specify the EndpointName if and only if you set AutoGenerateEndpointName to False; otherwise a 400 error is thrown.
        public let endpointName: String?

        public init(autoGenerateEndpointName: Bool? = nil, endpointName: String? = nil) {
            self.autoGenerateEndpointName = autoGenerateEndpointName
            self.endpointName = endpointName
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case autoGenerateEndpointName = "AutoGenerateEndpointName"
            case endpointName = "EndpointName"
        }
    }

    public struct ModelDeployResult: AWSDecodableShape {
        /// The name of the endpoint to which the model has been deployed.  If model deployment fails, this field is omitted from the response.
        public let endpointName: String?

        public init(endpointName: String? = nil) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct ModelDigests: AWSDecodableShape {
        /// Provides a hash value that uniquely identifies the stored model artifacts.
        public let artifactDigest: String?

        public init(artifactDigest: String? = nil) {
            self.artifactDigest = artifactDigest
        }

        private enum CodingKeys: String, CodingKey {
            case artifactDigest = "ArtifactDigest"
        }
    }

    public struct ModelExplainabilityAppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// JSON formatted S3 file that defines explainability parameters. For more information on this JSON configuration file, see Configure model explainability parameters.
        public let configUri: String
        /// Sets the environment variables in the Docker container.
        public let environment: [String: String]?
        /// The container image to be run by the model explainability job.
        public let imageUri: String

        public init(configUri: String, environment: [String: String]? = nil, imageUri: String) {
            self.configUri = configUri
            self.environment = environment
            self.imageUri = imageUri
        }

        public func validate(name: String) throws {
            try self.validate(self.configUri, name: "configUri", parent: name, max: 1024)
            try self.validate(self.configUri, name: "configUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 50)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case configUri = "ConfigUri"
            case environment = "Environment"
            case imageUri = "ImageUri"
        }
    }

    public struct ModelExplainabilityBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the baseline model explainability job.
        public let baseliningJobName: String?
        public let constraintsResource: MonitoringConstraintsResource?

        public init(baseliningJobName: String? = nil, constraintsResource: MonitoringConstraintsResource? = nil) {
            self.baseliningJobName = baseliningJobName
            self.constraintsResource = constraintsResource
        }

        public func validate(name: String) throws {
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, max: 63)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, min: 1)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.constraintsResource?.validate(name: "\(name).constraintsResource")
        }

        private enum CodingKeys: String, CodingKey {
            case baseliningJobName = "BaseliningJobName"
            case constraintsResource = "ConstraintsResource"
        }
    }

    public struct ModelExplainabilityJobInput: AWSEncodableShape & AWSDecodableShape {
        /// Input object for the batch transform job.
        public let batchTransformInput: BatchTransformInput?
        public let endpointInput: EndpointInput?

        public init(batchTransformInput: BatchTransformInput? = nil, endpointInput: EndpointInput? = nil) {
            self.batchTransformInput = batchTransformInput
            self.endpointInput = endpointInput
        }

        public func validate(name: String) throws {
            try self.batchTransformInput?.validate(name: "\(name).batchTransformInput")
            try self.endpointInput?.validate(name: "\(name).endpointInput")
        }

        private enum CodingKeys: String, CodingKey {
            case batchTransformInput = "BatchTransformInput"
            case endpointInput = "EndpointInput"
        }
    }

    public struct ModelInfrastructureConfig: AWSEncodableShape & AWSDecodableShape {
        /// The inference option to which to deploy your model. Possible values are the following:    RealTime: Deploy to real-time inference.
        public let infrastructureType: ModelInfrastructureType
        /// The infrastructure configuration for deploying the model to real-time inference.
        public let realTimeInferenceConfig: RealTimeInferenceConfig

        public init(infrastructureType: ModelInfrastructureType, realTimeInferenceConfig: RealTimeInferenceConfig) {
            self.infrastructureType = infrastructureType
            self.realTimeInferenceConfig = realTimeInferenceConfig
        }

        public func validate(name: String) throws {
            try self.realTimeInferenceConfig.validate(name: "\(name).realTimeInferenceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureType = "InfrastructureType"
            case realTimeInferenceConfig = "RealTimeInferenceConfig"
        }
    }

    public struct ModelInput: AWSEncodableShape & AWSDecodableShape {
        /// The input configuration object for the model.
        public let dataInputConfig: String

        public init(dataInputConfig: String) {
            self.dataInputConfig = dataInputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, max: 1024)
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, min: 1)
            try self.validate(self.dataInputConfig, name: "dataInputConfig", parent: name, pattern: "^[\\S\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataInputConfig = "DataInputConfig"
        }
    }

    public struct ModelLatencyThreshold: AWSEncodableShape & AWSDecodableShape {
        /// The model latency percentile threshold.
        public let percentile: String?
        /// The model latency percentile value in milliseconds.
        public let valueInMilliseconds: Int?

        public init(percentile: String? = nil, valueInMilliseconds: Int? = nil) {
            self.percentile = percentile
            self.valueInMilliseconds = valueInMilliseconds
        }

        public func validate(name: String) throws {
            try self.validate(self.percentile, name: "percentile", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case percentile = "Percentile"
            case valueInMilliseconds = "ValueInMilliseconds"
        }
    }

    public struct ModelMetadataFilter: AWSEncodableShape {
        /// The name of the of the model to filter by.
        public let name: ModelMetadataFilterType
        /// The value to filter the model metadata.
        public let value: String

        public init(name: ModelMetadataFilterType, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct ModelMetadataSearchExpression: AWSEncodableShape {
        /// A list of filter objects.
        public let filters: [ModelMetadataFilter]?

        public init(filters: [ModelMetadataFilter]? = nil) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 4)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
        }
    }

    public struct ModelMetadataSummary: AWSDecodableShape {
        /// The machine learning domain of the model.
        public let domain: String
        /// The machine learning framework of the model.
        public let framework: String
        /// The framework version of the model.
        public let frameworkVersion: String
        /// The name of the model.
        public let model: String
        /// The machine learning task of the model.
        public let task: String

        public init(domain: String, framework: String, frameworkVersion: String, model: String, task: String) {
            self.domain = domain
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.model = model
            self.task = task
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case model = "Model"
            case task = "Task"
        }
    }

    public struct ModelMetrics: AWSEncodableShape & AWSDecodableShape {
        /// Metrics that measure bais in a model.
        public let bias: Bias?
        /// Metrics that help explain a model.
        public let explainability: Explainability?
        /// Metrics that measure the quality of the input data for a model.
        public let modelDataQuality: ModelDataQuality?
        /// Metrics that measure the quality of a model.
        public let modelQuality: ModelQuality?

        public init(bias: Bias? = nil, explainability: Explainability? = nil, modelDataQuality: ModelDataQuality? = nil, modelQuality: ModelQuality? = nil) {
            self.bias = bias
            self.explainability = explainability
            self.modelDataQuality = modelDataQuality
            self.modelQuality = modelQuality
        }

        public func validate(name: String) throws {
            try self.bias?.validate(name: "\(name).bias")
            try self.explainability?.validate(name: "\(name).explainability")
            try self.modelDataQuality?.validate(name: "\(name).modelDataQuality")
            try self.modelQuality?.validate(name: "\(name).modelQuality")
        }

        private enum CodingKeys: String, CodingKey {
            case bias = "Bias"
            case explainability = "Explainability"
            case modelDataQuality = "ModelDataQuality"
            case modelQuality = "ModelQuality"
        }
    }

    public struct ModelPackage: AWSDecodableShape {
        /// An array of additional Inference Specification objects.
        public let additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]?
        /// A description provided when the model approval is set.
        public let approvalDescription: String?
        /// Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For information about listing model packages on Amazon Web Services Marketplace, see List Your Algorithm or Model Package on Amazon Web Services Marketplace.
        public let certifyForMarketplace: Bool?
        /// Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.
        public let createdBy: UserContext?
        /// The time that the model package was created.
        public let creationTime: Date?
        /// The metadata properties for the model package.
        public let customerMetadataProperties: [String: String]?
        /// The machine learning domain of your model package and its components. Common  machine learning domains include computer vision and natural language processing.
        public let domain: String?
        /// Represents the drift check baselines that can be used when the model monitor is set using the model package.
        public let driftCheckBaselines: DriftCheckBaselines?
        /// Defines how to perform inference generation after a training job is run.
        public let inferenceSpecification: InferenceSpecification?
        /// Information about the user who created or modified an experiment, trial, trial component, lineage group, or project.
        public let lastModifiedBy: UserContext?
        /// The last time the model package was modified.
        public let lastModifiedTime: Date?
        /// Metadata properties of the tracking entity, trial, or trial component.
        public let metadataProperties: MetadataProperties?
        /// The approval status of the model. This can be one of the following values.    APPROVED - The model is approved    REJECTED - The model is rejected.    PENDING_MANUAL_APPROVAL - The model is waiting for manual approval.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// Metrics for the model.
        public let modelMetrics: ModelMetrics?
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String?
        /// The description of the model package.
        public let modelPackageDescription: String?
        /// The model group to which the model belongs.
        public let modelPackageGroupName: String?
        /// The name of the model.
        public let modelPackageName: String?
        /// The status of the model package. This can be one of the following values.    PENDING - The model package is pending being created.    IN_PROGRESS - The model package is in the process of being created.    COMPLETED - The model package was successfully created.    FAILED - The model package failed.    DELETING - The model package is in the process of being deleted.
        public let modelPackageStatus: ModelPackageStatus?
        /// Specifies the validation and image scan statuses of the model package.
        public let modelPackageStatusDetails: ModelPackageStatusDetails?
        /// The version number of a versioned model.
        public let modelPackageVersion: Int?
        /// The Amazon Simple Storage Service path where the sample payload are stored. This path must point to  a single gzip compressed tar archive (.tar.gz suffix).
        public let samplePayloadUrl: String?
        /// A list of algorithms that were used to create a model package.
        public let sourceAlgorithmSpecification: SourceAlgorithmSpecification?
        /// A list of the tags associated with the model package. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?
        /// The machine learning task your model package accomplishes. Common machine  learning tasks include object detection and image classification.
        public let task: String?
        /// Specifies batch transform jobs that SageMaker runs to validate your model package.
        public let validationSpecification: ModelPackageValidationSpecification?

        public init(additionalInferenceSpecifications: [AdditionalInferenceSpecificationDefinition]? = nil, approvalDescription: String? = nil, certifyForMarketplace: Bool? = nil, createdBy: UserContext? = nil, creationTime: Date? = nil, customerMetadataProperties: [String: String]? = nil, domain: String? = nil, driftCheckBaselines: DriftCheckBaselines? = nil, inferenceSpecification: InferenceSpecification? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, metadataProperties: MetadataProperties? = nil, modelApprovalStatus: ModelApprovalStatus? = nil, modelMetrics: ModelMetrics? = nil, modelPackageArn: String? = nil, modelPackageDescription: String? = nil, modelPackageGroupName: String? = nil, modelPackageName: String? = nil, modelPackageStatus: ModelPackageStatus? = nil, modelPackageStatusDetails: ModelPackageStatusDetails? = nil, modelPackageVersion: Int? = nil, samplePayloadUrl: String? = nil, sourceAlgorithmSpecification: SourceAlgorithmSpecification? = nil, tags: [Tag]? = nil, task: String? = nil, validationSpecification: ModelPackageValidationSpecification? = nil) {
            self.additionalInferenceSpecifications = additionalInferenceSpecifications
            self.approvalDescription = approvalDescription
            self.certifyForMarketplace = certifyForMarketplace
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.customerMetadataProperties = customerMetadataProperties
            self.domain = domain
            self.driftCheckBaselines = driftCheckBaselines
            self.inferenceSpecification = inferenceSpecification
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.metadataProperties = metadataProperties
            self.modelApprovalStatus = modelApprovalStatus
            self.modelMetrics = modelMetrics
            self.modelPackageArn = modelPackageArn
            self.modelPackageDescription = modelPackageDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageName = modelPackageName
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageStatusDetails = modelPackageStatusDetails
            self.modelPackageVersion = modelPackageVersion
            self.samplePayloadUrl = samplePayloadUrl
            self.sourceAlgorithmSpecification = sourceAlgorithmSpecification
            self.tags = tags
            self.task = task
            self.validationSpecification = validationSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInferenceSpecifications = "AdditionalInferenceSpecifications"
            case approvalDescription = "ApprovalDescription"
            case certifyForMarketplace = "CertifyForMarketplace"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case customerMetadataProperties = "CustomerMetadataProperties"
            case domain = "Domain"
            case driftCheckBaselines = "DriftCheckBaselines"
            case inferenceSpecification = "InferenceSpecification"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case metadataProperties = "MetadataProperties"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelMetrics = "ModelMetrics"
            case modelPackageArn = "ModelPackageArn"
            case modelPackageDescription = "ModelPackageDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageName = "ModelPackageName"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageStatusDetails = "ModelPackageStatusDetails"
            case modelPackageVersion = "ModelPackageVersion"
            case samplePayloadUrl = "SamplePayloadUrl"
            case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
            case tags = "Tags"
            case task = "Task"
            case validationSpecification = "ValidationSpecification"
        }
    }

    public struct ModelPackageContainerDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The DNS host name for the Docker container.
        public let containerHostname: String?
        /// The environment variables to set in the Docker container. Each key and value in the Environment string to string map can have length of up to 1024. We support up to 16 entries in the map.
        public let environment: [String: String]?
        /// The machine learning framework of the model package container image.
        public let framework: String?
        /// The framework version of the Model Package Container Image.
        public let frameworkVersion: String?
        /// The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored. If you are using your own custom algorithm instead of an algorithm provided by SageMaker, the inference code must meet SageMaker requirements. SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information, see Using Your Own Algorithms with Amazon SageMaker.
        public let image: String
        /// An MD5 hash of the training algorithm that identifies the Docker image used for training.
        public let imageDigest: String?
        /// The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).  The model artifacts must be in an S3 bucket that is in the same region as the model package.
        public let modelDataUrl: String?
        /// A structure with Model Input details.
        public let modelInput: ModelInput?
        /// The name of a pre-trained machine learning benchmarked by  Amazon SageMaker Inference Recommender model that matches your model.  You can find a list of benchmarked models by calling ListModelMetadata.
        public let nearestModelName: String?
        /// The Amazon Web Services Marketplace product ID of the model package.
        public let productId: String?

        public init(containerHostname: String? = nil, environment: [String: String]? = nil, framework: String? = nil, frameworkVersion: String? = nil, image: String, imageDigest: String? = nil, modelDataUrl: String? = nil, modelInput: ModelInput? = nil, nearestModelName: String? = nil, productId: String? = nil) {
            self.containerHostname = containerHostname
            self.environment = environment
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.image = image
            self.imageDigest = imageDigest
            self.modelDataUrl = modelDataUrl
            self.modelInput = modelInput
            self.nearestModelName = nearestModelName
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.containerHostname, name: "containerHostname", parent: name, max: 63)
            try self.validate(self.containerHostname, name: "containerHostname", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 1024)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 16)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, max: 10)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, min: 3)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, pattern: "^[0-9]\\.[A-Za-z0-9.-]+$")
            try self.validate(self.image, name: "image", parent: name, max: 255)
            try self.validate(self.image, name: "image", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, max: 72)
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, max: 1024)
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.modelInput?.validate(name: "\(name).modelInput")
            try self.validate(self.productId, name: "productId", parent: name, max: 256)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerHostname = "ContainerHostname"
            case environment = "Environment"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case image = "Image"
            case imageDigest = "ImageDigest"
            case modelDataUrl = "ModelDataUrl"
            case modelInput = "ModelInput"
            case nearestModelName = "NearestModelName"
            case productId = "ProductId"
        }
    }

    public struct ModelPackageGroup: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The time that the model group was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the model group.
        public let modelPackageGroupArn: String?
        /// The description for the model group.
        public let modelPackageGroupDescription: String?
        /// The name of the model group.
        public let modelPackageGroupName: String?
        /// The status of the model group. This can be one of the following values.    PENDING - The model group is pending being created.    IN_PROGRESS - The model group is in the process of being created.    COMPLETED - The model group was successfully created.    FAILED - The model group failed.    DELETING - The model group is in the process of being deleted.    DELETE_FAILED - SageMaker failed to delete the model group.
        public let modelPackageGroupStatus: ModelPackageGroupStatus?
        /// A list of the tags associated with the model group. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, modelPackageGroupArn: String? = nil, modelPackageGroupDescription: String? = nil, modelPackageGroupName: String? = nil, modelPackageGroupStatus: ModelPackageGroupStatus? = nil, tags: [Tag]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.modelPackageGroupArn = modelPackageGroupArn
            self.modelPackageGroupDescription = modelPackageGroupDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageGroupStatus = modelPackageGroupStatus
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case modelPackageGroupArn = "ModelPackageGroupArn"
            case modelPackageGroupDescription = "ModelPackageGroupDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageGroupStatus = "ModelPackageGroupStatus"
            case tags = "Tags"
        }
    }

    public struct ModelPackageGroupSummary: AWSDecodableShape {
        /// The time that the model group was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model group.
        public let modelPackageGroupArn: String
        /// A description of the model group.
        public let modelPackageGroupDescription: String?
        /// The name of the model group.
        public let modelPackageGroupName: String
        /// The status of the model group.
        public let modelPackageGroupStatus: ModelPackageGroupStatus

        public init(creationTime: Date, modelPackageGroupArn: String, modelPackageGroupDescription: String? = nil, modelPackageGroupName: String, modelPackageGroupStatus: ModelPackageGroupStatus) {
            self.creationTime = creationTime
            self.modelPackageGroupArn = modelPackageGroupArn
            self.modelPackageGroupDescription = modelPackageGroupDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageGroupStatus = modelPackageGroupStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case modelPackageGroupArn = "ModelPackageGroupArn"
            case modelPackageGroupDescription = "ModelPackageGroupDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageGroupStatus = "ModelPackageGroupStatus"
        }
    }

    public struct ModelPackageStatusDetails: AWSDecodableShape {
        /// The status of the scan of the Docker image container for the model package.
        public let imageScanStatuses: [ModelPackageStatusItem]?
        /// The validation status of the model package.
        public let validationStatuses: [ModelPackageStatusItem]

        public init(imageScanStatuses: [ModelPackageStatusItem]? = nil, validationStatuses: [ModelPackageStatusItem]) {
            self.imageScanStatuses = imageScanStatuses
            self.validationStatuses = validationStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanStatuses = "ImageScanStatuses"
            case validationStatuses = "ValidationStatuses"
        }
    }

    public struct ModelPackageStatusItem: AWSDecodableShape {
        /// if the overall status is Failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the model package for which the overall status is being reported.
        public let name: String
        /// The current status.
        public let status: DetailedModelPackageStatus

        public init(failureReason: String? = nil, name: String, status: DetailedModelPackageStatus) {
            self.failureReason = failureReason
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct ModelPackageSummary: AWSDecodableShape {
        /// A timestamp that shows when the model package was created.
        public let creationTime: Date
        /// The approval status of the model. This can be one of the following values.    APPROVED - The model is approved    REJECTED - The model is rejected.    PENDING_MANUAL_APPROVAL - The model is waiting for manual approval.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String
        /// A brief description of the model package.
        public let modelPackageDescription: String?
        /// If the model package is a versioned model, the model group that the versioned model belongs to.
        public let modelPackageGroupName: String?
        /// The name of the model package.
        public let modelPackageName: String
        /// The overall status of the model package.
        public let modelPackageStatus: ModelPackageStatus
        /// If the model package is a versioned model, the version of the model.
        public let modelPackageVersion: Int?

        public init(creationTime: Date, modelApprovalStatus: ModelApprovalStatus? = nil, modelPackageArn: String, modelPackageDescription: String? = nil, modelPackageGroupName: String? = nil, modelPackageName: String, modelPackageStatus: ModelPackageStatus, modelPackageVersion: Int? = nil) {
            self.creationTime = creationTime
            self.modelApprovalStatus = modelApprovalStatus
            self.modelPackageArn = modelPackageArn
            self.modelPackageDescription = modelPackageDescription
            self.modelPackageGroupName = modelPackageGroupName
            self.modelPackageName = modelPackageName
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageVersion = modelPackageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelPackageArn = "ModelPackageArn"
            case modelPackageDescription = "ModelPackageDescription"
            case modelPackageGroupName = "ModelPackageGroupName"
            case modelPackageName = "ModelPackageName"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageVersion = "ModelPackageVersion"
        }
    }

    public struct ModelPackageValidationProfile: AWSEncodableShape & AWSDecodableShape {
        /// The name of the profile for the model package.
        public let profileName: String
        /// The TransformJobDefinition object that describes the transform job used for the validation of the model package.
        public let transformJobDefinition: TransformJobDefinition

        public init(profileName: String, transformJobDefinition: TransformJobDefinition) {
            self.profileName = profileName
            self.transformJobDefinition = transformJobDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 63)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 1)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.transformJobDefinition.validate(name: "\(name).transformJobDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "ProfileName"
            case transformJobDefinition = "TransformJobDefinition"
        }
    }

    public struct ModelPackageValidationSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An array of ModelPackageValidationProfile objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.
        public let validationProfiles: [ModelPackageValidationProfile]
        /// The IAM roles to be used for the validation of the model package.
        public let validationRole: String

        public init(validationProfiles: [ModelPackageValidationProfile], validationRole: String) {
            self.validationProfiles = validationProfiles
            self.validationRole = validationRole
        }

        public func validate(name: String) throws {
            try self.validationProfiles.forEach {
                try $0.validate(name: "\(name).validationProfiles[]")
            }
            try self.validate(self.validationProfiles, name: "validationProfiles", parent: name, max: 1)
            try self.validate(self.validationProfiles, name: "validationProfiles", parent: name, min: 1)
            try self.validate(self.validationRole, name: "validationRole", parent: name, max: 2048)
            try self.validate(self.validationRole, name: "validationRole", parent: name, min: 20)
            try self.validate(self.validationRole, name: "validationRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case validationProfiles = "ValidationProfiles"
            case validationRole = "ValidationRole"
        }
    }

    public struct ModelQuality: AWSEncodableShape & AWSDecodableShape {
        /// Model quality constraints.
        public let constraints: MetricsSource?
        /// Model quality statistics.
        public let statistics: MetricsSource?

        public init(constraints: MetricsSource? = nil, statistics: MetricsSource? = nil) {
            self.constraints = constraints
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.statistics?.validate(name: "\(name).statistics")
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case statistics = "Statistics"
        }
    }

    public struct ModelQualityAppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An array of arguments for the container used to run the monitoring job.
        public let containerArguments: [String]?
        /// Specifies the entrypoint for a container that the monitoring job runs.
        public let containerEntrypoint: [String]?
        /// Sets the environment variables in the container that the monitoring job runs.
        public let environment: [String: String]?
        /// The address of the container image that the monitoring job runs.
        public let imageUri: String
        /// An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        public let postAnalyticsProcessorSourceUri: String?
        /// The machine learning problem type of the model that the monitoring job monitors.
        public let problemType: MonitoringProblemType?
        /// An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.
        public let recordPreprocessorSourceUri: String?

        public init(containerArguments: [String]? = nil, containerEntrypoint: [String]? = nil, environment: [String: String]? = nil, imageUri: String, postAnalyticsProcessorSourceUri: String? = nil, problemType: MonitoringProblemType? = nil, recordPreprocessorSourceUri: String? = nil) {
            self.containerArguments = containerArguments
            self.containerEntrypoint = containerEntrypoint
            self.environment = environment
            self.imageUri = imageUri
            self.postAnalyticsProcessorSourceUri = postAnalyticsProcessorSourceUri
            self.problemType = problemType
            self.recordPreprocessorSourceUri = recordPreprocessorSourceUri
        }

        public func validate(name: String) throws {
            try self.containerArguments?.forEach {
                try validate($0, name: "containerArguments[]", parent: name, max: 256)
                try validate($0, name: "containerArguments[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, max: 50)
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, min: 1)
            try self.containerEntrypoint?.forEach {
                try validate($0, name: "containerEntrypoint[]", parent: name, max: 256)
                try validate($0, name: "containerEntrypoint[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, max: 100)
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, min: 1)
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 50)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, max: 1024)
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, max: 1024)
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerArguments = "ContainerArguments"
            case containerEntrypoint = "ContainerEntrypoint"
            case environment = "Environment"
            case imageUri = "ImageUri"
            case postAnalyticsProcessorSourceUri = "PostAnalyticsProcessorSourceUri"
            case problemType = "ProblemType"
            case recordPreprocessorSourceUri = "RecordPreprocessorSourceUri"
        }
    }

    public struct ModelQualityBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the job that performs baselining for the monitoring job.
        public let baseliningJobName: String?
        public let constraintsResource: MonitoringConstraintsResource?

        public init(baseliningJobName: String? = nil, constraintsResource: MonitoringConstraintsResource? = nil) {
            self.baseliningJobName = baseliningJobName
            self.constraintsResource = constraintsResource
        }

        public func validate(name: String) throws {
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, max: 63)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, min: 1)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.constraintsResource?.validate(name: "\(name).constraintsResource")
        }

        private enum CodingKeys: String, CodingKey {
            case baseliningJobName = "BaseliningJobName"
            case constraintsResource = "ConstraintsResource"
        }
    }

    public struct ModelQualityJobInput: AWSEncodableShape & AWSDecodableShape {
        /// Input object for the batch transform job.
        public let batchTransformInput: BatchTransformInput?
        public let endpointInput: EndpointInput?
        /// The ground truth label provided for the model.
        public let groundTruthS3Input: MonitoringGroundTruthS3Input

        public init(batchTransformInput: BatchTransformInput? = nil, endpointInput: EndpointInput? = nil, groundTruthS3Input: MonitoringGroundTruthS3Input) {
            self.batchTransformInput = batchTransformInput
            self.endpointInput = endpointInput
            self.groundTruthS3Input = groundTruthS3Input
        }

        public func validate(name: String) throws {
            try self.batchTransformInput?.validate(name: "\(name).batchTransformInput")
            try self.endpointInput?.validate(name: "\(name).endpointInput")
            try self.groundTruthS3Input.validate(name: "\(name).groundTruthS3Input")
        }

        private enum CodingKeys: String, CodingKey {
            case batchTransformInput = "BatchTransformInput"
            case endpointInput = "EndpointInput"
            case groundTruthS3Input = "GroundTruthS3Input"
        }
    }

    public struct ModelStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created model.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct ModelSummary: AWSDecodableShape {
        /// A timestamp that indicates when the model was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String
        /// The name of the model that you want a summary for.
        public let modelName: String

        public init(creationTime: Date, modelArn: String, modelName: String) {
            self.creationTime = creationTime
            self.modelArn = modelArn
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case modelArn = "ModelArn"
            case modelName = "ModelName"
        }
    }

    public struct ModelVariantConfig: AWSEncodableShape {
        /// The configuration for the infrastructure that the model will be deployed to.
        public let infrastructureConfig: ModelInfrastructureConfig
        /// The name of the Amazon SageMaker Model entity.
        public let modelName: String
        /// The name of the variant.
        public let variantName: String

        public init(infrastructureConfig: ModelInfrastructureConfig, modelName: String, variantName: String) {
            self.infrastructureConfig = infrastructureConfig
            self.modelName = modelName
            self.variantName = variantName
        }

        public func validate(name: String) throws {
            try self.infrastructureConfig.validate(name: "\(name).infrastructureConfig")
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.variantName, name: "variantName", parent: name, max: 63)
            try self.validate(self.variantName, name: "variantName", parent: name, pattern: "^[a-zA-Z0-9]([\\-a-zA-Z0-9]*[a-zA-Z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfig = "InfrastructureConfig"
            case modelName = "ModelName"
            case variantName = "VariantName"
        }
    }

    public struct ModelVariantConfigSummary: AWSDecodableShape {
        /// The configuration of the infrastructure that the model has been deployed to.
        public let infrastructureConfig: ModelInfrastructureConfig
        /// The name of the Amazon SageMaker Model entity.
        public let modelName: String
        /// The status of deployment for the model variant on the hosted inference endpoint.    Creating - Amazon SageMaker is preparing the model variant on the hosted inference endpoint.     InService - The model variant is running on the hosted inference endpoint.     Updating - Amazon SageMaker is updating the model variant on the hosted inference endpoint.     Deleting - Amazon SageMaker is deleting the model variant on the hosted inference endpoint.     Deleted - The model variant has been deleted on the hosted inference endpoint. This can only happen after stopping the experiment.
        public let status: ModelVariantStatus
        /// The name of the variant.
        public let variantName: String

        public init(infrastructureConfig: ModelInfrastructureConfig, modelName: String, status: ModelVariantStatus, variantName: String) {
            self.infrastructureConfig = infrastructureConfig
            self.modelName = modelName
            self.status = status
            self.variantName = variantName
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfig = "InfrastructureConfig"
            case modelName = "ModelName"
            case status = "Status"
            case variantName = "VariantName"
        }
    }

    public struct MonitoringAlertActions: AWSDecodableShape {
        /// An alert action taken to light up an icon on the Model Dashboard when an alert goes into InAlert status.
        public let modelDashboardIndicator: ModelDashboardIndicatorAction?

        public init(modelDashboardIndicator: ModelDashboardIndicatorAction? = nil) {
            self.modelDashboardIndicator = modelDashboardIndicator
        }

        private enum CodingKeys: String, CodingKey {
            case modelDashboardIndicator = "ModelDashboardIndicator"
        }
    }

    public struct MonitoringAlertHistorySummary: AWSDecodableShape {
        /// The current alert status of an alert.
        public let alertStatus: MonitoringAlertStatus
        /// A timestamp that indicates when the first alert transition occurred in an alert history. An alert transition can be from status InAlert to OK,  or from OK to InAlert.
        public let creationTime: Date
        /// The name of a monitoring alert.
        public let monitoringAlertName: String
        /// The name of a monitoring schedule.
        public let monitoringScheduleName: String

        public init(alertStatus: MonitoringAlertStatus, creationTime: Date, monitoringAlertName: String, monitoringScheduleName: String) {
            self.alertStatus = alertStatus
            self.creationTime = creationTime
            self.monitoringAlertName = monitoringAlertName
            self.monitoringScheduleName = monitoringScheduleName
        }

        private enum CodingKeys: String, CodingKey {
            case alertStatus = "AlertStatus"
            case creationTime = "CreationTime"
            case monitoringAlertName = "MonitoringAlertName"
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct MonitoringAlertSummary: AWSDecodableShape {
        /// A list of alert actions taken in response to an alert going into InAlert status.
        public let actions: MonitoringAlertActions
        /// The current status of an alert.
        public let alertStatus: MonitoringAlertStatus
        /// A timestamp that indicates when a monitor alert was created.
        public let creationTime: Date
        /// Within EvaluationPeriod, how many execution failures will raise an alert.
        public let datapointsToAlert: Int
        /// The number of most recent monitoring executions to consider when evaluating alert status.
        public let evaluationPeriod: Int
        /// A timestamp that indicates when a monitor alert was last updated.
        public let lastModifiedTime: Date
        /// The name of a monitoring alert.
        public let monitoringAlertName: String

        public init(actions: MonitoringAlertActions, alertStatus: MonitoringAlertStatus, creationTime: Date, datapointsToAlert: Int, evaluationPeriod: Int, lastModifiedTime: Date, monitoringAlertName: String) {
            self.actions = actions
            self.alertStatus = alertStatus
            self.creationTime = creationTime
            self.datapointsToAlert = datapointsToAlert
            self.evaluationPeriod = evaluationPeriod
            self.lastModifiedTime = lastModifiedTime
            self.monitoringAlertName = monitoringAlertName
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case alertStatus = "AlertStatus"
            case creationTime = "CreationTime"
            case datapointsToAlert = "DatapointsToAlert"
            case evaluationPeriod = "EvaluationPeriod"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringAlertName = "MonitoringAlertName"
        }
    }

    public struct MonitoringAppSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An array of arguments for the container used to run the monitoring job.
        public let containerArguments: [String]?
        /// Specifies the entrypoint for a container used to run the monitoring job.
        public let containerEntrypoint: [String]?
        /// The container image to be run by the monitoring job.
        public let imageUri: String
        /// An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        public let postAnalyticsProcessorSourceUri: String?
        /// An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.
        public let recordPreprocessorSourceUri: String?

        public init(containerArguments: [String]? = nil, containerEntrypoint: [String]? = nil, imageUri: String, postAnalyticsProcessorSourceUri: String? = nil, recordPreprocessorSourceUri: String? = nil) {
            self.containerArguments = containerArguments
            self.containerEntrypoint = containerEntrypoint
            self.imageUri = imageUri
            self.postAnalyticsProcessorSourceUri = postAnalyticsProcessorSourceUri
            self.recordPreprocessorSourceUri = recordPreprocessorSourceUri
        }

        public func validate(name: String) throws {
            try self.containerArguments?.forEach {
                try validate($0, name: "containerArguments[]", parent: name, max: 256)
                try validate($0, name: "containerArguments[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, max: 50)
            try self.validate(self.containerArguments, name: "containerArguments", parent: name, min: 1)
            try self.containerEntrypoint?.forEach {
                try validate($0, name: "containerEntrypoint[]", parent: name, max: 256)
                try validate($0, name: "containerEntrypoint[]", parent: name, pattern: ".*")
            }
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, max: 100)
            try self.validate(self.containerEntrypoint, name: "containerEntrypoint", parent: name, min: 1)
            try self.validate(self.imageUri, name: "imageUri", parent: name, max: 255)
            try self.validate(self.imageUri, name: "imageUri", parent: name, pattern: ".*")
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, max: 1024)
            try self.validate(self.postAnalyticsProcessorSourceUri, name: "postAnalyticsProcessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, max: 1024)
            try self.validate(self.recordPreprocessorSourceUri, name: "recordPreprocessorSourceUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerArguments = "ContainerArguments"
            case containerEntrypoint = "ContainerEntrypoint"
            case imageUri = "ImageUri"
            case postAnalyticsProcessorSourceUri = "PostAnalyticsProcessorSourceUri"
            case recordPreprocessorSourceUri = "RecordPreprocessorSourceUri"
        }
    }

    public struct MonitoringBaselineConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the job that performs baselining for the monitoring job.
        public let baseliningJobName: String?
        /// The baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        public let constraintsResource: MonitoringConstraintsResource?
        /// The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        public let statisticsResource: MonitoringStatisticsResource?

        public init(baseliningJobName: String? = nil, constraintsResource: MonitoringConstraintsResource? = nil, statisticsResource: MonitoringStatisticsResource? = nil) {
            self.baseliningJobName = baseliningJobName
            self.constraintsResource = constraintsResource
            self.statisticsResource = statisticsResource
        }

        public func validate(name: String) throws {
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, max: 63)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, min: 1)
            try self.validate(self.baseliningJobName, name: "baseliningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.constraintsResource?.validate(name: "\(name).constraintsResource")
            try self.statisticsResource?.validate(name: "\(name).statisticsResource")
        }

        private enum CodingKeys: String, CodingKey {
            case baseliningJobName = "BaseliningJobName"
            case constraintsResource = "ConstraintsResource"
            case statisticsResource = "StatisticsResource"
        }
    }

    public struct MonitoringClusterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        public let instanceCount: Int
        /// The ML compute instance type for the processing job.
        public let instanceType: ProcessingInstanceType
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        public let volumeKmsKeyId: String?
        /// The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        public let volumeSizeInGB: Int

        public init(instanceCount: Int, instanceType: ProcessingInstanceType, volumeKmsKeyId: String? = nil, volumeSizeInGB: Int) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeKmsKeyId = volumeKmsKeyId
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, max: 100)
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, max: 16384)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct MonitoringConstraintsResource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 URI for the constraints resource.
        public let s3Uri: String?

        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
        }
    }

    public struct MonitoringCsvDatasetFormat: AWSEncodableShape & AWSDecodableShape {
        /// Indicates if the CSV data has a header.
        public let header: Bool?

        public init(header: Bool? = nil) {
            self.header = header
        }

        private enum CodingKeys: String, CodingKey {
            case header = "Header"
        }
    }

    public struct MonitoringDatasetFormat: AWSEncodableShape & AWSDecodableShape {
        /// The CSV dataset used in the monitoring job.
        public let csv: MonitoringCsvDatasetFormat?
        /// The JSON dataset used in the monitoring job
        public let json: MonitoringJsonDatasetFormat?
        /// The Parquet dataset used in the monitoring job
        public let parquet: MonitoringParquetDatasetFormat?

        public init(csv: MonitoringCsvDatasetFormat? = nil, json: MonitoringJsonDatasetFormat? = nil, parquet: MonitoringParquetDatasetFormat? = nil) {
            self.csv = csv
            self.json = json
            self.parquet = parquet
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "Csv"
            case json = "Json"
            case parquet = "Parquet"
        }
    }

    public struct MonitoringExecutionSummary: AWSDecodableShape {
        /// The time at which the monitoring job was created.
        public let creationTime: Date
        /// The name of the endpoint used to run the monitoring job.
        public let endpointName: String?
        /// Contains the reason a monitoring job failed, if it failed.
        public let failureReason: String?
        /// A timestamp that indicates the last time the monitoring job was modified.
        public let lastModifiedTime: Date
        /// The status of the monitoring job.
        public let monitoringExecutionStatus: ExecutionStatus
        /// The name of the monitoring job.
        public let monitoringJobDefinitionName: String?
        /// The name of the monitoring schedule.
        public let monitoringScheduleName: String
        /// The type of the monitoring job.
        public let monitoringType: MonitoringType?
        /// The Amazon Resource Name (ARN) of the monitoring job.
        public let processingJobArn: String?
        /// The time the monitoring job was scheduled.
        public let scheduledTime: Date

        public init(creationTime: Date, endpointName: String? = nil, failureReason: String? = nil, lastModifiedTime: Date, monitoringExecutionStatus: ExecutionStatus, monitoringJobDefinitionName: String? = nil, monitoringScheduleName: String, monitoringType: MonitoringType? = nil, processingJobArn: String? = nil, scheduledTime: Date) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.monitoringExecutionStatus = monitoringExecutionStatus
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringType = monitoringType
            self.processingJobArn = processingJobArn
            self.scheduledTime = scheduledTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringExecutionStatus = "MonitoringExecutionStatus"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringType = "MonitoringType"
            case processingJobArn = "ProcessingJobArn"
            case scheduledTime = "ScheduledTime"
        }
    }

    public struct MonitoringGroundTruthS3Input: AWSEncodableShape & AWSDecodableShape {
        /// The address of the Amazon S3 location of the ground truth labels.
        public let s3Uri: String?

        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 512)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
        }
    }

    public struct MonitoringInput: AWSEncodableShape & AWSDecodableShape {
        /// Input object for the batch transform job.
        public let batchTransformInput: BatchTransformInput?
        /// The endpoint for a monitoring job.
        public let endpointInput: EndpointInput?

        public init(batchTransformInput: BatchTransformInput? = nil, endpointInput: EndpointInput? = nil) {
            self.batchTransformInput = batchTransformInput
            self.endpointInput = endpointInput
        }

        public func validate(name: String) throws {
            try self.batchTransformInput?.validate(name: "\(name).batchTransformInput")
            try self.endpointInput?.validate(name: "\(name).endpointInput")
        }

        private enum CodingKeys: String, CodingKey {
            case batchTransformInput = "BatchTransformInput"
            case endpointInput = "EndpointInput"
        }
    }

    public struct MonitoringJobDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Baseline configuration used to validate that the data conforms to the specified constraints and statistics
        public let baselineConfig: MonitoringBaselineConfig?
        /// Sets the environment variables in the Docker container.
        public let environment: [String: String]?
        /// Configures the monitoring job to run a specified Docker container image.
        public let monitoringAppSpecification: MonitoringAppSpecification
        /// The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.
        public let monitoringInputs: [MonitoringInput]
        /// The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage Service (Amazon S3).
        public let monitoringOutputConfig: MonitoringOutputConfig
        /// Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.
        public let monitoringResources: MonitoringResources
        /// Specifies networking options for an monitoring job.
        public let networkConfig: NetworkConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        public let roleArn: String
        /// Specifies a time limit for how long the monitoring job is allowed to run.
        public let stoppingCondition: MonitoringStoppingCondition?

        public init(baselineConfig: MonitoringBaselineConfig? = nil, environment: [String: String]? = nil, monitoringAppSpecification: MonitoringAppSpecification, monitoringInputs: [MonitoringInput], monitoringOutputConfig: MonitoringOutputConfig, monitoringResources: MonitoringResources, networkConfig: NetworkConfig? = nil, roleArn: String, stoppingCondition: MonitoringStoppingCondition? = nil) {
            self.baselineConfig = baselineConfig
            self.environment = environment
            self.monitoringAppSpecification = monitoringAppSpecification
            self.monitoringInputs = monitoringInputs
            self.monitoringOutputConfig = monitoringOutputConfig
            self.monitoringResources = monitoringResources
            self.networkConfig = networkConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
        }

        public func validate(name: String) throws {
            try self.baselineConfig?.validate(name: "\(name).baselineConfig")
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 256)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 50)
            try self.monitoringAppSpecification.validate(name: "\(name).monitoringAppSpecification")
            try self.monitoringInputs.forEach {
                try $0.validate(name: "\(name).monitoringInputs[]")
            }
            try self.validate(self.monitoringInputs, name: "monitoringInputs", parent: name, max: 1)
            try self.validate(self.monitoringInputs, name: "monitoringInputs", parent: name, min: 1)
            try self.monitoringOutputConfig.validate(name: "\(name).monitoringOutputConfig")
            try self.monitoringResources.validate(name: "\(name).monitoringResources")
            try self.networkConfig?.validate(name: "\(name).networkConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.stoppingCondition?.validate(name: "\(name).stoppingCondition")
        }

        private enum CodingKeys: String, CodingKey {
            case baselineConfig = "BaselineConfig"
            case environment = "Environment"
            case monitoringAppSpecification = "MonitoringAppSpecification"
            case monitoringInputs = "MonitoringInputs"
            case monitoringOutputConfig = "MonitoringOutputConfig"
            case monitoringResources = "MonitoringResources"
            case networkConfig = "NetworkConfig"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct MonitoringJobDefinitionSummary: AWSDecodableShape {
        /// The time that the monitoring job was created.
        public let creationTime: Date
        /// The name of the endpoint that the job monitors.
        public let endpointName: String
        /// The Amazon Resource Name (ARN) of the monitoring job.
        public let monitoringJobDefinitionArn: String
        /// The name of the monitoring job.
        public let monitoringJobDefinitionName: String

        public init(creationTime: Date, endpointName: String, monitoringJobDefinitionArn: String, monitoringJobDefinitionName: String) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.monitoringJobDefinitionArn = monitoringJobDefinitionArn
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case monitoringJobDefinitionArn = "MonitoringJobDefinitionArn"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
        }
    }

    public struct MonitoringJsonDatasetFormat: AWSEncodableShape & AWSDecodableShape {
        /// Indicates if the file should be read as a json object per line.
        public let line: Bool?

        public init(line: Bool? = nil) {
            self.line = line
        }

        private enum CodingKeys: String, CodingKey {
            case line = "Line"
        }
    }

    public struct MonitoringNetworkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether to encrypt all communications between the instances used for the monitoring jobs. Choose True to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.
        public let enableInterContainerTrafficEncryption: Bool?
        /// Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.
        public let enableNetworkIsolation: Bool?
        public let vpcConfig: VpcConfig?

        public init(enableInterContainerTrafficEncryption: Bool? = nil, enableNetworkIsolation: Bool? = nil, vpcConfig: VpcConfig? = nil) {
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableNetworkIsolation = enableNetworkIsolation
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct MonitoringOutput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 storage location where the results of a monitoring job are saved.
        public let s3Output: MonitoringS3Output

        public init(s3Output: MonitoringS3Output) {
            self.s3Output = s3Output
        }

        public func validate(name: String) throws {
            try self.s3Output.validate(name: "\(name).s3Output")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Output = "S3Output"
        }
    }

    public struct MonitoringOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        public let kmsKeyId: String?
        /// Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        public let monitoringOutputs: [MonitoringOutput]

        public init(kmsKeyId: String? = nil, monitoringOutputs: [MonitoringOutput]) {
            self.kmsKeyId = kmsKeyId
            self.monitoringOutputs = monitoringOutputs
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.monitoringOutputs.forEach {
                try $0.validate(name: "\(name).monitoringOutputs[]")
            }
            try self.validate(self.monitoringOutputs, name: "monitoringOutputs", parent: name, max: 1)
            try self.validate(self.monitoringOutputs, name: "monitoringOutputs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case monitoringOutputs = "MonitoringOutputs"
        }
    }

    public struct MonitoringParquetDatasetFormat: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct MonitoringResources: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the cluster resources used to run the processing job.
        public let clusterConfig: MonitoringClusterConfig

        public init(clusterConfig: MonitoringClusterConfig) {
            self.clusterConfig = clusterConfig
        }

        public func validate(name: String) throws {
            try self.clusterConfig.validate(name: "\(name).clusterConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterConfig = "ClusterConfig"
        }
    }

    public struct MonitoringS3Output: AWSEncodableShape & AWSDecodableShape {
        /// The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        public let localPath: String
        /// Whether to upload the results of the monitoring job continuously or after the job completes.
        public let s3UploadMode: ProcessingS3UploadMode?
        /// A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        public let s3Uri: String

        public init(localPath: String, s3UploadMode: ProcessingS3UploadMode? = nil, s3Uri: String) {
            self.localPath = localPath
            self.s3UploadMode = s3UploadMode
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 512)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "LocalPath"
            case s3UploadMode = "S3UploadMode"
            case s3Uri = "S3Uri"
        }
    }

    public struct MonitoringSchedule: AWSDecodableShape {
        /// The time that the monitoring schedule was created.
        public let creationTime: Date?
        /// The endpoint that hosts the model being monitored.
        public let endpointName: String?
        /// If the monitoring schedule failed, the reason it failed.
        public let failureReason: String?
        /// The last time the monitoring schedule was changed.
        public let lastModifiedTime: Date?
        public let lastMonitoringExecutionSummary: MonitoringExecutionSummary?
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String?
        public let monitoringScheduleConfig: MonitoringScheduleConfig?
        /// The name of the monitoring schedule.
        public let monitoringScheduleName: String?
        /// The status of the monitoring schedule. This can be one of the following values.    PENDING - The schedule is pending being created.    FAILED - The schedule failed.    SCHEDULED - The schedule was successfully created.    STOPPED - The schedule was stopped.
        public let monitoringScheduleStatus: ScheduleStatus?
        /// The type of the monitoring job definition to schedule.
        public let monitoringType: MonitoringType?
        /// A list of the tags associated with the monitoring schedlue. For more information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        public init(creationTime: Date? = nil, endpointName: String? = nil, failureReason: String? = nil, lastModifiedTime: Date? = nil, lastMonitoringExecutionSummary: MonitoringExecutionSummary? = nil, monitoringScheduleArn: String? = nil, monitoringScheduleConfig: MonitoringScheduleConfig? = nil, monitoringScheduleName: String? = nil, monitoringScheduleStatus: ScheduleStatus? = nil, monitoringType: MonitoringType? = nil, tags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.lastMonitoringExecutionSummary = lastMonitoringExecutionSummary
            self.monitoringScheduleArn = monitoringScheduleArn
            self.monitoringScheduleConfig = monitoringScheduleConfig
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringScheduleStatus = monitoringScheduleStatus
            self.monitoringType = monitoringType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case lastMonitoringExecutionSummary = "LastMonitoringExecutionSummary"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case monitoringScheduleConfig = "MonitoringScheduleConfig"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringScheduleStatus = "MonitoringScheduleStatus"
            case monitoringType = "MonitoringType"
            case tags = "Tags"
        }
    }

    public struct MonitoringScheduleConfig: AWSEncodableShape & AWSDecodableShape {
        /// Defines the monitoring job.
        public let monitoringJobDefinition: MonitoringJobDefinition?
        /// The name of the monitoring job definition to schedule.
        public let monitoringJobDefinitionName: String?
        /// The type of the monitoring job definition to schedule.
        public let monitoringType: MonitoringType?
        /// Configures the monitoring schedule.
        public let scheduleConfig: ScheduleConfig?

        public init(monitoringJobDefinition: MonitoringJobDefinition? = nil, monitoringJobDefinitionName: String? = nil, monitoringType: MonitoringType? = nil, scheduleConfig: ScheduleConfig? = nil) {
            self.monitoringJobDefinition = monitoringJobDefinition
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
            self.monitoringType = monitoringType
            self.scheduleConfig = scheduleConfig
        }

        public func validate(name: String) throws {
            try self.monitoringJobDefinition?.validate(name: "\(name).monitoringJobDefinition")
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, max: 63)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, min: 1)
            try self.validate(self.monitoringJobDefinitionName, name: "monitoringJobDefinitionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.scheduleConfig?.validate(name: "\(name).scheduleConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringJobDefinition = "MonitoringJobDefinition"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
            case monitoringType = "MonitoringType"
            case scheduleConfig = "ScheduleConfig"
        }
    }

    public struct MonitoringScheduleSummary: AWSDecodableShape {
        /// The creation time of the monitoring schedule.
        public let creationTime: Date
        /// The name of the endpoint using the monitoring schedule.
        public let endpointName: String?
        /// The last time the monitoring schedule was modified.
        public let lastModifiedTime: Date
        /// The name of the monitoring job definition that the schedule is for.
        public let monitoringJobDefinitionName: String?
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String
        /// The name of the monitoring schedule.
        public let monitoringScheduleName: String
        /// The status of the monitoring schedule.
        public let monitoringScheduleStatus: ScheduleStatus
        /// The type of the monitoring job definition that the schedule is for.
        public let monitoringType: MonitoringType?

        public init(creationTime: Date, endpointName: String? = nil, lastModifiedTime: Date, monitoringJobDefinitionName: String? = nil, monitoringScheduleArn: String, monitoringScheduleName: String, monitoringScheduleStatus: ScheduleStatus, monitoringType: MonitoringType? = nil) {
            self.creationTime = creationTime
            self.endpointName = endpointName
            self.lastModifiedTime = lastModifiedTime
            self.monitoringJobDefinitionName = monitoringJobDefinitionName
            self.monitoringScheduleArn = monitoringScheduleArn
            self.monitoringScheduleName = monitoringScheduleName
            self.monitoringScheduleStatus = monitoringScheduleStatus
            self.monitoringType = monitoringType
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointName = "EndpointName"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringJobDefinitionName = "MonitoringJobDefinitionName"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case monitoringScheduleName = "MonitoringScheduleName"
            case monitoringScheduleStatus = "MonitoringScheduleStatus"
            case monitoringType = "MonitoringType"
        }
    }

    public struct MonitoringStatisticsResource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 URI for the statistics resource.
        public let s3Uri: String?

        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
        }
    }

    public struct MonitoringStoppingCondition: AWSEncodableShape & AWSDecodableShape {
        /// The maximum runtime allowed in seconds.  The MaxRuntimeInSeconds cannot exceed the frequency of the job. For data quality and model explainability, this can be up to 3600 seconds for an hourly schedule. For model bias and model quality hourly schedules, this can be up to 1800 seconds.
        public let maxRuntimeInSeconds: Int

        public init(maxRuntimeInSeconds: Int) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRuntimeInSeconds, name: "maxRuntimeInSeconds", parent: name, max: 86400)
            try self.validate(self.maxRuntimeInSeconds, name: "maxRuntimeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRuntimeInSeconds = "MaxRuntimeInSeconds"
        }
    }

    public struct MultiModelConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether to cache models for a multi-model endpoint. By default, multi-model endpoints cache models so that a model does not have to be loaded into memory each time it is invoked. Some use cases do not benefit from model caching. For example, if an endpoint hosts a large number of models that are each invoked infrequently, the endpoint might perform better if you disable model caching. To disable model caching, set the value of this parameter to Disabled.
        public let modelCacheSetting: ModelCacheSetting?

        public init(modelCacheSetting: ModelCacheSetting? = nil) {
            self.modelCacheSetting = modelCacheSetting
        }

        private enum CodingKeys: String, CodingKey {
            case modelCacheSetting = "ModelCacheSetting"
        }
    }

    public struct NeoVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The VPC security group IDs. IDs have the form of sg-xxxxxxxx.  Specify the security groups for the VPC that is specified in the Subnets field.
        public let securityGroupIds: [String]
        /// The ID of the subnets in the VPC that you want to connect the  compilation job to for accessing the model in Amazon S3.
        public let subnets: [String]

        public init(securityGroupIds: [String], subnets: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 32)
                try validate($0, name: "subnets[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
        }
    }

    public struct NestedFilters: AWSEncodableShape {
        /// A list of filters. Each filter acts on a property. Filters must contain at least one Filters value. For example, a NestedFilters call might include a filter on the PropertyName parameter of the InputDataConfig property: InputDataConfig.DataSource.S3DataSource.S3Uri.
        public let filters: [Filter]
        /// The name of the property to use in the nested filters. The value must match a listed property name, such as InputDataConfig.
        public let nestedPropertyName: String

        public init(filters: [Filter], nestedPropertyName: String) {
            self.filters = filters
            self.nestedPropertyName = nestedPropertyName
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nestedPropertyName, name: "nestedPropertyName", parent: name, max: 255)
            try self.validate(self.nestedPropertyName, name: "nestedPropertyName", parent: name, min: 1)
            try self.validate(self.nestedPropertyName, name: "nestedPropertyName", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case nestedPropertyName = "NestedPropertyName"
        }
    }

    public struct NetworkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        public let enableInterContainerTrafficEncryption: Bool?
        /// Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        public let enableNetworkIsolation: Bool?
        public let vpcConfig: VpcConfig?

        public init(enableInterContainerTrafficEncryption: Bool? = nil, enableNetworkIsolation: Bool? = nil, vpcConfig: VpcConfig? = nil) {
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableNetworkIsolation = enableNetworkIsolation
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct NotebookInstanceLifecycleConfigSummary: AWSDecodableShape {
        /// A timestamp that tells when the lifecycle configuration was created.
        public let creationTime: Date?
        /// A timestamp that tells when the lifecycle configuration was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String

        public init(creationTime: Date? = nil, lastModifiedTime: Date? = nil, notebookInstanceLifecycleConfigArn: String, notebookInstanceLifecycleConfigName: String) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        }
    }

    public struct NotebookInstanceLifecycleHook: AWSEncodableShape & AWSDecodableShape {
        /// A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\S\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct NotebookInstanceSummary: AWSDecodableShape {
        /// An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in Amazon Web Services CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// A timestamp that shows when the notebook instance was created.
        public let creationTime: Date?
        /// The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in Amazon Web Services CodeCommit or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// The type of ML compute instance that the notebook instance is running on.
        public let instanceType: InstanceType?
        /// A timestamp that shows when the notebook instance was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String
        /// The name of a notebook instance lifecycle configuration associated with this notebook instance. For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let notebookInstanceLifecycleConfigName: String?
        /// The name of the notebook instance that you want a summary for.
        public let notebookInstanceName: String
        /// The status of the notebook instance.
        public let notebookInstanceStatus: NotebookInstanceStatus?
        /// The URL that you use to connect to the Jupyter notebook running in your notebook instance.
        public let url: String?

        public init(additionalCodeRepositories: [String]? = nil, creationTime: Date? = nil, defaultCodeRepository: String? = nil, instanceType: InstanceType? = nil, lastModifiedTime: Date? = nil, notebookInstanceArn: String, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String, notebookInstanceStatus: NotebookInstanceStatus? = nil, url: String? = nil) {
            self.additionalCodeRepositories = additionalCodeRepositories
            self.creationTime = creationTime
            self.defaultCodeRepository = defaultCodeRepository
            self.instanceType = instanceType
            self.lastModifiedTime = lastModifiedTime
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case creationTime = "CreationTime"
            case defaultCodeRepository = "DefaultCodeRepository"
            case instanceType = "InstanceType"
            case lastModifiedTime = "LastModifiedTime"
            case notebookInstanceArn = "NotebookInstanceArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case url = "Url"
        }
    }

    public struct NotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for the Amazon SNS topic to which notifications should be published.
        public let notificationTopicArn: String?

        public init(notificationTopicArn: String? = nil) {
            self.notificationTopicArn = notificationTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.notificationTopicArn, name: "notificationTopicArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sns:[a-z0-9\\-]*:[0-9]{12}:[a-zA-Z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationTopicArn = "NotificationTopicArn"
        }
    }

    public struct ObjectiveStatusCounters: AWSDecodableShape {
        /// The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.
        public let failed: Int?
        /// The number of training jobs that are in progress and pending evaluation of their final objective metric.
        public let pending: Int?
        /// The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.
        public let succeeded: Int?

        public init(failed: Int? = nil, pending: Int? = nil, succeeded: Int? = nil) {
            self.failed = failed
            self.pending = pending
            self.succeeded = succeeded
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "Failed"
            case pending = "Pending"
            case succeeded = "Succeeded"
        }
    }

    public struct OfflineStoreConfig: AWSEncodableShape & AWSDecodableShape {
        /// The meta data of the Glue table that is autogenerated when an OfflineStore is created.
        public let dataCatalogConfig: DataCatalogConfig?
        /// Set to True to disable the automatic creation of an Amazon Web Services Glue table when configuring an OfflineStore.
        public let disableGlueTableCreation: Bool?
        /// The Amazon Simple Storage (Amazon S3) location of OfflineStore.
        public let s3StorageConfig: S3StorageConfig
        /// Format for the offline store table. Supported formats are Glue (Default) and Apache Iceberg.
        public let tableFormat: TableFormat?

        public init(dataCatalogConfig: DataCatalogConfig? = nil, disableGlueTableCreation: Bool? = nil, s3StorageConfig: S3StorageConfig, tableFormat: TableFormat? = nil) {
            self.dataCatalogConfig = dataCatalogConfig
            self.disableGlueTableCreation = disableGlueTableCreation
            self.s3StorageConfig = s3StorageConfig
            self.tableFormat = tableFormat
        }

        public func validate(name: String) throws {
            try self.dataCatalogConfig?.validate(name: "\(name).dataCatalogConfig")
            try self.s3StorageConfig.validate(name: "\(name).s3StorageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogConfig = "DataCatalogConfig"
            case disableGlueTableCreation = "DisableGlueTableCreation"
            case s3StorageConfig = "S3StorageConfig"
            case tableFormat = "TableFormat"
        }
    }

    public struct OfflineStoreStatus: AWSDecodableShape {
        /// The justification for why the OfflineStoreStatus is Blocked (if applicable).
        public let blockedReason: String?
        /// An OfflineStore status.
        public let status: OfflineStoreStatusValue

        public init(blockedReason: String? = nil, status: OfflineStoreStatusValue) {
            self.blockedReason = blockedReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case blockedReason = "BlockedReason"
            case status = "Status"
        }
    }

    public struct OidcConfig: AWSEncodableShape {
        /// The OIDC IdP authorization endpoint used to configure your private workforce.
        public let authorizationEndpoint: String
        /// The OIDC IdP client ID used to configure your private workforce.
        public let clientId: String
        /// The OIDC IdP client secret used to configure your private workforce.
        public let clientSecret: String
        /// The OIDC IdP issuer used to configure your private workforce.
        public let issuer: String
        /// The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
        public let jwksUri: String
        /// The OIDC IdP logout endpoint used to configure your private workforce.
        public let logoutEndpoint: String
        /// The OIDC IdP token endpoint used to configure your private workforce.
        public let tokenEndpoint: String
        /// The OIDC IdP user information endpoint used to configure your private workforce.
        public let userInfoEndpoint: String

        public init(authorizationEndpoint: String, clientId: String, clientSecret: String, issuer: String, jwksUri: String, logoutEndpoint: String, tokenEndpoint: String, userInfoEndpoint: String) {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.issuer = issuer
            self.jwksUri = jwksUri
            self.logoutEndpoint = logoutEndpoint
            self.tokenEndpoint = tokenEndpoint
            self.userInfoEndpoint = userInfoEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizationEndpoint, name: "authorizationEndpoint", parent: name, max: 500)
            try self.validate(self.authorizationEndpoint, name: "authorizationEndpoint", parent: name, pattern: "^https://\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 1024)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 1024)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.issuer, name: "issuer", parent: name, max: 500)
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "^https://\\S+$")
            try self.validate(self.jwksUri, name: "jwksUri", parent: name, max: 500)
            try self.validate(self.jwksUri, name: "jwksUri", parent: name, pattern: "^https://\\S+$")
            try self.validate(self.logoutEndpoint, name: "logoutEndpoint", parent: name, max: 500)
            try self.validate(self.logoutEndpoint, name: "logoutEndpoint", parent: name, pattern: "^https://\\S+$")
            try self.validate(self.tokenEndpoint, name: "tokenEndpoint", parent: name, max: 500)
            try self.validate(self.tokenEndpoint, name: "tokenEndpoint", parent: name, pattern: "^https://\\S+$")
            try self.validate(self.userInfoEndpoint, name: "userInfoEndpoint", parent: name, max: 500)
            try self.validate(self.userInfoEndpoint, name: "userInfoEndpoint", parent: name, pattern: "^https://\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "AuthorizationEndpoint"
            case clientId = "ClientId"
            case clientSecret = "ClientSecret"
            case issuer = "Issuer"
            case jwksUri = "JwksUri"
            case logoutEndpoint = "LogoutEndpoint"
            case tokenEndpoint = "TokenEndpoint"
            case userInfoEndpoint = "UserInfoEndpoint"
        }
    }

    public struct OidcConfigForResponse: AWSDecodableShape {
        /// The OIDC IdP authorization endpoint used to configure your private workforce.
        public let authorizationEndpoint: String?
        /// The OIDC IdP client ID used to configure your private workforce.
        public let clientId: String?
        /// The OIDC IdP issuer used to configure your private workforce.
        public let issuer: String?
        /// The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
        public let jwksUri: String?
        /// The OIDC IdP logout endpoint used to configure your private workforce.
        public let logoutEndpoint: String?
        /// The OIDC IdP token endpoint used to configure your private workforce.
        public let tokenEndpoint: String?
        /// The OIDC IdP user information endpoint used to configure your private workforce.
        public let userInfoEndpoint: String?

        public init(authorizationEndpoint: String? = nil, clientId: String? = nil, issuer: String? = nil, jwksUri: String? = nil, logoutEndpoint: String? = nil, tokenEndpoint: String? = nil, userInfoEndpoint: String? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.issuer = issuer
            self.jwksUri = jwksUri
            self.logoutEndpoint = logoutEndpoint
            self.tokenEndpoint = tokenEndpoint
            self.userInfoEndpoint = userInfoEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "AuthorizationEndpoint"
            case clientId = "ClientId"
            case issuer = "Issuer"
            case jwksUri = "JwksUri"
            case logoutEndpoint = "LogoutEndpoint"
            case tokenEndpoint = "TokenEndpoint"
            case userInfoEndpoint = "UserInfoEndpoint"
        }
    }

    public struct OidcMemberDefinition: AWSEncodableShape & AWSDecodableShape {
        /// A list of comma seperated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
        public let groups: [String]

        public init(groups: [String]) {
            self.groups = groups
        }

        public func validate(name: String) throws {
            try self.groups.forEach {
                try validate($0, name: "groups[]", parent: name, max: 63)
                try validate($0, name: "groups[]", parent: name, min: 1)
                try validate($0, name: "groups[]", parent: name, pattern: "^[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}]+$")
            }
            try self.validate(self.groups, name: "groups", parent: name, max: 10)
            try self.validate(self.groups, name: "groups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
        }
    }

    public struct OnlineStoreConfig: AWSEncodableShape & AWSDecodableShape {
        /// Turn OnlineStore off by specifying False  for the EnableOnlineStore flag. Turn OnlineStore  on by specifying True  for the EnableOnlineStore flag.  The default value is False.
        public let enableOnlineStore: Bool?
        /// Use to specify KMS Key ID (KMSKeyId) for at-rest encryption of your OnlineStore.
        public let securityConfig: OnlineStoreSecurityConfig?

        public init(enableOnlineStore: Bool? = nil, securityConfig: OnlineStoreSecurityConfig? = nil) {
            self.enableOnlineStore = enableOnlineStore
            self.securityConfig = securityConfig
        }

        public func validate(name: String) throws {
            try self.securityConfig?.validate(name: "\(name).securityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableOnlineStore = "EnableOnlineStore"
            case securityConfig = "SecurityConfig"
        }
    }

    public struct OnlineStoreSecurityConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption. The caller (either IAM user or IAM role) of CreateFeatureGroup must have below permissions to the OnlineStore KmsKeyId:    "kms:Encrypt"     "kms:Decrypt"     "kms:DescribeKey"     "kms:CreateGrant"     "kms:RetireGrant"     "kms:ReEncryptFrom"     "kms:ReEncryptTo"     "kms:GenerateDataKey"     "kms:ListAliases"     "kms:ListGrants"     "kms:RevokeGrant"    The caller (either IAM user or IAM role) to all DataPlane operations (PutRecord, GetRecord, DeleteRecord) must have the following permissions to the KmsKeyId:    "kms:Decrypt"
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct OutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional parameters for compiler options in JSON format. The compiler options are TargetPlatform specific. It is required for NVIDIA accelerators and highly recommended for CPU compilations. For any other cases, it is optional to specify CompilerOptions.     DTYPE: Specifies the data type for the input. When compiling for ml_* (except for ml_inf) instances using PyTorch framework, provide the data type (dtype) of the model's input. "float32" is used if "DTYPE" is not specified. Options for data type are:   float32: Use either "float" or "float32".   int64: Use either "int64" or "long".   For example, {"dtype" : "float32"}.    CPU: Compilation for CPU supports the following compiler options.    mcpu: CPU micro-architecture. For example, {'mcpu': 'skylake-avx512'}     mattr: CPU flags. For example, {'mattr': ['+neon', '+vfpv4']}       ARM: Details of ARM CPU compilations.    NEON: NEON is an implementation of the Advanced SIMD extension used in ARMv7 processors. For example, add {'mattr': ['+neon']} to the compiler options if compiling for ARM 32-bit platform with the NEON support.      NVIDIA: Compilation for NVIDIA GPU supports the following compiler options.    gpu_code: Specifies the targeted architecture.    trt-ver: Specifies the TensorRT versions in x.y.z. format.    cuda-ver: Specifies the CUDA version in x.y format.   For example, {'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver': '10.1'}     ANDROID: Compilation for the Android OS supports the following compiler options:    ANDROID_PLATFORM: Specifies the Android API levels. Available levels range from 21 to 29. For example, {'ANDROID_PLATFORM': 28}.    mattr: Add {'mattr': ['+neon']} to compiler options if compiling for ARM 32-bit platform with NEON support.      INFERENTIA: Compilation for target ml_inf1 uses compiler options passed in as a JSON string. For example, "CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\"".  For information about supported compiler options, see  Neuron Compiler CLI.     CoreML: Compilation for the CoreML OutputConfig$TargetDevice supports the following compiler options:    class_labels: Specifies the classification labels file name inside input tar.gz file. For example, {"class_labels": "imagenet_labels_1000.txt"}. Labels inside the txt file should be separated by newlines.      EIA: Compilation for the Elastic Inference Accelerator supports the following  compiler options:    precision_mode: Specifies the precision of compiled artifacts. Supported values are "FP16" and "FP32". Default is "FP32".    signature_def_key: Specifies the signature to use for models in SavedModel format. Defaults is TensorFlow's default signature def key.    output_names: Specifies a list of output tensor names for  models in FrozenGraph format. Set at most one API field, either: signature_def_key or output_names.   For example:  {"precision_mode": "FP32",  "output_names": ["output:0"]}
        public let compilerOptions: String?
        /// The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.  The KmsKeyId can be any of the following formats:    Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias
        public let kmsKeyId: String?
        /// Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For example, s3://bucket-name/key-name-prefix.
        public let s3OutputLocation: String
        /// Identifies the target device or the machine learning instance that you want to run your model on after the compilation has completed. Alternatively, you can specify OS, architecture, and accelerator using TargetPlatform fields. It can be used instead of TargetPlatform.
        public let targetDevice: TargetDevice?
        /// Contains information about a target platform that you want your model to run on, such as OS, architecture, and accelerators. It is an alternative of TargetDevice. The following examples show how to configure the TargetPlatform and CompilerOptions JSON strings for popular target platforms:    Raspberry Pi 3 Model B+  "TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},   "CompilerOptions": {'mattr': ['+neon']}    Jetson TX2  "TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "NVIDIA"},   "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1', 'cuda-ver': '10.0'}    EC2 m5.2xlarge instance OS  "TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator": "NVIDIA"},   "CompilerOptions": {'mcpu': 'skylake-avx512'}    RK3399  "TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator": "MALI"}    ARMv7 phone (CPU)  "TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},   "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr': ['+neon']}    ARMv8 phone (CPU)  "TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},   "CompilerOptions": {'ANDROID_PLATFORM': 29}
        public let targetPlatform: TargetPlatform?

        public init(compilerOptions: String? = nil, kmsKeyId: String? = nil, s3OutputLocation: String, targetDevice: TargetDevice? = nil, targetPlatform: TargetPlatform? = nil) {
            self.compilerOptions = compilerOptions
            self.kmsKeyId = kmsKeyId
            self.s3OutputLocation = s3OutputLocation
            self.targetDevice = targetDevice
            self.targetPlatform = targetPlatform
        }

        public func validate(name: String) throws {
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, max: 1024)
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, min: 3)
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputLocation, name: "s3OutputLocation", parent: name, max: 1024)
            try self.validate(self.s3OutputLocation, name: "s3OutputLocation", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case compilerOptions = "CompilerOptions"
            case kmsKeyId = "KmsKeyId"
            case s3OutputLocation = "S3OutputLocation"
            case targetDevice = "TargetDevice"
            case targetPlatform = "TargetPlatform"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"    If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call kms:Encrypt. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for OutputDataConfig. If you use a bucket policy with an s3:PutObject permission that only allows objects with server-side encryption, set the condition key of s3:x-amz-server-side-encryption to "aws:kms". For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.  The KMS key policy must grant permission to the IAM role that you specify in your CreateTrainingJob, CreateTransformJob, or CreateHyperParameterTuningJob requests. For more information, see Using Key Policies in Amazon Web Services KMS in the Amazon Web Services Key Management Service Developer Guide.
        public let kmsKeyId: String?
        /// Identifies the S3 path where you want SageMaker to store the model artifacts. For example, s3://bucket-name/key-name-prefix.
        public let s3OutputPath: String

        public init(kmsKeyId: String? = nil, s3OutputPath: String) {
            self.kmsKeyId = kmsKeyId
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct OutputParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the output parameter.
        public let name: String
        /// The value of the output parameter.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct ParallelismConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The max number of steps that can be executed in parallel.
        public let maxParallelExecutionSteps: Int

        public init(maxParallelExecutionSteps: Int) {
            self.maxParallelExecutionSteps = maxParallelExecutionSteps
        }

        public func validate(name: String) throws {
            try self.validate(self.maxParallelExecutionSteps, name: "maxParallelExecutionSteps", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxParallelExecutionSteps = "MaxParallelExecutionSteps"
        }
    }

    public struct Parameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the parameter to assign a value to. This  parameter name must match a named parameter in the  pipeline definition.
        public let name: String
        /// The literal value for the parameter.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct ParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// A CategoricalParameterRangeSpecification object that defines the possible values for a categorical hyperparameter.
        public let categoricalParameterRangeSpecification: CategoricalParameterRangeSpecification?
        /// A ContinuousParameterRangeSpecification object that defines the possible values for a continuous hyperparameter.
        public let continuousParameterRangeSpecification: ContinuousParameterRangeSpecification?
        /// A IntegerParameterRangeSpecification object that defines the possible values for an integer hyperparameter.
        public let integerParameterRangeSpecification: IntegerParameterRangeSpecification?

        public init(categoricalParameterRangeSpecification: CategoricalParameterRangeSpecification? = nil, continuousParameterRangeSpecification: ContinuousParameterRangeSpecification? = nil, integerParameterRangeSpecification: IntegerParameterRangeSpecification? = nil) {
            self.categoricalParameterRangeSpecification = categoricalParameterRangeSpecification
            self.continuousParameterRangeSpecification = continuousParameterRangeSpecification
            self.integerParameterRangeSpecification = integerParameterRangeSpecification
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRangeSpecification?.validate(name: "\(name).categoricalParameterRangeSpecification")
            try self.continuousParameterRangeSpecification?.validate(name: "\(name).continuousParameterRangeSpecification")
            try self.integerParameterRangeSpecification?.validate(name: "\(name).integerParameterRangeSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRangeSpecification = "CategoricalParameterRangeSpecification"
            case continuousParameterRangeSpecification = "ContinuousParameterRangeSpecification"
            case integerParameterRangeSpecification = "IntegerParameterRangeSpecification"
        }
    }

    public struct ParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// The array of CategoricalParameterRange objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.
        public let categoricalParameterRanges: [CategoricalParameterRange]?
        /// The array of ContinuousParameterRange objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.
        public let continuousParameterRanges: [ContinuousParameterRange]?
        /// The array of IntegerParameterRange objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.
        public let integerParameterRanges: [IntegerParameterRange]?

        public init(categoricalParameterRanges: [CategoricalParameterRange]? = nil, continuousParameterRanges: [ContinuousParameterRange]? = nil, integerParameterRanges: [IntegerParameterRange]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalParameterRanges[]")
            }
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, max: 30)
            try self.continuousParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousParameterRanges[]")
            }
            try self.validate(self.continuousParameterRanges, name: "continuousParameterRanges", parent: name, max: 30)
            try self.integerParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerParameterRanges[]")
            }
            try self.validate(self.integerParameterRanges, name: "integerParameterRanges", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
            case continuousParameterRanges = "ContinuousParameterRanges"
            case integerParameterRanges = "IntegerParameterRanges"
        }
    }

    public struct Parent: AWSDecodableShape {
        /// The name of the experiment.
        public let experimentName: String?
        /// The name of the trial.
        public let trialName: String?

        public init(experimentName: String? = nil, trialName: String? = nil) {
            self.experimentName = experimentName
            self.trialName = trialName
        }

        private enum CodingKeys: String, CodingKey {
            case experimentName = "ExperimentName"
            case trialName = "TrialName"
        }
    }

    public struct ParentHyperParameterTuningJob: AWSEncodableShape & AWSDecodableShape {
        /// The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.
        public let hyperParameterTuningJobName: String?

        public init(hyperParameterTuningJobName: String? = nil) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, max: 32)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, min: 1)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public struct PendingDeploymentSummary: AWSDecodableShape {
        /// The name of the endpoint configuration used in the deployment.
        public let endpointConfigName: String
        /// An array of PendingProductionVariantSummary objects, one for each model hosted behind this endpoint for the in-progress deployment.
        public let productionVariants: [PendingProductionVariantSummary]?
        /// An array of PendingProductionVariantSummary objects, one for each model hosted behind this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants for the in-progress deployment.
        public let shadowProductionVariants: [PendingProductionVariantSummary]?
        /// The start time of the deployment.
        public let startTime: Date?

        public init(endpointConfigName: String, productionVariants: [PendingProductionVariantSummary]? = nil, shadowProductionVariants: [PendingProductionVariantSummary]? = nil, startTime: Date? = nil) {
            self.endpointConfigName = endpointConfigName
            self.productionVariants = productionVariants
            self.shadowProductionVariants = shadowProductionVariants
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
            case productionVariants = "ProductionVariants"
            case shadowProductionVariants = "ShadowProductionVariants"
            case startTime = "StartTime"
        }
    }

    public struct PendingProductionVariantSummary: AWSDecodableShape {
        /// The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorType: ProductionVariantAcceleratorType?
        /// The number of instances associated with the variant.
        public let currentInstanceCount: Int?
        /// The serverless configuration for the endpoint.
        public let currentServerlessConfig: ProductionVariantServerlessConfig?
        /// The weight associated with the variant.
        public let currentWeight: Float?
        /// An array of DeployedImage objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this ProductionVariant.
        public let deployedImages: [DeployedImage]?
        /// The number of instances requested in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the  CreateEndpointConfig operation.
        public let desiredInstanceCount: Int?
        /// The serverless configuration requested for this deployment, as specified in the endpoint configuration for the endpoint.
        public let desiredServerlessConfig: ProductionVariantServerlessConfig?
        /// The requested weight for the variant in this deployment, as specified in the endpoint configuration for the endpoint. The value is taken from the request to the  CreateEndpointConfig operation.
        public let desiredWeight: Float?
        /// The type of instances associated with the variant.
        public let instanceType: ProductionVariantInstanceType?
        /// The name of the variant.
        public let variantName: String
        /// The endpoint variant status which describes the current deployment stage status or operational status.
        public let variantStatus: [ProductionVariantStatus]?

        public init(acceleratorType: ProductionVariantAcceleratorType? = nil, currentInstanceCount: Int? = nil, currentServerlessConfig: ProductionVariantServerlessConfig? = nil, currentWeight: Float? = nil, deployedImages: [DeployedImage]? = nil, desiredInstanceCount: Int? = nil, desiredServerlessConfig: ProductionVariantServerlessConfig? = nil, desiredWeight: Float? = nil, instanceType: ProductionVariantInstanceType? = nil, variantName: String, variantStatus: [ProductionVariantStatus]? = nil) {
            self.acceleratorType = acceleratorType
            self.currentInstanceCount = currentInstanceCount
            self.currentServerlessConfig = currentServerlessConfig
            self.currentWeight = currentWeight
            self.deployedImages = deployedImages
            self.desiredInstanceCount = desiredInstanceCount
            self.desiredServerlessConfig = desiredServerlessConfig
            self.desiredWeight = desiredWeight
            self.instanceType = instanceType
            self.variantName = variantName
            self.variantStatus = variantStatus
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorType = "AcceleratorType"
            case currentInstanceCount = "CurrentInstanceCount"
            case currentServerlessConfig = "CurrentServerlessConfig"
            case currentWeight = "CurrentWeight"
            case deployedImages = "DeployedImages"
            case desiredInstanceCount = "DesiredInstanceCount"
            case desiredServerlessConfig = "DesiredServerlessConfig"
            case desiredWeight = "DesiredWeight"
            case instanceType = "InstanceType"
            case variantName = "VariantName"
            case variantStatus = "VariantStatus"
        }
    }

    public struct Phase: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how long traffic phase should be.
        public let durationInSeconds: Int?
        /// Specifies how many concurrent users to start with.
        public let initialNumberOfUsers: Int?
        /// Specified how many new users to spawn in a minute.
        public let spawnRate: Int?

        public init(durationInSeconds: Int? = nil, initialNumberOfUsers: Int? = nil, spawnRate: Int? = nil) {
            self.durationInSeconds = durationInSeconds
            self.initialNumberOfUsers = initialNumberOfUsers
            self.spawnRate = spawnRate
        }

        public func validate(name: String) throws {
            try self.validate(self.durationInSeconds, name: "durationInSeconds", parent: name, min: 1)
            try self.validate(self.initialNumberOfUsers, name: "initialNumberOfUsers", parent: name, min: 1)
            try self.validate(self.spawnRate, name: "spawnRate", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case durationInSeconds = "DurationInSeconds"
            case initialNumberOfUsers = "InitialNumberOfUsers"
            case spawnRate = "SpawnRate"
        }
    }

    public struct Pipeline: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The creation time of the pipeline.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// The time that the pipeline was last modified.
        public let lastModifiedTime: Date?
        /// The time when the pipeline was last run.
        public let lastRunTime: Date?
        /// The parallelism configuration applied to the pipeline.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The description of the pipeline.
        public let pipelineDescription: String?
        /// The display name of the pipeline.
        public let pipelineDisplayName: String?
        /// The name of the pipeline.
        public let pipelineName: String?
        /// The status of the pipeline.
        public let pipelineStatus: PipelineStatus?
        /// The Amazon Resource Name (ARN) of the role that created the pipeline.
        public let roleArn: String?
        /// A list of tags that apply to the pipeline.
        public let tags: [Tag]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lastRunTime: Date? = nil, parallelismConfiguration: ParallelismConfiguration? = nil, pipelineArn: String? = nil, pipelineDescription: String? = nil, pipelineDisplayName: String? = nil, pipelineName: String? = nil, pipelineStatus: PipelineStatus? = nil, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lastRunTime = lastRunTime
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineArn = pipelineArn
            self.pipelineDescription = pipelineDescription
            self.pipelineDisplayName = pipelineDisplayName
            self.pipelineName = pipelineName
            self.pipelineStatus = pipelineStatus
            self.roleArn = roleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lastRunTime = "LastRunTime"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineArn = "PipelineArn"
            case pipelineDescription = "PipelineDescription"
            case pipelineDisplayName = "PipelineDisplayName"
            case pipelineName = "PipelineName"
            case pipelineStatus = "PipelineStatus"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct PipelineDefinitionS3Location: AWSEncodableShape {
        /// Name of the S3 bucket.
        public let bucket: String
        /// The object key (or key name) uniquely identifies the  object in an S3 bucket.
        public let objectKey: String
        /// Version Id of the pipeline definition file. If not specified, Amazon SageMaker  will retrieve the latest version.
        public let versionId: String?

        public init(bucket: String, objectKey: String, versionId: String? = nil) {
            self.bucket = bucket
            self.objectKey = objectKey
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.objectKey, name: "objectKey", parent: name, max: 1024)
            try self.validate(self.objectKey, name: "objectKey", parent: name, min: 1)
            try self.validate(self.objectKey, name: "objectKey", parent: name, pattern: "^.+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 1024)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case objectKey = "ObjectKey"
            case versionId = "VersionId"
        }
    }

    public struct PipelineExecution: AWSDecodableShape {
        public let createdBy: UserContext?
        /// The creation time of the pipeline execution.
        public let creationTime: Date?
        /// If the execution failed, a message describing why.
        public let failureReason: String?
        public let lastModifiedBy: UserContext?
        /// The time that the pipeline execution was last modified.
        public let lastModifiedTime: Date?
        /// The parallelism configuration applied to the pipeline execution.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline that was executed.
        public let pipelineArn: String?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?
        /// The description of the pipeline execution.
        public let pipelineExecutionDescription: String?
        /// The display name of the pipeline execution.
        public let pipelineExecutionDisplayName: String?
        /// The status of the pipeline status.
        public let pipelineExecutionStatus: PipelineExecutionStatus?
        public let pipelineExperimentConfig: PipelineExperimentConfig?
        /// Contains a list of pipeline parameters. This list can be empty.
        public let pipelineParameters: [Parameter]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, failureReason: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, parallelismConfiguration: ParallelismConfiguration? = nil, pipelineArn: String? = nil, pipelineExecutionArn: String? = nil, pipelineExecutionDescription: String? = nil, pipelineExecutionDisplayName: String? = nil, pipelineExecutionStatus: PipelineExecutionStatus? = nil, pipelineExperimentConfig: PipelineExperimentConfig? = nil, pipelineParameters: [Parameter]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineArn = pipelineArn
            self.pipelineExecutionArn = pipelineExecutionArn
            self.pipelineExecutionDescription = pipelineExecutionDescription
            self.pipelineExecutionDisplayName = pipelineExecutionDisplayName
            self.pipelineExecutionStatus = pipelineExecutionStatus
            self.pipelineExperimentConfig = pipelineExperimentConfig
            self.pipelineParameters = pipelineParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineArn = "PipelineArn"
            case pipelineExecutionArn = "PipelineExecutionArn"
            case pipelineExecutionDescription = "PipelineExecutionDescription"
            case pipelineExecutionDisplayName = "PipelineExecutionDisplayName"
            case pipelineExecutionStatus = "PipelineExecutionStatus"
            case pipelineExperimentConfig = "PipelineExperimentConfig"
            case pipelineParameters = "PipelineParameters"
        }
    }

    public struct PipelineExecutionStep: AWSDecodableShape {
        /// The current attempt of the execution step. For more information, see Retry Policy for SageMaker Pipelines steps.
        public let attemptCount: Int?
        /// If this pipeline execution step was cached, details on the cache hit.
        public let cacheHitResult: CacheHitResult?
        /// The time that the step stopped executing.
        public let endTime: Date?
        /// The reason why the step failed execution. This is only returned if the step failed its execution.
        public let failureReason: String?
        /// Metadata to run the pipeline step.
        public let metadata: PipelineExecutionStepMetadata?
        /// The time that the step started executing.
        public let startTime: Date?
        /// The description of the step.
        public let stepDescription: String?
        /// The display name of the step.
        public let stepDisplayName: String?
        /// The name of the step that is executed.
        public let stepName: String?
        /// The status of the step execution.
        public let stepStatus: StepStatus?

        public init(attemptCount: Int? = nil, cacheHitResult: CacheHitResult? = nil, endTime: Date? = nil, failureReason: String? = nil, metadata: PipelineExecutionStepMetadata? = nil, startTime: Date? = nil, stepDescription: String? = nil, stepDisplayName: String? = nil, stepName: String? = nil, stepStatus: StepStatus? = nil) {
            self.attemptCount = attemptCount
            self.cacheHitResult = cacheHitResult
            self.endTime = endTime
            self.failureReason = failureReason
            self.metadata = metadata
            self.startTime = startTime
            self.stepDescription = stepDescription
            self.stepDisplayName = stepDisplayName
            self.stepName = stepName
            self.stepStatus = stepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case attemptCount = "AttemptCount"
            case cacheHitResult = "CacheHitResult"
            case endTime = "EndTime"
            case failureReason = "FailureReason"
            case metadata = "Metadata"
            case startTime = "StartTime"
            case stepDescription = "StepDescription"
            case stepDisplayName = "StepDisplayName"
            case stepName = "StepName"
            case stepStatus = "StepStatus"
        }
    }

    public struct PipelineExecutionStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AutoML job that was run by this step.
        public let autoMLJob: AutoMLJobStepMetadata?
        /// The URL of the Amazon SQS queue used by this step execution, the pipeline generated token, and a list of output parameters.
        public let callback: CallbackStepMetadata?
        /// Container for the metadata for a Clarify check step. The configurations  and outcomes of the check step execution. This includes:    The type of the check conducted,   The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.   The Amazon S3 URIs of newly calculated baseline constraints and statistics.   The model package group name provided.   The Amazon S3 URI of the violation report if violations detected.   The Amazon Resource Name (ARN) of check processing job initiated by the step execution.   The boolean flags indicating if the drift check is skipped.   If step property BaselineUsedForDriftCheck is set the same as  CalculatedBaseline.
        public let clarifyCheck: ClarifyCheckStepMetadata?
        /// The outcome of the condition evaluation that was run by this step execution.
        public let condition: ConditionStepMetadata?
        /// The configurations and outcomes of an Amazon EMR step execution.
        public let emr: EMRStepMetadata?
        /// The configurations and outcomes of a Fail step execution.
        public let fail: FailStepMetadata?
        /// The Amazon Resource Name (ARN) of the Lambda function that was run by this step execution and a list of output parameters.
        public let lambda: LambdaStepMetadata?
        /// The Amazon Resource Name (ARN) of the model that was created by this step execution.
        public let model: ModelStepMetadata?
        /// The Amazon Resource Name (ARN) of the processing job that was run by this step execution.
        public let processingJob: ProcessingJobStepMetadata?
        /// The configurations and outcomes of the check step execution. This includes:    The type of the check conducted.   The Amazon S3 URIs of baseline constraints and statistics files to be used for the drift check.   The Amazon S3 URIs of newly calculated baseline constraints and statistics.   The model package group name provided.   The Amazon S3 URI of the violation report if violations detected.   The Amazon Resource Name (ARN) of check processing job initiated by the step execution.   The Boolean flags indicating if the drift check is skipped.   If step property BaselineUsedForDriftCheck is set the same as  CalculatedBaseline.
        public let qualityCheck: QualityCheckStepMetadata?
        /// The Amazon Resource Name (ARN) of the model package that the model was registered to by this step execution.
        public let registerModel: RegisterModelStepMetadata?
        /// The Amazon Resource Name (ARN) of the training job that was run by this step execution.
        public let trainingJob: TrainingJobStepMetadata?
        /// The Amazon Resource Name (ARN) of the transform job that was run by this step execution.
        public let transformJob: TransformJobStepMetadata?
        /// The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.
        public let tuningJob: TuningJobStepMetaData?

        public init(autoMLJob: AutoMLJobStepMetadata? = nil, callback: CallbackStepMetadata? = nil, clarifyCheck: ClarifyCheckStepMetadata? = nil, condition: ConditionStepMetadata? = nil, emr: EMRStepMetadata? = nil, fail: FailStepMetadata? = nil, lambda: LambdaStepMetadata? = nil, model: ModelStepMetadata? = nil, processingJob: ProcessingJobStepMetadata? = nil, qualityCheck: QualityCheckStepMetadata? = nil, registerModel: RegisterModelStepMetadata? = nil, trainingJob: TrainingJobStepMetadata? = nil, transformJob: TransformJobStepMetadata? = nil, tuningJob: TuningJobStepMetaData? = nil) {
            self.autoMLJob = autoMLJob
            self.callback = callback
            self.clarifyCheck = clarifyCheck
            self.condition = condition
            self.emr = emr
            self.fail = fail
            self.lambda = lambda
            self.model = model
            self.processingJob = processingJob
            self.qualityCheck = qualityCheck
            self.registerModel = registerModel
            self.trainingJob = trainingJob
            self.transformJob = transformJob
            self.tuningJob = tuningJob
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJob = "AutoMLJob"
            case callback = "Callback"
            case clarifyCheck = "ClarifyCheck"
            case condition = "Condition"
            case emr = "EMR"
            case fail = "Fail"
            case lambda = "Lambda"
            case model = "Model"
            case processingJob = "ProcessingJob"
            case qualityCheck = "QualityCheck"
            case registerModel = "RegisterModel"
            case trainingJob = "TrainingJob"
            case transformJob = "TransformJob"
            case tuningJob = "TuningJob"
        }
    }

    public struct PipelineExecutionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?
        /// The description of the pipeline execution.
        public let pipelineExecutionDescription: String?
        /// The display name of the pipeline execution.
        public let pipelineExecutionDisplayName: String?
        /// A message generated by SageMaker Pipelines describing why the pipeline execution failed.
        public let pipelineExecutionFailureReason: String?
        /// The status of the pipeline execution.
        public let pipelineExecutionStatus: PipelineExecutionStatus?
        /// The start time of the pipeline execution.
        public let startTime: Date?

        public init(pipelineExecutionArn: String? = nil, pipelineExecutionDescription: String? = nil, pipelineExecutionDisplayName: String? = nil, pipelineExecutionFailureReason: String? = nil, pipelineExecutionStatus: PipelineExecutionStatus? = nil, startTime: Date? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
            self.pipelineExecutionDescription = pipelineExecutionDescription
            self.pipelineExecutionDisplayName = pipelineExecutionDisplayName
            self.pipelineExecutionFailureReason = pipelineExecutionFailureReason
            self.pipelineExecutionStatus = pipelineExecutionStatus
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
            case pipelineExecutionDescription = "PipelineExecutionDescription"
            case pipelineExecutionDisplayName = "PipelineExecutionDisplayName"
            case pipelineExecutionFailureReason = "PipelineExecutionFailureReason"
            case pipelineExecutionStatus = "PipelineExecutionStatus"
            case startTime = "StartTime"
        }
    }

    public struct PipelineExperimentConfig: AWSDecodableShape {
        /// The name of the experiment.
        public let experimentName: String?
        /// The name of the trial.
        public let trialName: String?

        public init(experimentName: String? = nil, trialName: String? = nil) {
            self.experimentName = experimentName
            self.trialName = trialName
        }

        private enum CodingKeys: String, CodingKey {
            case experimentName = "ExperimentName"
            case trialName = "TrialName"
        }
    }

    public struct PipelineSummary: AWSDecodableShape {
        /// The creation time of the pipeline.
        public let creationTime: Date?
        /// The last time that a pipeline execution began.
        public let lastExecutionTime: Date?
        /// The time that the pipeline was last modified.
        public let lastModifiedTime: Date?
        ///  The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The description of the pipeline.
        public let pipelineDescription: String?
        /// The display name of the pipeline.
        public let pipelineDisplayName: String?
        /// The name of the pipeline.
        public let pipelineName: String?
        /// The Amazon Resource Name (ARN) that the pipeline used to execute.
        public let roleArn: String?

        public init(creationTime: Date? = nil, lastExecutionTime: Date? = nil, lastModifiedTime: Date? = nil, pipelineArn: String? = nil, pipelineDescription: String? = nil, pipelineDisplayName: String? = nil, pipelineName: String? = nil, roleArn: String? = nil) {
            self.creationTime = creationTime
            self.lastExecutionTime = lastExecutionTime
            self.lastModifiedTime = lastModifiedTime
            self.pipelineArn = pipelineArn
            self.pipelineDescription = pipelineDescription
            self.pipelineDisplayName = pipelineDisplayName
            self.pipelineName = pipelineName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastExecutionTime = "LastExecutionTime"
            case lastModifiedTime = "LastModifiedTime"
            case pipelineArn = "PipelineArn"
            case pipelineDescription = "PipelineDescription"
            case pipelineDisplayName = "PipelineDisplayName"
            case pipelineName = "PipelineName"
            case roleArn = "RoleArn"
        }
    }

    public struct ProcessingClusterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of ML compute instances to use in the processing job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        public let instanceCount: Int
        /// The ML compute instance type for the processing job.
        public let instanceType: ProcessingInstanceType
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the processing job.   Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a VolumeKmsKeyId when using an instance type with local storage. For a list of instance types that support local instance storage, see Instance Store Volumes. For more information about local instance storage encryption, see SSD Instance Store Volumes.
        public let volumeKmsKeyId: String?
        /// The size of the ML storage volume in gigabytes that you want to provision. You must specify sufficient ML storage for your scenario.  Certain Nitro-based instances include local storage with a fixed total size, dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts the local instance storage instead of Amazon EBS gp2 storage. You can't request a VolumeSizeInGB greater than the total size of the local instance storage. For a list of instance types that support local instance storage, including the total size per instance type, see Instance Store Volumes.
        public let volumeSizeInGB: Int

        public init(instanceCount: Int, instanceType: ProcessingInstanceType, volumeKmsKeyId: String? = nil, volumeSizeInGB: Int) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeKmsKeyId = volumeKmsKeyId
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, max: 100)
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, max: 16384)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct ProcessingFeatureStoreOutput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your  processing script is responsible for putting records into your Feature Store.
        public let featureGroupName: String

        public init(featureGroupName: String) {
            self.featureGroupName = featureGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupName = "FeatureGroupName"
        }
    }

    public struct ProcessingInput: AWSEncodableShape & AWSDecodableShape {
        /// When True, input operations such as data download are managed natively by the processing job application. When False (default), input operations are managed by Amazon SageMaker.
        public let appManaged: Bool?
        /// Configuration for a Dataset Definition input.
        public let datasetDefinition: DatasetDefinition?
        /// The name for the processing job input.
        public let inputName: String
        /// Configuration for downloading input data from Amazon S3 into the processing container.
        public let s3Input: ProcessingS3Input?

        public init(appManaged: Bool? = nil, datasetDefinition: DatasetDefinition? = nil, inputName: String, s3Input: ProcessingS3Input? = nil) {
            self.appManaged = appManaged
            self.datasetDefinition = datasetDefinition
            self.inputName = inputName
            self.s3Input = s3Input
        }

        public func validate(name: String) throws {
            try self.datasetDefinition?.validate(name: "\(name).datasetDefinition")
            try self.s3Input?.validate(name: "\(name).s3Input")
        }

        private enum CodingKeys: String, CodingKey {
            case appManaged = "AppManaged"
            case datasetDefinition = "DatasetDefinition"
            case inputName = "InputName"
            case s3Input = "S3Input"
        }
    }

    public struct ProcessingJob: AWSDecodableShape {
        public let appSpecification: AppSpecification?
        /// The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.
        public let autoMLJobArn: String?
        /// The time the processing job was created.
        public let creationTime: Date?
        /// Sets the environment variables in the Docker container.
        public let environment: [String: String]?
        /// A string, up to one KB in size, that contains metadata from the processing container when the processing job exits.
        public let exitMessage: String?
        public let experimentConfig: ExperimentConfig?
        /// A string, up to one KB in size, that contains the reason a processing job failed, if it failed.
        public let failureReason: String?
        /// The time the processing job was last modified.
        public let lastModifiedTime: Date?
        /// The ARN of a monitoring schedule for an endpoint associated with this processing job.
        public let monitoringScheduleArn: String?
        public let networkConfig: NetworkConfig?
        /// The time that the processing job ended.
        public let processingEndTime: Date?
        /// List of input configurations for the processing job.
        public let processingInputs: [ProcessingInput]?
        /// The ARN of the processing job.
        public let processingJobArn: String?
        /// The name of the processing job.
        public let processingJobName: String?
        /// The status of the processing job.
        public let processingJobStatus: ProcessingJobStatus?
        public let processingOutputConfig: ProcessingOutputConfig?
        public let processingResources: ProcessingResources?
        /// The time that the processing job started.
        public let processingStartTime: Date?
        /// The ARN of the role used to create the processing job.
        public let roleArn: String?
        public let stoppingCondition: ProcessingStoppingCondition?
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// The ARN of the training job associated with this processing job.
        public let trainingJobArn: String?

        public init(appSpecification: AppSpecification? = nil, autoMLJobArn: String? = nil, creationTime: Date? = nil, environment: [String: String]? = nil, exitMessage: String? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, lastModifiedTime: Date? = nil, monitoringScheduleArn: String? = nil, networkConfig: NetworkConfig? = nil, processingEndTime: Date? = nil, processingInputs: [ProcessingInput]? = nil, processingJobArn: String? = nil, processingJobName: String? = nil, processingJobStatus: ProcessingJobStatus? = nil, processingOutputConfig: ProcessingOutputConfig? = nil, processingResources: ProcessingResources? = nil, processingStartTime: Date? = nil, roleArn: String? = nil, stoppingCondition: ProcessingStoppingCondition? = nil, tags: [Tag]? = nil, trainingJobArn: String? = nil) {
            self.appSpecification = appSpecification
            self.autoMLJobArn = autoMLJobArn
            self.creationTime = creationTime
            self.environment = environment
            self.exitMessage = exitMessage
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.monitoringScheduleArn = monitoringScheduleArn
            self.networkConfig = networkConfig
            self.processingEndTime = processingEndTime
            self.processingInputs = processingInputs
            self.processingJobArn = processingJobArn
            self.processingJobName = processingJobName
            self.processingJobStatus = processingJobStatus
            self.processingOutputConfig = processingOutputConfig
            self.processingResources = processingResources
            self.processingStartTime = processingStartTime
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
            self.trainingJobArn = trainingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case appSpecification = "AppSpecification"
            case autoMLJobArn = "AutoMLJobArn"
            case creationTime = "CreationTime"
            case environment = "Environment"
            case exitMessage = "ExitMessage"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case monitoringScheduleArn = "MonitoringScheduleArn"
            case networkConfig = "NetworkConfig"
            case processingEndTime = "ProcessingEndTime"
            case processingInputs = "ProcessingInputs"
            case processingJobArn = "ProcessingJobArn"
            case processingJobName = "ProcessingJobName"
            case processingJobStatus = "ProcessingJobStatus"
            case processingOutputConfig = "ProcessingOutputConfig"
            case processingResources = "ProcessingResources"
            case processingStartTime = "ProcessingStartTime"
            case roleArn = "RoleArn"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
            case trainingJobArn = "TrainingJobArn"
        }
    }

    public struct ProcessingJobStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the processing job.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct ProcessingJobSummary: AWSDecodableShape {
        /// The time at which the processing job was created.
        public let creationTime: Date
        /// An optional string, up to one KB in size, that contains metadata from the processing container when the processing job exits.
        public let exitMessage: String?
        /// A string, up to one KB in size, that contains the reason a processing job failed, if it failed.
        public let failureReason: String?
        /// A timestamp that indicates the last time the processing job was modified.
        public let lastModifiedTime: Date?
        /// The time at which the processing job completed.
        public let processingEndTime: Date?
        /// The Amazon Resource Name (ARN) of the processing job..
        public let processingJobArn: String
        /// The name of the processing job.
        public let processingJobName: String
        /// The status of the processing job.
        public let processingJobStatus: ProcessingJobStatus

        public init(creationTime: Date, exitMessage: String? = nil, failureReason: String? = nil, lastModifiedTime: Date? = nil, processingEndTime: Date? = nil, processingJobArn: String, processingJobName: String, processingJobStatus: ProcessingJobStatus) {
            self.creationTime = creationTime
            self.exitMessage = exitMessage
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.processingEndTime = processingEndTime
            self.processingJobArn = processingJobArn
            self.processingJobName = processingJobName
            self.processingJobStatus = processingJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case exitMessage = "ExitMessage"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case processingEndTime = "ProcessingEndTime"
            case processingJobArn = "ProcessingJobArn"
            case processingJobName = "ProcessingJobName"
            case processingJobStatus = "ProcessingJobStatus"
        }
    }

    public struct ProcessingOutput: AWSEncodableShape & AWSDecodableShape {
        /// When True, output operations such as data upload are managed natively by the processing job application. When False (default), output operations are managed by Amazon SageMaker.
        public let appManaged: Bool?
        /// Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output type is only supported when AppManaged is specified.
        public let featureStoreOutput: ProcessingFeatureStoreOutput?
        /// The name for the processing job output.
        public let outputName: String
        /// Configuration for processing job outputs in Amazon S3.
        public let s3Output: ProcessingS3Output?

        public init(appManaged: Bool? = nil, featureStoreOutput: ProcessingFeatureStoreOutput? = nil, outputName: String, s3Output: ProcessingS3Output? = nil) {
            self.appManaged = appManaged
            self.featureStoreOutput = featureStoreOutput
            self.outputName = outputName
            self.s3Output = s3Output
        }

        public func validate(name: String) throws {
            try self.featureStoreOutput?.validate(name: "\(name).featureStoreOutput")
            try self.s3Output?.validate(name: "\(name).s3Output")
        }

        private enum CodingKeys: String, CodingKey {
            case appManaged = "AppManaged"
            case featureStoreOutput = "FeatureStoreOutput"
            case outputName = "OutputName"
            case s3Output = "S3Output"
        }
    }

    public struct ProcessingOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing job output. KmsKeyId can be an ID of a KMS key, ARN of a KMS key, alias of a KMS key, or alias of a KMS key. The KmsKeyId is applied to all outputs.
        public let kmsKeyId: String?
        /// An array of outputs configuring the data to upload from the processing container.
        public let outputs: [ProcessingOutput]

        public init(kmsKeyId: String? = nil, outputs: [ProcessingOutput]) {
            self.kmsKeyId = kmsKeyId
            self.outputs = outputs
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.outputs.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case outputs = "Outputs"
        }
    }

    public struct ProcessingResources: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the resources in a cluster used to run the processing job.
        public let clusterConfig: ProcessingClusterConfig

        public init(clusterConfig: ProcessingClusterConfig) {
            self.clusterConfig = clusterConfig
        }

        public func validate(name: String) throws {
            try self.clusterConfig.validate(name: "\(name).clusterConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterConfig = "ClusterConfig"
        }
    }

    public struct ProcessingS3Input: AWSEncodableShape & AWSDecodableShape {
        /// The local path in your container where you want Amazon SageMaker to write input data to.  LocalPath is an absolute path to the input data and must begin with  /opt/ml/processing/. LocalPath is a required  parameter when AppManaged is False (default).
        public let localPath: String?
        /// Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing  container. Gzip can only be used when Pipe mode is  specified as the S3InputMode. In Pipe mode, Amazon SageMaker streams input  data from the source directly to your container without using the EBS volume.
        public let s3CompressionType: ProcessingS3CompressionType?
        /// Whether to distribute the data from Amazon S3 to all processing instances with  FullyReplicated, or whether the data from Amazon S3 is shared by Amazon S3 key,  downloading one shard of data to each processing instance.
        public let s3DataDistributionType: ProcessingS3DataDistributionType?
        /// Whether you use an S3Prefix or a ManifestFile for the data type. If you choose S3Prefix, S3Uri identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing job. If you choose ManifestFile, S3Uri identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for the processing job.
        public let s3DataType: ProcessingS3DataType
        /// Whether to use File or Pipe input mode. In File mode, Amazon SageMaker copies the data  from the input source onto the local ML storage volume before starting your processing  container. This is the most commonly used input mode. In Pipe mode, Amazon SageMaker  streams input data from the source directly to your processing container into named  pipes without using the ML storage volume.
        public let s3InputMode: ProcessingS3InputMode?
        /// The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.
        public let s3Uri: String

        public init(localPath: String? = nil, s3CompressionType: ProcessingS3CompressionType? = nil, s3DataDistributionType: ProcessingS3DataDistributionType? = nil, s3DataType: ProcessingS3DataType, s3InputMode: ProcessingS3InputMode? = nil, s3Uri: String) {
            self.localPath = localPath
            self.s3CompressionType = s3CompressionType
            self.s3DataDistributionType = s3DataDistributionType
            self.s3DataType = s3DataType
            self.s3InputMode = s3InputMode
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "LocalPath"
            case s3CompressionType = "S3CompressionType"
            case s3DataDistributionType = "S3DataDistributionType"
            case s3DataType = "S3DataType"
            case s3InputMode = "S3InputMode"
            case s3Uri = "S3Uri"
        }
    }

    public struct ProcessingS3Output: AWSEncodableShape & AWSDecodableShape {
        /// The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3.  LocalPath is an absolute path to a directory containing output files.  This directory will be created by the platform and exist when your container's  entrypoint is invoked.
        public let localPath: String
        /// Whether to upload the results of the processing job continuously or after the job completes.
        public let s3UploadMode: ProcessingS3UploadMode
        /// A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of a processing job.
        public let s3Uri: String

        public init(localPath: String, s3UploadMode: ProcessingS3UploadMode, s3Uri: String) {
            self.localPath = localPath
            self.s3UploadMode = s3UploadMode
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 256)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "LocalPath"
            case s3UploadMode = "S3UploadMode"
            case s3Uri = "S3Uri"
        }
    }

    public struct ProcessingStoppingCondition: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the maximum runtime in seconds.
        public let maxRuntimeInSeconds: Int

        public init(maxRuntimeInSeconds: Int) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRuntimeInSeconds, name: "maxRuntimeInSeconds", parent: name, max: 604_800)
            try self.validate(self.maxRuntimeInSeconds, name: "maxRuntimeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRuntimeInSeconds = "MaxRuntimeInSeconds"
        }
    }

    public struct ProductionVariant: AWSEncodableShape & AWSDecodableShape {
        /// The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorType: ProductionVariantAcceleratorType?
        /// The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see How Your Container Should Respond to Health Check (Ping) Requests.
        public let containerStartupHealthCheckTimeoutInSeconds: Int?
        /// Specifies configuration for a core dump from the model container when the process crashes.
        public let coreDumpConfig: ProductionVariantCoreDumpConfig?
        /// Number of instances to launch initially.
        public let initialInstanceCount: Int?
        /// Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the VariantWeight to the sum of all VariantWeight values across all ProductionVariants. If unspecified, it defaults to 1.0.
        public let initialVariantWeight: Float?
        /// The ML compute instance type.
        public let instanceType: ProductionVariantInstanceType?
        /// The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant.
        public let modelDataDownloadTimeoutInSeconds: Int?
        /// The name of the model that you want to host. This is the name that you specified when creating the model.
        public let modelName: String
        /// The serverless configuration for an endpoint. Specifies a serverless endpoint configuration instead of an instance-based endpoint configuration.
        public let serverlessConfig: ProductionVariantServerlessConfig?
        /// The name of the production variant.
        public let variantName: String
        /// The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Currenly only Amazon EBS gp2 storage volumes are supported.
        public let volumeSizeInGB: Int?

        public init(acceleratorType: ProductionVariantAcceleratorType? = nil, containerStartupHealthCheckTimeoutInSeconds: Int? = nil, coreDumpConfig: ProductionVariantCoreDumpConfig? = nil, initialInstanceCount: Int? = nil, initialVariantWeight: Float? = nil, instanceType: ProductionVariantInstanceType? = nil, modelDataDownloadTimeoutInSeconds: Int? = nil, modelName: String, serverlessConfig: ProductionVariantServerlessConfig? = nil, variantName: String, volumeSizeInGB: Int? = nil) {
            self.acceleratorType = acceleratorType
            self.containerStartupHealthCheckTimeoutInSeconds = containerStartupHealthCheckTimeoutInSeconds
            self.coreDumpConfig = coreDumpConfig
            self.initialInstanceCount = initialInstanceCount
            self.initialVariantWeight = initialVariantWeight
            self.instanceType = instanceType
            self.modelDataDownloadTimeoutInSeconds = modelDataDownloadTimeoutInSeconds
            self.modelName = modelName
            self.serverlessConfig = serverlessConfig
            self.variantName = variantName
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.containerStartupHealthCheckTimeoutInSeconds, name: "containerStartupHealthCheckTimeoutInSeconds", parent: name, max: 3600)
            try self.validate(self.containerStartupHealthCheckTimeoutInSeconds, name: "containerStartupHealthCheckTimeoutInSeconds", parent: name, min: 60)
            try self.coreDumpConfig?.validate(name: "\(name).coreDumpConfig")
            try self.validate(self.initialInstanceCount, name: "initialInstanceCount", parent: name, min: 1)
            try self.validate(self.initialVariantWeight, name: "initialVariantWeight", parent: name, min: 0.0)
            try self.validate(self.modelDataDownloadTimeoutInSeconds, name: "modelDataDownloadTimeoutInSeconds", parent: name, max: 3600)
            try self.validate(self.modelDataDownloadTimeoutInSeconds, name: "modelDataDownloadTimeoutInSeconds", parent: name, min: 60)
            try self.validate(self.modelName, name: "modelName", parent: name, max: 63)
            try self.validate(self.modelName, name: "modelName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.serverlessConfig?.validate(name: "\(name).serverlessConfig")
            try self.validate(self.variantName, name: "variantName", parent: name, max: 63)
            try self.validate(self.variantName, name: "variantName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, max: 512)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorType = "AcceleratorType"
            case containerStartupHealthCheckTimeoutInSeconds = "ContainerStartupHealthCheckTimeoutInSeconds"
            case coreDumpConfig = "CoreDumpConfig"
            case initialInstanceCount = "InitialInstanceCount"
            case initialVariantWeight = "InitialVariantWeight"
            case instanceType = "InstanceType"
            case modelDataDownloadTimeoutInSeconds = "ModelDataDownloadTimeoutInSeconds"
            case modelName = "ModelName"
            case serverlessConfig = "ServerlessConfig"
            case variantName = "VariantName"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct ProductionVariantCoreDumpConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket to send the core dump to.
        public let destinationS3Uri: String
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"    If you use a KMS key ID or an alias of your KMS key, the SageMaker execution role must include permissions to call kms:Encrypt. If you don't provide a KMS key ID, SageMaker uses the default KMS key for Amazon S3 for your role's account. SageMaker uses server-side encryption with KMS-managed keys for OutputDataConfig. If you use a bucket policy with an s3:PutObject permission that only allows objects with server-side encryption, set the condition key of s3:x-amz-server-side-encryption to "aws:kms". For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.  The KMS key policy must grant permission to the IAM role that you specify in your CreateEndpoint and UpdateEndpoint requests. For more information, see Using Key Policies in Amazon Web Services KMS in the Amazon Web Services Key Management Service Developer Guide.
        public let kmsKeyId: String?

        public init(destinationS3Uri: String, kmsKeyId: String? = nil) {
            self.destinationS3Uri = destinationS3Uri
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, max: 512)
            try self.validate(self.destinationS3Uri, name: "destinationS3Uri", parent: name, pattern: "^(https|s3)://([^/])/?(.*)$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationS3Uri = "DestinationS3Uri"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ProductionVariantServerlessConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of concurrent invocations your serverless endpoint can process.
        public let maxConcurrency: Int
        /// The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.
        public let memorySizeInMB: Int

        public init(maxConcurrency: Int, memorySizeInMB: Int) {
            self.maxConcurrency = maxConcurrency
            self.memorySizeInMB = memorySizeInMB
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConcurrency, name: "maxConcurrency", parent: name, max: 200)
            try self.validate(self.maxConcurrency, name: "maxConcurrency", parent: name, min: 1)
            try self.validate(self.memorySizeInMB, name: "memorySizeInMB", parent: name, max: 6144)
            try self.validate(self.memorySizeInMB, name: "memorySizeInMB", parent: name, min: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrency = "MaxConcurrency"
            case memorySizeInMB = "MemorySizeInMB"
        }
    }

    public struct ProductionVariantStatus: AWSDecodableShape {
        /// The start time of the current status change.
        public let startTime: Date?
        /// The endpoint variant status which describes the current deployment stage status or operational status.    Creating: Creating inference resources for the production variant.    Deleting: Terminating inference resources for the production variant.    Updating: Updating capacity for the production variant.    ActivatingTraffic: Turning on traffic for the production variant.    Baking: Waiting period to monitor the CloudWatch alarms in the automatic rollback configuration.
        public let status: VariantStatus
        /// A message that describes the status of the production variant.
        public let statusMessage: String?

        public init(startTime: Date? = nil, status: VariantStatus, statusMessage: String? = nil) {
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ProductionVariantSummary: AWSDecodableShape {
        /// The number of instances associated with the variant.
        public let currentInstanceCount: Int?
        /// The serverless configuration for the endpoint.
        public let currentServerlessConfig: ProductionVariantServerlessConfig?
        /// The weight associated with the variant.
        public let currentWeight: Float?
        /// An array of DeployedImage objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this ProductionVariant.
        public let deployedImages: [DeployedImage]?
        /// The number of instances requested in the UpdateEndpointWeightsAndCapacities request.
        public let desiredInstanceCount: Int?
        /// The serverless configuration requested for the endpoint update.
        public let desiredServerlessConfig: ProductionVariantServerlessConfig?
        /// The requested weight, as specified in the UpdateEndpointWeightsAndCapacities request.
        public let desiredWeight: Float?
        /// The name of the variant.
        public let variantName: String
        /// The endpoint variant status which describes the current deployment stage status or operational status.
        public let variantStatus: [ProductionVariantStatus]?

        public init(currentInstanceCount: Int? = nil, currentServerlessConfig: ProductionVariantServerlessConfig? = nil, currentWeight: Float? = nil, deployedImages: [DeployedImage]? = nil, desiredInstanceCount: Int? = nil, desiredServerlessConfig: ProductionVariantServerlessConfig? = nil, desiredWeight: Float? = nil, variantName: String, variantStatus: [ProductionVariantStatus]? = nil) {
            self.currentInstanceCount = currentInstanceCount
            self.currentServerlessConfig = currentServerlessConfig
            self.currentWeight = currentWeight
            self.deployedImages = deployedImages
            self.desiredInstanceCount = desiredInstanceCount
            self.desiredServerlessConfig = desiredServerlessConfig
            self.desiredWeight = desiredWeight
            self.variantName = variantName
            self.variantStatus = variantStatus
        }

        private enum CodingKeys: String, CodingKey {
            case currentInstanceCount = "CurrentInstanceCount"
            case currentServerlessConfig = "CurrentServerlessConfig"
            case currentWeight = "CurrentWeight"
            case deployedImages = "DeployedImages"
            case desiredInstanceCount = "DesiredInstanceCount"
            case desiredServerlessConfig = "DesiredServerlessConfig"
            case desiredWeight = "DesiredWeight"
            case variantName = "VariantName"
            case variantStatus = "VariantStatus"
        }
    }

    public struct ProfilerConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configuration to turn off Amazon SageMaker Debugger's system monitoring and profiling functionality. To turn it off, set to True.
        public let disableProfiler: Bool?
        /// A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.
        public let profilingIntervalInMilliseconds: Int64?
        /// Configuration information for capturing framework metrics. Available key strings for different profiling options are DetailedProfilingConfig, PythonProfilingConfig, and DataLoaderProfilingConfig. The following codes are configuration structures for the ProfilingParameters parameter. To learn more about how to configure the ProfilingParameters parameter,  see Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job.
        public let profilingParameters: [String: String]?
        /// Path to Amazon S3 storage location for system and framework metrics.
        public let s3OutputPath: String?

        public init(disableProfiler: Bool? = nil, profilingIntervalInMilliseconds: Int64? = nil, profilingParameters: [String: String]? = nil, s3OutputPath: String? = nil) {
            self.disableProfiler = disableProfiler
            self.profilingIntervalInMilliseconds = profilingIntervalInMilliseconds
            self.profilingParameters = profilingParameters
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.profilingParameters?.forEach {
                try validate($0.key, name: "profilingParameters.key", parent: name, max: 256)
                try validate($0.key, name: "profilingParameters.key", parent: name, min: 1)
                try validate($0.key, name: "profilingParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "profilingParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "profilingParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.profilingParameters, name: "profilingParameters", parent: name, max: 20)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case disableProfiler = "DisableProfiler"
            case profilingIntervalInMilliseconds = "ProfilingIntervalInMilliseconds"
            case profilingParameters = "ProfilingParameters"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct ProfilerConfigForUpdate: AWSEncodableShape {
        /// To turn off Amazon SageMaker Debugger monitoring and profiling while a training job is in progress, set to True.
        public let disableProfiler: Bool?
        /// A time interval for capturing system metrics in milliseconds. Available values are 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.
        public let profilingIntervalInMilliseconds: Int64?
        /// Configuration information for capturing framework metrics. Available key strings for different profiling options are DetailedProfilingConfig, PythonProfilingConfig, and DataLoaderProfilingConfig. The following codes are configuration structures for the ProfilingParameters parameter. To learn more about how to configure the ProfilingParameters parameter,  see Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job.
        public let profilingParameters: [String: String]?
        /// Path to Amazon S3 storage location for system and framework metrics.
        public let s3OutputPath: String?

        public init(disableProfiler: Bool? = nil, profilingIntervalInMilliseconds: Int64? = nil, profilingParameters: [String: String]? = nil, s3OutputPath: String? = nil) {
            self.disableProfiler = disableProfiler
            self.profilingIntervalInMilliseconds = profilingIntervalInMilliseconds
            self.profilingParameters = profilingParameters
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.profilingParameters?.forEach {
                try validate($0.key, name: "profilingParameters.key", parent: name, max: 256)
                try validate($0.key, name: "profilingParameters.key", parent: name, min: 1)
                try validate($0.key, name: "profilingParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "profilingParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "profilingParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.profilingParameters, name: "profilingParameters", parent: name, max: 20)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case disableProfiler = "DisableProfiler"
            case profilingIntervalInMilliseconds = "ProfilingIntervalInMilliseconds"
            case profilingParameters = "ProfilingParameters"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct ProfilerRuleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The instance type to deploy a custom rule for profiling a training job.
        public let instanceType: ProcessingInstanceType?
        /// Path to local storage location for output of rules. Defaults to /opt/ml/processing/output/rule/.
        public let localPath: String?
        /// The name of the rule configuration. It must be unique relative to other rule configuration names.
        public let ruleConfigurationName: String
        /// The Amazon Elastic Container Registry Image for the managed rule evaluation.
        public let ruleEvaluatorImage: String
        /// Runtime configuration for rule container.
        public let ruleParameters: [String: String]?
        /// Path to Amazon S3 storage location for rules.
        public let s3OutputPath: String?
        /// The size, in GB, of the ML storage volume attached to the processing instance.
        public let volumeSizeInGB: Int?

        public init(instanceType: ProcessingInstanceType? = nil, localPath: String? = nil, ruleConfigurationName: String, ruleEvaluatorImage: String, ruleParameters: [String: String]? = nil, s3OutputPath: String? = nil, volumeSizeInGB: Int? = nil) {
            self.instanceType = instanceType
            self.localPath = localPath
            self.ruleConfigurationName = ruleConfigurationName
            self.ruleEvaluatorImage = ruleEvaluatorImage
            self.ruleParameters = ruleParameters
            self.s3OutputPath = s3OutputPath
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, max: 256)
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, min: 1)
            try self.validate(self.ruleConfigurationName, name: "ruleConfigurationName", parent: name, pattern: ".*")
            try self.validate(self.ruleEvaluatorImage, name: "ruleEvaluatorImage", parent: name, max: 255)
            try self.validate(self.ruleEvaluatorImage, name: "ruleEvaluatorImage", parent: name, pattern: ".*")
            try self.ruleParameters?.forEach {
                try validate($0.key, name: "ruleParameters.key", parent: name, max: 256)
                try validate($0.key, name: "ruleParameters.key", parent: name, min: 1)
                try validate($0.key, name: "ruleParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "ruleParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "ruleParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.ruleParameters, name: "ruleParameters", parent: name, max: 100)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case localPath = "LocalPath"
            case ruleConfigurationName = "RuleConfigurationName"
            case ruleEvaluatorImage = "RuleEvaluatorImage"
            case ruleParameters = "RuleParameters"
            case s3OutputPath = "S3OutputPath"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct ProfilerRuleEvaluationStatus: AWSDecodableShape {
        /// Timestamp when the rule evaluation status was last modified.
        public let lastModifiedTime: Date?
        /// The name of the rule configuration.
        public let ruleConfigurationName: String?
        /// The Amazon Resource Name (ARN) of the rule evaluation job.
        public let ruleEvaluationJobArn: String?
        /// Status of the rule evaluation.
        public let ruleEvaluationStatus: RuleEvaluationStatus?
        /// Details from the rule evaluation.
        public let statusDetails: String?

        public init(lastModifiedTime: Date? = nil, ruleConfigurationName: String? = nil, ruleEvaluationJobArn: String? = nil, ruleEvaluationStatus: RuleEvaluationStatus? = nil, statusDetails: String? = nil) {
            self.lastModifiedTime = lastModifiedTime
            self.ruleConfigurationName = ruleConfigurationName
            self.ruleEvaluationJobArn = ruleEvaluationJobArn
            self.ruleEvaluationStatus = ruleEvaluationStatus
            self.statusDetails = statusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case ruleConfigurationName = "RuleConfigurationName"
            case ruleEvaluationJobArn = "RuleEvaluationJobArn"
            case ruleEvaluationStatus = "RuleEvaluationStatus"
            case statusDetails = "StatusDetails"
        }
    }

    public struct Project: AWSDecodableShape {
        /// Who created the project.
        public let createdBy: UserContext?
        /// A timestamp specifying when the project was created.
        public let creationTime: Date?
        public let lastModifiedBy: UserContext?
        /// A timestamp container for when the project was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The description of the project.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String?
        /// The name of the project.
        public let projectName: String?
        /// The status of the project.
        public let projectStatus: ProjectStatus?
        public let serviceCatalogProvisionedProductDetails: ServiceCatalogProvisionedProductDetails?
        public let serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, projectArn: String? = nil, projectDescription: String? = nil, projectId: String? = nil, projectName: String? = nil, projectStatus: ProjectStatus? = nil, serviceCatalogProvisionedProductDetails: ServiceCatalogProvisionedProductDetails? = nil, serviceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails? = nil, tags: [Tag]? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
            self.projectStatus = projectStatus
            self.serviceCatalogProvisionedProductDetails = serviceCatalogProvisionedProductDetails
            self.serviceCatalogProvisioningDetails = serviceCatalogProvisioningDetails
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case projectArn = "ProjectArn"
            case projectDescription = "ProjectDescription"
            case projectId = "ProjectId"
            case projectName = "ProjectName"
            case projectStatus = "ProjectStatus"
            case serviceCatalogProvisionedProductDetails = "ServiceCatalogProvisionedProductDetails"
            case serviceCatalogProvisioningDetails = "ServiceCatalogProvisioningDetails"
            case tags = "Tags"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The time that the project was created.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String
        /// The description of the project.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The name of the project.
        public let projectName: String
        /// The status of the project.
        public let projectStatus: ProjectStatus

        public init(creationTime: Date, projectArn: String, projectDescription: String? = nil, projectId: String, projectName: String, projectStatus: ProjectStatus) {
            self.creationTime = creationTime
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
            self.projectStatus = projectStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case projectArn = "ProjectArn"
            case projectDescription = "ProjectDescription"
            case projectId = "ProjectId"
            case projectName = "ProjectName"
            case projectStatus = "ProjectStatus"
        }
    }

    public struct PropertyNameQuery: AWSEncodableShape {
        /// Text that begins a property's name.
        public let propertyNameHint: String

        public init(propertyNameHint: String) {
            self.propertyNameHint = propertyNameHint
        }

        public func validate(name: String) throws {
            try self.validate(self.propertyNameHint, name: "propertyNameHint", parent: name, max: 100)
            try self.validate(self.propertyNameHint, name: "propertyNameHint", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameHint = "PropertyNameHint"
        }
    }

    public struct PropertyNameSuggestion: AWSDecodableShape {
        /// A suggested property name based on what you entered in the search textbox in the Amazon SageMaker console.
        public let propertyName: String?

        public init(propertyName: String? = nil) {
            self.propertyName = propertyName
        }

        private enum CodingKeys: String, CodingKey {
            case propertyName = "PropertyName"
        }
    }

    public struct ProvisioningParameter: AWSEncodableShape & AWSDecodableShape {
        /// The key that identifies a provisioning parameter.
        public let key: String?
        /// The value of the provisioning parameter.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: ".*")
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct PublicWorkforceTaskPrice: AWSEncodableShape & AWSDecodableShape {
        /// Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.
        public let amountInUsd: USD?

        public init(amountInUsd: USD? = nil) {
            self.amountInUsd = amountInUsd
        }

        public func validate(name: String) throws {
            try self.amountInUsd?.validate(name: "\(name).amountInUsd")
        }

        private enum CodingKeys: String, CodingKey {
            case amountInUsd = "AmountInUsd"
        }
    }

    public struct PutModelPackageGroupPolicyInput: AWSEncodableShape {
        /// The name of the model group to add a resource policy to.
        public let modelPackageGroupName: String
        /// The resource policy for the model group.
        public let resourcePolicy: String

        public init(modelPackageGroupName: String, resourcePolicy: String) {
            self.modelPackageGroupName = modelPackageGroupName
            self.resourcePolicy = resourcePolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, max: 63)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, min: 1)
            try self.validate(self.modelPackageGroupName, name: "modelPackageGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, max: 20480)
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, min: 1)
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupName = "ModelPackageGroupName"
            case resourcePolicy = "ResourcePolicy"
        }
    }

    public struct PutModelPackageGroupPolicyOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model package group.
        public let modelPackageGroupArn: String

        public init(modelPackageGroupArn: String) {
            self.modelPackageGroupArn = modelPackageGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageGroupArn = "ModelPackageGroupArn"
        }
    }

    public struct QualityCheckStepMetadata: AWSDecodableShape {
        /// The Amazon S3 URI of the baseline constraints file used for the drift check.
        public let baselineUsedForDriftCheckConstraints: String?
        /// The Amazon S3 URI of the baseline statistics file used for the drift check.
        public let baselineUsedForDriftCheckStatistics: String?
        /// The Amazon S3 URI of the newly calculated baseline constraints file.
        public let calculatedBaselineConstraints: String?
        /// The Amazon S3 URI of the newly calculated baseline statistics file.
        public let calculatedBaselineStatistics: String?
        /// The Amazon Resource Name (ARN) of the Quality check processing job that was run by this step execution.
        public let checkJobArn: String?
        /// The type of the Quality check step.
        public let checkType: String?
        /// The model package group name.
        public let modelPackageGroupName: String?
        /// This flag indicates if a newly calculated baseline can be accessed through step properties  BaselineUsedForDriftCheckConstraints and BaselineUsedForDriftCheckStatistics.  If it is set to False, the previous baseline of the configured check type must also be available.  These can be accessed through the BaselineUsedForDriftCheckConstraints and  BaselineUsedForDriftCheckStatistics properties.
        public let registerNewBaseline: Bool?
        /// This flag indicates if the drift check against the previous baseline will be skipped or not.  If it is set to False, the previous baseline of the configured check type must be available.
        public let skipCheck: Bool?
        /// The Amazon S3 URI of violation report if violations are detected.
        public let violationReport: String?

        public init(baselineUsedForDriftCheckConstraints: String? = nil, baselineUsedForDriftCheckStatistics: String? = nil, calculatedBaselineConstraints: String? = nil, calculatedBaselineStatistics: String? = nil, checkJobArn: String? = nil, checkType: String? = nil, modelPackageGroupName: String? = nil, registerNewBaseline: Bool? = nil, skipCheck: Bool? = nil, violationReport: String? = nil) {
            self.baselineUsedForDriftCheckConstraints = baselineUsedForDriftCheckConstraints
            self.baselineUsedForDriftCheckStatistics = baselineUsedForDriftCheckStatistics
            self.calculatedBaselineConstraints = calculatedBaselineConstraints
            self.calculatedBaselineStatistics = calculatedBaselineStatistics
            self.checkJobArn = checkJobArn
            self.checkType = checkType
            self.modelPackageGroupName = modelPackageGroupName
            self.registerNewBaseline = registerNewBaseline
            self.skipCheck = skipCheck
            self.violationReport = violationReport
        }

        private enum CodingKeys: String, CodingKey {
            case baselineUsedForDriftCheckConstraints = "BaselineUsedForDriftCheckConstraints"
            case baselineUsedForDriftCheckStatistics = "BaselineUsedForDriftCheckStatistics"
            case calculatedBaselineConstraints = "CalculatedBaselineConstraints"
            case calculatedBaselineStatistics = "CalculatedBaselineStatistics"
            case checkJobArn = "CheckJobArn"
            case checkType = "CheckType"
            case modelPackageGroupName = "ModelPackageGroupName"
            case registerNewBaseline = "RegisterNewBaseline"
            case skipCheck = "SkipCheck"
            case violationReport = "ViolationReport"
        }
    }

    public struct QueryFilters: AWSEncodableShape {
        /// Filter the lineage entities connected to the StartArn(s) after the create date.
        public let createdAfter: Date?
        /// Filter the lineage entities connected to the StartArn(s) by created date.
        public let createdBefore: Date?
        /// Filter the lineage entities connected to the StartArn(s) by the type of the lineage entity.
        public let lineageTypes: [LineageType]?
        /// Filter the lineage entities connected to the StartArn(s) after the last modified date.
        public let modifiedAfter: Date?
        /// Filter the lineage entities connected to the StartArn(s) before the last modified date.
        public let modifiedBefore: Date?
        /// Filter the lineage entities connected to the StartArn(s) by a set if property key value pairs.  If multiple pairs are provided, an entity is included in the results if it matches any of the provided pairs.
        public let properties: [String: String]?
        /// Filter the lineage entities connected to the StartArn by type. For example: DataSet,  Model, Endpoint, or ModelDeployment.
        public let types: [String]?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, lineageTypes: [LineageType]? = nil, modifiedAfter: Date? = nil, modifiedBefore: Date? = nil, properties: [String: String]? = nil, types: [String]? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.lineageTypes = lineageTypes
            self.modifiedAfter = modifiedAfter
            self.modifiedBefore = modifiedBefore
            self.properties = properties
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.lineageTypes, name: "lineageTypes", parent: name, max: 4)
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 5)
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, max: 40)
            }
            try self.validate(self.types, name: "types", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case lineageTypes = "LineageTypes"
            case modifiedAfter = "ModifiedAfter"
            case modifiedBefore = "ModifiedBefore"
            case properties = "Properties"
            case types = "Types"
        }
    }

    public struct QueryLineageRequest: AWSEncodableShape {
        /// Associations between lineage entities have a direction.  This parameter determines the direction from the  StartArn(s) that the query traverses.
        public let direction: Direction?
        /// A set of filtering parameters that allow you to specify which entities should be returned.   Properties - Key-value pairs to match on the lineage entities' properties.   LineageTypes - A set of lineage entity types to match on. For example: TrialComponent,  Artifact, or Context.   CreatedBefore - Filter entities created before this date.   ModifiedBefore - Filter entities modified before this date.   ModifiedAfter - Filter entities modified after this date.
        public let filters: QueryFilters?
        ///  Setting this value to True retrieves not only the entities of interest but also the  Associations and  lineage entities on the path. Set to False to only return lineage entities that match your query.
        public let includeEdges: Bool?
        /// The maximum depth in lineage relationships from the StartArns that are traversed. Depth is a measure of the number  of Associations from the StartArn entity to the matched results.
        public let maxDepth: Int?
        /// Limits the number of vertices in the results. Use the NextToken in a response to to retrieve the next page of results.
        public let maxResults: Int?
        /// Limits the number of vertices in the request. Use the NextToken in a response to to retrieve the next page of results.
        public let nextToken: String?
        /// A list of resource Amazon Resource Name (ARN) that represent the starting point for your lineage query.
        public let startArns: [String]?

        public init(direction: Direction? = nil, filters: QueryFilters? = nil, includeEdges: Bool? = nil, maxDepth: Int? = nil, maxResults: Int? = nil, nextToken: String? = nil, startArns: [String]? = nil) {
            self.direction = direction
            self.filters = filters
            self.includeEdges = includeEdges
            self.maxDepth = maxDepth
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startArns = startArns
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.startArns?.forEach {
                try validate($0, name: "startArns[]", parent: name, max: 256)
                try validate($0, name: "startArns[]", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:(experiment|experiment-trial-component|artifact|action|context)/")
            }
            try self.validate(self.startArns, name: "startArns", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case filters = "Filters"
            case includeEdges = "IncludeEdges"
            case maxDepth = "MaxDepth"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startArns = "StartArns"
        }
    }

    public struct QueryLineageResponse: AWSDecodableShape {
        /// A list of edges that connect vertices in the response.
        public let edges: [Edge]?
        /// Limits the number of vertices in the response. Use the NextToken in a response to to retrieve the next page of results.
        public let nextToken: String?
        /// A list of vertices connected to the start entity(ies) in the lineage graph.
        public let vertices: [Vertex]?

        public init(edges: [Edge]? = nil, nextToken: String? = nil, vertices: [Vertex]? = nil) {
            self.edges = edges
            self.nextToken = nextToken
            self.vertices = vertices
        }

        private enum CodingKeys: String, CodingKey {
            case edges = "Edges"
            case nextToken = "NextToken"
            case vertices = "Vertices"
        }
    }

    public struct RSessionAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// A list of custom SageMaker images that are configured to run as a RSession app.
        public let customImages: [CustomImage]?
        public let defaultResourceSpec: ResourceSpec?

        public init(customImages: [CustomImage]? = nil, defaultResourceSpec: ResourceSpec? = nil) {
            self.customImages = customImages
            self.defaultResourceSpec = defaultResourceSpec
        }

        public func validate(name: String) throws {
            try self.customImages?.forEach {
                try $0.validate(name: "\(name).customImages[]")
            }
            try self.validate(self.customImages, name: "customImages", parent: name, max: 200)
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
        }

        private enum CodingKeys: String, CodingKey {
            case customImages = "CustomImages"
            case defaultResourceSpec = "DefaultResourceSpec"
        }
    }

    public struct RStudioServerProAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the current user has access to the RStudioServerPro app.
        public let accessStatus: RStudioServerProAccessStatus?
        /// The level of permissions that the user has within the RStudioServerPro app. This value defaults to `User`. The `Admin` value allows the user access to the RStudio Administrative Dashboard.
        public let userGroup: RStudioServerProUserGroup?

        public init(accessStatus: RStudioServerProAccessStatus? = nil, userGroup: RStudioServerProUserGroup? = nil) {
            self.accessStatus = accessStatus
            self.userGroup = userGroup
        }

        private enum CodingKeys: String, CodingKey {
            case accessStatus = "AccessStatus"
            case userGroup = "UserGroup"
        }
    }

    public struct RStudioServerProDomainSettings: AWSEncodableShape & AWSDecodableShape {
        public let defaultResourceSpec: ResourceSpec?
        /// The ARN of the execution role for the RStudioServerPro Domain-level app.
        public let domainExecutionRoleArn: String
        /// A URL pointing to an RStudio Connect server.
        public let rStudioConnectUrl: String?
        /// A URL pointing to an RStudio Package Manager server.
        public let rStudioPackageManagerUrl: String?

        public init(defaultResourceSpec: ResourceSpec? = nil, domainExecutionRoleArn: String, rStudioConnectUrl: String? = nil, rStudioPackageManagerUrl: String? = nil) {
            self.defaultResourceSpec = defaultResourceSpec
            self.domainExecutionRoleArn = domainExecutionRoleArn
            self.rStudioConnectUrl = rStudioConnectUrl
            self.rStudioPackageManagerUrl = rStudioPackageManagerUrl
        }

        public func validate(name: String) throws {
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, min: 20)
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultResourceSpec = "DefaultResourceSpec"
            case domainExecutionRoleArn = "DomainExecutionRoleArn"
            case rStudioConnectUrl = "RStudioConnectUrl"
            case rStudioPackageManagerUrl = "RStudioPackageManagerUrl"
        }
    }

    public struct RStudioServerProDomainSettingsForUpdate: AWSEncodableShape {
        public let defaultResourceSpec: ResourceSpec?
        /// The execution role for the RStudioServerPro Domain-level app.
        public let domainExecutionRoleArn: String
        /// A URL pointing to an RStudio Connect server.
        public let rStudioConnectUrl: String?
        /// A URL pointing to an RStudio Package Manager server.
        public let rStudioPackageManagerUrl: String?

        public init(defaultResourceSpec: ResourceSpec? = nil, domainExecutionRoleArn: String, rStudioConnectUrl: String? = nil, rStudioPackageManagerUrl: String? = nil) {
            self.defaultResourceSpec = defaultResourceSpec
            self.domainExecutionRoleArn = domainExecutionRoleArn
            self.rStudioConnectUrl = rStudioConnectUrl
            self.rStudioPackageManagerUrl = rStudioPackageManagerUrl
        }

        public func validate(name: String) throws {
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, min: 20)
            try self.validate(self.domainExecutionRoleArn, name: "domainExecutionRoleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultResourceSpec = "DefaultResourceSpec"
            case domainExecutionRoleArn = "DomainExecutionRoleArn"
            case rStudioConnectUrl = "RStudioConnectUrl"
            case rStudioPackageManagerUrl = "RStudioPackageManagerUrl"
        }
    }

    public struct RealTimeInferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances of the type specified by InstanceType.
        public let instanceCount: Int
        /// The instance type the model is deployed to.
        public let instanceType: InstanceType

        public init(instanceCount: Int, instanceType: InstanceType) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
        }
    }

    public struct RecommendationJobCompiledOutputConfig: AWSEncodableShape {
        /// Identifies the Amazon S3 bucket where you want SageMaker to store the  compiled model artifacts.
        public let s3OutputUri: String?

        public init(s3OutputUri: String? = nil) {
            self.s3OutputUri = s3OutputUri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3OutputUri, name: "s3OutputUri", parent: name, max: 1024)
            try self.validate(self.s3OutputUri, name: "s3OutputUri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputUri = "S3OutputUri"
        }
    }

    public struct RecommendationJobContainerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The machine learning domain of the model and its components. Valid Values: COMPUTER_VISION | NATURAL_LANGUAGE_PROCESSING | MACHINE_LEARNING
        public let domain: String?
        /// The machine learning framework of the container image. Valid Values: TENSORFLOW | PYTORCH | XGBOOST | SAGEMAKER-SCIKIT-LEARN
        public let framework: String?
        /// The framework version of the container image.
        public let frameworkVersion: String?
        /// The name of a pre-trained machine learning model benchmarked by Amazon SageMaker Inference Recommender that matches your model. Valid Values: efficientnetb7 | unet | xgboost | faster-rcnn-resnet101 | nasnetlarge | vgg16 | inception-v3 | mask-rcnn | sagemaker-scikit-learn | densenet201-gluon | resnet18v2-gluon | xception | densenet201 | yolov4 | resnet152 | bert-base-cased | xceptionV1-keras | resnet50 | retinanet
        public let nearestModelName: String?
        /// Specifies the SamplePayloadUrl and all other sample payload-related fields.
        public let payloadConfig: RecommendationJobPayloadConfig?
        /// A list of the instance types that are used to generate inferences in real-time.
        public let supportedInstanceTypes: [String]?
        /// The machine learning task that the model accomplishes. Valid Values: IMAGE_CLASSIFICATION | OBJECT_DETECTION | TEXT_GENERATION | IMAGE_SEGMENTATION | FILL_MASK | CLASSIFICATION | REGRESSION | OTHER
        public let task: String?

        public init(domain: String? = nil, framework: String? = nil, frameworkVersion: String? = nil, nearestModelName: String? = nil, payloadConfig: RecommendationJobPayloadConfig? = nil, supportedInstanceTypes: [String]? = nil, task: String? = nil) {
            self.domain = domain
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.nearestModelName = nearestModelName
            self.payloadConfig = payloadConfig
            self.supportedInstanceTypes = supportedInstanceTypes
            self.task = task
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case nearestModelName = "NearestModelName"
            case payloadConfig = "PayloadConfig"
            case supportedInstanceTypes = "SupportedInstanceTypes"
            case task = "Task"
        }
    }

    public struct RecommendationJobInferenceBenchmark: AWSDecodableShape {
        public let endpointConfiguration: EndpointOutputConfiguration?
        /// The reason why a benchmark failed.
        public let failureReason: String?
        public let metrics: RecommendationMetrics?
        public let modelConfiguration: ModelConfiguration

        public init(endpointConfiguration: EndpointOutputConfiguration? = nil, failureReason: String? = nil, metrics: RecommendationMetrics? = nil, modelConfiguration: ModelConfiguration) {
            self.endpointConfiguration = endpointConfiguration
            self.failureReason = failureReason
            self.metrics = metrics
            self.modelConfiguration = modelConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfiguration = "EndpointConfiguration"
            case failureReason = "FailureReason"
            case metrics = "Metrics"
            case modelConfiguration = "ModelConfiguration"
        }
    }

    public struct RecommendationJobInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies mandatory fields for running an Inference Recommender job. The fields specified in ContainerConfig override the corresponding fields in the model package.
        public let containerConfig: RecommendationJobContainerConfig?
        /// Specifies the endpoint configuration to use for a job.
        public let endpointConfigurations: [EndpointInputConfiguration]?
        /// Existing customer endpoints on which to run an Inference Recommender job.
        public let endpoints: [EndpointInfo]?
        /// Specifies the maximum duration of the job, in seconds.>
        public let jobDurationInSeconds: Int?
        /// The Amazon Resource Name (ARN) of a versioned model package.
        public let modelPackageVersionArn: String
        /// Defines the resource limit of the job.
        public let resourceLimit: RecommendationJobResourceLimit?
        /// Specifies the traffic pattern of the job.
        public let trafficPattern: TrafficPattern?
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key  that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.  This key will be passed to SageMaker Hosting for endpoint creation.  The SageMaker execution role must have kms:CreateGrant permission in order to encrypt data on the storage  volume of the endpoints created for inference recommendation. The inference recommendation job will fail  asynchronously during endpoint configuration creation if the role passed does not have  kms:CreateGrant permission. The KmsKeyId can be any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:::key/"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:::alias/"    For more information about key identifiers, see  Key identifiers (KeyID) in the  Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.
        public let volumeKmsKeyId: String?
        /// Inference Recommender provisions SageMaker endpoints with access to VPC in the inference recommendation job.
        public let vpcConfig: RecommendationJobVpcConfig?

        public init(containerConfig: RecommendationJobContainerConfig? = nil, endpointConfigurations: [EndpointInputConfiguration]? = nil, endpoints: [EndpointInfo]? = nil, jobDurationInSeconds: Int? = nil, modelPackageVersionArn: String, resourceLimit: RecommendationJobResourceLimit? = nil, trafficPattern: TrafficPattern? = nil, volumeKmsKeyId: String? = nil, vpcConfig: RecommendationJobVpcConfig? = nil) {
            self.containerConfig = containerConfig
            self.endpointConfigurations = endpointConfigurations
            self.endpoints = endpoints
            self.jobDurationInSeconds = jobDurationInSeconds
            self.modelPackageVersionArn = modelPackageVersionArn
            self.resourceLimit = resourceLimit
            self.trafficPattern = trafficPattern
            self.volumeKmsKeyId = volumeKmsKeyId
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations?.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, max: 10)
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, min: 1)
            try self.endpoints?.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 1)
            try self.validate(self.jobDurationInSeconds, name: "jobDurationInSeconds", parent: name, min: 1)
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, max: 2048)
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, min: 1)
            try self.validate(self.modelPackageVersionArn, name: "modelPackageVersionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:model-package/")
            try self.resourceLimit?.validate(name: "\(name).resourceLimit")
            try self.trafficPattern?.validate(name: "\(name).trafficPattern")
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case containerConfig = "ContainerConfig"
            case endpointConfigurations = "EndpointConfigurations"
            case endpoints = "Endpoints"
            case jobDurationInSeconds = "JobDurationInSeconds"
            case modelPackageVersionArn = "ModelPackageVersionArn"
            case resourceLimit = "ResourceLimit"
            case trafficPattern = "TrafficPattern"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct RecommendationJobOutputConfig: AWSEncodableShape {
        /// Provides information about the output configuration for the compiled  model.
        public let compiledOutputConfig: RecommendationJobCompiledOutputConfig?
        /// The Amazon Resource Name (ARN) of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key  that Amazon SageMaker uses to encrypt your output artifacts with Amazon S3 server-side encryption.  The SageMaker execution role must have kms:GenerateDataKey permission. The KmsKeyId can be any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:::key/"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:::alias/"    For more information about key identifiers, see  Key identifiers (KeyID) in the  Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.
        public let kmsKeyId: String?

        public init(compiledOutputConfig: RecommendationJobCompiledOutputConfig? = nil, kmsKeyId: String? = nil) {
            self.compiledOutputConfig = compiledOutputConfig
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.compiledOutputConfig?.validate(name: "\(name).compiledOutputConfig")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case compiledOutputConfig = "CompiledOutputConfig"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct RecommendationJobPayloadConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where the sample payload is stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        public let samplePayloadUrl: String?
        /// The supported MIME types for the input data.
        public let supportedContentTypes: [String]?

        public init(samplePayloadUrl: String? = nil, supportedContentTypes: [String]? = nil) {
            self.samplePayloadUrl = samplePayloadUrl
            self.supportedContentTypes = supportedContentTypes
        }

        private enum CodingKeys: String, CodingKey {
            case samplePayloadUrl = "SamplePayloadUrl"
            case supportedContentTypes = "SupportedContentTypes"
        }
    }

    public struct RecommendationJobResourceLimit: AWSEncodableShape & AWSDecodableShape {
        /// Defines the maximum number of load tests.
        public let maxNumberOfTests: Int?
        /// Defines the maximum number of parallel load tests.
        public let maxParallelOfTests: Int?

        public init(maxNumberOfTests: Int? = nil, maxParallelOfTests: Int? = nil) {
            self.maxNumberOfTests = maxNumberOfTests
            self.maxParallelOfTests = maxParallelOfTests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNumberOfTests, name: "maxNumberOfTests", parent: name, min: 1)
            try self.validate(self.maxParallelOfTests, name: "maxParallelOfTests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTests = "MaxNumberOfTests"
            case maxParallelOfTests = "MaxParallelOfTests"
        }
    }

    public struct RecommendationJobStoppingConditions: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of requests per minute expected for the endpoint.
        public let maxInvocations: Int?
        /// The interval of time taken by a model to respond as viewed from SageMaker.  The interval includes the local communication time taken to send the request  and to fetch the response from the container of a model and the time taken to  complete the inference in the container.
        public let modelLatencyThresholds: [ModelLatencyThreshold]?

        public init(maxInvocations: Int? = nil, modelLatencyThresholds: [ModelLatencyThreshold]? = nil) {
            self.maxInvocations = maxInvocations
            self.modelLatencyThresholds = modelLatencyThresholds
        }

        public func validate(name: String) throws {
            try self.modelLatencyThresholds?.forEach {
                try $0.validate(name: "\(name).modelLatencyThresholds[]")
            }
            try self.validate(self.modelLatencyThresholds, name: "modelLatencyThresholds", parent: name, max: 1)
            try self.validate(self.modelLatencyThresholds, name: "modelLatencyThresholds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxInvocations = "MaxInvocations"
            case modelLatencyThresholds = "ModelLatencyThresholds"
        }
    }

    public struct RecommendationJobVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The VPC security group IDs. IDs have the form of sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        public let securityGroupIds: [String]
        /// The ID of the subnets in the VPC to which you want to connect your model.
        public let subnets: [String]

        public init(securityGroupIds: [String], subnets: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 32)
                try validate($0, name: "subnets[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
        }
    }

    public struct RecommendationMetrics: AWSDecodableShape {
        /// Defines the cost per hour for the instance.
        public let costPerHour: Float
        /// Defines the cost per inference for the instance .
        public let costPerInference: Float
        /// The expected maximum number of requests per minute for the instance.
        public let maxInvocations: Int
        /// The expected model latency at maximum invocation per minute for the instance.
        public let modelLatency: Int

        public init(costPerHour: Float, costPerInference: Float, maxInvocations: Int, modelLatency: Int) {
            self.costPerHour = costPerHour
            self.costPerInference = costPerInference
            self.maxInvocations = maxInvocations
            self.modelLatency = modelLatency
        }

        private enum CodingKeys: String, CodingKey {
            case costPerHour = "CostPerHour"
            case costPerInference = "CostPerInference"
            case maxInvocations = "MaxInvocations"
            case modelLatency = "ModelLatency"
        }
    }

    public struct RedshiftDatasetDefinition: AWSEncodableShape & AWSDecodableShape {
        public let clusterId: String
        /// The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.
        public let clusterRoleArn: String
        public let database: String
        public let dbUser: String
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a Redshift execution.
        public let kmsKeyId: String?
        public let outputCompression: RedshiftResultCompressionType?
        public let outputFormat: RedshiftResultFormat
        /// The location in Amazon S3 where the Redshift query results are stored.
        public let outputS3Uri: String
        public let queryString: String

        public init(clusterId: String, clusterRoleArn: String, database: String, dbUser: String, kmsKeyId: String? = nil, outputCompression: RedshiftResultCompressionType? = nil, outputFormat: RedshiftResultFormat, outputS3Uri: String, queryString: String) {
            self.clusterId = clusterId
            self.clusterRoleArn = clusterRoleArn
            self.database = database
            self.dbUser = dbUser
            self.kmsKeyId = kmsKeyId
            self.outputCompression = outputCompression
            self.outputFormat = outputFormat
            self.outputS3Uri = outputS3Uri
            self.queryString = queryString
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 63)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 1)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: ".*")
            try self.validate(self.clusterRoleArn, name: "clusterRoleArn", parent: name, max: 2048)
            try self.validate(self.clusterRoleArn, name: "clusterRoleArn", parent: name, min: 20)
            try self.validate(self.clusterRoleArn, name: "clusterRoleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.database, name: "database", parent: name, max: 64)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, pattern: ".*")
            try self.validate(self.dbUser, name: "dbUser", parent: name, max: 128)
            try self.validate(self.dbUser, name: "dbUser", parent: name, min: 1)
            try self.validate(self.dbUser, name: "dbUser", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, max: 1024)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.queryString, name: "queryString", parent: name, max: 4096)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
            try self.validate(self.queryString, name: "queryString", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case clusterRoleArn = "ClusterRoleArn"
            case database = "Database"
            case dbUser = "DbUser"
            case kmsKeyId = "KmsKeyId"
            case outputCompression = "OutputCompression"
            case outputFormat = "OutputFormat"
            case outputS3Uri = "OutputS3Uri"
            case queryString = "QueryString"
        }
    }

    public struct RegisterDevicesRequest: AWSEncodableShape {
        /// The name of the fleet.
        public let deviceFleetName: String
        /// A list of devices to register with SageMaker Edge Manager.
        public let devices: [Device]
        /// The tags associated with devices.
        public let tags: [Tag]?

        public init(deviceFleetName: String, devices: [Device], tags: [Tag]? = nil) {
            self.deviceFleetName = deviceFleetName
            self.devices = devices
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.devices.forEach {
                try $0.validate(name: "\(name).devices[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case devices = "Devices"
            case tags = "Tags"
        }
    }

    public struct RegisterModelStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model package.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct RenderUiTemplateRequest: AWSEncodableShape {
        /// The HumanTaskUiArn of the worker UI that you want to render. Do not provide a HumanTaskUiArn if you use the UiTemplate parameter. See a list of available Human Ui Amazon Resource Names (ARNs) in UiConfig.
        public let humanTaskUiArn: String?
        /// The Amazon Resource Name (ARN) that has access to the S3 objects that are used by the template.
        public let roleArn: String
        /// A RenderableTask object containing a representative task to render.
        public let task: RenderableTask
        /// A Template object containing the worker UI template to render.
        public let uiTemplate: UiTemplate?

        public init(humanTaskUiArn: String? = nil, roleArn: String, task: RenderableTask, uiTemplate: UiTemplate? = nil) {
            self.humanTaskUiArn = humanTaskUiArn
            self.roleArn = roleArn
            self.task = task
            self.uiTemplate = uiTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, max: 1024)
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:human-task-ui/")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.task.validate(name: "\(name).task")
            try self.uiTemplate?.validate(name: "\(name).uiTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiArn = "HumanTaskUiArn"
            case roleArn = "RoleArn"
            case task = "Task"
            case uiTemplate = "UiTemplate"
        }
    }

    public struct RenderUiTemplateResponse: AWSDecodableShape {
        /// A list of one or more RenderingError objects if any were encountered while rendering the template. If there were no errors, the list is empty.
        public let errors: [RenderingError]
        /// A Liquid template that renders the HTML for the worker UI.
        public let renderedContent: String

        public init(errors: [RenderingError], renderedContent: String) {
            self.errors = errors
            self.renderedContent = renderedContent
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case renderedContent = "RenderedContent"
        }
    }

    public struct RenderableTask: AWSEncodableShape {
        /// A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable task.input. For example, if you define a variable task.input.text in your template, you can supply the variable in the JSON object as "text": "sample text".
        public let input: String

        public init(input: String) {
            self.input = input
        }

        public func validate(name: String) throws {
            try self.validate(self.input, name: "input", parent: name, max: 128_000)
            try self.validate(self.input, name: "input", parent: name, min: 2)
            try self.validate(self.input, name: "input", parent: name, pattern: "^[\\S\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "Input"
        }
    }

    public struct RenderingError: AWSDecodableShape {
        /// A unique identifier for a specific class of errors.
        public let code: String
        /// A human-readable message describing the error.
        public let message: String

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct RepositoryAuthConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an Amazon Web Services Lambda function, see Create a Lambda function with the console in the Amazon Web Services Lambda Developer Guide.
        public let repositoryCredentialsProviderArn: String

        public init(repositoryCredentialsProviderArn: String) {
            self.repositoryCredentialsProviderArn = repositoryCredentialsProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryCredentialsProviderArn, name: "repositoryCredentialsProviderArn", parent: name, max: 2048)
            try self.validate(self.repositoryCredentialsProviderArn, name: "repositoryCredentialsProviderArn", parent: name, min: 1)
            try self.validate(self.repositoryCredentialsProviderArn, name: "repositoryCredentialsProviderArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryCredentialsProviderArn = "RepositoryCredentialsProviderArn"
        }
    }

    public struct ResolvedAttributes: AWSDecodableShape {
        public let autoMLJobObjective: AutoMLJobObjective?
        public let completionCriteria: AutoMLJobCompletionCriteria?
        /// The problem type.
        public let problemType: ProblemType?

        public init(autoMLJobObjective: AutoMLJobObjective? = nil, completionCriteria: AutoMLJobCompletionCriteria? = nil, problemType: ProblemType? = nil) {
            self.autoMLJobObjective = autoMLJobObjective
            self.completionCriteria = completionCriteria
            self.problemType = problemType
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobObjective = "AutoMLJobObjective"
            case completionCriteria = "CompletionCriteria"
            case problemType = "ProblemType"
        }
    }

    public struct ResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of ML compute instances to use. For distributed training, provide a value greater than 1.
        public let instanceCount: Int?
        /// The configuration of a heterogeneous cluster in JSON format.
        public let instanceGroups: [InstanceGroup]?
        /// The ML compute instance type.   SageMaker Training on Amazon Elastic Compute Cloud (EC2) P4de instances is in preview release starting December 9th, 2022.   Amazon EC2 P4de instances (currently in preview) are powered by 8 NVIDIA A100 GPUs with 80GB high-performance HBM2e GPU memory, which accelerate the speed of training ML models that need to be trained on large datasets of high-resolution data. In this preview release, Amazon SageMaker supports ML training jobs on P4de instances (ml.p4de.24xlarge) to reduce model training time. The ml.p4de.24xlarge instances are available in the following Amazon Web Services Regions.    US East (N. Virginia) (us-east-1)   US West (Oregon) (us-west-2)   To request quota limit increase and start using P4de instances, contact the SageMaker Training service team through your account team.
        public let instanceType: TrainingInstanceType?
        /// The duration of time in seconds to retain configured resources in a warm pool for subsequent training jobs.
        public let keepAlivePeriodInSeconds: Int?
        /// The Amazon Web Services KMS key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.  Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a VolumeKmsKeyId when using an instance type with local storage. For a list of instance types that support local instance storage, see Instance Store Volumes. For more information about local instance storage encryption, see SSD Instance Store Volumes.  The VolumeKmsKeyId can be in any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"
        public let volumeKmsKeyId: String?
        /// The size of the ML storage volume that you want to provision.  ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose File as the TrainingInputMode in the algorithm specification.  When using an ML instance with NVMe SSD volumes, SageMaker doesn't provision Amazon EBS General Purpose SSD (gp2) storage. Available storage is fixed to the NVMe-type instance's storage capacity. SageMaker configures storage paths for training datasets, checkpoints, model artifacts, and outputs to use the entire capacity of the instance storage. For example, ML instance families with the NVMe-type instance storage include ml.p4d, ml.g4dn, and ml.g5.  When using an ML instance with the EBS-only storage option and without instance storage, you must define the size of EBS volume through VolumeSizeInGB in the ResourceConfig API. For example, ML instance families that use EBS volumes include ml.c5 and ml.p2.  To look up instance types and their instance storage types and volumes, see Amazon EC2 Instance Types. To find the default local paths defined by the SageMaker training platform, see Amazon SageMaker Training Storage Folders for Training Datasets, Checkpoints, Model Artifacts, and Outputs.
        public let volumeSizeInGB: Int

        public init(instanceCount: Int? = nil, instanceGroups: [InstanceGroup]? = nil, instanceType: TrainingInstanceType? = nil, keepAlivePeriodInSeconds: Int? = nil, volumeKmsKeyId: String? = nil, volumeSizeInGB: Int) {
            self.instanceCount = instanceCount
            self.instanceGroups = instanceGroups
            self.instanceType = instanceType
            self.keepAlivePeriodInSeconds = keepAlivePeriodInSeconds
            self.volumeKmsKeyId = volumeKmsKeyId
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 0)
            try self.instanceGroups?.forEach {
                try $0.validate(name: "\(name).instanceGroups[]")
            }
            try self.validate(self.instanceGroups, name: "instanceGroups", parent: name, max: 5)
            try self.validate(self.keepAlivePeriodInSeconds, name: "keepAlivePeriodInSeconds", parent: name, max: 3600)
            try self.validate(self.keepAlivePeriodInSeconds, name: "keepAlivePeriodInSeconds", parent: name, min: 0)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceGroups = "InstanceGroups"
            case instanceType = "InstanceType"
            case keepAlivePeriodInSeconds = "KeepAlivePeriodInSeconds"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct ResourceConfigForUpdate: AWSEncodableShape {
        /// The KeepAlivePeriodInSeconds value specified in the ResourceConfig to update.
        public let keepAlivePeriodInSeconds: Int

        public init(keepAlivePeriodInSeconds: Int) {
            self.keepAlivePeriodInSeconds = keepAlivePeriodInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.keepAlivePeriodInSeconds, name: "keepAlivePeriodInSeconds", parent: name, max: 3600)
            try self.validate(self.keepAlivePeriodInSeconds, name: "keepAlivePeriodInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case keepAlivePeriodInSeconds = "KeepAlivePeriodInSeconds"
        }
    }

    public struct ResourceLimits: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of training jobs that a hyperparameter tuning job can launch.
        public let maxNumberOfTrainingJobs: Int?
        /// The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.
        public let maxParallelTrainingJobs: Int

        public init(maxNumberOfTrainingJobs: Int? = nil, maxParallelTrainingJobs: Int) {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNumberOfTrainingJobs, name: "maxNumberOfTrainingJobs", parent: name, min: 1)
            try self.validate(self.maxParallelTrainingJobs, name: "maxParallelTrainingJobs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTrainingJobs = "MaxNumberOfTrainingJobs"
            case maxParallelTrainingJobs = "MaxParallelTrainingJobs"
        }
    }

    public struct ResourceSpec: AWSEncodableShape & AWSDecodableShape {
        /// The instance type that the image version runs on.   JupyterServer apps only support the system value. For KernelGateway apps, the system value is translated to ml.t3.medium. KernelGateway apps also support all other values for available instance types.
        public let instanceType: AppInstanceType?
        ///  The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
        public let lifecycleConfigArn: String?
        /// The ARN of the SageMaker image that the image version belongs to.
        public let sageMakerImageArn: String?
        /// The ARN of the image version created on the instance.
        public let sageMakerImageVersionArn: String?

        public init(instanceType: AppInstanceType? = nil, lifecycleConfigArn: String? = nil, sageMakerImageArn: String? = nil, sageMakerImageVersionArn: String? = nil) {
            self.instanceType = instanceType
            self.lifecycleConfigArn = lifecycleConfigArn
            self.sageMakerImageArn = sageMakerImageArn
            self.sageMakerImageVersionArn = sageMakerImageVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecycleConfigArn, name: "lifecycleConfigArn", parent: name, max: 256)
            try self.validate(self.lifecycleConfigArn, name: "lifecycleConfigArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:studio-lifecycle-config/")
            try self.validate(self.sageMakerImageArn, name: "sageMakerImageArn", parent: name, max: 256)
            try self.validate(self.sageMakerImageArn, name: "sageMakerImageArn", parent: name, pattern: "^arn:aws(-[\\w]+)*:sagemaker:.+:[0-9]{12}:image/[a-z0-9]([-.]?[a-z0-9])*$")
            try self.validate(self.sageMakerImageVersionArn, name: "sageMakerImageVersionArn", parent: name, max: 256)
            try self.validate(self.sageMakerImageVersionArn, name: "sageMakerImageVersionArn", parent: name, pattern: "^arn:aws(-[\\w]+)*:sagemaker:.+:[0-9]{12}:image-version/[a-z0-9]([-.]?[a-z0-9])*/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case lifecycleConfigArn = "LifecycleConfigArn"
            case sageMakerImageArn = "SageMakerImageArn"
            case sageMakerImageVersionArn = "SageMakerImageVersionArn"
        }
    }

    public struct RetentionPolicy: AWSEncodableShape {
        /// The default is Retain, which specifies to keep the data stored on the EFS volume. Specify Delete to delete the data stored on the EFS volume.
        public let homeEfsFileSystem: RetentionType?

        public init(homeEfsFileSystem: RetentionType? = nil) {
            self.homeEfsFileSystem = homeEfsFileSystem
        }

        private enum CodingKeys: String, CodingKey {
            case homeEfsFileSystem = "HomeEfsFileSystem"
        }
    }

    public struct RetryPipelineExecutionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than once.
        public let clientRequestToken: String
        /// This configuration, if specified, overrides the parallelism configuration  of the parent pipeline.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String

        public init(clientRequestToken: String = RetryPipelineExecutionRequest.idempotencyToken(), parallelismConfiguration: ParallelismConfiguration? = nil, pipelineExecutionArn: String) {
            self.clientRequestToken = clientRequestToken
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct RetryPipelineExecutionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct RetryStrategy: AWSEncodableShape & AWSDecodableShape {
        /// The number of times to retry the job. When the job is retried, it's SecondaryStatus is changed to STARTING.
        public let maximumRetryAttempts: Int

        public init(maximumRetryAttempts: Int) {
            self.maximumRetryAttempts = maximumRetryAttempts
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 30)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct S3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more attribute names to use that are found in a specified augmented manifest file.
        public let attributeNames: [String]?
        /// A list of names of instance groups that get data from the S3 data source.
        public let instanceGroupNames: [String]?
        /// If you want SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify FullyReplicated.  If you want SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify ShardedByS3Key. If there are n ML compute instances launched for a training job, each instance gets approximately 1/n of the number of S3 objects. In this case, model training on each machine uses only the subset of training data.  Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipe modes. Keep this in mind when developing algorithms.  In distributed training, where you use multiple ML compute EC2 instances, you might choose ShardedByS3Key. If the algorithm requires copying training data to the ML storage volume (when TrainingInputMode is set to File), this copies 1/n of the number of objects.
        public let s3DataDistributionType: S3DataDistribution?
        /// If you choose S3Prefix, S3Uri identifies a key name prefix. SageMaker uses all objects that match the specified key name prefix for model training.  If you choose ManifestFile, S3Uri identifies an object that is a manifest file containing a list of object keys that you want SageMaker to use for model training.  If you choose AugmentedManifestFile, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. AugmentedManifestFile can only be used if the Channel's input mode is Pipe.
        public let s3DataType: S3DataType
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest. For example:    A key name prefix might look like this: s3://bucketname/exampleprefix    A manifest might look like this: s3://bucketname/example.manifest  A manifest is an S3 object which is a JSON file consisting of an array of elements. The first element is a prefix which is followed by one or more suffixes. SageMaker appends the suffix elements to the prefix to get a full set of S3Uri. Note that the prefix must be a valid non-empty S3Uri that precludes users from specifying a manifest whose individual S3Uri is sourced from different S3 buckets. The following code example shows a valid manifest format:   [ {"prefix": "s3://customer_bucket/some/prefix/"},   "relative/path/to/custdata-1",   "relative/path/custdata-2",   ...   "relative/path/custdata-N"   ]  This JSON is equivalent to the following S3Uri list:  s3://customer_bucket/some/prefix/relative/path/to/custdata-1   s3://customer_bucket/some/prefix/relative/path/custdata-2   ...   s3://customer_bucket/some/prefix/relative/path/custdata-N  The complete set of S3Uri in this manifest is the input data for the channel for this data source. The object that each S3Uri points to must be readable by the IAM role that SageMaker uses to perform tasks on your behalf.
        public let s3Uri: String

        public init(attributeNames: [String]? = nil, instanceGroupNames: [String]? = nil, s3DataDistributionType: S3DataDistribution? = nil, s3DataType: S3DataType, s3Uri: String) {
            self.attributeNames = attributeNames
            self.instanceGroupNames = instanceGroupNames
            self.s3DataDistributionType = s3DataDistributionType
            self.s3DataType = s3DataType
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.attributeNames?.forEach {
                try validate($0, name: "attributeNames[]", parent: name, max: 256)
                try validate($0, name: "attributeNames[]", parent: name, min: 1)
                try validate($0, name: "attributeNames[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.attributeNames, name: "attributeNames", parent: name, max: 16)
            try self.instanceGroupNames?.forEach {
                try validate($0, name: "instanceGroupNames[]", parent: name, max: 64)
                try validate($0, name: "instanceGroupNames[]", parent: name, min: 1)
                try validate($0, name: "instanceGroupNames[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.instanceGroupNames, name: "instanceGroupNames", parent: name, max: 5)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeNames = "AttributeNames"
            case instanceGroupNames = "InstanceGroupNames"
            case s3DataDistributionType = "S3DataDistributionType"
            case s3DataType = "S3DataType"
            case s3Uri = "S3Uri"
        }
    }

    public struct S3StorageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location. The IAM roleARN that is passed as a parameter to CreateFeatureGroup must have below permissions to the KmsKeyId:    "kms:GenerateDataKey"
        public let kmsKeyId: String?
        /// The S3 path where offline records are written.
        public let resolvedOutputS3Uri: String?
        /// The S3 URI, or location in Amazon S3, of OfflineStore. S3 URIs have a format similar to the following: s3://example-bucket/prefix/.
        public let s3Uri: String

        public init(kmsKeyId: String? = nil, resolvedOutputS3Uri: String? = nil, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.resolvedOutputS3Uri = resolvedOutputS3Uri
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.resolvedOutputS3Uri, name: "resolvedOutputS3Uri", parent: name, max: 1024)
            try self.validate(self.resolvedOutputS3Uri, name: "resolvedOutputS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case resolvedOutputS3Uri = "ResolvedOutputS3Uri"
            case s3Uri = "S3Uri"
        }
    }

    public struct ScheduleConfig: AWSEncodableShape & AWSDecodableShape {
        /// A cron expression that describes details about the monitoring schedule. Currently the only supported cron expressions are:   If you want to set the job to start every hour, please use the following:  Hourly: cron(0 * ? * * *)    If you want to start the job daily:  cron(0 [00-23] ? * * *)    For example, the following are valid cron expressions:   Daily at noon UTC: cron(0 12 ? * * *)    Daily at midnight UTC: cron(0 0 ? * * *)    To support running every 6, 12 hours, the following are also supported:  cron(0 [00-23]/[01-24] ? * * *)  For example, the following are valid cron expressions:   Every 12 hours, starting at 5pm UTC: cron(0 17/12 ? * * *)    Every two hours starting at midnight: cron(0 0/2 ? * * *)       Even though the cron expression is set to start at 5PM UTC, note that there could be a delay of 0-20 minutes from the actual requested time to run the execution.    We recommend that if you would like a daily schedule, you do not provide this parameter. Amazon SageMaker will pick a time for running every day.
        public let scheduleExpression: String

        public init(scheduleExpression: String) {
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct SearchExpression: AWSEncodableShape {
        /// A list of filter objects.
        public let filters: [Filter]?
        /// A list of nested filter objects.
        public let nestedFilters: [NestedFilters]?
        /// A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify And. If only a single conditional statement needs to be true for the entire search expression to be true, specify Or. The default value is And.
        public let `operator`: BooleanOperator?
        /// A list of search expression objects.
        public let subExpressions: [SearchExpression]?

        public init(filters: [Filter]? = nil, nestedFilters: [NestedFilters]? = nil, operator: BooleanOperator? = nil, subExpressions: [SearchExpression]? = nil) {
            self.filters = filters
            self.nestedFilters = nestedFilters
            self.`operator` = `operator`
            self.subExpressions = subExpressions
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.nestedFilters?.forEach {
                try $0.validate(name: "\(name).nestedFilters[]")
            }
            try self.validate(self.nestedFilters, name: "nestedFilters", parent: name, max: 20)
            try self.validate(self.nestedFilters, name: "nestedFilters", parent: name, min: 1)
            try self.subExpressions?.forEach {
                try $0.validate(name: "\(name).subExpressions[]")
            }
            try self.validate(self.subExpressions, name: "subExpressions", parent: name, max: 20)
            try self.validate(self.subExpressions, name: "subExpressions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case nestedFilters = "NestedFilters"
            case `operator` = "Operator"
            case subExpressions = "SubExpressions"
        }
    }

    public struct SearchRecord: AWSDecodableShape {
        public let endpoint: Endpoint?
        /// The properties of an experiment.
        public let experiment: Experiment?
        public let featureGroup: FeatureGroup?
        /// The feature metadata used to search through the features.
        public let featureMetadata: FeatureMetadata?
        /// The properties of a hyperparameter tuning job.
        public let hyperParameterTuningJob: HyperParameterTuningJobSearchEntity?
        public let model: ModelDashboardModel?
        /// An Amazon SageMaker Model Card that documents details about a machine learning model.
        public let modelCard: ModelCard?
        public let modelPackage: ModelPackage?
        public let modelPackageGroup: ModelPackageGroup?
        public let pipeline: Pipeline?
        public let pipelineExecution: PipelineExecution?
        /// The properties of a project.
        public let project: Project?
        /// The properties of a training job.
        public let trainingJob: TrainingJob?
        /// The properties of a trial.
        public let trial: Trial?
        /// The properties of a trial component.
        public let trialComponent: TrialComponent?

        public init(endpoint: Endpoint? = nil, experiment: Experiment? = nil, featureGroup: FeatureGroup? = nil, featureMetadata: FeatureMetadata? = nil, hyperParameterTuningJob: HyperParameterTuningJobSearchEntity? = nil, model: ModelDashboardModel? = nil, modelCard: ModelCard? = nil, modelPackage: ModelPackage? = nil, modelPackageGroup: ModelPackageGroup? = nil, pipeline: Pipeline? = nil, pipelineExecution: PipelineExecution? = nil, project: Project? = nil, trainingJob: TrainingJob? = nil, trial: Trial? = nil, trialComponent: TrialComponent? = nil) {
            self.endpoint = endpoint
            self.experiment = experiment
            self.featureGroup = featureGroup
            self.featureMetadata = featureMetadata
            self.hyperParameterTuningJob = hyperParameterTuningJob
            self.model = model
            self.modelCard = modelCard
            self.modelPackage = modelPackage
            self.modelPackageGroup = modelPackageGroup
            self.pipeline = pipeline
            self.pipelineExecution = pipelineExecution
            self.project = project
            self.trainingJob = trainingJob
            self.trial = trial
            self.trialComponent = trialComponent
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case experiment = "Experiment"
            case featureGroup = "FeatureGroup"
            case featureMetadata = "FeatureMetadata"
            case hyperParameterTuningJob = "HyperParameterTuningJob"
            case model = "Model"
            case modelCard = "ModelCard"
            case modelPackage = "ModelPackage"
            case modelPackageGroup = "ModelPackageGroup"
            case pipeline = "Pipeline"
            case pipelineExecution = "PipelineExecution"
            case project = "Project"
            case trainingJob = "TrainingJob"
            case trial = "Trial"
            case trialComponent = "TrialComponent"
        }
    }

    public struct SearchRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// If more than MaxResults resources match the specified SearchExpression, the response includes a NextToken. The NextToken can be passed to the next SearchRequest to continue retrieving results.
        public let nextToken: String?
        /// The name of the Amazon SageMaker resource to search for.
        public let resource: ResourceType
        /// A Boolean conditional statement. Resources must satisfy this condition to be included in search results. You must provide at least one subexpression, filter, or nested filter. The maximum number of recursive SubExpressions, NestedFilters, and Filters that can be included in a SearchExpression object is 50.
        public let searchExpression: SearchExpression?
        /// The name of the resource property used to sort the SearchResults. The default is LastModifiedTime.
        public let sortBy: String?
        /// How SearchResults are ordered. Valid values are Ascending or Descending. The default is Descending.
        public let sortOrder: SearchSortOrder?

        public init(maxResults: Int? = nil, nextToken: String? = nil, resource: ResourceType, searchExpression: SearchExpression? = nil, sortBy: String? = nil, sortOrder: SearchSortOrder? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resource = resource
            self.searchExpression = searchExpression
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.searchExpression?.validate(name: "\(name).searchExpression")
            try self.validate(self.sortBy, name: "sortBy", parent: name, max: 255)
            try self.validate(self.sortBy, name: "sortBy", parent: name, min: 1)
            try self.validate(self.sortBy, name: "sortBy", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resource = "Resource"
            case searchExpression = "SearchExpression"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct SearchResponse: AWSDecodableShape {
        /// If the result of the previous Search request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// A list of SearchRecord objects.
        public let results: [SearchRecord]?

        public init(nextToken: String? = nil, results: [SearchRecord]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct SecondaryStatusTransition: AWSDecodableShape {
        /// A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.
        public let endTime: Date?
        /// A timestamp that shows when the training job transitioned to the current secondary status state.
        public let startTime: Date
        /// Contains a secondary status information from a training job. Status might be one of the following secondary statuses:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.     We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTrainingStack     DownloadingTrainingImage
        public let status: SecondaryStatus
        /// A detailed description of the progress within a secondary status.  SageMaker provides secondary statuses and status messages that apply to each of them:  Starting    Starting the training job.   Launching requested ML instances.   Insufficient capacity error from EC2 while launching instances, retrying!   Launched instance was unhealthy, replacing it!   Preparing the instances for training.    Training    Downloading the training image.   Training image download completed. Training in progress.      Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.  To have an overview of your training job's progress, view TrainingJobStatus and SecondaryStatus in DescribeTrainingJob, and StatusMessage together. For example, at the start of a training job, you might see the following:    TrainingJobStatus - InProgress    SecondaryStatus - Training    StatusMessage - Downloading the training image
        public let statusMessage: String?

        public init(endTime: Date? = nil, startTime: Date, status: SecondaryStatus, statusMessage: String? = nil) {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct SendPipelineExecutionStepFailureRequest: AWSEncodableShape {
        /// The pipeline generated token from the Amazon SQS queue.
        public let callbackToken: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time.
        public let clientRequestToken: String?
        /// A message describing why the step failed.
        public let failureReason: String?

        public init(callbackToken: String, clientRequestToken: String? = SendPipelineExecutionStepFailureRequest.idempotencyToken(), failureReason: String? = nil) {
            self.callbackToken = callbackToken
            self.clientRequestToken = clientRequestToken
            self.failureReason = failureReason
        }

        public func validate(name: String) throws {
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, max: 10)
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, min: 10)
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.failureReason, name: "failureReason", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case callbackToken = "CallbackToken"
            case clientRequestToken = "ClientRequestToken"
            case failureReason = "FailureReason"
        }
    }

    public struct SendPipelineExecutionStepFailureResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct SendPipelineExecutionStepSuccessRequest: AWSEncodableShape {
        /// The pipeline generated token from the Amazon SQS queue.
        public let callbackToken: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time.
        public let clientRequestToken: String?
        /// A list of the output parameters of the callback step.
        public let outputParameters: [OutputParameter]?

        public init(callbackToken: String, clientRequestToken: String? = SendPipelineExecutionStepSuccessRequest.idempotencyToken(), outputParameters: [OutputParameter]? = nil) {
            self.callbackToken = callbackToken
            self.clientRequestToken = clientRequestToken
            self.outputParameters = outputParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, max: 10)
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, min: 10)
            try self.validate(self.callbackToken, name: "callbackToken", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.outputParameters?.forEach {
                try $0.validate(name: "\(name).outputParameters[]")
            }
            try self.validate(self.outputParameters, name: "outputParameters", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case callbackToken = "CallbackToken"
            case clientRequestToken = "ClientRequestToken"
            case outputParameters = "OutputParameters"
        }
    }

    public struct SendPipelineExecutionStepSuccessResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct ServiceCatalogProvisionedProductDetails: AWSDecodableShape {
        /// The ID of the provisioned product.
        public let provisionedProductId: String?
        /// The current status of the product.    AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.    UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.    TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.    ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.    PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public let provisionedProductStatusMessage: String?

        public init(provisionedProductId: String? = nil, provisionedProductStatusMessage: String? = nil) {
            self.provisionedProductId = provisionedProductId
            self.provisionedProductStatusMessage = provisionedProductStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductStatusMessage = "ProvisionedProductStatusMessage"
        }
    }

    public struct ServiceCatalogProvisioningDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
        public let pathId: String?
        /// The ID of the product to provision.
        public let productId: String
        /// The ID of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// A list of key value pairs that you specify when you provision a product.
        public let provisioningParameters: [ProvisioningParameter]?

        public init(pathId: String? = nil, productId: String, provisioningArtifactId: String? = nil, provisioningParameters: [ProvisioningParameter]? = nil) {
            self.pathId = pathId
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.pathId, name: "pathId", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, min: 1)
            try self.validate(self.pathId, name: "pathId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.provisioningParameters?.forEach {
                try $0.validate(name: "\(name).provisioningParameters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case pathId = "PathId"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningParameters = "ProvisioningParameters"
        }
    }

    public struct ServiceCatalogProvisioningUpdateDetails: AWSEncodableShape {
        /// The ID of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// A list of key value pairs that you specify when you provision a product.
        public let provisioningParameters: [ProvisioningParameter]?

        public init(provisioningArtifactId: String? = nil, provisioningParameters: [ProvisioningParameter]? = nil) {
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.provisioningParameters?.forEach {
                try $0.validate(name: "\(name).provisioningParameters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningParameters = "ProvisioningParameters"
        }
    }

    public struct ShadowModeConfig: AWSEncodableShape & AWSDecodableShape {
        /// List of shadow variant configurations.
        public let shadowModelVariants: [ShadowModelVariantConfig]
        ///  The name of the production variant, which takes all the inference requests.
        public let sourceModelVariantName: String

        public init(shadowModelVariants: [ShadowModelVariantConfig], sourceModelVariantName: String) {
            self.shadowModelVariants = shadowModelVariants
            self.sourceModelVariantName = sourceModelVariantName
        }

        public func validate(name: String) throws {
            try self.shadowModelVariants.forEach {
                try $0.validate(name: "\(name).shadowModelVariants[]")
            }
            try self.validate(self.shadowModelVariants, name: "shadowModelVariants", parent: name, max: 1)
            try self.validate(self.shadowModelVariants, name: "shadowModelVariants", parent: name, min: 1)
            try self.validate(self.sourceModelVariantName, name: "sourceModelVariantName", parent: name, max: 63)
            try self.validate(self.sourceModelVariantName, name: "sourceModelVariantName", parent: name, pattern: "^[a-zA-Z0-9]([\\-a-zA-Z0-9]*[a-zA-Z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case shadowModelVariants = "ShadowModelVariants"
            case sourceModelVariantName = "SourceModelVariantName"
        }
    }

    public struct ShadowModelVariantConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The percentage of inference requests that Amazon SageMaker replicates from the production variant to the shadow variant.
        public let samplingPercentage: Int
        /// The name of the shadow variant.
        public let shadowModelVariantName: String

        public init(samplingPercentage: Int, shadowModelVariantName: String) {
            self.samplingPercentage = samplingPercentage
            self.shadowModelVariantName = shadowModelVariantName
        }

        public func validate(name: String) throws {
            try self.validate(self.samplingPercentage, name: "samplingPercentage", parent: name, max: 100)
            try self.validate(self.shadowModelVariantName, name: "shadowModelVariantName", parent: name, max: 63)
            try self.validate(self.shadowModelVariantName, name: "shadowModelVariantName", parent: name, pattern: "^[a-zA-Z0-9]([\\-a-zA-Z0-9]*[a-zA-Z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case samplingPercentage = "SamplingPercentage"
            case shadowModelVariantName = "ShadowModelVariantName"
        }
    }

    public struct SharingSettings: AWSEncodableShape & AWSDecodableShape {
        /// Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        public let notebookOutputOption: NotebookOutputOption?
        /// When NotebookOutputOption is Allowed, the Amazon Web Services Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        public let s3KmsKeyId: String?
        /// When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        public let s3OutputPath: String?

        public init(notebookOutputOption: NotebookOutputOption? = nil, s3KmsKeyId: String? = nil, s3OutputPath: String? = nil) {
            self.notebookOutputOption = notebookOutputOption
            self.s3KmsKeyId = s3KmsKeyId
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3KmsKeyId, name: "s3KmsKeyId", parent: name, max: 2048)
            try self.validate(self.s3KmsKeyId, name: "s3KmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookOutputOption = "NotebookOutputOption"
            case s3KmsKeyId = "S3KmsKeyId"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct ShuffleConfig: AWSEncodableShape & AWSDecodableShape {
        /// Determines the shuffling order in ShuffleConfig value.
        public let seed: Int64

        public init(seed: Int64) {
            self.seed = seed
        }

        private enum CodingKeys: String, CodingKey {
            case seed = "Seed"
        }
    }

    public struct SourceAlgorithm: AWSEncodableShape & AWSDecodableShape {
        /// The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in Amazon Web Services Marketplace that you are subscribed to.
        public let algorithmName: String
        /// The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).  The model artifacts must be in an S3 bucket that is in the same region as the algorithm.
        public let modelDataUrl: String?

        public init(algorithmName: String, modelDataUrl: String? = nil) {
            self.algorithmName = algorithmName
            self.modelDataUrl = modelDataUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, max: 170)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, min: 1)
            try self.validate(self.algorithmName, name: "algorithmName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:[a-z\\-]*\\/)?([a-zA-Z0-9]([a-zA-Z0-9-]){0,62})(?<!-)$")
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, max: 1024)
            try self.validate(self.modelDataUrl, name: "modelDataUrl", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case modelDataUrl = "ModelDataUrl"
        }
    }

    public struct SourceAlgorithmSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A list of the algorithms that were used to create a model package.
        public let sourceAlgorithms: [SourceAlgorithm]

        public init(sourceAlgorithms: [SourceAlgorithm]) {
            self.sourceAlgorithms = sourceAlgorithms
        }

        public func validate(name: String) throws {
            try self.sourceAlgorithms.forEach {
                try $0.validate(name: "\(name).sourceAlgorithms[]")
            }
            try self.validate(self.sourceAlgorithms, name: "sourceAlgorithms", parent: name, max: 1)
            try self.validate(self.sourceAlgorithms, name: "sourceAlgorithms", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAlgorithms = "SourceAlgorithms"
        }
    }

    public struct SourceIpConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of one to ten Classless Inter-Domain Routing (CIDR) values. Maximum: Ten CIDR values  The following Length Constraints apply to individual CIDR values in the CIDR value list.
        public let cidrs: [String]

        public init(cidrs: [String]) {
            self.cidrs = cidrs
        }

        public func validate(name: String) throws {
            try self.cidrs.forEach {
                try validate($0, name: "cidrs[]", parent: name, max: 64)
                try validate($0, name: "cidrs[]", parent: name, min: 4)
                try validate($0, name: "cidrs[]", parent: name, pattern: "^(^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$)|(^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9]))$)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cidrs = "Cidrs"
        }
    }

    public struct SpaceDetails: AWSDecodableShape {
        /// The creation time.
        public let creationTime: Date?
        /// The ID of the associated Domain.
        public let domainId: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The name of the space.
        public let spaceName: String?
        /// The status.
        public let status: SpaceStatus?

        public init(creationTime: Date? = nil, domainId: String? = nil, lastModifiedTime: Date? = nil, spaceName: String? = nil, status: SpaceStatus? = nil) {
            self.creationTime = creationTime
            self.domainId = domainId
            self.lastModifiedTime = lastModifiedTime
            self.spaceName = spaceName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case lastModifiedTime = "LastModifiedTime"
            case spaceName = "SpaceName"
            case status = "Status"
        }
    }

    public struct SpaceSettings: AWSEncodableShape & AWSDecodableShape {
        public let jupyterServerAppSettings: JupyterServerAppSettings?
        public let kernelGatewayAppSettings: KernelGatewayAppSettings?

        public init(jupyterServerAppSettings: JupyterServerAppSettings? = nil, kernelGatewayAppSettings: KernelGatewayAppSettings? = nil) {
            self.jupyterServerAppSettings = jupyterServerAppSettings
            self.kernelGatewayAppSettings = kernelGatewayAppSettings
        }

        public func validate(name: String) throws {
            try self.jupyterServerAppSettings?.validate(name: "\(name).jupyterServerAppSettings")
            try self.kernelGatewayAppSettings?.validate(name: "\(name).kernelGatewayAppSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case jupyterServerAppSettings = "JupyterServerAppSettings"
            case kernelGatewayAppSettings = "KernelGatewayAppSettings"
        }
    }

    public struct StartEdgeDeploymentStageRequest: AWSEncodableShape {
        /// The name of the edge deployment plan to start.
        public let edgeDeploymentPlanName: String
        /// The name of the stage to start.
        public let stageName: String

        public init(edgeDeploymentPlanName: String, stageName: String) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 63)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case stageName = "StageName"
        }
    }

    public struct StartInferenceExperimentRequest: AWSEncodableShape {
        /// The name of the inference experiment to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN of the started inference experiment to start.
        public let inferenceExperimentArn: String

        public init(inferenceExperimentArn: String) {
            self.inferenceExperimentArn = inferenceExperimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperimentArn = "InferenceExperimentArn"
        }
    }

    public struct StartMonitoringScheduleRequest: AWSEncodableShape {
        /// The name of the schedule to start.
        public let monitoringScheduleName: String

        public init(monitoringScheduleName: String) {
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct StartNotebookInstanceInput: AWSEncodableShape {
        /// The name of the notebook instance to start.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct StartPipelineExecutionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than once.
        public let clientRequestToken: String
        /// This configuration, if specified, overrides the parallelism configuration  of the parent pipeline for this specific run.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The description of the pipeline execution.
        public let pipelineExecutionDescription: String?
        /// The display name of the pipeline execution.
        public let pipelineExecutionDisplayName: String?
        /// The name of the pipeline.
        public let pipelineName: String
        /// Contains a list of pipeline parameters. This list can be empty.
        public let pipelineParameters: [Parameter]?

        public init(clientRequestToken: String = StartPipelineExecutionRequest.idempotencyToken(), parallelismConfiguration: ParallelismConfiguration? = nil, pipelineExecutionDescription: String? = nil, pipelineExecutionDisplayName: String? = nil, pipelineName: String, pipelineParameters: [Parameter]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineExecutionDescription = pipelineExecutionDescription
            self.pipelineExecutionDisplayName = pipelineExecutionDisplayName
            self.pipelineName = pipelineName
            self.pipelineParameters = pipelineParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
            try self.validate(self.pipelineExecutionDescription, name: "pipelineExecutionDescription", parent: name, max: 3072)
            try self.validate(self.pipelineExecutionDescription, name: "pipelineExecutionDescription", parent: name, pattern: ".*")
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, max: 82)
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, min: 1)
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,81}$")
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 2048)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^(arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline/.*)?([a-zA-Z0-9](-*[a-zA-Z0-9]){0,255})$")
            try self.pipelineParameters?.forEach {
                try $0.validate(name: "\(name).pipelineParameters[]")
            }
            try self.validate(self.pipelineParameters, name: "pipelineParameters", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineExecutionDescription = "PipelineExecutionDescription"
            case pipelineExecutionDisplayName = "PipelineExecutionDisplayName"
            case pipelineName = "PipelineName"
            case pipelineParameters = "PipelineParameters"
        }
    }

    public struct StartPipelineExecutionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct StopAutoMLJobRequest: AWSEncodableShape {
        /// The name of the object you are requesting.
        public let autoMLJobName: String

        public init(autoMLJobName: String) {
            self.autoMLJobName = autoMLJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, max: 32)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, min: 1)
            try self.validate(self.autoMLJobName, name: "autoMLJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobName = "AutoMLJobName"
        }
    }

    public struct StopCompilationJobRequest: AWSEncodableShape {
        /// The name of the model compilation job to stop.
        public let compilationJobName: String

        public init(compilationJobName: String) {
            self.compilationJobName = compilationJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, max: 63)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, min: 1)
            try self.validate(self.compilationJobName, name: "compilationJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
        }
    }

    public struct StopEdgeDeploymentStageRequest: AWSEncodableShape {
        /// The name of the edge deployment plan to stop.
        public let edgeDeploymentPlanName: String
        /// The name of the stage to stop.
        public let stageName: String

        public init(edgeDeploymentPlanName: String, stageName: String) {
            self.edgeDeploymentPlanName = edgeDeploymentPlanName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, max: 63)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, min: 1)
            try self.validate(self.edgeDeploymentPlanName, name: "edgeDeploymentPlanName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 63)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgeDeploymentPlanName = "EdgeDeploymentPlanName"
            case stageName = "StageName"
        }
    }

    public struct StopEdgePackagingJobRequest: AWSEncodableShape {
        /// The name of the edge packaging job.
        public let edgePackagingJobName: String

        public init(edgePackagingJobName: String) {
            self.edgePackagingJobName = edgePackagingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, max: 63)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, min: 1)
            try self.validate(self.edgePackagingJobName, name: "edgePackagingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case edgePackagingJobName = "EdgePackagingJobName"
        }
    }

    public struct StopHyperParameterTuningJobRequest: AWSEncodableShape {
        /// The name of the tuning job to stop.
        public let hyperParameterTuningJobName: String

        public init(hyperParameterTuningJobName: String) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, max: 32)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, min: 1)
            try self.validate(self.hyperParameterTuningJobName, name: "hyperParameterTuningJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public struct StopInferenceExperimentRequest: AWSEncodableShape {
        ///  An array of ModelVariantConfig objects. There is one for each variant that you want to deploy after the inference experiment stops. Each ModelVariantConfig describes the infrastructure configuration for deploying the corresponding variant.
        public let desiredModelVariants: [ModelVariantConfig]?
        ///  The desired state of the experiment after stopping. The possible states are the following:     Completed: The experiment completed successfully    Cancelled: The experiment was canceled
        public let desiredState: InferenceExperimentStopDesiredState?
        ///  Array of key-value pairs, with names of variants mapped to actions. The possible actions are the following:     Promote - Promote the shadow variant to a production variant    Remove - Delete the variant    Retain - Keep the variant as it is
        public let modelVariantActions: [String: ModelVariantAction]
        /// The name of the inference experiment to stop.
        public let name: String
        /// The reason for stopping the experiment.
        public let reason: String?

        public init(desiredModelVariants: [ModelVariantConfig]? = nil, desiredState: InferenceExperimentStopDesiredState? = nil, modelVariantActions: [String: ModelVariantAction], name: String, reason: String? = nil) {
            self.desiredModelVariants = desiredModelVariants
            self.desiredState = desiredState
            self.modelVariantActions = modelVariantActions
            self.name = name
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.desiredModelVariants?.forEach {
                try $0.validate(name: "\(name).desiredModelVariants[]")
            }
            try self.validate(self.desiredModelVariants, name: "desiredModelVariants", parent: name, max: 2)
            try self.validate(self.desiredModelVariants, name: "desiredModelVariants", parent: name, min: 1)
            try self.modelVariantActions.forEach {
                try validate($0.key, name: "modelVariantActions.key", parent: name, max: 63)
                try validate($0.key, name: "modelVariantActions.key", parent: name, pattern: "^[a-zA-Z0-9]([\\-a-zA-Z0-9]*[a-zA-Z0-9])?$")
            }
            try self.validate(self.modelVariantActions, name: "modelVariantActions", parent: name, max: 2)
            try self.validate(self.modelVariantActions, name: "modelVariantActions", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.reason, name: "reason", parent: name, max: 1024)
            try self.validate(self.reason, name: "reason", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredModelVariants = "DesiredModelVariants"
            case desiredState = "DesiredState"
            case modelVariantActions = "ModelVariantActions"
            case name = "Name"
            case reason = "Reason"
        }
    }

    public struct StopInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN of the stopped inference experiment.
        public let inferenceExperimentArn: String

        public init(inferenceExperimentArn: String) {
            self.inferenceExperimentArn = inferenceExperimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperimentArn = "InferenceExperimentArn"
        }
    }

    public struct StopInferenceRecommendationsJobRequest: AWSEncodableShape {
        /// The name of the job you want to stop.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct StopLabelingJobRequest: AWSEncodableShape {
        /// The name of the labeling job to stop.
        public let labelingJobName: String

        public init(labelingJobName: String) {
            self.labelingJobName = labelingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, max: 63)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, min: 1)
            try self.validate(self.labelingJobName, name: "labelingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobName = "LabelingJobName"
        }
    }

    public struct StopMonitoringScheduleRequest: AWSEncodableShape {
        /// The name of the schedule to stop.
        public let monitoringScheduleName: String

        public init(monitoringScheduleName: String) {
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct StopNotebookInstanceInput: AWSEncodableShape {
        /// The name of the notebook instance to terminate.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct StopPipelineExecutionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than once.
        public let clientRequestToken: String
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String

        public init(clientRequestToken: String = StopPipelineExecutionRequest.idempotencyToken(), pipelineExecutionArn: String) {
            self.clientRequestToken = clientRequestToken
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 128)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct StopPipelineExecutionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct StopProcessingJobRequest: AWSEncodableShape {
        /// The name of the processing job to stop.
        public let processingJobName: String

        public init(processingJobName: String) {
            self.processingJobName = processingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, max: 63)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, min: 1)
            try self.validate(self.processingJobName, name: "processingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case processingJobName = "ProcessingJobName"
        }
    }

    public struct StopTrainingJobRequest: AWSEncodableShape {
        /// The name of the training job to stop.
        public let trainingJobName: String

        public init(trainingJobName: String) {
            self.trainingJobName = trainingJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, max: 63)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, min: 1)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobName = "TrainingJobName"
        }
    }

    public struct StopTransformJobRequest: AWSEncodableShape {
        /// The name of the batch transform job to stop.
        public let transformJobName: String

        public init(transformJobName: String) {
            self.transformJobName = transformJobName
        }

        public func validate(name: String) throws {
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, max: 63)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, min: 1)
            try self.validate(self.transformJobName, name: "transformJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobName = "TransformJobName"
        }
    }

    public struct StoppingCondition: AWSEncodableShape & AWSDecodableShape {
        /// The maximum length of time, in seconds, that a training or compilation job can run before it is stopped. For compilation jobs, if the job does not complete during this time, a TimeOut error is generated. We recommend starting with 900 seconds and increasing as necessary based on your model. For all other jobs, if the job does not complete during this time, SageMaker ends the job. When RetryStrategy is specified in the job request, MaxRuntimeInSeconds specifies the maximum time for all of the attempts in total, not each individual attempt. The default value is 1 day. The maximum value is 28 days. The maximum time that a TrainingJob can run in total, including any time spent publishing metrics or archiving and uploading models after it has been stopped, is 30 days.
        public let maxRuntimeInSeconds: Int?
        /// The maximum length of time, in seconds, that a managed Spot training job has to complete. It is the amount of time spent waiting for Spot capacity plus the amount of time the job can run. It must be equal to or greater than MaxRuntimeInSeconds. If the job does not complete during this time, SageMaker ends the job. When RetryStrategy is specified in the job request, MaxWaitTimeInSeconds specifies the maximum time for all of the attempts in total, not each individual attempt.
        public let maxWaitTimeInSeconds: Int?

        public init(maxRuntimeInSeconds: Int? = nil, maxWaitTimeInSeconds: Int? = nil) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
            self.maxWaitTimeInSeconds = maxWaitTimeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRuntimeInSeconds, name: "maxRuntimeInSeconds", parent: name, min: 1)
            try self.validate(self.maxWaitTimeInSeconds, name: "maxWaitTimeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRuntimeInSeconds = "MaxRuntimeInSeconds"
            case maxWaitTimeInSeconds = "MaxWaitTimeInSeconds"
        }
    }

    public struct StudioLifecycleConfigDetails: AWSDecodableShape {
        /// The creation time of the Studio Lifecycle Configuration.
        public let creationTime: Date?
        /// This value is equivalent to CreationTime because Studio Lifecycle Configurations are immutable.
        public let lastModifiedTime: Date?
        /// The App type to which the Lifecycle Configuration is attached.
        public let studioLifecycleConfigAppType: StudioLifecycleConfigAppType?
        ///  The Amazon Resource Name (ARN) of the Lifecycle Configuration.
        public let studioLifecycleConfigArn: String?
        /// The name of the Studio Lifecycle Configuration.
        public let studioLifecycleConfigName: String?

        public init(creationTime: Date? = nil, lastModifiedTime: Date? = nil, studioLifecycleConfigAppType: StudioLifecycleConfigAppType? = nil, studioLifecycleConfigArn: String? = nil, studioLifecycleConfigName: String? = nil) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.studioLifecycleConfigAppType = studioLifecycleConfigAppType
            self.studioLifecycleConfigArn = studioLifecycleConfigArn
            self.studioLifecycleConfigName = studioLifecycleConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case studioLifecycleConfigAppType = "StudioLifecycleConfigAppType"
            case studioLifecycleConfigArn = "StudioLifecycleConfigArn"
            case studioLifecycleConfigName = "StudioLifecycleConfigName"
        }
    }

    public struct SubscribedWorkteam: AWSDecodableShape {
        /// Marketplace product listing ID.
        public let listingId: String?
        /// The description of the vendor from the Amazon Marketplace.
        public let marketplaceDescription: String?
        /// The title of the service provided by the vendor in the Amazon Marketplace.
        public let marketplaceTitle: String?
        /// The name of the vendor in the Amazon Marketplace.
        public let sellerName: String?
        /// The Amazon Resource Name (ARN) of the vendor that you have subscribed.
        public let workteamArn: String

        public init(listingId: String? = nil, marketplaceDescription: String? = nil, marketplaceTitle: String? = nil, sellerName: String? = nil, workteamArn: String) {
            self.listingId = listingId
            self.marketplaceDescription = marketplaceDescription
            self.marketplaceTitle = marketplaceTitle
            self.sellerName = sellerName
            self.workteamArn = workteamArn
        }

        private enum CodingKeys: String, CodingKey {
            case listingId = "ListingId"
            case marketplaceDescription = "MarketplaceDescription"
            case marketplaceTitle = "MarketplaceTitle"
            case sellerName = "SellerName"
            case workteamArn = "WorkteamArn"
        }
    }

    public struct SuggestionQuery: AWSEncodableShape {
        /// Defines a property name hint. Only property names that begin with the specified hint are included in the response.
        public let propertyNameQuery: PropertyNameQuery?

        public init(propertyNameQuery: PropertyNameQuery? = nil) {
            self.propertyNameQuery = propertyNameQuery
        }

        public func validate(name: String) throws {
            try self.propertyNameQuery?.validate(name: "\(name).propertyNameQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameQuery = "PropertyNameQuery"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. Tag keys must be unique per resource.
        public let key: String
        /// The tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TargetPlatform: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a target platform accelerator (optional).    NVIDIA: Nvidia graphics processing unit. It also requires gpu-code, trt-ver, cuda-ver compiler options    MALI: ARM Mali graphics processor    INTEL_GRAPHICS: Integrated Intel graphics
        public let accelerator: TargetPlatformAccelerator?
        /// Specifies a target platform architecture.    X86_64: 64-bit version of the x86 instruction set.    X86: 32-bit version of the x86 instruction set.    ARM64: ARMv8 64-bit CPU.    ARM_EABIHF: ARMv7 32-bit, Hard Float.    ARM_EABI: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM platform.
        public let arch: TargetPlatformArch
        /// Specifies a target platform OS.    LINUX: Linux-based operating systems.    ANDROID: Android operating systems. Android API level can be specified using the ANDROID_PLATFORM compiler option. For example, "CompilerOptions": {'ANDROID_PLATFORM': 28}
        public let os: TargetPlatformOs

        public init(accelerator: TargetPlatformAccelerator? = nil, arch: TargetPlatformArch, os: TargetPlatformOs) {
            self.accelerator = accelerator
            self.arch = arch
            self.os = os
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
            case arch = "Arch"
            case os = "Os"
        }
    }

    public struct TensorBoardAppSettings: AWSEncodableShape & AWSDecodableShape {
        /// The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.
        public let defaultResourceSpec: ResourceSpec?

        public init(defaultResourceSpec: ResourceSpec? = nil) {
            self.defaultResourceSpec = defaultResourceSpec
        }

        public func validate(name: String) throws {
            try self.defaultResourceSpec?.validate(name: "\(name).defaultResourceSpec")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultResourceSpec = "DefaultResourceSpec"
        }
    }

    public struct TensorBoardOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Path to local storage location for tensorBoard output. Defaults to /opt/ml/output/tensorboard.
        public let localPath: String?
        /// Path to Amazon S3 storage location for TensorBoard output.
        public let s3OutputPath: String

        public init(localPath: String? = nil, s3OutputPath: String) {
            self.localPath = localPath
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "LocalPath"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct TimeSeriesForecastingSettings: AWSEncodableShape & AWSDecodableShape {
        /// The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the  AmazonSageMakerCanvasForecastAccess policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
        public let amazonForecastRoleArn: String?
        /// Describes whether time series forecasting is enabled or disabled in the Canvas app.
        public let status: FeatureStatus?

        public init(amazonForecastRoleArn: String? = nil, status: FeatureStatus? = nil) {
            self.amazonForecastRoleArn = amazonForecastRoleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.amazonForecastRoleArn, name: "amazonForecastRoleArn", parent: name, max: 2048)
            try self.validate(self.amazonForecastRoleArn, name: "amazonForecastRoleArn", parent: name, min: 20)
            try self.validate(self.amazonForecastRoleArn, name: "amazonForecastRoleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonForecastRoleArn = "AmazonForecastRoleArn"
            case status = "Status"
        }
    }

    public struct TrafficPattern: AWSEncodableShape & AWSDecodableShape {
        /// Defines the phases traffic specification.
        public let phases: [Phase]?
        /// Defines the traffic patterns.
        public let trafficType: TrafficType?

        public init(phases: [Phase]? = nil, trafficType: TrafficType? = nil) {
            self.phases = phases
            self.trafficType = trafficType
        }

        public func validate(name: String) throws {
            try self.phases?.forEach {
                try $0.validate(name: "\(name).phases[]")
            }
            try self.validate(self.phases, name: "phases", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case phases = "Phases"
            case trafficType = "TrafficType"
        }
    }

    public struct TrafficRoutingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Batch size for the first step to turn on traffic on the new endpoint fleet. Value must be less than or equal to 50% of the variant's total instance count.
        public let canarySize: CapacitySize?
        /// Batch size for each step to turn on traffic on the new endpoint fleet. Value must be 10-50% of the variant's total instance count.
        public let linearStepSize: CapacitySize?
        /// Traffic routing strategy type.    ALL_AT_ONCE: Endpoint traffic shifts to the new fleet in a single step.     CANARY: Endpoint traffic shifts to the new fleet in two steps. The first step is the canary, which is a small portion of the traffic. The second step is the remainder of the traffic.     LINEAR: Endpoint traffic shifts to the new fleet in n steps of a configurable size.
        public let type: TrafficRoutingConfigType
        /// The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet.
        public let waitIntervalInSeconds: Int

        public init(canarySize: CapacitySize? = nil, linearStepSize: CapacitySize? = nil, type: TrafficRoutingConfigType, waitIntervalInSeconds: Int) {
            self.canarySize = canarySize
            self.linearStepSize = linearStepSize
            self.type = type
            self.waitIntervalInSeconds = waitIntervalInSeconds
        }

        public func validate(name: String) throws {
            try self.canarySize?.validate(name: "\(name).canarySize")
            try self.linearStepSize?.validate(name: "\(name).linearStepSize")
            try self.validate(self.waitIntervalInSeconds, name: "waitIntervalInSeconds", parent: name, max: 3600)
            try self.validate(self.waitIntervalInSeconds, name: "waitIntervalInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case canarySize = "CanarySize"
            case linearStepSize = "LinearStepSize"
            case type = "Type"
            case waitIntervalInSeconds = "WaitIntervalInSeconds"
        }
    }

    public struct TrainingJob: AWSDecodableShape {
        /// Information about the algorithm used for training, and algorithm metadata.
        public let algorithmSpecification: AlgorithmSpecification?
        /// The Amazon Resource Name (ARN) of the job.
        public let autoMLJobArn: String?
        /// The billable time in seconds.
        public let billableTimeInSeconds: Int?
        public let checkpointConfig: CheckpointConfig?
        /// A timestamp that indicates when the training job was created.
        public let creationTime: Date?
        public let debugHookConfig: DebugHookConfig?
        /// Information about the debug rule configuration.
        public let debugRuleConfigurations: [DebugRuleConfiguration]?
        /// Information about the evaluation status of the rules for the training job.
        public let debugRuleEvaluationStatuses: [DebugRuleEvaluationStatus]?
        /// To encrypt all communications between ML compute instances in distributed training, choose True. Encryption provides greater security for distributed training, but training might take longer. How long it takes depends on the amount of communication between compute instances, especially if you use a deep learning algorithm in distributed training.
        public let enableInterContainerTrafficEncryption: Bool?
        /// When true, enables managed spot training using Amazon EC2 Spot instances to run training jobs instead of on-demand instances. For more information, see Managed Spot Training.
        public let enableManagedSpotTraining: Bool?
        /// If the TrainingJob was created with network isolation, the value is set to true. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.
        public let enableNetworkIsolation: Bool?
        /// The environment variables to set in the Docker container.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// If the training job failed, the reason it failed.
        public let failureReason: String?
        /// A list of final metric values that are set when the training job completes. Used only if the training job was configured to use metrics.
        public let finalMetricDataList: [MetricData]?
        /// Algorithm-specific parameters.
        public let hyperParameters: [String: String]?
        /// An array of Channel objects that describes each data input channel.
        public let inputDataConfig: [Channel]?
        /// The Amazon Resource Name (ARN) of the labeling job.
        public let labelingJobArn: String?
        /// A timestamp that indicates when the status of the training job was last modified.
        public let lastModifiedTime: Date?
        /// Information about the Amazon S3 location that is configured for storing model artifacts.
        public let modelArtifacts: ModelArtifacts?
        /// The S3 path where model artifacts that you configured when creating the job are stored. SageMaker creates subfolders for model artifacts.
        public let outputDataConfig: OutputDataConfig?
        /// Resources, including ML compute instances and ML storage volumes, that are configured for model training.
        public let resourceConfig: ResourceConfig?
        /// The number of times to retry the job when the job fails due to an InternalServerError.
        public let retryStrategy: RetryStrategy?
        /// The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.
        public let roleArn: String?
        ///  Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see StatusMessage under SecondaryStatusTransition. SageMaker provides primary statuses and secondary statuses that apply to each of them:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.      Valid values for SecondaryStatus are subject to change.   We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTrainingStack     DownloadingTrainingImage
        public let secondaryStatus: SecondaryStatus?
        /// A history of all of the secondary statuses that the training job has transitioned through.
        public let secondaryStatusTransitions: [SecondaryStatusTransition]?
        /// Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs. To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts, so the results of training are not lost.
        public let stoppingCondition: StoppingCondition?
        /// An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. For more information, see Tagging Amazon Web Services Resources.
        public let tags: [Tag]?
        public let tensorBoardOutputConfig: TensorBoardOutputConfig?
        /// Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of TrainingStartTime and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when SageMaker detects a job failure.
        public let trainingEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String?
        /// The name of the training job.
        public let trainingJobName: String?
        /// The status of the training job. Training job statuses are:    InProgress - The training is in progress.    Completed - The training job has completed.    Failed - The training job has failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeTrainingJobResponse call.    Stopping - The training job is stopping.    Stopped - The training job has stopped.   For more detailed information, see SecondaryStatus.
        public let trainingJobStatus: TrainingJobStatus?
        /// Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of TrainingEndTime. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.
        public let trainingStartTime: Date?
        /// The training time in seconds.
        public let trainingTimeInSeconds: Int?
        /// The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.
        public let tuningJobArn: String?
        /// A VpcConfig object that specifies the VPC that this training job has access to. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?

        public init(algorithmSpecification: AlgorithmSpecification? = nil, autoMLJobArn: String? = nil, billableTimeInSeconds: Int? = nil, checkpointConfig: CheckpointConfig? = nil, creationTime: Date? = nil, debugHookConfig: DebugHookConfig? = nil, debugRuleConfigurations: [DebugRuleConfiguration]? = nil, debugRuleEvaluationStatuses: [DebugRuleEvaluationStatus]? = nil, enableInterContainerTrafficEncryption: Bool? = nil, enableManagedSpotTraining: Bool? = nil, enableNetworkIsolation: Bool? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, finalMetricDataList: [MetricData]? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, labelingJobArn: String? = nil, lastModifiedTime: Date? = nil, modelArtifacts: ModelArtifacts? = nil, outputDataConfig: OutputDataConfig? = nil, resourceConfig: ResourceConfig? = nil, retryStrategy: RetryStrategy? = nil, roleArn: String? = nil, secondaryStatus: SecondaryStatus? = nil, secondaryStatusTransitions: [SecondaryStatusTransition]? = nil, stoppingCondition: StoppingCondition? = nil, tags: [Tag]? = nil, tensorBoardOutputConfig: TensorBoardOutputConfig? = nil, trainingEndTime: Date? = nil, trainingJobArn: String? = nil, trainingJobName: String? = nil, trainingJobStatus: TrainingJobStatus? = nil, trainingStartTime: Date? = nil, trainingTimeInSeconds: Int? = nil, tuningJobArn: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.autoMLJobArn = autoMLJobArn
            self.billableTimeInSeconds = billableTimeInSeconds
            self.checkpointConfig = checkpointConfig
            self.creationTime = creationTime
            self.debugHookConfig = debugHookConfig
            self.debugRuleConfigurations = debugRuleConfigurations
            self.debugRuleEvaluationStatuses = debugRuleEvaluationStatuses
            self.enableInterContainerTrafficEncryption = enableInterContainerTrafficEncryption
            self.enableManagedSpotTraining = enableManagedSpotTraining
            self.enableNetworkIsolation = enableNetworkIsolation
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.finalMetricDataList = finalMetricDataList
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.labelingJobArn = labelingJobArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArtifacts = modelArtifacts
            self.outputDataConfig = outputDataConfig
            self.resourceConfig = resourceConfig
            self.retryStrategy = retryStrategy
            self.roleArn = roleArn
            self.secondaryStatus = secondaryStatus
            self.secondaryStatusTransitions = secondaryStatusTransitions
            self.stoppingCondition = stoppingCondition
            self.tags = tags
            self.tensorBoardOutputConfig = tensorBoardOutputConfig
            self.trainingEndTime = trainingEndTime
            self.trainingJobArn = trainingJobArn
            self.trainingJobName = trainingJobName
            self.trainingJobStatus = trainingJobStatus
            self.trainingStartTime = trainingStartTime
            self.trainingTimeInSeconds = trainingTimeInSeconds
            self.tuningJobArn = tuningJobArn
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "AlgorithmSpecification"
            case autoMLJobArn = "AutoMLJobArn"
            case billableTimeInSeconds = "BillableTimeInSeconds"
            case checkpointConfig = "CheckpointConfig"
            case creationTime = "CreationTime"
            case debugHookConfig = "DebugHookConfig"
            case debugRuleConfigurations = "DebugRuleConfigurations"
            case debugRuleEvaluationStatuses = "DebugRuleEvaluationStatuses"
            case enableInterContainerTrafficEncryption = "EnableInterContainerTrafficEncryption"
            case enableManagedSpotTraining = "EnableManagedSpotTraining"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case finalMetricDataList = "FinalMetricDataList"
            case hyperParameters = "HyperParameters"
            case inputDataConfig = "InputDataConfig"
            case labelingJobArn = "LabelingJobArn"
            case lastModifiedTime = "LastModifiedTime"
            case modelArtifacts = "ModelArtifacts"
            case outputDataConfig = "OutputDataConfig"
            case resourceConfig = "ResourceConfig"
            case retryStrategy = "RetryStrategy"
            case roleArn = "RoleArn"
            case secondaryStatus = "SecondaryStatus"
            case secondaryStatusTransitions = "SecondaryStatusTransitions"
            case stoppingCondition = "StoppingCondition"
            case tags = "Tags"
            case tensorBoardOutputConfig = "TensorBoardOutputConfig"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobArn = "TrainingJobArn"
            case trainingJobName = "TrainingJobName"
            case trainingJobStatus = "TrainingJobStatus"
            case trainingStartTime = "TrainingStartTime"
            case trainingTimeInSeconds = "TrainingTimeInSeconds"
            case tuningJobArn = "TuningJobArn"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct TrainingJobDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The hyperparameters used for the training job.
        public let hyperParameters: [String: String]?
        /// An array of Channel objects, each of which specifies an input source.
        public let inputDataConfig: [Channel]
        /// the path to the S3 bucket where you want to store model artifacts. SageMaker creates subfolders for the artifacts.
        public let outputDataConfig: OutputDataConfig
        /// The resources, including the ML compute instances and ML storage volumes, to use for model training.
        public let resourceConfig: ResourceConfig
        /// Specifies a limit to how long a model training job can run. It also specifies how long a managed Spot training job has to complete. When the job reaches the time limit, SageMaker ends the training job. Use this API to cap model training costs. To stop a job, SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms can use this 120-second window to save the model artifacts.
        public let stoppingCondition: StoppingCondition
        public let trainingInputMode: TrainingInputMode

        public init(hyperParameters: [String: String]? = nil, inputDataConfig: [Channel], outputDataConfig: OutputDataConfig, resourceConfig: ResourceConfig, stoppingCondition: StoppingCondition, trainingInputMode: TrainingInputMode) {
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.outputDataConfig = outputDataConfig
            self.resourceConfig = resourceConfig
            self.stoppingCondition = stoppingCondition
            self.trainingInputMode = trainingInputMode
        }

        public func validate(name: String) throws {
            try self.hyperParameters?.forEach {
                try validate($0.key, name: "hyperParameters.key", parent: name, max: 256)
                try validate($0.key, name: "hyperParameters.key", parent: name, pattern: ".*")
                try validate($0.value, name: "hyperParameters[\"\($0.key)\"]", parent: name, max: 2500)
                try validate($0.value, name: "hyperParameters[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.hyperParameters, name: "hyperParameters", parent: name, max: 100)
            try self.inputDataConfig.forEach {
                try $0.validate(name: "\(name).inputDataConfig[]")
            }
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, max: 20)
            try self.validate(self.inputDataConfig, name: "inputDataConfig", parent: name, min: 1)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.resourceConfig.validate(name: "\(name).resourceConfig")
            try self.stoppingCondition.validate(name: "\(name).stoppingCondition")
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameters = "HyperParameters"
            case inputDataConfig = "InputDataConfig"
            case outputDataConfig = "OutputDataConfig"
            case resourceConfig = "ResourceConfig"
            case stoppingCondition = "StoppingCondition"
            case trainingInputMode = "TrainingInputMode"
        }
    }

    public struct TrainingJobStatusCounters: AWSDecodableShape {
        /// The number of completed training jobs launched by the hyperparameter tuning job.
        public let completed: Int?
        /// The number of in-progress training jobs launched by a hyperparameter tuning job.
        public let inProgress: Int?
        /// The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.
        public let nonRetryableError: Int?
        /// The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.
        public let retryableError: Int?
        /// The number of training jobs launched by a hyperparameter tuning job that were manually stopped.
        public let stopped: Int?

        public init(completed: Int? = nil, inProgress: Int? = nil, nonRetryableError: Int? = nil, retryableError: Int? = nil, stopped: Int? = nil) {
            self.completed = completed
            self.inProgress = inProgress
            self.nonRetryableError = nonRetryableError
            self.retryableError = retryableError
            self.stopped = stopped
        }

        private enum CodingKeys: String, CodingKey {
            case completed = "Completed"
            case inProgress = "InProgress"
            case nonRetryableError = "NonRetryableError"
            case retryableError = "RetryableError"
            case stopped = "Stopped"
        }
    }

    public struct TrainingJobStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the training job that was run by this step execution.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct TrainingJobSummary: AWSDecodableShape {
        /// A timestamp that shows when the training job was created.
        public let creationTime: Date
        ///  Timestamp when the training job was last modified.
        public let lastModifiedTime: Date?
        /// A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (Completed, Failed, or Stopped).
        public let trainingEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        /// The name of the training job that you want a summary for.
        public let trainingJobName: String
        /// The status of the training job.
        public let trainingJobStatus: TrainingJobStatus
        /// The status of the warm pool associated with the training job.
        public let warmPoolStatus: WarmPoolStatus?

        public init(creationTime: Date, lastModifiedTime: Date? = nil, trainingEndTime: Date? = nil, trainingJobArn: String, trainingJobName: String, trainingJobStatus: TrainingJobStatus, warmPoolStatus: WarmPoolStatus? = nil) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.trainingEndTime = trainingEndTime
            self.trainingJobArn = trainingJobArn
            self.trainingJobName = trainingJobName
            self.trainingJobStatus = trainingJobStatus
            self.warmPoolStatus = warmPoolStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobArn = "TrainingJobArn"
            case trainingJobName = "TrainingJobName"
            case trainingJobStatus = "TrainingJobStatus"
            case warmPoolStatus = "WarmPoolStatus"
        }
    }

    public struct TrainingSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A list of MetricDefinition objects, which are used for parsing metrics generated by the algorithm.
        public let metricDefinitions: [MetricDefinition]?
        /// A list of the HyperParameterSpecification objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.>
        public let supportedHyperParameters: [HyperParameterSpecification]?
        /// A list of the instance types that this algorithm can use for training.
        public let supportedTrainingInstanceTypes: [TrainingInstanceType]
        /// A list of the metrics that the algorithm emits that can be used as the objective metric in a hyperparameter tuning job.
        public let supportedTuningJobObjectiveMetrics: [HyperParameterTuningJobObjective]?
        /// Indicates whether the algorithm supports distributed training. If set to false, buyers can't request more than one instance during training.
        public let supportsDistributedTraining: Bool?
        /// A list of ChannelSpecification objects, which specify the input sources to be used by the algorithm.
        public let trainingChannels: [ChannelSpecification]
        /// The Amazon ECR registry path of the Docker image that contains the training algorithm.
        public let trainingImage: String
        /// An MD5 hash of the training algorithm that identifies the Docker image used for training.
        public let trainingImageDigest: String?

        public init(metricDefinitions: [MetricDefinition]? = nil, supportedHyperParameters: [HyperParameterSpecification]? = nil, supportedTrainingInstanceTypes: [TrainingInstanceType], supportedTuningJobObjectiveMetrics: [HyperParameterTuningJobObjective]? = nil, supportsDistributedTraining: Bool? = nil, trainingChannels: [ChannelSpecification], trainingImage: String, trainingImageDigest: String? = nil) {
            self.metricDefinitions = metricDefinitions
            self.supportedHyperParameters = supportedHyperParameters
            self.supportedTrainingInstanceTypes = supportedTrainingInstanceTypes
            self.supportedTuningJobObjectiveMetrics = supportedTuningJobObjectiveMetrics
            self.supportsDistributedTraining = supportsDistributedTraining
            self.trainingChannels = trainingChannels
            self.trainingImage = trainingImage
            self.trainingImageDigest = trainingImageDigest
        }

        public func validate(name: String) throws {
            try self.metricDefinitions?.forEach {
                try $0.validate(name: "\(name).metricDefinitions[]")
            }
            try self.validate(self.metricDefinitions, name: "metricDefinitions", parent: name, max: 40)
            try self.supportedHyperParameters?.forEach {
                try $0.validate(name: "\(name).supportedHyperParameters[]")
            }
            try self.validate(self.supportedHyperParameters, name: "supportedHyperParameters", parent: name, max: 100)
            try self.supportedTuningJobObjectiveMetrics?.forEach {
                try $0.validate(name: "\(name).supportedTuningJobObjectiveMetrics[]")
            }
            try self.trainingChannels.forEach {
                try $0.validate(name: "\(name).trainingChannels[]")
            }
            try self.validate(self.trainingChannels, name: "trainingChannels", parent: name, max: 8)
            try self.validate(self.trainingChannels, name: "trainingChannels", parent: name, min: 1)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, max: 255)
            try self.validate(self.trainingImage, name: "trainingImage", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.trainingImageDigest, name: "trainingImageDigest", parent: name, max: 72)
            try self.validate(self.trainingImageDigest, name: "trainingImageDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case metricDefinitions = "MetricDefinitions"
            case supportedHyperParameters = "SupportedHyperParameters"
            case supportedTrainingInstanceTypes = "SupportedTrainingInstanceTypes"
            case supportedTuningJobObjectiveMetrics = "SupportedTuningJobObjectiveMetrics"
            case supportsDistributedTraining = "SupportsDistributedTraining"
            case trainingChannels = "TrainingChannels"
            case trainingImage = "TrainingImage"
            case trainingImageDigest = "TrainingImageDigest"
        }
    }

    public struct TransformDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The S3 location of the data source that is associated with a channel.
        public let s3DataSource: TransformS3DataSource

        public init(s3DataSource: TransformS3DataSource) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
        }
    }

    public struct TransformInput: AWSEncodableShape & AWSDecodableShape {
        /// If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
        public let compressionType: CompressionType?
        /// The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
        public let contentType: String?
        /// Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.
        public let dataSource: TransformDataSource
        /// The method to use to split the transform job's data files into smaller batches. Splitting is necessary when the total size of each object is too large to fit in a single request. You can also use data splitting to improve performance by processing multiple concurrent mini-batches. The default value for SplitType is None, which indicates that input data files are not split, and request payloads contain the entire contents of an input object. Set the value of this parameter to Line to split records on a newline character boundary. SplitType also supports a number of record-oriented binary data formats. Currently, the supported record formats are:   RecordIO   TFRecord   When splitting is enabled, the size of a mini-batch depends on the values of the BatchStrategy and MaxPayloadInMB parameters. When the value of BatchStrategy is MultiRecord, Amazon SageMaker sends the maximum number of records in each request, up to the MaxPayloadInMB limit. If the value of BatchStrategy is SingleRecord, Amazon SageMaker sends individual records in each request.  Some data formats represent a record as a binary payload wrapped with extra padding bytes. When splitting is applied to a binary data format, padding is removed if the value of BatchStrategy is set to SingleRecord. Padding is not removed if the value of BatchStrategy is set to MultiRecord. For more information about RecordIO, see Create a Dataset Using RecordIO in the MXNet documentation. For more information about TFRecord, see Consuming TFRecord data in the TensorFlow documentation.
        public let splitType: SplitType?

        public init(compressionType: CompressionType? = nil, contentType: String? = nil, dataSource: TransformDataSource, splitType: SplitType? = nil) {
            self.compressionType = compressionType
            self.contentType = contentType
            self.dataSource = dataSource
            self.splitType = splitType
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case compressionType = "CompressionType"
            case contentType = "ContentType"
            case dataSource = "DataSource"
            case splitType = "SplitType"
        }
    }

    public struct TransformJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AutoML job that created the transform job.
        public let autoMLJobArn: String?
        /// Specifies the number of records to include in a mini-batch for an HTTP inference request. A record is a single unit of input data that inference can be made on. For example, a single line in a CSV file is a record.
        public let batchStrategy: BatchStrategy?
        /// A timestamp that shows when the transform Job was created.
        public let creationTime: Date?
        public let dataProcessing: DataProcessing?
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        public let experimentConfig: ExperimentConfig?
        /// If the transform job failed, the reason it failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the  labeling job that created the transform job.
        public let labelingJobArn: String?
        /// The maximum number of parallel requests that can be sent to each instance in a transform job. If MaxConcurrentTransforms is set to 0 or left unset, SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms, you don't need to set a value for MaxConcurrentTransforms.
        public let maxConcurrentTransforms: Int?
        /// The maximum allowed size of the payload, in MB. A payload is the data portion of a record (without metadata). The value in MaxPayloadInMB must be greater than, or equal to, the size of a single record. To estimate the size of a record in MB, divide the size of your dataset by the number of records. To ensure that the records fit within the maximum payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in algorithms do not support HTTP chunked encoding.
        public let maxPayloadInMB: Int?
        public let modelClientConfig: ModelClientConfig?
        /// The name of the model associated with the transform job.
        public let modelName: String?
        /// A list of tags associated with the transform job.
        public let tags: [Tag]?
        /// Indicates when the transform job has been completed, or has stopped or failed. You are billed for the time interval between this time and the value of TransformStartTime.
        public let transformEndTime: Date?
        public let transformInput: TransformInput?
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String?
        /// The name of the transform job.
        public let transformJobName: String?
        /// The status of the transform job. Transform job statuses are:    InProgress - The job is in progress.    Completed - The job has completed.    Failed - The transform job has failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeTransformJob call.    Stopping - The transform job is stopping.    Stopped - The transform job has stopped.
        public let transformJobStatus: TransformJobStatus?
        public let transformOutput: TransformOutput?
        public let transformResources: TransformResources?
        /// Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of TransformEndTime.
        public let transformStartTime: Date?

        public init(autoMLJobArn: String? = nil, batchStrategy: BatchStrategy? = nil, creationTime: Date? = nil, dataProcessing: DataProcessing? = nil, environment: [String: String]? = nil, experimentConfig: ExperimentConfig? = nil, failureReason: String? = nil, labelingJobArn: String? = nil, maxConcurrentTransforms: Int? = nil, maxPayloadInMB: Int? = nil, modelClientConfig: ModelClientConfig? = nil, modelName: String? = nil, tags: [Tag]? = nil, transformEndTime: Date? = nil, transformInput: TransformInput? = nil, transformJobArn: String? = nil, transformJobName: String? = nil, transformJobStatus: TransformJobStatus? = nil, transformOutput: TransformOutput? = nil, transformResources: TransformResources? = nil, transformStartTime: Date? = nil) {
            self.autoMLJobArn = autoMLJobArn
            self.batchStrategy = batchStrategy
            self.creationTime = creationTime
            self.dataProcessing = dataProcessing
            self.environment = environment
            self.experimentConfig = experimentConfig
            self.failureReason = failureReason
            self.labelingJobArn = labelingJobArn
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.maxPayloadInMB = maxPayloadInMB
            self.modelClientConfig = modelClientConfig
            self.modelName = modelName
            self.tags = tags
            self.transformEndTime = transformEndTime
            self.transformInput = transformInput
            self.transformJobArn = transformJobArn
            self.transformJobName = transformJobName
            self.transformJobStatus = transformJobStatus
            self.transformOutput = transformOutput
            self.transformResources = transformResources
            self.transformStartTime = transformStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLJobArn = "AutoMLJobArn"
            case batchStrategy = "BatchStrategy"
            case creationTime = "CreationTime"
            case dataProcessing = "DataProcessing"
            case environment = "Environment"
            case experimentConfig = "ExperimentConfig"
            case failureReason = "FailureReason"
            case labelingJobArn = "LabelingJobArn"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case maxPayloadInMB = "MaxPayloadInMB"
            case modelClientConfig = "ModelClientConfig"
            case modelName = "ModelName"
            case tags = "Tags"
            case transformEndTime = "TransformEndTime"
            case transformInput = "TransformInput"
            case transformJobArn = "TransformJobArn"
            case transformJobName = "TransformJobName"
            case transformJobStatus = "TransformJobStatus"
            case transformOutput = "TransformOutput"
            case transformResources = "TransformResources"
            case transformStartTime = "TransformStartTime"
        }
    }

    public struct TransformJobDefinition: AWSEncodableShape & AWSDecodableShape {
        /// A string that determines the number of records included in a single mini-batch.  SingleRecord means only one record is used per mini-batch. MultiRecord means a mini-batch is set to contain as many records that can fit within the MaxPayloadInMB limit.
        public let batchStrategy: BatchStrategy?
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        /// The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
        public let maxConcurrentTransforms: Int?
        /// The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
        public let maxPayloadInMB: Int?
        /// A description of the input source and the way the transform job consumes it.
        public let transformInput: TransformInput
        /// Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        public let transformOutput: TransformOutput
        /// Identifies the ML compute instances for the transform job.
        public let transformResources: TransformResources

        public init(batchStrategy: BatchStrategy? = nil, environment: [String: String]? = nil, maxConcurrentTransforms: Int? = nil, maxPayloadInMB: Int? = nil, transformInput: TransformInput, transformOutput: TransformOutput, transformResources: TransformResources) {
            self.batchStrategy = batchStrategy
            self.environment = environment
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.maxPayloadInMB = maxPayloadInMB
            self.transformInput = transformInput
            self.transformOutput = transformOutput
            self.transformResources = transformResources
        }

        public func validate(name: String) throws {
            try self.environment?.forEach {
                try validate($0.key, name: "environment.key", parent: name, max: 1024)
                try validate($0.key, name: "environment.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]{0,1023}$")
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, max: 10240)
                try validate($0.value, name: "environment[\"\($0.key)\"]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.environment, name: "environment", parent: name, max: 16)
            try self.validate(self.maxConcurrentTransforms, name: "maxConcurrentTransforms", parent: name, min: 0)
            try self.validate(self.maxPayloadInMB, name: "maxPayloadInMB", parent: name, min: 0)
            try self.transformInput.validate(name: "\(name).transformInput")
            try self.transformOutput.validate(name: "\(name).transformOutput")
            try self.transformResources.validate(name: "\(name).transformResources")
        }

        private enum CodingKeys: String, CodingKey {
            case batchStrategy = "BatchStrategy"
            case environment = "Environment"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case maxPayloadInMB = "MaxPayloadInMB"
            case transformInput = "TransformInput"
            case transformOutput = "TransformOutput"
            case transformResources = "TransformResources"
        }
    }

    public struct TransformJobStepMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the transform job that was run by this step execution.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct TransformJobSummary: AWSDecodableShape {
        /// A timestamp that shows when the transform Job was created.
        public let creationTime: Date
        /// If the transform job failed, the reason it failed.
        public let failureReason: String?
        /// Indicates when the transform job was last modified.
        public let lastModifiedTime: Date?
        /// Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.
        public let transformEndTime: Date?
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String
        /// The name of the transform job.
        public let transformJobName: String
        /// The status of the transform job.
        public let transformJobStatus: TransformJobStatus

        public init(creationTime: Date, failureReason: String? = nil, lastModifiedTime: Date? = nil, transformEndTime: Date? = nil, transformJobArn: String, transformJobName: String, transformJobStatus: TransformJobStatus) {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.transformEndTime = transformEndTime
            self.transformJobArn = transformJobArn
            self.transformJobName = transformJobName
            self.transformJobStatus = transformJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case transformEndTime = "TransformEndTime"
            case transformJobArn = "TransformJobArn"
            case transformJobName = "TransformJobName"
            case transformJobStatus = "TransformJobStatus"
        }
    }

    public struct TransformOutput: AWSEncodableShape & AWSDecodableShape {
        /// The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
        public let accept: String?
        /// Defines how to assemble the results of the transform job as a single S3 object. Choose a format that is most convenient to you. To concatenate the results in binary format, specify None. To add a newline character at the end of every transformed record, specify Line.
        public let assembleWith: AssemblyType?
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias    If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.  The KMS key policy must grant permission to the IAM role that you specify in your
        /// 	CreateModel
        /// 		request. For more information, see Using Key Policies in Amazon Web Services KMS in the Amazon Web Services Key Management Service Developer Guide.
        public let kmsKeyId: String?
        /// The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, s3://bucket-name/key-name-prefix. For every S3 object used as input for the transform job, batch transform stores the transformed data with an .out suffix in a corresponding subfolder in the location in the output prefix. For example, for the input data stored at s3://bucket-name/input-name-prefix/dataset01/data.csv, batch transform stores the transformed data at s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out. Batch transform doesn't upload partially processed objects. For an input S3 object that contains multiple records, it creates an .out file only if the transform job succeeds on the entire file. When the input contains multiple S3 objects, the batch transform job processes the listed S3 objects and uploads only the output for successfully processed objects. If any object fails in the transform job batch transform marks the job as failed to prompt investigation.
        public let s3OutputPath: String

        public init(accept: String? = nil, assembleWith: AssemblyType? = nil, kmsKeyId: String? = nil, s3OutputPath: String) {
            self.accept = accept
            self.assembleWith = assembleWith
            self.kmsKeyId = kmsKeyId
            self.s3OutputPath = s3OutputPath
        }

        public func validate(name: String) throws {
            try self.validate(self.accept, name: "accept", parent: name, max: 256)
            try self.validate(self.accept, name: "accept", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, max: 1024)
            try self.validate(self.s3OutputPath, name: "s3OutputPath", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case accept = "Accept"
            case assembleWith = "AssembleWith"
            case kmsKeyId = "KmsKeyId"
            case s3OutputPath = "S3OutputPath"
        }
    }

    public struct TransformResources: AWSEncodableShape & AWSDecodableShape {
        /// The number of ML compute instances to use in the transform job. The default value is 1, and the maximum is 100. For distributed transform jobs, specify a value greater than 1.
        public let instanceCount: Int
        /// The ML compute instance type for the transform job. If you are using built-in algorithms to transform moderately sized datasets, we recommend using ml.m4.xlarge or ml.m5.largeinstance types.
        public let instanceType: TransformInstanceType
        /// The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.  Certain Nitro-based instances include local storage, dependent on the instance type. Local storage volumes are encrypted using a hardware module on the instance. You can't request a VolumeKmsKeyId when using an instance type with local storage. For a list of instance types that support local instance storage, see Instance Store Volumes. For more information about local instance storage encryption, see SSD Instance Store Volumes.   The VolumeKmsKeyId can be any of the following formats:   Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias name ARN: arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias
        public let volumeKmsKeyId: String?

        public init(instanceCount: Int, instanceType: TransformInstanceType, volumeKmsKeyId: String? = nil) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeKmsKeyId = volumeKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, max: 2048)
            try self.validate(self.volumeKmsKeyId, name: "volumeKmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case volumeKmsKeyId = "VolumeKmsKeyId"
        }
    }

    public struct TransformS3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// If you choose S3Prefix, S3Uri identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform.  If you choose ManifestFile, S3Uri identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform.  The following values are compatible: ManifestFile, S3Prefix  The following value is not compatible: AugmentedManifestFile
        public let s3DataType: S3DataType
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest. For example:   A key name prefix might look like this: s3://bucketname/exampleprefix.    A manifest might look like this: s3://bucketname/example.manifest  The manifest is an S3 object which is a JSON file with the following format:   [ {"prefix": "s3://customer_bucket/some/prefix/"},   "relative/path/to/custdata-1",   "relative/path/custdata-2",   ...   "relative/path/custdata-N"   ]  The preceding JSON matches the following S3Uris:   s3://customer_bucket/some/prefix/relative/path/to/custdata-1   s3://customer_bucket/some/prefix/relative/path/custdata-2   ...   s3://customer_bucket/some/prefix/relative/path/custdata-N  The complete set of S3Uris in this manifest constitutes the input data for the channel for this datasource. The object that each S3Uris points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.
        public let s3Uri: String

        public init(s3DataType: S3DataType, s3Uri: String) {
            self.s3DataType = s3DataType
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataType = "S3DataType"
            case s3Uri = "S3Uri"
        }
    }

    public struct Trial: AWSDecodableShape {
        /// Who created the trial.
        public let createdBy: UserContext?
        /// When the trial was created.
        public let creationTime: Date?
        /// The name of the trial as displayed. If DisplayName isn't specified, TrialName is displayed.
        public let displayName: String?
        /// The name of the experiment the trial is part of.
        public let experimentName: String?
        public let lastModifiedBy: UserContext?
        /// Who last modified the trial.
        public let lastModifiedTime: Date?
        public let metadataProperties: MetadataProperties?
        public let source: TrialSource?
        /// The list of tags that are associated with the trial. You can use Search API to search on the tags.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?
        /// A list of the components associated with the trial. For each component, a summary of the component's properties is included.
        public let trialComponentSummaries: [TrialComponentSimpleSummary]?
        /// The name of the trial.
        public let trialName: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, displayName: String? = nil, experimentName: String? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, metadataProperties: MetadataProperties? = nil, source: TrialSource? = nil, tags: [Tag]? = nil, trialArn: String? = nil, trialComponentSummaries: [TrialComponentSimpleSummary]? = nil, trialName: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.displayName = displayName
            self.experimentName = experimentName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.metadataProperties = metadataProperties
            self.source = source
            self.tags = tags
            self.trialArn = trialArn
            self.trialComponentSummaries = trialComponentSummaries
            self.trialName = trialName
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case experimentName = "ExperimentName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case metadataProperties = "MetadataProperties"
            case source = "Source"
            case tags = "Tags"
            case trialArn = "TrialArn"
            case trialComponentSummaries = "TrialComponentSummaries"
            case trialName = "TrialName"
        }
    }

    public struct TrialComponent: AWSDecodableShape {
        /// Who created the trial component.
        public let createdBy: UserContext?
        /// When the component was created.
        public let creationTime: Date?
        /// The name of the component as displayed. If DisplayName isn't specified, TrialComponentName is displayed.
        public let displayName: String?
        /// When the component ended.
        public let endTime: Date?
        /// The input artifacts of the component.
        public let inputArtifacts: [String: TrialComponentArtifact]?
        public let lastModifiedBy: UserContext?
        /// When the component was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the lineage group resource.
        public let lineageGroupArn: String?
        public let metadataProperties: MetadataProperties?
        /// The metrics for the component.
        public let metrics: [TrialComponentMetricSummary]?
        /// The output artifacts of the component.
        public let outputArtifacts: [String: TrialComponentArtifact]?
        /// The hyperparameters of the component.
        public let parameters: [String: TrialComponentParameterValue]?
        /// An array of the parents of the component. A parent is a trial the component is associated with and the experiment the trial is part of. A component might not have any parents.
        public let parents: [Parent]?
        /// The name of the experiment run.
        public let runName: String?
        /// The Amazon Resource Name (ARN) and job type of the source of the component.
        public let source: TrialComponentSource?
        /// Details of the source of the component.
        public let sourceDetail: TrialComponentSourceDetail?
        /// When the component started.
        public let startTime: Date?
        public let status: TrialComponentStatus?
        /// The list of tags that are associated with the component. You can use Search API to search on the tags.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?
        /// The name of the trial component.
        public let trialComponentName: String?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, displayName: String? = nil, endTime: Date? = nil, inputArtifacts: [String: TrialComponentArtifact]? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, lineageGroupArn: String? = nil, metadataProperties: MetadataProperties? = nil, metrics: [TrialComponentMetricSummary]? = nil, outputArtifacts: [String: TrialComponentArtifact]? = nil, parameters: [String: TrialComponentParameterValue]? = nil, parents: [Parent]? = nil, runName: String? = nil, source: TrialComponentSource? = nil, sourceDetail: TrialComponentSourceDetail? = nil, startTime: Date? = nil, status: TrialComponentStatus? = nil, tags: [Tag]? = nil, trialComponentArn: String? = nil, trialComponentName: String? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.displayName = displayName
            self.endTime = endTime
            self.inputArtifacts = inputArtifacts
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.lineageGroupArn = lineageGroupArn
            self.metadataProperties = metadataProperties
            self.metrics = metrics
            self.outputArtifacts = outputArtifacts
            self.parameters = parameters
            self.parents = parents
            self.runName = runName
            self.source = source
            self.sourceDetail = sourceDetail
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.trialComponentArn = trialComponentArn
            self.trialComponentName = trialComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case endTime = "EndTime"
            case inputArtifacts = "InputArtifacts"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case lineageGroupArn = "LineageGroupArn"
            case metadataProperties = "MetadataProperties"
            case metrics = "Metrics"
            case outputArtifacts = "OutputArtifacts"
            case parameters = "Parameters"
            case parents = "Parents"
            case runName = "RunName"
            case source = "Source"
            case sourceDetail = "SourceDetail"
            case startTime = "StartTime"
            case status = "Status"
            case tags = "Tags"
            case trialComponentArn = "TrialComponentArn"
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct TrialComponentArtifact: AWSEncodableShape & AWSDecodableShape {
        /// The media type of the artifact, which indicates the type of data in the artifact file. The media type consists of a type and a subtype concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The type specifies the category of the media. The subtype specifies the kind of data.
        public let mediaType: String?
        /// The location of the artifact.
        public let value: String

        public init(mediaType: String? = nil, value: String) {
            self.mediaType = mediaType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaType, name: "mediaType", parent: name, max: 64)
            try self.validate(self.mediaType, name: "mediaType", parent: name, pattern: "^[-\\w]+\\/[-\\w+]+$")
            try self.validate(self.value, name: "value", parent: name, max: 2048)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case mediaType = "MediaType"
            case value = "Value"
        }
    }

    public struct TrialComponentMetricSummary: AWSDecodableShape {
        /// The average value of the metric.
        public let avg: Double?
        /// The number of samples used to generate the metric.
        public let count: Int?
        /// The most recent value of the metric.
        public let last: Double?
        /// The maximum value of the metric.
        public let max: Double?
        /// The name of the metric.
        public let metricName: String?
        /// The minimum value of the metric.
        public let min: Double?
        /// The Amazon Resource Name (ARN) of the source.
        public let sourceArn: String?
        /// The standard deviation of the metric.
        public let stdDev: Double?
        /// When the metric was last updated.
        public let timeStamp: Date?

        public init(avg: Double? = nil, count: Int? = nil, last: Double? = nil, max: Double? = nil, metricName: String? = nil, min: Double? = nil, sourceArn: String? = nil, stdDev: Double? = nil, timeStamp: Date? = nil) {
            self.avg = avg
            self.count = count
            self.last = last
            self.max = max
            self.metricName = metricName
            self.min = min
            self.sourceArn = sourceArn
            self.stdDev = stdDev
            self.timeStamp = timeStamp
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "Avg"
            case count = "Count"
            case last = "Last"
            case max = "Max"
            case metricName = "MetricName"
            case min = "Min"
            case sourceArn = "SourceArn"
            case stdDev = "StdDev"
            case timeStamp = "TimeStamp"
        }
    }

    public struct TrialComponentSimpleSummary: AWSDecodableShape {
        public let createdBy: UserContext?
        /// When the component was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?
        /// The name of the trial component.
        public let trialComponentName: String?
        public let trialComponentSource: TrialComponentSource?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, trialComponentArn: String? = nil, trialComponentName: String? = nil, trialComponentSource: TrialComponentSource? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.trialComponentArn = trialComponentArn
            self.trialComponentName = trialComponentName
            self.trialComponentSource = trialComponentSource
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case trialComponentArn = "TrialComponentArn"
            case trialComponentName = "TrialComponentName"
            case trialComponentSource = "TrialComponentSource"
        }
    }

    public struct TrialComponentSource: AWSDecodableShape {
        /// The source Amazon Resource Name (ARN).
        public let sourceArn: String
        /// The source job type.
        public let sourceType: String?

        public init(sourceArn: String, sourceType: String? = nil) {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct TrialComponentSourceDetail: AWSDecodableShape {
        /// Information about a processing job that's the source of a trial component.
        public let processingJob: ProcessingJob?
        /// The Amazon Resource Name (ARN) of the source.
        public let sourceArn: String?
        /// Information about a training job that's the source of a trial component.
        public let trainingJob: TrainingJob?
        /// Information about a transform job that's the source of a trial component.
        public let transformJob: TransformJob?

        public init(processingJob: ProcessingJob? = nil, sourceArn: String? = nil, trainingJob: TrainingJob? = nil, transformJob: TransformJob? = nil) {
            self.processingJob = processingJob
            self.sourceArn = sourceArn
            self.trainingJob = trainingJob
            self.transformJob = transformJob
        }

        private enum CodingKeys: String, CodingKey {
            case processingJob = "ProcessingJob"
            case sourceArn = "SourceArn"
            case trainingJob = "TrainingJob"
            case transformJob = "TransformJob"
        }
    }

    public struct TrialComponentStatus: AWSEncodableShape & AWSDecodableShape {
        /// If the component failed, a message describing why.
        public let message: String?
        /// The status of the trial component.
        public let primaryStatus: TrialComponentPrimaryStatus?

        public init(message: String? = nil, primaryStatus: TrialComponentPrimaryStatus? = nil) {
            self.message = message
            self.primaryStatus = primaryStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.message, name: "message", parent: name, max: 1024)
            try self.validate(self.message, name: "message", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case primaryStatus = "PrimaryStatus"
        }
    }

    public struct TrialComponentSummary: AWSDecodableShape {
        /// Who created the trial component.
        public let createdBy: UserContext?
        /// When the component was created.
        public let creationTime: Date?
        /// The name of the component as displayed. If DisplayName isn't specified, TrialComponentName is displayed.
        public let displayName: String?
        /// When the component ended.
        public let endTime: Date?
        /// Who last modified the component.
        public let lastModifiedBy: UserContext?
        /// When the component was last modified.
        public let lastModifiedTime: Date?
        /// When the component started.
        public let startTime: Date?
        /// The status of the component. States include:   InProgress   Completed   Failed
        public let status: TrialComponentStatus?
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?
        /// The name of the trial component.
        public let trialComponentName: String?
        public let trialComponentSource: TrialComponentSource?

        public init(createdBy: UserContext? = nil, creationTime: Date? = nil, displayName: String? = nil, endTime: Date? = nil, lastModifiedBy: UserContext? = nil, lastModifiedTime: Date? = nil, startTime: Date? = nil, status: TrialComponentStatus? = nil, trialComponentArn: String? = nil, trialComponentName: String? = nil, trialComponentSource: TrialComponentSource? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.displayName = displayName
            self.endTime = endTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.startTime = startTime
            self.status = status
            self.trialComponentArn = trialComponentArn
            self.trialComponentName = trialComponentName
            self.trialComponentSource = trialComponentSource
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case endTime = "EndTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case startTime = "StartTime"
            case status = "Status"
            case trialComponentArn = "TrialComponentArn"
            case trialComponentName = "TrialComponentName"
            case trialComponentSource = "TrialComponentSource"
        }
    }

    public struct TrialSource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the source.
        public let sourceArn: String
        /// The source job type.
        public let sourceType: String?

        public init(sourceArn: String, sourceType: String? = nil) {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct TrialSummary: AWSDecodableShape {
        /// When the trial was created.
        public let creationTime: Date?
        /// The name of the trial as displayed. If DisplayName isn't specified, TrialName is displayed.
        public let displayName: String?
        /// When the trial was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?
        /// The name of the trial.
        public let trialName: String?
        public let trialSource: TrialSource?

        public init(creationTime: Date? = nil, displayName: String? = nil, lastModifiedTime: Date? = nil, trialArn: String? = nil, trialName: String? = nil, trialSource: TrialSource? = nil) {
            self.creationTime = creationTime
            self.displayName = displayName
            self.lastModifiedTime = lastModifiedTime
            self.trialArn = trialArn
            self.trialName = trialName
            self.trialSource = trialSource
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case displayName = "DisplayName"
            case lastModifiedTime = "LastModifiedTime"
            case trialArn = "TrialArn"
            case trialName = "TrialName"
            case trialSource = "TrialSource"
        }
    }

    public struct TuningJobCompletionCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The value of the objective metric.
        public let targetObjectiveMetricValue: Float

        public init(targetObjectiveMetricValue: Float) {
            self.targetObjectiveMetricValue = targetObjectiveMetricValue
        }

        private enum CodingKeys: String, CodingKey {
            case targetObjectiveMetricValue = "TargetObjectiveMetricValue"
        }
    }

    public struct TuningJobStepMetaData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the tuning job that was run by this step execution.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct USD: AWSEncodableShape & AWSDecodableShape {
        /// The fractional portion, in cents, of the amount.
        public let cents: Int?
        /// The whole number of dollars in the amount.
        public let dollars: Int?
        /// Fractions of a cent, in tenths.
        public let tenthFractionsOfACent: Int?

        public init(cents: Int? = nil, dollars: Int? = nil, tenthFractionsOfACent: Int? = nil) {
            self.cents = cents
            self.dollars = dollars
            self.tenthFractionsOfACent = tenthFractionsOfACent
        }

        public func validate(name: String) throws {
            try self.validate(self.cents, name: "cents", parent: name, max: 99)
            try self.validate(self.cents, name: "cents", parent: name, min: 0)
            try self.validate(self.dollars, name: "dollars", parent: name, max: 2)
            try self.validate(self.dollars, name: "dollars", parent: name, min: 0)
            try self.validate(self.tenthFractionsOfACent, name: "tenthFractionsOfACent", parent: name, max: 9)
            try self.validate(self.tenthFractionsOfACent, name: "tenthFractionsOfACent", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case cents = "Cents"
            case dollars = "Dollars"
            case tenthFractionsOfACent = "TenthFractionsOfACent"
        }
    }

    public struct UiConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the worker task template used to render the worker UI and tools for labeling job tasks. Use this parameter when you are creating a labeling job for named entity recognition, 3D point cloud and video frame labeling jobs. Use your labeling job task type to select one of the following ARNs and use it with this parameter when you create a labeling job. Replace aws-region with the Amazon Web Services Region you are creating your labeling job in. For example, replace aws-region with us-west-1 if you create a labeling job in US West (N. California).  Named Entity Recognition  Use the following HumanTaskUiArn for named entity recognition labeling jobs:  arn:aws:sagemaker:aws-region:394669845002:human-task-ui/NamedEntityRecognition   3D Point Cloud HumanTaskUiArns  Use this HumanTaskUiArn for 3D point cloud object detection and 3D point cloud object detection adjustment labeling jobs.     arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection    Use this HumanTaskUiArn for 3D point cloud object tracking and 3D point cloud object tracking adjustment labeling jobs.     arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking    Use this HumanTaskUiArn for 3D point cloud semantic segmentation and 3D point cloud semantic segmentation adjustment labeling jobs.    arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation     Video Frame HumanTaskUiArns  Use this HumanTaskUiArn for video frame object detection and video frame object detection adjustment labeling jobs.     arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection    Use this HumanTaskUiArn for video frame object tracking and video frame object tracking adjustment labeling jobs.     arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking
        public let humanTaskUiArn: String?
        /// The Amazon S3 bucket location of the UI template, or worker task template. This is the template used to render the worker UI and tools for labeling job tasks. For more information about the contents of a UI template, see  Creating Your Custom Labeling Task Template.
        public let uiTemplateS3Uri: String?

        public init(humanTaskUiArn: String? = nil, uiTemplateS3Uri: String? = nil) {
            self.humanTaskUiArn = humanTaskUiArn
            self.uiTemplateS3Uri = uiTemplateS3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, max: 1024)
            try self.validate(self.humanTaskUiArn, name: "humanTaskUiArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:human-task-ui/")
            try self.validate(self.uiTemplateS3Uri, name: "uiTemplateS3Uri", parent: name, max: 1024)
            try self.validate(self.uiTemplateS3Uri, name: "uiTemplateS3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskUiArn = "HumanTaskUiArn"
            case uiTemplateS3Uri = "UiTemplateS3Uri"
        }
    }

    public struct UiTemplate: AWSEncodableShape {
        /// The content of the Liquid template for the worker user interface.
        public let content: String

        public init(content: String) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 128_000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\S\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct UiTemplateInfo: AWSDecodableShape {
        /// The SHA-256 digest of the contents of the template.
        public let contentSha256: String?
        /// The URL for the user interface template.
        public let url: String?

        public init(contentSha256: String? = nil, url: String? = nil) {
            self.contentSha256 = contentSha256
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case contentSha256 = "ContentSha256"
            case url = "Url"
        }
    }

    public struct UpdateActionRequest: AWSEncodableShape {
        /// The name of the action to update.
        public let actionName: String
        /// The new description for the action.
        public let description: String?
        /// The new list of properties. Overwrites the current property list.
        public let properties: [String: String]?
        /// A list of properties to remove.
        public let propertiesToRemove: [String]?
        /// The new status for the action.
        public let status: ActionStatus?

        public init(actionName: String, description: String? = nil, properties: [String: String]? = nil, propertiesToRemove: [String]? = nil, status: ActionStatus? = nil) {
            self.actionName = actionName
            self.description = description
            self.properties = properties
            self.propertiesToRemove = propertiesToRemove
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 120)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.propertiesToRemove?.forEach {
                try validate($0, name: "propertiesToRemove[]", parent: name, max: 256)
                try validate($0, name: "propertiesToRemove[]", parent: name, pattern: ".*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "ActionName"
            case description = "Description"
            case properties = "Properties"
            case propertiesToRemove = "PropertiesToRemove"
            case status = "Status"
        }
    }

    public struct UpdateActionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let actionArn: String?

        public init(actionArn: String? = nil) {
            self.actionArn = actionArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionArn = "ActionArn"
        }
    }

    public struct UpdateAppImageConfigRequest: AWSEncodableShape {
        /// The name of the AppImageConfig to update.
        public let appImageConfigName: String
        /// The new KernelGateway app to run on the image.
        public let kernelGatewayImageConfig: KernelGatewayImageConfig?

        public init(appImageConfigName: String, kernelGatewayImageConfig: KernelGatewayImageConfig? = nil) {
            self.appImageConfigName = appImageConfigName
            self.kernelGatewayImageConfig = kernelGatewayImageConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, max: 63)
            try self.validate(self.appImageConfigName, name: "appImageConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.kernelGatewayImageConfig?.validate(name: "\(name).kernelGatewayImageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigName = "AppImageConfigName"
            case kernelGatewayImageConfig = "KernelGatewayImageConfig"
        }
    }

    public struct UpdateAppImageConfigResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the AppImageConfig.
        public let appImageConfigArn: String?

        public init(appImageConfigArn: String? = nil) {
            self.appImageConfigArn = appImageConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case appImageConfigArn = "AppImageConfigArn"
        }
    }

    public struct UpdateArtifactRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the artifact to update.
        public let artifactArn: String
        /// The new name for the artifact.
        public let artifactName: String?
        /// The new list of properties. Overwrites the current property list.
        public let properties: [String: String]?
        /// A list of properties to remove.
        public let propertiesToRemove: [String]?

        public init(artifactArn: String, artifactName: String? = nil, properties: [String: String]? = nil, propertiesToRemove: [String]? = nil) {
            self.artifactArn = artifactArn
            self.artifactName = artifactName
            self.properties = properties
            self.propertiesToRemove = propertiesToRemove
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, max: 256)
            try self.validate(self.artifactArn, name: "artifactArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:artifact/")
            try self.validate(self.artifactName, name: "artifactName", parent: name, max: 120)
            try self.validate(self.artifactName, name: "artifactName", parent: name, min: 1)
            try self.validate(self.artifactName, name: "artifactName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.propertiesToRemove?.forEach {
                try validate($0, name: "propertiesToRemove[]", parent: name, max: 256)
                try validate($0, name: "propertiesToRemove[]", parent: name, pattern: ".*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
            case artifactName = "ArtifactName"
            case properties = "Properties"
            case propertiesToRemove = "PropertiesToRemove"
        }
    }

    public struct UpdateArtifactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the artifact.
        public let artifactArn: String?

        public init(artifactArn: String? = nil) {
            self.artifactArn = artifactArn
        }

        private enum CodingKeys: String, CodingKey {
            case artifactArn = "ArtifactArn"
        }
    }

    public struct UpdateCodeRepositoryInput: AWSEncodableShape {
        /// The name of the Git repository to update.
        public let codeRepositoryName: String
        /// The configuration of the git repository, including the URL and the Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the credentials used to access the repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password}
        public let gitConfig: GitConfigForUpdate?

        public init(codeRepositoryName: String, gitConfig: GitConfigForUpdate? = nil) {
            self.codeRepositoryName = codeRepositoryName
            self.gitConfig = gitConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, max: 63)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, min: 1)
            try self.validate(self.codeRepositoryName, name: "codeRepositoryName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.gitConfig?.validate(name: "\(name).gitConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
            case gitConfig = "GitConfig"
        }
    }

    public struct UpdateCodeRepositoryOutput: AWSDecodableShape {
        /// The ARN of the Git repository.
        public let codeRepositoryArn: String

        public init(codeRepositoryArn: String) {
            self.codeRepositoryArn = codeRepositoryArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
        }
    }

    public struct UpdateContextRequest: AWSEncodableShape {
        /// The name of the context to update.
        public let contextName: String
        /// The new description for the context.
        public let description: String?
        /// The new list of properties. Overwrites the current property list.
        public let properties: [String: String]?
        /// A list of properties to remove.
        public let propertiesToRemove: [String]?

        public init(contextName: String, description: String? = nil, properties: [String: String]? = nil, propertiesToRemove: [String]? = nil) {
            self.contextName = contextName
            self.description = description
            self.properties = properties
            self.propertiesToRemove = propertiesToRemove
        }

        public func validate(name: String) throws {
            try self.validate(self.contextName, name: "contextName", parent: name, max: 120)
            try self.validate(self.contextName, name: "contextName", parent: name, min: 1)
            try self.validate(self.contextName, name: "contextName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, pattern: ".*")
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "properties[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 30)
            try self.propertiesToRemove?.forEach {
                try validate($0, name: "propertiesToRemove[]", parent: name, max: 256)
                try validate($0, name: "propertiesToRemove[]", parent: name, pattern: ".*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contextName = "ContextName"
            case description = "Description"
            case properties = "Properties"
            case propertiesToRemove = "PropertiesToRemove"
        }
    }

    public struct UpdateContextResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the context.
        public let contextArn: String?

        public init(contextArn: String? = nil) {
            self.contextArn = contextArn
        }

        private enum CodingKeys: String, CodingKey {
            case contextArn = "ContextArn"
        }
    }

    public struct UpdateDeviceFleetRequest: AWSEncodableShape {
        /// Description of the fleet.
        public let description: String?
        /// The name of the fleet.
        public let deviceFleetName: String
        /// Whether to create an Amazon Web Services IoT Role Alias during device fleet creation.  The name of the role alias generated will match this pattern:  "SageMakerEdge-{DeviceFleetName}". For example, if your device fleet is called "demo-fleet", the name of  the role alias will be "SageMakerEdge-demo-fleet".
        public let enableIotRoleAlias: Bool?
        /// Output configuration  for storing sample data collected by the fleet.
        public let outputConfig: EdgeOutputConfig
        /// The Amazon Resource Name (ARN) of the device.
        public let roleArn: String?

        public init(description: String? = nil, deviceFleetName: String, enableIotRoleAlias: Bool? = nil, outputConfig: EdgeOutputConfig, roleArn: String? = nil) {
            self.description = description
            self.deviceFleetName = deviceFleetName
            self.enableIotRoleAlias = enableIotRoleAlias
            self.outputConfig = outputConfig
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 800)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case deviceFleetName = "DeviceFleetName"
            case enableIotRoleAlias = "EnableIotRoleAlias"
            case outputConfig = "OutputConfig"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdateDevicesRequest: AWSEncodableShape {
        /// The name of the fleet the devices belong to.
        public let deviceFleetName: String
        /// List of devices to register with Edge Manager agent.
        public let devices: [Device]

        public init(deviceFleetName: String, devices: [Device]) {
            self.deviceFleetName = deviceFleetName
            self.devices = devices
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, max: 63)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, min: 1)
            try self.validate(self.deviceFleetName, name: "deviceFleetName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.devices.forEach {
                try $0.validate(name: "\(name).devices[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deviceFleetName = "DeviceFleetName"
            case devices = "Devices"
        }
    }

    public struct UpdateDomainRequest: AWSEncodableShape {
        /// The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Required when CreateDomain.AppNetworkAccessType is VPCOnly and DomainSettings.RStudioServerProDomainSettings.DomainExecutionRoleArn is provided.
        public let appSecurityGroupManagement: AppSecurityGroupManagement?
        /// The default settings used to create a space within the Domain.
        public let defaultSpaceSettings: DefaultSpaceSettings?
        /// A collection of settings.
        public let defaultUserSettings: UserSettings?
        /// The ID of the domain to be updated.
        public let domainId: String
        /// A collection of DomainSettings configuration values to update.
        public let domainSettingsForUpdate: DomainSettingsForUpdate?

        public init(appSecurityGroupManagement: AppSecurityGroupManagement? = nil, defaultSpaceSettings: DefaultSpaceSettings? = nil, defaultUserSettings: UserSettings? = nil, domainId: String, domainSettingsForUpdate: DomainSettingsForUpdate? = nil) {
            self.appSecurityGroupManagement = appSecurityGroupManagement
            self.defaultSpaceSettings = defaultSpaceSettings
            self.defaultUserSettings = defaultUserSettings
            self.domainId = domainId
            self.domainSettingsForUpdate = domainSettingsForUpdate
        }

        public func validate(name: String) throws {
            try self.defaultSpaceSettings?.validate(name: "\(name).defaultSpaceSettings")
            try self.defaultUserSettings?.validate(name: "\(name).defaultUserSettings")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.domainSettingsForUpdate?.validate(name: "\(name).domainSettingsForUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case appSecurityGroupManagement = "AppSecurityGroupManagement"
            case defaultSpaceSettings = "DefaultSpaceSettings"
            case defaultUserSettings = "DefaultUserSettings"
            case domainId = "DomainId"
            case domainSettingsForUpdate = "DomainSettingsForUpdate"
        }
    }

    public struct UpdateDomainResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain.
        public let domainArn: String?

        public init(domainArn: String? = nil) {
            self.domainArn = domainArn
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "DomainArn"
        }
    }

    public struct UpdateEndpointInput: AWSEncodableShape {
        /// The deployment configuration for an endpoint, which contains the desired deployment strategy and rollback configurations.
        public let deploymentConfig: DeploymentConfig?
        /// The name of the new endpoint configuration.
        public let endpointConfigName: String
        /// The name of the endpoint whose configuration you want to update.
        public let endpointName: String
        /// When you are updating endpoint resources with UpdateEndpointInput$RetainAllVariantProperties, whose value is set to true, ExcludeRetainedVariantProperties specifies the list of type VariantProperty to override with the values provided by EndpointConfig. If you don't specify a value for ExcludeAllVariantProperties, no variant properties are overridden.
        public let excludeRetainedVariantProperties: [VariantProperty]?
        /// When updating endpoint resources, enables or disables the retention of variant properties, such as the instance count or the variant weight. To retain the variant properties of an endpoint when updating it, set RetainAllVariantProperties to true. To use the variant properties specified in a new EndpointConfig call when updating an endpoint, set RetainAllVariantProperties to false. The default is false.
        public let retainAllVariantProperties: Bool?
        /// Specifies whether to reuse the last deployment configuration. The default value is false (the configuration is not reused).
        public let retainDeploymentConfig: Bool?

        public init(deploymentConfig: DeploymentConfig? = nil, endpointConfigName: String, endpointName: String, excludeRetainedVariantProperties: [VariantProperty]? = nil, retainAllVariantProperties: Bool? = nil, retainDeploymentConfig: Bool? = nil) {
            self.deploymentConfig = deploymentConfig
            self.endpointConfigName = endpointConfigName
            self.endpointName = endpointName
            self.excludeRetainedVariantProperties = excludeRetainedVariantProperties
            self.retainAllVariantProperties = retainAllVariantProperties
            self.retainDeploymentConfig = retainDeploymentConfig
        }

        public func validate(name: String) throws {
            try self.deploymentConfig?.validate(name: "\(name).deploymentConfig")
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, max: 63)
            try self.validate(self.endpointConfigName, name: "endpointConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.excludeRetainedVariantProperties, name: "excludeRetainedVariantProperties", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentConfig = "DeploymentConfig"
            case endpointConfigName = "EndpointConfigName"
            case endpointName = "EndpointName"
            case excludeRetainedVariantProperties = "ExcludeRetainedVariantProperties"
            case retainAllVariantProperties = "RetainAllVariantProperties"
            case retainDeploymentConfig = "RetainDeploymentConfig"
        }
    }

    public struct UpdateEndpointOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct UpdateEndpointWeightsAndCapacitiesInput: AWSEncodableShape {
        /// An object that provides new capacity and weight values for a variant.
        public let desiredWeightsAndCapacities: [DesiredWeightAndCapacity]
        /// The name of an existing SageMaker endpoint.
        public let endpointName: String

        public init(desiredWeightsAndCapacities: [DesiredWeightAndCapacity], endpointName: String) {
            self.desiredWeightsAndCapacities = desiredWeightsAndCapacities
            self.endpointName = endpointName
        }

        public func validate(name: String) throws {
            try self.desiredWeightsAndCapacities.forEach {
                try $0.validate(name: "\(name).desiredWeightsAndCapacities[]")
            }
            try self.validate(self.desiredWeightsAndCapacities, name: "desiredWeightsAndCapacities", parent: name, min: 1)
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 63)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredWeightsAndCapacities = "DesiredWeightsAndCapacities"
            case endpointName = "EndpointName"
        }
    }

    public struct UpdateEndpointWeightsAndCapacitiesOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct UpdateExperimentRequest: AWSEncodableShape {
        /// The description of the experiment.
        public let description: String?
        /// The name of the experiment as displayed. The name doesn't need to be unique. If DisplayName isn't specified, ExperimentName is displayed.
        public let displayName: String?
        /// The name of the experiment to update.
        public let experimentName: String

        public init(description: String? = nil, displayName: String? = nil, experimentName: String) {
            self.description = description
            self.displayName = displayName
            self.experimentName = experimentName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 3072)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.experimentName, name: "experimentName", parent: name, max: 120)
            try self.validate(self.experimentName, name: "experimentName", parent: name, min: 1)
            try self.validate(self.experimentName, name: "experimentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case experimentName = "ExperimentName"
        }
    }

    public struct UpdateExperimentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the experiment.
        public let experimentArn: String?

        public init(experimentArn: String? = nil) {
            self.experimentArn = experimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case experimentArn = "ExperimentArn"
        }
    }

    public struct UpdateFeatureGroupRequest: AWSEncodableShape {
        /// Updates the feature group. Updating a feature group is an asynchronous operation. When you get an HTTP 200 response, you've made a valid request. It takes some time after you've made a valid request for Feature Store to update the feature group.
        public let featureAdditions: [FeatureDefinition]?
        /// The name of the feature group that you're updating.
        public let featureGroupName: String

        public init(featureAdditions: [FeatureDefinition]? = nil, featureGroupName: String) {
            self.featureAdditions = featureAdditions
            self.featureGroupName = featureGroupName
        }

        public func validate(name: String) throws {
            try self.featureAdditions?.forEach {
                try $0.validate(name: "\(name).featureAdditions[]")
            }
            try self.validate(self.featureAdditions, name: "featureAdditions", parent: name, max: 100)
            try self.validate(self.featureAdditions, name: "featureAdditions", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureAdditions = "FeatureAdditions"
            case featureGroupName = "FeatureGroupName"
        }
    }

    public struct UpdateFeatureGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the feature group that you're updating.
        public let featureGroupArn: String

        public init(featureGroupArn: String) {
            self.featureGroupArn = featureGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case featureGroupArn = "FeatureGroupArn"
        }
    }

    public struct UpdateFeatureMetadataRequest: AWSEncodableShape {
        /// A description that you can write to better describe the feature.
        public let description: String?
        /// The name of the feature group containing the feature that you're updating.
        public let featureGroupName: String
        /// The name of the feature that you're updating.
        public let featureName: String
        /// A list of key-value pairs that you can add to better describe the feature.
        public let parameterAdditions: [FeatureParameter]?
        /// A list of parameter keys that you can specify to remove parameters that describe your feature.
        public let parameterRemovals: [String]?

        public init(description: String? = nil, featureGroupName: String, featureName: String, parameterAdditions: [FeatureParameter]? = nil, parameterRemovals: [String]? = nil) {
            self.description = description
            self.featureGroupName = featureGroupName
            self.featureName = featureName
            self.parameterAdditions = parameterAdditions
            self.parameterRemovals = parameterRemovals
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, max: 64)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, min: 1)
            try self.validate(self.featureGroupName, name: "featureGroupName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,63}$")
            try self.validate(self.featureName, name: "featureName", parent: name, max: 64)
            try self.validate(self.featureName, name: "featureName", parent: name, min: 1)
            try self.validate(self.featureName, name: "featureName", parent: name, pattern: "^[a-zA-Z0-9]([-_]*[a-zA-Z0-9]){0,63}$")
            try self.parameterAdditions?.forEach {
                try $0.validate(name: "\(name).parameterAdditions[]")
            }
            try self.validate(self.parameterAdditions, name: "parameterAdditions", parent: name, max: 25)
            try self.parameterRemovals?.forEach {
                try validate($0, name: "parameterRemovals[]", parent: name, max: 255)
                try validate($0, name: "parameterRemovals[]", parent: name, min: 1)
                try validate($0, name: "parameterRemovals[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$")
            }
            try self.validate(self.parameterRemovals, name: "parameterRemovals", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case featureGroupName = "FeatureGroupName"
            case featureName = "FeatureName"
            case parameterAdditions = "ParameterAdditions"
            case parameterRemovals = "ParameterRemovals"
        }
    }

    public struct UpdateHubRequest: AWSEncodableShape {
        /// A description of the updated hub.
        public let hubDescription: String?
        /// The display name of the hub.
        public let hubDisplayName: String?
        /// The name of the hub to update.
        public let hubName: String
        /// The searchable keywords for the hub.
        public let hubSearchKeywords: [String]?

        public init(hubDescription: String? = nil, hubDisplayName: String? = nil, hubName: String, hubSearchKeywords: [String]? = nil) {
            self.hubDescription = hubDescription
            self.hubDisplayName = hubDisplayName
            self.hubName = hubName
            self.hubSearchKeywords = hubSearchKeywords
        }

        public func validate(name: String) throws {
            try self.validate(self.hubDescription, name: "hubDescription", parent: name, max: 1023)
            try self.validate(self.hubDescription, name: "hubDescription", parent: name, pattern: ".*")
            try self.validate(self.hubDisplayName, name: "hubDisplayName", parent: name, max: 255)
            try self.validate(self.hubDisplayName, name: "hubDisplayName", parent: name, pattern: ".*")
            try self.validate(self.hubName, name: "hubName", parent: name, max: 63)
            try self.validate(self.hubName, name: "hubName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.hubSearchKeywords?.forEach {
                try validate($0, name: "hubSearchKeywords[]", parent: name, max: 255)
                try validate($0, name: "hubSearchKeywords[]", parent: name, pattern: "^[^A-Z]*$")
            }
            try self.validate(self.hubSearchKeywords, name: "hubSearchKeywords", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case hubDescription = "HubDescription"
            case hubDisplayName = "HubDisplayName"
            case hubName = "HubName"
            case hubSearchKeywords = "HubSearchKeywords"
        }
    }

    public struct UpdateHubResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated hub.
        public let hubArn: String

        public init(hubArn: String) {
            self.hubArn = hubArn
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
        }
    }

    public struct UpdateImageRequest: AWSEncodableShape {
        /// A list of properties to delete. Only the Description and DisplayName properties can be deleted.
        public let deleteProperties: [String]?
        /// The new description for the image.
        public let description: String?
        /// The new display name for the image.
        public let displayName: String?
        /// The name of the image to update.
        public let imageName: String
        /// The new ARN for the IAM role that enables Amazon SageMaker to perform tasks on your behalf.
        public let roleArn: String?

        public init(deleteProperties: [String]? = nil, description: String? = nil, displayName: String? = nil, imageName: String, roleArn: String? = nil) {
            self.deleteProperties = deleteProperties
            self.description = description
            self.displayName = displayName
            self.imageName = imageName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.deleteProperties?.forEach {
                try validate($0, name: "deleteProperties[]", parent: name, max: 11)
                try validate($0, name: "deleteProperties[]", parent: name, min: 1)
                try validate($0, name: "deleteProperties[]", parent: name, pattern: "^(^DisplayName$)|(^Description$)$")
            }
            try self.validate(self.deleteProperties, name: "deleteProperties", parent: name, max: 2)
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 128)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^\\S(.*\\S)?$")
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteProperties = "DeleteProperties"
            case description = "Description"
            case displayName = "DisplayName"
            case imageName = "ImageName"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdateImageResponse: AWSDecodableShape {
        /// The ARN of the image.
        public let imageArn: String?

        public init(imageArn: String? = nil) {
            self.imageArn = imageArn
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "ImageArn"
        }
    }

    public struct UpdateImageVersionRequest: AWSEncodableShape {
        /// The alias of the image version.
        public let alias: String?
        /// A list of aliases to add.
        public let aliasesToAdd: [String]?
        /// A list of aliases to delete.
        public let aliasesToDelete: [String]?
        /// Indicates Horovod compatibility.
        public let horovod: Bool?
        /// The name of the image.
        public let imageName: String
        /// Indicates SageMaker job type compatibility.    TRAINING: The image version is compatible with SageMaker training jobs.    INFERENCE: The image version is compatible with SageMaker inference jobs.    NOTEBOOK_KERNEL: The image version is compatible with SageMaker notebook kernels.
        public let jobType: JobType?
        /// The machine learning framework vended in the image version.
        public let mlFramework: String?
        /// Indicates CPU or GPU compatibility.    CPU: The image version is compatible with CPU.    GPU: The image version is compatible with GPU.
        public let processor: Processor?
        /// The supported programming language and its version.
        public let programmingLang: String?
        /// The maintainer description of the image version.
        public let releaseNotes: String?
        /// The availability of the image version specified by the maintainer.    NOT_PROVIDED: The maintainers did not provide a status for image version stability.    STABLE: The image version is stable.    TO_BE_ARCHIVED: The image version is set to be archived. Custom image versions that are set to be archived are automatically archived after three months.    ARCHIVED: The image version is archived. Archived image versions are not searchable and are no longer actively supported.
        public let vendorGuidance: VendorGuidance?
        /// The version of the image.
        public let version: Int?

        public init(alias: String? = nil, aliasesToAdd: [String]? = nil, aliasesToDelete: [String]? = nil, horovod: Bool? = nil, imageName: String, jobType: JobType? = nil, mlFramework: String? = nil, processor: Processor? = nil, programmingLang: String? = nil, releaseNotes: String? = nil, vendorGuidance: VendorGuidance? = nil, version: Int? = nil) {
            self.alias = alias
            self.aliasesToAdd = aliasesToAdd
            self.aliasesToDelete = aliasesToDelete
            self.horovod = horovod
            self.imageName = imageName
            self.jobType = jobType
            self.mlFramework = mlFramework
            self.processor = processor
            self.programmingLang = programmingLang
            self.releaseNotes = releaseNotes
            self.vendorGuidance = vendorGuidance
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 128)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            try self.aliasesToAdd?.forEach {
                try validate($0, name: "aliasesToAdd[]", parent: name, max: 128)
                try validate($0, name: "aliasesToAdd[]", parent: name, min: 1)
                try validate($0, name: "aliasesToAdd[]", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            }
            try self.aliasesToDelete?.forEach {
                try validate($0, name: "aliasesToDelete[]", parent: name, max: 128)
                try validate($0, name: "aliasesToDelete[]", parent: name, min: 1)
                try validate($0, name: "aliasesToDelete[]", parent: name, pattern: "^(?!^[.-])^([a-zA-Z0-9-_.]+)$")
            }
            try self.validate(self.imageName, name: "imageName", parent: name, max: 63)
            try self.validate(self.imageName, name: "imageName", parent: name, min: 1)
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "^[a-zA-Z0-9]([-.]?[a-zA-Z0-9]){0,62}$")
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, max: 128)
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, min: 1)
            try self.validate(self.mlFramework, name: "mlFramework", parent: name, pattern: "^[a-zA-Z]+ ?\\d+\\.\\d+(\\.\\d+)?$")
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, max: 128)
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, min: 1)
            try self.validate(self.programmingLang, name: "programmingLang", parent: name, pattern: "^[a-zA-Z]+ ?\\d+\\.\\d+(\\.\\d+)?$")
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, max: 255)
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, min: 1)
            try self.validate(self.releaseNotes, name: "releaseNotes", parent: name, pattern: ".*")
            try self.validate(self.version, name: "version", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case aliasesToAdd = "AliasesToAdd"
            case aliasesToDelete = "AliasesToDelete"
            case horovod = "Horovod"
            case imageName = "ImageName"
            case jobType = "JobType"
            case mlFramework = "MLFramework"
            case processor = "Processor"
            case programmingLang = "ProgrammingLang"
            case releaseNotes = "ReleaseNotes"
            case vendorGuidance = "VendorGuidance"
            case version = "Version"
        }
    }

    public struct UpdateImageVersionResponse: AWSDecodableShape {
        /// The ARN of the image version.
        public let imageVersionArn: String?

        public init(imageVersionArn: String? = nil) {
            self.imageVersionArn = imageVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionArn = "ImageVersionArn"
        }
    }

    public struct UpdateInferenceExperimentRequest: AWSEncodableShape {
        /// The Amazon S3 location and configuration for storing inference request and response data.
        public let dataStorageConfig: InferenceExperimentDataStorageConfig?
        /// The description of the inference experiment.
        public let description: String?
        ///  An array of ModelVariantConfig objects. There is one for each variant, whose infrastructure configuration you want to update.
        public let modelVariants: [ModelVariantConfig]?
        /// The name of the inference experiment to be updated.
        public let name: String
        ///  The duration for which the inference experiment will run. If the status of the inference experiment is Created, then you can update both the start and end dates. If the status of the inference experiment is Running, then you can update only the end date.
        public let schedule: InferenceExperimentSchedule?
        ///  The configuration of ShadowMode inference experiment type. Use this field to specify a production variant which takes all the inference requests, and a shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant also specify the percentage of requests that Amazon SageMaker replicates.
        public let shadowModeConfig: ShadowModeConfig?

        public init(dataStorageConfig: InferenceExperimentDataStorageConfig? = nil, description: String? = nil, modelVariants: [ModelVariantConfig]? = nil, name: String, schedule: InferenceExperimentSchedule? = nil, shadowModeConfig: ShadowModeConfig? = nil) {
            self.dataStorageConfig = dataStorageConfig
            self.description = description
            self.modelVariants = modelVariants
            self.name = name
            self.schedule = schedule
            self.shadowModeConfig = shadowModeConfig
        }

        public func validate(name: String) throws {
            try self.dataStorageConfig?.validate(name: "\(name).dataStorageConfig")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.modelVariants?.forEach {
                try $0.validate(name: "\(name).modelVariants[]")
            }
            try self.validate(self.modelVariants, name: "modelVariants", parent: name, max: 2)
            try self.validate(self.modelVariants, name: "modelVariants", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.shadowModeConfig?.validate(name: "\(name).shadowModeConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case dataStorageConfig = "DataStorageConfig"
            case description = "Description"
            case modelVariants = "ModelVariants"
            case name = "Name"
            case schedule = "Schedule"
            case shadowModeConfig = "ShadowModeConfig"
        }
    }

    public struct UpdateInferenceExperimentResponse: AWSDecodableShape {
        /// The ARN of the updated inference experiment.
        public let inferenceExperimentArn: String

        public init(inferenceExperimentArn: String) {
            self.inferenceExperimentArn = inferenceExperimentArn
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceExperimentArn = "InferenceExperimentArn"
        }
    }

    public struct UpdateModelCardRequest: AWSEncodableShape {
        /// The updated model card content. Content must be in model card JSON schema and provided as a string. When updating model card content, be sure to include the full content and not just updated content.
        public let content: String?
        /// The name of the model card to update.
        public let modelCardName: String
        /// The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.    Draft: The model card is a work in progress.    PendingReview: The model card is pending review.    Approved: The model card is approved.    Archived: The model card is archived. No more updates should be made to the model card, but it can still be exported.
        public let modelCardStatus: ModelCardStatus?

        public init(content: String? = nil, modelCardName: String, modelCardStatus: ModelCardStatus? = nil) {
            self.content = content
            self.modelCardName = modelCardName
            self.modelCardStatus = modelCardStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 100_000)
            try self.validate(self.content, name: "content", parent: name, pattern: ".*")
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, max: 63)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, min: 1)
            try self.validate(self.modelCardName, name: "modelCardName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case modelCardName = "ModelCardName"
            case modelCardStatus = "ModelCardStatus"
        }
    }

    public struct UpdateModelCardResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated model card.
        public let modelCardArn: String

        public init(modelCardArn: String) {
            self.modelCardArn = modelCardArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelCardArn = "ModelCardArn"
        }
    }

    public struct UpdateModelPackageInput: AWSEncodableShape {
        /// An array of additional Inference Specification objects to be added to the  existing array additional Inference Specification. Total number of additional  Inference Specifications can not exceed 15. Each additional Inference Specification  specifies artifacts based on this model package that can be used on inference endpoints.  Generally used with SageMaker Neo to store the compiled artifacts.
        public let additionalInferenceSpecificationsToAdd: [AdditionalInferenceSpecificationDefinition]?
        /// A description for the approval status of the model.
        public let approvalDescription: String?
        /// The metadata properties associated with the model package versions.
        public let customerMetadataProperties: [String: String]?
        /// The metadata properties associated with the model package versions to remove.
        public let customerMetadataPropertiesToRemove: [String]?
        /// The approval status of the model.
        public let modelApprovalStatus: ModelApprovalStatus?
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String

        public init(additionalInferenceSpecificationsToAdd: [AdditionalInferenceSpecificationDefinition]? = nil, approvalDescription: String? = nil, customerMetadataProperties: [String: String]? = nil, customerMetadataPropertiesToRemove: [String]? = nil, modelApprovalStatus: ModelApprovalStatus? = nil, modelPackageArn: String) {
            self.additionalInferenceSpecificationsToAdd = additionalInferenceSpecificationsToAdd
            self.approvalDescription = approvalDescription
            self.customerMetadataProperties = customerMetadataProperties
            self.customerMetadataPropertiesToRemove = customerMetadataPropertiesToRemove
            self.modelApprovalStatus = modelApprovalStatus
            self.modelPackageArn = modelPackageArn
        }

        public func validate(name: String) throws {
            try self.additionalInferenceSpecificationsToAdd?.forEach {
                try $0.validate(name: "\(name).additionalInferenceSpecificationsToAdd[]")
            }
            try self.validate(self.additionalInferenceSpecificationsToAdd, name: "additionalInferenceSpecificationsToAdd", parent: name, max: 15)
            try self.validate(self.additionalInferenceSpecificationsToAdd, name: "additionalInferenceSpecificationsToAdd", parent: name, min: 1)
            try self.validate(self.approvalDescription, name: "approvalDescription", parent: name, max: 1024)
            try self.validate(self.approvalDescription, name: "approvalDescription", parent: name, pattern: ".*")
            try self.customerMetadataProperties?.forEach {
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, max: 128)
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, min: 1)
                try validate($0.key, name: "customerMetadataProperties.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,128}$")
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "customerMetadataProperties[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,256}$")
            }
            try self.validate(self.customerMetadataProperties, name: "customerMetadataProperties", parent: name, max: 50)
            try self.validate(self.customerMetadataProperties, name: "customerMetadataProperties", parent: name, min: 1)
            try self.customerMetadataPropertiesToRemove?.forEach {
                try validate($0, name: "customerMetadataPropertiesToRemove[]", parent: name, max: 128)
                try validate($0, name: "customerMetadataPropertiesToRemove[]", parent: name, min: 1)
                try validate($0, name: "customerMetadataPropertiesToRemove[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,128}$")
            }
            try self.validate(self.modelPackageArn, name: "modelPackageArn", parent: name, max: 2048)
            try self.validate(self.modelPackageArn, name: "modelPackageArn", parent: name, min: 1)
            try self.validate(self.modelPackageArn, name: "modelPackageArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:model-package/")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInferenceSpecificationsToAdd = "AdditionalInferenceSpecificationsToAdd"
            case approvalDescription = "ApprovalDescription"
            case customerMetadataProperties = "CustomerMetadataProperties"
            case customerMetadataPropertiesToRemove = "CustomerMetadataPropertiesToRemove"
            case modelApprovalStatus = "ModelApprovalStatus"
            case modelPackageArn = "ModelPackageArn"
        }
    }

    public struct UpdateModelPackageOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model.
        public let modelPackageArn: String

        public init(modelPackageArn: String) {
            self.modelPackageArn = modelPackageArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageArn = "ModelPackageArn"
        }
    }

    public struct UpdateMonitoringAlertRequest: AWSEncodableShape {
        /// Within EvaluationPeriod, how many execution failures will raise an alert.
        public let datapointsToAlert: Int
        /// The number of most recent monitoring executions to consider when evaluating alert status.
        public let evaluationPeriod: Int
        /// The name of a monitoring alert.
        public let monitoringAlertName: String
        /// The name of a monitoring schedule.
        public let monitoringScheduleName: String

        public init(datapointsToAlert: Int, evaluationPeriod: Int, monitoringAlertName: String, monitoringScheduleName: String) {
            self.datapointsToAlert = datapointsToAlert
            self.evaluationPeriod = evaluationPeriod
            self.monitoringAlertName = monitoringAlertName
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.validate(self.datapointsToAlert, name: "datapointsToAlert", parent: name, max: 100)
            try self.validate(self.datapointsToAlert, name: "datapointsToAlert", parent: name, min: 1)
            try self.validate(self.evaluationPeriod, name: "evaluationPeriod", parent: name, max: 100)
            try self.validate(self.evaluationPeriod, name: "evaluationPeriod", parent: name, min: 1)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, max: 63)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, min: 1)
            try self.validate(self.monitoringAlertName, name: "monitoringAlertName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case datapointsToAlert = "DatapointsToAlert"
            case evaluationPeriod = "EvaluationPeriod"
            case monitoringAlertName = "MonitoringAlertName"
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct UpdateMonitoringAlertResponse: AWSDecodableShape {
        /// The name of a monitoring alert.
        public let monitoringAlertName: String?
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String

        public init(monitoringAlertName: String? = nil, monitoringScheduleArn: String) {
            self.monitoringAlertName = monitoringAlertName
            self.monitoringScheduleArn = monitoringScheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringAlertName = "MonitoringAlertName"
            case monitoringScheduleArn = "MonitoringScheduleArn"
        }
    }

    public struct UpdateMonitoringScheduleRequest: AWSEncodableShape {
        /// The configuration object that specifies the monitoring schedule and defines the monitoring job.
        public let monitoringScheduleConfig: MonitoringScheduleConfig
        /// The name of the monitoring schedule. The name must be unique within an Amazon Web Services Region within an Amazon Web Services account.
        public let monitoringScheduleName: String

        public init(monitoringScheduleConfig: MonitoringScheduleConfig, monitoringScheduleName: String) {
            self.monitoringScheduleConfig = monitoringScheduleConfig
            self.monitoringScheduleName = monitoringScheduleName
        }

        public func validate(name: String) throws {
            try self.monitoringScheduleConfig.validate(name: "\(name).monitoringScheduleConfig")
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, max: 63)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, min: 1)
            try self.validate(self.monitoringScheduleName, name: "monitoringScheduleName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleConfig = "MonitoringScheduleConfig"
            case monitoringScheduleName = "MonitoringScheduleName"
        }
    }

    public struct UpdateMonitoringScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitoring schedule.
        public let monitoringScheduleArn: String

        public init(monitoringScheduleArn: String) {
            self.monitoringScheduleArn = monitoringScheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitoringScheduleArn = "MonitoringScheduleArn"
        }
    }

    public struct UpdateNotebookInstanceInput: AWSEncodableShape {
        /// A list of the Elastic Inference (EI) instance types to associate with this notebook instance. Currently only one EI instance type can be associated with a notebook instance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        /// An array of up to three Git repositories to associate with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in Amazon Web Services CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// The Git repository to associate with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in Amazon Web Services CodeCommit or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// A list of the Elastic Inference (EI) instance types to remove from this notebook instance. This operation is idempotent. If you specify an accelerator type that is not associated with the notebook instance when you call this method, it does not throw an error.
        public let disassociateAcceleratorTypes: Bool?
        /// A list of names or URLs of the default Git repositories to remove from this notebook instance. This operation is idempotent. If you specify a Git repository that is not associated with the notebook instance when you call this method, it does not throw an error.
        public let disassociateAdditionalCodeRepositories: Bool?
        /// The name or URL of the default Git repository to remove from this notebook instance. This operation is idempotent. If you specify a Git repository that is not associated with the notebook instance when you call this method, it does not throw an error.
        public let disassociateDefaultCodeRepository: Bool?
        /// Set to true to remove the notebook instance lifecycle configuration currently associated with the notebook instance. This operation is idempotent. If you specify a lifecycle configuration that is not associated with the notebook instance when you call this method, it does not throw an error.
        public let disassociateLifecycleConfig: Bool?
        /// Information on the IMDS configuration of the notebook instance
        public let instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration?
        /// The Amazon ML compute instance type.
        public let instanceType: InstanceType?
        /// The name of a lifecycle configuration to associate with the notebook instance. For information about lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let lifecycleConfigName: String?
        /// The name of the notebook instance to update.
        public let notebookInstanceName: String
        /// The Amazon Resource Name (ARN) of the IAM role that SageMaker can assume to access the notebook instance. For more information, see SageMaker Roles.   To be able to pass this role to SageMaker, the caller of this API must have the iam:PassRole permission.
        public let roleArn: String?
        /// Whether root access is enabled or disabled for users of the notebook instance. The default value is Enabled.  If you set this to Disabled, users don't have root access on the notebook instance, but lifecycle configuration scripts still run with root permissions.
        public let rootAccess: RootAccess?
        /// The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB. ML storage volumes are encrypted, so SageMaker can't determine the amount of available free space on the volume. Because of this, you can increase the volume size when you update a notebook instance, but you can't decrease the volume size. If you want to decrease the size of the ML storage volume in use, create a new notebook instance with the desired size.
        public let volumeSizeInGB: Int?

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, disassociateAcceleratorTypes: Bool? = nil, disassociateAdditionalCodeRepositories: Bool? = nil, disassociateDefaultCodeRepository: Bool? = nil, disassociateLifecycleConfig: Bool? = nil, instanceMetadataServiceConfiguration: InstanceMetadataServiceConfiguration? = nil, instanceType: InstanceType? = nil, lifecycleConfigName: String? = nil, notebookInstanceName: String, roleArn: String? = nil, rootAccess: RootAccess? = nil, volumeSizeInGB: Int? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.disassociateAcceleratorTypes = disassociateAcceleratorTypes
            self.disassociateAdditionalCodeRepositories = disassociateAdditionalCodeRepositories
            self.disassociateDefaultCodeRepository = disassociateDefaultCodeRepository
            self.disassociateLifecycleConfig = disassociateLifecycleConfig
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.lifecycleConfigName = lifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.additionalCodeRepositories?.forEach {
                try validate($0, name: "additionalCodeRepositories[]", parent: name, max: 1024)
                try validate($0, name: "additionalCodeRepositories[]", parent: name, min: 1)
                try validate($0, name: "additionalCodeRepositories[]", parent: name, pattern: "^https://([^/]+)/?(.*)$|^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            }
            try self.validate(self.additionalCodeRepositories, name: "additionalCodeRepositories", parent: name, max: 3)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, max: 1024)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, min: 1)
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, pattern: "^https://([^/]+)/?(.*)$|^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.instanceMetadataServiceConfiguration?.validate(name: "\(name).instanceMetadataServiceConfiguration")
            try self.validate(self.lifecycleConfigName, name: "lifecycleConfigName", parent: name, max: 63)
            try self.validate(self.lifecycleConfigName, name: "lifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, max: 63)
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, max: 16384)
            try self.validate(self.volumeSizeInGB, name: "volumeSizeInGB", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case defaultCodeRepository = "DefaultCodeRepository"
            case disassociateAcceleratorTypes = "DisassociateAcceleratorTypes"
            case disassociateAdditionalCodeRepositories = "DisassociateAdditionalCodeRepositories"
            case disassociateDefaultCodeRepository = "DisassociateDefaultCodeRepository"
            case disassociateLifecycleConfig = "DisassociateLifecycleConfig"
            case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
            case instanceType = "InstanceType"
            case lifecycleConfigName = "LifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case roleArn = "RoleArn"
            case rootAccess = "RootAccess"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct UpdateNotebookInstanceLifecycleConfigInput: AWSEncodableShape {
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String
        /// The shell script that runs only once, when you create a notebook instance. The shell script must be a base64-encoded string.
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// The shell script that runs every time you start a notebook instance, including when you create the notebook instance. The shell script must be a base64-encoded string.
        public let onStart: [NotebookInstanceLifecycleHook]?

        public init(notebookInstanceLifecycleConfigName: String, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.onCreate = onCreate
            self.onStart = onStart
        }

        public func validate(name: String) throws {
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, max: 63)
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.onCreate?.forEach {
                try $0.validate(name: "\(name).onCreate[]")
            }
            try self.validate(self.onCreate, name: "onCreate", parent: name, max: 1)
            try self.onStart?.forEach {
                try $0.validate(name: "\(name).onStart[]")
            }
            try self.validate(self.onStart, name: "onStart", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case onCreate = "OnCreate"
            case onStart = "OnStart"
        }
    }

    public struct UpdateNotebookInstanceLifecycleConfigOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateNotebookInstanceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePipelineExecutionRequest: AWSEncodableShape {
        /// This configuration, if specified, overrides the parallelism configuration  of the parent pipeline for this specific run.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The Amazon Resource Name (ARN) of the pipeline execution.
        public let pipelineExecutionArn: String
        /// The description of the pipeline execution.
        public let pipelineExecutionDescription: String?
        /// The display name of the pipeline execution.
        public let pipelineExecutionDisplayName: String?

        public init(parallelismConfiguration: ParallelismConfiguration? = nil, pipelineExecutionArn: String, pipelineExecutionDescription: String? = nil, pipelineExecutionDisplayName: String? = nil) {
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineExecutionArn = pipelineExecutionArn
            self.pipelineExecutionDescription = pipelineExecutionDescription
            self.pipelineExecutionDisplayName = pipelineExecutionDisplayName
        }

        public func validate(name: String) throws {
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, max: 256)
            try self.validate(self.pipelineExecutionArn, name: "pipelineExecutionArn", parent: name, pattern: "^arn:aws[a-z\\-]*:sagemaker:[a-z0-9\\-]*:[0-9]{12}:pipeline\\/.*\\/execution\\/.*$")
            try self.validate(self.pipelineExecutionDescription, name: "pipelineExecutionDescription", parent: name, max: 3072)
            try self.validate(self.pipelineExecutionDescription, name: "pipelineExecutionDescription", parent: name, pattern: ".*")
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, max: 82)
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, min: 1)
            try self.validate(self.pipelineExecutionDisplayName, name: "pipelineExecutionDisplayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,81}$")
        }

        private enum CodingKeys: String, CodingKey {
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineExecutionArn = "PipelineExecutionArn"
            case pipelineExecutionDescription = "PipelineExecutionDescription"
            case pipelineExecutionDisplayName = "PipelineExecutionDisplayName"
        }
    }

    public struct UpdatePipelineExecutionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated pipeline execution.
        public let pipelineExecutionArn: String?

        public init(pipelineExecutionArn: String? = nil) {
            self.pipelineExecutionArn = pipelineExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionArn = "PipelineExecutionArn"
        }
    }

    public struct UpdatePipelineRequest: AWSEncodableShape {
        /// If specified, it applies to all executions of this pipeline by default.
        public let parallelismConfiguration: ParallelismConfiguration?
        /// The JSON pipeline definition.
        public let pipelineDefinition: String?
        /// The location of the pipeline definition stored in Amazon S3. If specified,  SageMaker will retrieve the pipeline definition from this location.
        public let pipelineDefinitionS3Location: PipelineDefinitionS3Location?
        /// The description of the pipeline.
        public let pipelineDescription: String?
        /// The display name of the pipeline.
        public let pipelineDisplayName: String?
        /// The name of the pipeline to update.
        public let pipelineName: String
        /// The Amazon Resource Name (ARN) that the pipeline uses to execute.
        public let roleArn: String?

        public init(parallelismConfiguration: ParallelismConfiguration? = nil, pipelineDefinition: String? = nil, pipelineDefinitionS3Location: PipelineDefinitionS3Location? = nil, pipelineDescription: String? = nil, pipelineDisplayName: String? = nil, pipelineName: String, roleArn: String? = nil) {
            self.parallelismConfiguration = parallelismConfiguration
            self.pipelineDefinition = pipelineDefinition
            self.pipelineDefinitionS3Location = pipelineDefinitionS3Location
            self.pipelineDescription = pipelineDescription
            self.pipelineDisplayName = pipelineDisplayName
            self.pipelineName = pipelineName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, max: 1_048_576)
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, min: 1)
            try self.validate(self.pipelineDefinition, name: "pipelineDefinition", parent: name, pattern: "(?:[ \\r\\n\\t].*)*$")
            try self.pipelineDefinitionS3Location?.validate(name: "\(name).pipelineDefinitionS3Location")
            try self.validate(self.pipelineDescription, name: "pipelineDescription", parent: name, max: 3072)
            try self.validate(self.pipelineDescription, name: "pipelineDescription", parent: name, pattern: ".*")
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, max: 256)
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, min: 1)
            try self.validate(self.pipelineDisplayName, name: "pipelineDisplayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 256)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,255}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parallelismConfiguration = "ParallelismConfiguration"
            case pipelineDefinition = "PipelineDefinition"
            case pipelineDefinitionS3Location = "PipelineDefinitionS3Location"
            case pipelineDescription = "PipelineDescription"
            case pipelineDisplayName = "PipelineDisplayName"
            case pipelineName = "PipelineName"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdatePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated pipeline.
        public let pipelineArn: String?

        public init(pipelineArn: String? = nil) {
            self.pipelineArn = pipelineArn
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineArn = "PipelineArn"
        }
    }

    public struct UpdateProjectInput: AWSEncodableShape {
        /// The description for the project.
        public let projectDescription: String?
        /// The name of the project.
        public let projectName: String
        /// The product ID and provisioning artifact ID to provision a service catalog.  The provisioning artifact ID will default to the latest provisioning artifact  ID of the product, if you don't provide the provisioning artifact ID. For more  information, see What is Amazon Web Services Service Catalog.
        public let serviceCatalogProvisioningUpdateDetails: ServiceCatalogProvisioningUpdateDetails?
        /// An array of key-value pairs. You can use tags to categorize your  Amazon Web Services resources in different ways, for example, by purpose, owner, or  environment. For more information, see Tagging Amazon Web Services Resources. In addition, the project must have tag update constraints set in order to include this  parameter in the request.  For more information, see Amazon Web Services Service  Catalog Tag Update Constraints.
        public let tags: [Tag]?

        public init(projectDescription: String? = nil, projectName: String, serviceCatalogProvisioningUpdateDetails: ServiceCatalogProvisioningUpdateDetails? = nil, tags: [Tag]? = nil) {
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.serviceCatalogProvisioningUpdateDetails = serviceCatalogProvisioningUpdateDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 1024)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 32)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,31}$")
            try self.serviceCatalogProvisioningUpdateDetails?.validate(name: "\(name).serviceCatalogProvisioningUpdateDetails")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case projectDescription = "ProjectDescription"
            case projectName = "ProjectName"
            case serviceCatalogProvisioningUpdateDetails = "ServiceCatalogProvisioningUpdateDetails"
            case tags = "Tags"
        }
    }

    public struct UpdateProjectOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String

        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
        }
    }

    public struct UpdateSpaceRequest: AWSEncodableShape {
        /// The ID of the associated Domain.
        public let domainId: String
        /// The name of the space.
        public let spaceName: String
        /// A collection of space settings.
        public let spaceSettings: SpaceSettings?

        public init(domainId: String, spaceName: String, spaceSettings: SpaceSettings? = nil) {
            self.domainId = domainId
            self.spaceName = spaceName
            self.spaceSettings = spaceSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, max: 63)
            try self.validate(self.spaceName, name: "spaceName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.spaceSettings?.validate(name: "\(name).spaceSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case spaceName = "SpaceName"
            case spaceSettings = "SpaceSettings"
        }
    }

    public struct UpdateSpaceResponse: AWSDecodableShape {
        /// The space's Amazon Resource Name (ARN).
        public let spaceArn: String?

        public init(spaceArn: String? = nil) {
            self.spaceArn = spaceArn
        }

        private enum CodingKeys: String, CodingKey {
            case spaceArn = "SpaceArn"
        }
    }

    public struct UpdateTrainingJobRequest: AWSEncodableShape {
        /// Configuration information for Amazon SageMaker Debugger system monitoring, framework profiling, and storage paths.
        public let profilerConfig: ProfilerConfigForUpdate?
        /// Configuration information for Amazon SageMaker Debugger rules for profiling system and framework metrics.
        public let profilerRuleConfigurations: [ProfilerRuleConfiguration]?
        /// The training job ResourceConfig to update warm pool retention length.
        public let resourceConfig: ResourceConfigForUpdate?
        /// The name of a training job to update the Debugger profiling configuration.
        public let trainingJobName: String

        public init(profilerConfig: ProfilerConfigForUpdate? = nil, profilerRuleConfigurations: [ProfilerRuleConfiguration]? = nil, resourceConfig: ResourceConfigForUpdate? = nil, trainingJobName: String) {
            self.profilerConfig = profilerConfig
            self.profilerRuleConfigurations = profilerRuleConfigurations
            self.resourceConfig = resourceConfig
            self.trainingJobName = trainingJobName
        }

        public func validate(name: String) throws {
            try self.profilerConfig?.validate(name: "\(name).profilerConfig")
            try self.profilerRuleConfigurations?.forEach {
                try $0.validate(name: "\(name).profilerRuleConfigurations[]")
            }
            try self.validate(self.profilerRuleConfigurations, name: "profilerRuleConfigurations", parent: name, max: 20)
            try self.resourceConfig?.validate(name: "\(name).resourceConfig")
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, max: 63)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, min: 1)
            try self.validate(self.trainingJobName, name: "trainingJobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case profilerConfig = "ProfilerConfig"
            case profilerRuleConfigurations = "ProfilerRuleConfigurations"
            case resourceConfig = "ResourceConfig"
            case trainingJobName = "TrainingJobName"
        }
    }

    public struct UpdateTrainingJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String

        public init(trainingJobArn: String) {
            self.trainingJobArn = trainingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobArn = "TrainingJobArn"
        }
    }

    public struct UpdateTrialComponentRequest: AWSEncodableShape {
        /// The name of the component as displayed. The name doesn't need to be unique. If DisplayName isn't specified, TrialComponentName is displayed.
        public let displayName: String?
        /// When the component ended.
        public let endTime: Date?
        /// Replaces all of the component's input artifacts with the specified artifacts.
        public let inputArtifacts: [String: TrialComponentArtifact]?
        /// The input artifacts to remove from the component.
        public let inputArtifactsToRemove: [String]?
        /// Replaces all of the component's output artifacts with the specified artifacts.
        public let outputArtifacts: [String: TrialComponentArtifact]?
        /// The output artifacts to remove from the component.
        public let outputArtifactsToRemove: [String]?
        /// Replaces all of the component's hyperparameters with the specified hyperparameters.
        public let parameters: [String: TrialComponentParameterValue]?
        /// The hyperparameters to remove from the component.
        public let parametersToRemove: [String]?
        /// When the component started.
        public let startTime: Date?
        /// The new status of the component.
        public let status: TrialComponentStatus?
        /// The name of the component to update.
        public let trialComponentName: String

        public init(displayName: String? = nil, endTime: Date? = nil, inputArtifacts: [String: TrialComponentArtifact]? = nil, inputArtifactsToRemove: [String]? = nil, outputArtifacts: [String: TrialComponentArtifact]? = nil, outputArtifactsToRemove: [String]? = nil, parameters: [String: TrialComponentParameterValue]? = nil, parametersToRemove: [String]? = nil, startTime: Date? = nil, status: TrialComponentStatus? = nil, trialComponentName: String) {
            self.displayName = displayName
            self.endTime = endTime
            self.inputArtifacts = inputArtifacts
            self.inputArtifactsToRemove = inputArtifactsToRemove
            self.outputArtifacts = outputArtifacts
            self.outputArtifactsToRemove = outputArtifactsToRemove
            self.parameters = parameters
            self.parametersToRemove = parametersToRemove
            self.startTime = startTime
            self.status = status
            self.trialComponentName = trialComponentName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.inputArtifacts?.forEach {
                try validate($0.key, name: "inputArtifacts.key", parent: name, max: 64)
                try validate($0.key, name: "inputArtifacts.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).inputArtifacts[\"\($0.key)\"]")
            }
            try self.validate(self.inputArtifacts, name: "inputArtifacts", parent: name, max: 30)
            try self.inputArtifactsToRemove?.forEach {
                try validate($0, name: "inputArtifactsToRemove[]", parent: name, max: 256)
                try validate($0, name: "inputArtifactsToRemove[]", parent: name, pattern: ".*")
            }
            try self.outputArtifacts?.forEach {
                try validate($0.key, name: "outputArtifacts.key", parent: name, max: 64)
                try validate($0.key, name: "outputArtifacts.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).outputArtifacts[\"\($0.key)\"]")
            }
            try self.validate(self.outputArtifacts, name: "outputArtifacts", parent: name, max: 30)
            try self.outputArtifactsToRemove?.forEach {
                try validate($0, name: "outputArtifactsToRemove[]", parent: name, max: 256)
                try validate($0, name: "outputArtifactsToRemove[]", parent: name, pattern: ".*")
            }
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 256)
                try validate($0.key, name: "parameters.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 150)
            try self.parametersToRemove?.forEach {
                try validate($0, name: "parametersToRemove[]", parent: name, max: 256)
                try validate($0, name: "parametersToRemove[]", parent: name, pattern: ".*")
            }
            try self.status?.validate(name: "\(name).status")
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, max: 120)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, min: 1)
            try self.validate(self.trialComponentName, name: "trialComponentName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case endTime = "EndTime"
            case inputArtifacts = "InputArtifacts"
            case inputArtifactsToRemove = "InputArtifactsToRemove"
            case outputArtifacts = "OutputArtifacts"
            case outputArtifactsToRemove = "OutputArtifactsToRemove"
            case parameters = "Parameters"
            case parametersToRemove = "ParametersToRemove"
            case startTime = "StartTime"
            case status = "Status"
            case trialComponentName = "TrialComponentName"
        }
    }

    public struct UpdateTrialComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial component.
        public let trialComponentArn: String?

        public init(trialComponentArn: String? = nil) {
            self.trialComponentArn = trialComponentArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialComponentArn = "TrialComponentArn"
        }
    }

    public struct UpdateTrialRequest: AWSEncodableShape {
        /// The name of the trial as displayed. The name doesn't need to be unique. If DisplayName isn't specified, TrialName is displayed.
        public let displayName: String?
        /// The name of the trial to update.
        public let trialName: String

        public init(displayName: String? = nil, trialName: String) {
            self.displayName = displayName
            self.trialName = trialName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 120)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
            try self.validate(self.trialName, name: "trialName", parent: name, max: 120)
            try self.validate(self.trialName, name: "trialName", parent: name, min: 1)
            try self.validate(self.trialName, name: "trialName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,119}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case trialName = "TrialName"
        }
    }

    public struct UpdateTrialResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the trial.
        public let trialArn: String?

        public init(trialArn: String? = nil) {
            self.trialArn = trialArn
        }

        private enum CodingKeys: String, CodingKey {
            case trialArn = "TrialArn"
        }
    }

    public struct UpdateUserProfileRequest: AWSEncodableShape {
        /// The domain ID.
        public let domainId: String
        /// The user profile name.
        public let userProfileName: String
        /// A collection of settings.
        public let userSettings: UserSettings?

        public init(domainId: String, userProfileName: String, userSettings: UserSettings? = nil) {
            self.domainId = domainId
            self.userProfileName = userProfileName
            self.userSettings = userSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, max: 63)
            try self.validate(self.userProfileName, name: "userProfileName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
            try self.userSettings?.validate(name: "\(name).userSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case userProfileName = "UserProfileName"
            case userSettings = "UserSettings"
        }
    }

    public struct UpdateUserProfileResponse: AWSDecodableShape {
        /// The user profile Amazon Resource Name (ARN).
        public let userProfileArn: String?

        public init(userProfileArn: String? = nil) {
            self.userProfileArn = userProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case userProfileArn = "UserProfileArn"
        }
    }

    public struct UpdateWorkforceRequest: AWSEncodableShape {
        /// Use this parameter to update your OIDC Identity Provider (IdP)  configuration for a workforce made using your own IdP.
        public let oidcConfig: OidcConfig?
        /// A list of one to ten worker IP address ranges (CIDRs) that can be used to access tasks assigned to this workforce. Maximum: Ten CIDR values
        public let sourceIpConfig: SourceIpConfig?
        /// The name of the private workforce that you want to update. You can find your workforce name by using the  operation.
        public let workforceName: String
        /// Use this parameter to update your VPC configuration for a workforce.
        public let workforceVpcConfig: WorkforceVpcConfigRequest?

        public init(oidcConfig: OidcConfig? = nil, sourceIpConfig: SourceIpConfig? = nil, workforceName: String, workforceVpcConfig: WorkforceVpcConfigRequest? = nil) {
            self.oidcConfig = oidcConfig
            self.sourceIpConfig = sourceIpConfig
            self.workforceName = workforceName
            self.workforceVpcConfig = workforceVpcConfig
        }

        public func validate(name: String) throws {
            try self.oidcConfig?.validate(name: "\(name).oidcConfig")
            try self.sourceIpConfig?.validate(name: "\(name).sourceIpConfig")
            try self.validate(self.workforceName, name: "workforceName", parent: name, max: 63)
            try self.validate(self.workforceName, name: "workforceName", parent: name, min: 1)
            try self.validate(self.workforceName, name: "workforceName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9\\-]){0,62}$")
            try self.workforceVpcConfig?.validate(name: "\(name).workforceVpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case oidcConfig = "OidcConfig"
            case sourceIpConfig = "SourceIpConfig"
            case workforceName = "WorkforceName"
            case workforceVpcConfig = "WorkforceVpcConfig"
        }
    }

    public struct UpdateWorkforceResponse: AWSDecodableShape {
        /// A single private workforce. You can create one private work force in each Amazon Web Services Region. By default, any workforce-related API operation used in a specific region will apply to the workforce created in that region. To learn how to create a private workforce, see Create a Private Workforce.
        public let workforce: Workforce

        public init(workforce: Workforce) {
            self.workforce = workforce
        }

        private enum CodingKeys: String, CodingKey {
            case workforce = "Workforce"
        }
    }

    public struct UpdateWorkteamRequest: AWSEncodableShape {
        /// An updated description for the work team.
        public let description: String?
        /// A list of MemberDefinition objects that contains objects that identify the workers that make up the work team.  Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP).  For private workforces created using Amazon Cognito use CognitoMemberDefinition. For workforces created using your own OIDC identity provider (IdP) use OidcMemberDefinition. You should not provide input for both of these parameters in a single request. For workforces created using Amazon Cognito, private work teams correspond to Amazon Cognito user groups within the user pool used to create a workforce. All of the CognitoMemberDefinition objects that make up the member definition must have the same ClientId and UserPool values. To add a Amazon Cognito user group to an existing worker pool, see Adding groups to a User Pool. For more information about user pools, see Amazon Cognito User Pools. For workforces created using your own OIDC IdP, specify the user groups that you want to include in your private work team in OidcMemberDefinition by listing those groups in Groups. Be aware that user groups that are already in the work team must also be listed in Groups when you make this request to remain on the work team. If you do not include these user groups, they will no longer be associated with the work team you update.
        public let memberDefinitions: [MemberDefinition]?
        /// Configures SNS topic notifications for available or expiring work items
        public let notificationConfiguration: NotificationConfiguration?
        /// The name of the work team to update.
        public let workteamName: String

        public init(description: String? = nil, memberDefinitions: [MemberDefinition]? = nil, notificationConfiguration: NotificationConfiguration? = nil, workteamName: String) {
            self.description = description
            self.memberDefinitions = memberDefinitions
            self.notificationConfiguration = notificationConfiguration
            self.workteamName = workteamName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.memberDefinitions?.forEach {
                try $0.validate(name: "\(name).memberDefinitions[]")
            }
            try self.validate(self.memberDefinitions, name: "memberDefinitions", parent: name, max: 10)
            try self.validate(self.memberDefinitions, name: "memberDefinitions", parent: name, min: 1)
            try self.notificationConfiguration?.validate(name: "\(name).notificationConfiguration")
            try self.validate(self.workteamName, name: "workteamName", parent: name, max: 63)
            try self.validate(self.workteamName, name: "workteamName", parent: name, min: 1)
            try self.validate(self.workteamName, name: "workteamName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case memberDefinitions = "MemberDefinitions"
            case notificationConfiguration = "NotificationConfiguration"
            case workteamName = "WorkteamName"
        }
    }

    public struct UpdateWorkteamResponse: AWSDecodableShape {
        /// A Workteam object that describes the updated work team.
        public let workteam: Workteam

        public init(workteam: Workteam) {
            self.workteam = workteam
        }

        private enum CodingKeys: String, CodingKey {
            case workteam = "Workteam"
        }
    }

    public struct UserContext: AWSDecodableShape {
        /// The domain associated with the user.
        public let domainId: String?
        /// The Amazon Resource Name (ARN) of the user's profile.
        public let userProfileArn: String?
        /// The name of the user's profile.
        public let userProfileName: String?

        public init(domainId: String? = nil, userProfileArn: String? = nil, userProfileName: String? = nil) {
            self.domainId = domainId
            self.userProfileArn = userProfileArn
            self.userProfileName = userProfileName
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "DomainId"
            case userProfileArn = "UserProfileArn"
            case userProfileName = "UserProfileName"
        }
    }

    public struct UserProfileDetails: AWSDecodableShape {
        /// The creation time.
        public let creationTime: Date?
        /// The domain ID.
        public let domainId: String?
        /// The last modified time.
        public let lastModifiedTime: Date?
        /// The status.
        public let status: UserProfileStatus?
        /// The user profile name.
        public let userProfileName: String?

        public init(creationTime: Date? = nil, domainId: String? = nil, lastModifiedTime: Date? = nil, status: UserProfileStatus? = nil, userProfileName: String? = nil) {
            self.creationTime = creationTime
            self.domainId = domainId
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.userProfileName = userProfileName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case domainId = "DomainId"
            case lastModifiedTime = "LastModifiedTime"
            case status = "Status"
            case userProfileName = "UserProfileName"
        }
    }

    public struct UserSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Canvas app settings.
        public let canvasAppSettings: CanvasAppSettings?
        /// The execution role for the user.
        public let executionRole: String?
        /// The Jupyter server's app settings.
        public let jupyterServerAppSettings: JupyterServerAppSettings?
        /// The kernel gateway app settings.
        public let kernelGatewayAppSettings: KernelGatewayAppSettings?
        /// A collection of settings that configure the RSessionGateway app.
        public let rSessionAppSettings: RSessionAppSettings?
        /// A collection of settings that configure user interaction with the RStudioServerPro app.
        public let rStudioServerProAppSettings: RStudioServerProAppSettings?
        /// The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication. Optional when the CreateDomain.AppNetworkAccessType parameter is set to PublicInternetOnly. Required when the CreateDomain.AppNetworkAccessType parameter is set to VpcOnly. Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the number of security groups that you can specify is one less than the maximum number shown.
        public let securityGroups: [String]?
        /// Specifies options for sharing SageMaker Studio notebooks.
        public let sharingSettings: SharingSettings?
        /// The TensorBoard app settings.
        public let tensorBoardAppSettings: TensorBoardAppSettings?

        public init(canvasAppSettings: CanvasAppSettings? = nil, executionRole: String? = nil, jupyterServerAppSettings: JupyterServerAppSettings? = nil, kernelGatewayAppSettings: KernelGatewayAppSettings? = nil, rSessionAppSettings: RSessionAppSettings? = nil, rStudioServerProAppSettings: RStudioServerProAppSettings? = nil, securityGroups: [String]? = nil, sharingSettings: SharingSettings? = nil, tensorBoardAppSettings: TensorBoardAppSettings? = nil) {
            self.canvasAppSettings = canvasAppSettings
            self.executionRole = executionRole
            self.jupyterServerAppSettings = jupyterServerAppSettings
            self.kernelGatewayAppSettings = kernelGatewayAppSettings
            self.rSessionAppSettings = rSessionAppSettings
            self.rStudioServerProAppSettings = rStudioServerProAppSettings
            self.securityGroups = securityGroups
            self.sharingSettings = sharingSettings
            self.tensorBoardAppSettings = tensorBoardAppSettings
        }

        public func validate(name: String) throws {
            try self.canvasAppSettings?.validate(name: "\(name).canvasAppSettings")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 20)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.jupyterServerAppSettings?.validate(name: "\(name).jupyterServerAppSettings")
            try self.kernelGatewayAppSettings?.validate(name: "\(name).kernelGatewayAppSettings")
            try self.rSessionAppSettings?.validate(name: "\(name).rSessionAppSettings")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 32)
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 5)
            try self.sharingSettings?.validate(name: "\(name).sharingSettings")
            try self.tensorBoardAppSettings?.validate(name: "\(name).tensorBoardAppSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case canvasAppSettings = "CanvasAppSettings"
            case executionRole = "ExecutionRole"
            case jupyterServerAppSettings = "JupyterServerAppSettings"
            case kernelGatewayAppSettings = "KernelGatewayAppSettings"
            case rSessionAppSettings = "RSessionAppSettings"
            case rStudioServerProAppSettings = "RStudioServerProAppSettings"
            case securityGroups = "SecurityGroups"
            case sharingSettings = "SharingSettings"
            case tensorBoardAppSettings = "TensorBoardAppSettings"
        }
    }

    public struct VariantProperty: AWSEncodableShape {
        /// The type of variant property. The supported values are:    DesiredInstanceCount: Overrides the existing variant instance counts using the ProductionVariant$InitialInstanceCount values in the CreateEndpointConfigInput$ProductionVariants.    DesiredWeight: Overrides the existing variant weights using the ProductionVariant$InitialVariantWeight values in the CreateEndpointConfigInput$ProductionVariants.    DataCaptureConfig: (Not currently supported.)
        public let variantPropertyType: VariantPropertyType

        public init(variantPropertyType: VariantPropertyType) {
            self.variantPropertyType = variantPropertyType
        }

        private enum CodingKeys: String, CodingKey {
            case variantPropertyType = "VariantPropertyType"
        }
    }

    public struct Vertex: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the lineage entity resource.
        public let arn: String?
        /// The type of resource of the lineage entity.
        public let lineageType: LineageType?
        /// The type of the lineage entity resource. For example: DataSet, Model, Endpoint,  etc...
        public let type: String?

        public init(arn: String? = nil, lineageType: LineageType? = nil, type: String? = nil) {
            self.arn = arn
            self.lineageType = lineageType
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case lineageType = "LineageType"
            case type = "Type"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        public let securityGroupIds: [String]
        /// The ID of the subnets in the VPC to which you want to connect your training job or model. For information about the availability of specific instance types, see Supported Instance Types and Availability Zones.
        public let subnets: [String]

        public init(securityGroupIds: [String], subnets: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 32)
                try validate($0, name: "subnets[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
        }
    }

    public struct WarmPoolStatus: AWSDecodableShape {
        /// The billable time in seconds used by the warm pool. Billable time refers to the absolute wall-clock time. Multiply ResourceRetainedBillableTimeInSeconds by the number of instances (InstanceCount) in your training cluster to get the total compute time SageMaker bills you if you run warm pool training. The formula is as follows: ResourceRetainedBillableTimeInSeconds * InstanceCount.
        public let resourceRetainedBillableTimeInSeconds: Int?
        /// The name of the matching training job that reused the warm pool.
        public let reusedByJob: String?
        /// The status of the warm pool.    InUse: The warm pool is in use for the training job.    Available: The warm pool is available to reuse for a matching training job.    Reused: The warm pool moved to a matching training job for reuse.    Terminated: The warm pool is no longer available. Warm pools are unavailable if they are terminated by a user, terminated for a patch update, or terminated for exceeding the specified KeepAlivePeriodInSeconds.
        public let status: WarmPoolResourceStatus

        public init(resourceRetainedBillableTimeInSeconds: Int? = nil, reusedByJob: String? = nil, status: WarmPoolResourceStatus) {
            self.resourceRetainedBillableTimeInSeconds = resourceRetainedBillableTimeInSeconds
            self.reusedByJob = reusedByJob
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case resourceRetainedBillableTimeInSeconds = "ResourceRetainedBillableTimeInSeconds"
            case reusedByJob = "ReusedByJob"
            case status = "Status"
        }
    }

    public struct Workforce: AWSDecodableShape {
        /// The configuration of an Amazon Cognito workforce.  A single Cognito workforce is created using and corresponds to a single  Amazon Cognito user pool.
        public let cognitoConfig: CognitoConfig?
        /// The date that the workforce is created.
        public let createDate: Date?
        /// The reason your workforce failed.
        public let failureReason: String?
        /// The most recent date that  was used to successfully add one or more IP address ranges (CIDRs) to a private workforce's allow list.
        public let lastUpdatedDate: Date?
        /// The configuration of an OIDC Identity Provider (IdP) private workforce.
        public let oidcConfig: OidcConfigForResponse?
        /// A list of one to ten IP address ranges (CIDRs) to be added to the workforce allow list. By default, a workforce isn't restricted to specific IP addresses.
        public let sourceIpConfig: SourceIpConfig?
        /// The status of your workforce.
        public let status: WorkforceStatus?
        /// The subdomain for your OIDC Identity Provider.
        public let subDomain: String?
        /// The Amazon Resource Name (ARN) of the private workforce.
        public let workforceArn: String
        /// The name of the private workforce.
        public let workforceName: String
        /// The configuration of a VPC workforce.
        public let workforceVpcConfig: WorkforceVpcConfigResponse?

        public init(cognitoConfig: CognitoConfig? = nil, createDate: Date? = nil, failureReason: String? = nil, lastUpdatedDate: Date? = nil, oidcConfig: OidcConfigForResponse? = nil, sourceIpConfig: SourceIpConfig? = nil, status: WorkforceStatus? = nil, subDomain: String? = nil, workforceArn: String, workforceName: String, workforceVpcConfig: WorkforceVpcConfigResponse? = nil) {
            self.cognitoConfig = cognitoConfig
            self.createDate = createDate
            self.failureReason = failureReason
            self.lastUpdatedDate = lastUpdatedDate
            self.oidcConfig = oidcConfig
            self.sourceIpConfig = sourceIpConfig
            self.status = status
            self.subDomain = subDomain
            self.workforceArn = workforceArn
            self.workforceName = workforceName
            self.workforceVpcConfig = workforceVpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case cognitoConfig = "CognitoConfig"
            case createDate = "CreateDate"
            case failureReason = "FailureReason"
            case lastUpdatedDate = "LastUpdatedDate"
            case oidcConfig = "OidcConfig"
            case sourceIpConfig = "SourceIpConfig"
            case status = "Status"
            case subDomain = "SubDomain"
            case workforceArn = "WorkforceArn"
            case workforceName = "WorkforceName"
            case workforceVpcConfig = "WorkforceVpcConfig"
        }
    }

    public struct WorkforceVpcConfigRequest: AWSEncodableShape {
        /// The VPC security group IDs, in the form sg-xxxxxxxx. The security groups must be for the same VPC as specified in the subnet.
        public let securityGroupIds: [String]?
        /// The ID of the subnets in the VPC that you want to connect.
        public let subnets: [String]?
        /// The ID of the VPC that the workforce uses for communication.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]*$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 32)
                try validate($0, name: "subnets[]", parent: name, pattern: "^subnet-[0-9a-z]*$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 32)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct WorkforceVpcConfigResponse: AWSDecodableShape {
        /// The VPC security group IDs, in the form sg-xxxxxxxx. The security groups must be for the same VPC as specified in the subnet.
        public let securityGroupIds: [String]
        /// The ID of the subnets in the VPC that you want to connect.
        public let subnets: [String]
        /// The IDs for the VPC service endpoints of your VPC workforce when it is created and updated.
        public let vpcEndpointId: String?
        /// The ID of the VPC that the workforce uses for communication.
        public let vpcId: String

        public init(securityGroupIds: [String], subnets: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
            case vpcEndpointId = "VpcEndpointId"
            case vpcId = "VpcId"
        }
    }

    public struct Workteam: AWSDecodableShape {
        /// The date and time that the work team was created (timestamp).
        public let createDate: Date?
        /// A description of the work team.
        public let description: String
        /// The date and time that the work team was last updated (timestamp).
        public let lastUpdatedDate: Date?
        /// A list of MemberDefinition objects that contains objects that identify the workers that make up the work team.  Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP).  For private workforces created using Amazon Cognito use CognitoMemberDefinition. For workforces created using your own OIDC identity provider (IdP) use OidcMemberDefinition.
        public let memberDefinitions: [MemberDefinition]
        /// Configures SNS notifications of available or expiring work items for work teams.
        public let notificationConfiguration: NotificationConfiguration?
        /// The Amazon Marketplace identifier for a vendor's work team.
        public let productListingIds: [String]?
        /// The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.
        public let subDomain: String?
        /// The Amazon Resource Name (ARN) of the workforce.
        public let workforceArn: String?
        /// The Amazon Resource Name (ARN) that identifies the work team.
        public let workteamArn: String
        /// The name of the work team.
        public let workteamName: String

        public init(createDate: Date? = nil, description: String, lastUpdatedDate: Date? = nil, memberDefinitions: [MemberDefinition], notificationConfiguration: NotificationConfiguration? = nil, productListingIds: [String]? = nil, subDomain: String? = nil, workforceArn: String? = nil, workteamArn: String, workteamName: String) {
            self.createDate = createDate
            self.description = description
            self.lastUpdatedDate = lastUpdatedDate
            self.memberDefinitions = memberDefinitions
            self.notificationConfiguration = notificationConfiguration
            self.productListingIds = productListingIds
            self.subDomain = subDomain
            self.workforceArn = workforceArn
            self.workteamArn = workteamArn
            self.workteamName = workteamName
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case description = "Description"
            case lastUpdatedDate = "LastUpdatedDate"
            case memberDefinitions = "MemberDefinitions"
            case notificationConfiguration = "NotificationConfiguration"
            case productListingIds = "ProductListingIds"
            case subDomain = "SubDomain"
            case workforceArn = "WorkforceArn"
            case workteamArn = "WorkteamArn"
            case workteamName = "WorkteamName"
        }
    }
}

// MARK: - Errors

/// Error enum for SageMaker
public struct SageMakerErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case resourceInUse = "ResourceInUse"
        case resourceLimitExceeded = "ResourceLimitExceeded"
        case resourceNotFound = "ResourceNotFound"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SageMaker
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// There was a conflict when you attempted to modify a SageMaker entity such as an Experiment or Artifact.
    public static var conflictException: Self { .init(.conflictException) }
    /// Resource being accessed is in use.
    public static var resourceInUse: Self { .init(.resourceInUse) }
    ///  You have exceeded an SageMaker resource limit. For example, you might have too many training jobs created.
    public static var resourceLimitExceeded: Self { .init(.resourceLimitExceeded) }
    /// Resource being access is not found.
    public static var resourceNotFound: Self { .init(.resourceNotFound) }
}

extension SageMakerErrorType: Equatable {
    public static func == (lhs: SageMakerErrorType, rhs: SageMakerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SageMakerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
