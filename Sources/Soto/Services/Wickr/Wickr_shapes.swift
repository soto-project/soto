//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Wickr {
    // MARK: Enums

    public enum AccessLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case premium = "PREMIUM"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum BotStatus: Int, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The bot is active and operational, able to send and receive messages.
        case active = 2
        /// The bot has been created but is not yet active, pending initial setup or activation.
        case pending = 1
        public var description: String { return "\(self.rawValue)" }
    }

    public enum DataRetentionActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        case pubkeyMsgAck = "PUBKEY_MSG_ACK"
        public var description: String { return self.rawValue }
    }

    public enum SortDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case forceEnabled = "FORCE_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum UserStatus: Int, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The user has accepted their invitation and is active in the network.
        case active = 2
        /// The user has been invited to the network but has not yet accepted their invitation.
        case pending = 1
        public var description: String { return "\(self.rawValue)" }
    }

    // MARK: Shapes

    public struct BasicDeviceObject: AWSDecodableShape {
        /// The unique application ID for the Wickr app on this device.
        public let appId: String?
        /// The timestamp when the device first appeared in the Wickr database.
        public let created: String?
        /// The timestamp when the device last successfully logged into Wickr. This is also used to determine SSO idle time.
        public let lastLogin: String?
        /// The current status of the device, either 'Active' or 'Reset' depending on whether the device is currently active or has been marked for reset.
        public let statusText: String?
        /// Indicates whether the device is suspended.
        public let suspend: Bool?
        /// The operating system of the device (e.g., 'MacOSX', 'Windows', 'iOS', 'Android').
        public let type: String?

        @inlinable
        public init(appId: String? = nil, created: String? = nil, lastLogin: String? = nil, statusText: String? = nil, suspend: Bool? = nil, type: String? = nil) {
            self.appId = appId
            self.created = created
            self.lastLogin = lastLogin
            self.statusText = statusText
            self.suspend = suspend
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case created = "created"
            case lastLogin = "lastLogin"
            case statusText = "statusText"
            case suspend = "suspend"
            case type = "type"
        }
    }

    public struct BatchCreateUserRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without creating duplicate users.
        public let clientToken: String?
        /// The ID of the Wickr network where users will be created.
        public let networkId: String
        /// A list of user objects containing the details for each user to be created, including username, name, security groups, and optional invite codes. Maximum 50 users per batch request.
        public let users: [BatchCreateUserRequestItem]

        @inlinable
        public init(clientToken: String? = BatchCreateUserRequest.idempotencyToken(), networkId: String, users: [BatchCreateUserRequestItem]) {
            self.clientToken = clientToken
            self.networkId = networkId
            self.users = users
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.users, forKey: .users)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.users.forEach {
                try $0.validate(name: "\(name).users[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case users = "users"
        }
    }

    public struct BatchCreateUserRequestItem: AWSEncodableShape {
        /// Indicates whether the user can be verified through a custom invite code.
        public let codeValidation: Bool?
        /// The first name of the user.
        public let firstName: String?
        /// A custom invite code for the user. If not provided, one will be generated automatically.
        public let inviteCode: String?
        /// The time-to-live for the invite code in days. After this period, the invite code will expire.
        public let inviteCodeTtl: Int?
        /// The last name of the user.
        public let lastName: String?
        /// A list of security group IDs to which the user should be assigned.
        public let securityGroupIds: [String]
        /// The email address or username for the user. Must be unique within the network.
        public let username: String

        @inlinable
        public init(codeValidation: Bool? = nil, firstName: String? = nil, inviteCode: String? = nil, inviteCodeTtl: Int? = nil, lastName: String? = nil, securityGroupIds: [String], username: String) {
            self.codeValidation = codeValidation
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.inviteCodeTtl = inviteCodeTtl
            self.lastName = lastName
            self.securityGroupIds = securityGroupIds
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.inviteCode, name: "inviteCode", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[\\S\\s]*$")
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeValidation = "codeValidation"
            case firstName = "firstName"
            case inviteCode = "inviteCode"
            case inviteCodeTtl = "inviteCodeTtl"
            case lastName = "lastName"
            case securityGroupIds = "securityGroupIds"
            case username = "username"
        }
    }

    public struct BatchCreateUserResponse: AWSDecodableShape {
        /// A list of user creation attempts that failed, including error details explaining why each user could not be created.
        public let failed: [BatchUserErrorResponseItem]?
        /// A message indicating the overall result of the batch operation.
        public let message: String?
        /// A list of user objects that were successfully created, including their assigned user IDs and invite codes.
        public let successful: [User]?

        @inlinable
        public init(failed: [BatchUserErrorResponseItem]? = nil, message: String? = nil, successful: [User]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchDeleteUserRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without attempting to delete users again.
        public let clientToken: String?
        /// The ID of the Wickr network from which users will be deleted.
        public let networkId: String
        /// A list of user IDs identifying the users to be deleted from the network. Maximum 50 users per batch request.
        public let userIds: [String]

        @inlinable
        public init(clientToken: String? = BatchDeleteUserRequest.idempotencyToken(), networkId: String, userIds: [String]) {
            self.clientToken = clientToken
            self.networkId = networkId
            self.userIds = userIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.userIds, forKey: .userIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.userIds.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 10)
                try validate($0, name: "userIds[]", parent: name, min: 1)
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userIds = "userIds"
        }
    }

    public struct BatchDeleteUserResponse: AWSDecodableShape {
        /// A list of user deletion attempts that failed, including error details explaining why each user could not be deleted.
        public let failed: [BatchUserErrorResponseItem]?
        /// A message indicating the overall result of the batch deletion operation.
        public let message: String?
        /// A list of user IDs that were successfully deleted from the network.
        public let successful: [BatchUserSuccessResponseItem]?

        @inlinable
        public init(failed: [BatchUserErrorResponseItem]? = nil, message: String? = nil, successful: [BatchUserSuccessResponseItem]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchDeviceErrorResponseItem: AWSDecodableShape {
        /// The application ID of the device that failed to be processed.
        public let appId: String
        /// The field that caused the error.
        public let field: String?
        /// A description of why the device operation failed.
        public let reason: String?

        @inlinable
        public init(appId: String, field: String? = nil, reason: String? = nil) {
            self.appId = appId
            self.field = field
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case field = "field"
            case reason = "reason"
        }
    }

    public struct BatchDeviceSuccessResponseItem: AWSDecodableShape {
        /// The application ID of the device that was successfully processed.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct BatchLookupUserUnameRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the Wickr network where the users will be looked up.
        public let networkId: String
        /// A list of username hashes (unames) to look up. Each uname is a unique identifier for a user's username. Maximum 50 unames per batch request.
        public let unames: [String]

        @inlinable
        public init(clientToken: String? = BatchLookupUserUnameRequest.idempotencyToken(), networkId: String, unames: [String]) {
            self.clientToken = clientToken
            self.networkId = networkId
            self.unames = unames
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.unames, forKey: .unames)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.unames.forEach {
                try validate($0, name: "unames[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case unames = "unames"
        }
    }

    public struct BatchLookupUserUnameResponse: AWSDecodableShape {
        /// A list of username hash lookup attempts that failed, including error details explaining why each lookup failed.
        public let failed: [BatchUnameErrorResponseItem]?
        /// A message indicating the overall result of the batch lookup operation.
        public let message: String?
        /// A list of successfully resolved username hashes with their corresponding email addresses.
        public let successful: [BatchUnameSuccessResponseItem]?

        @inlinable
        public init(failed: [BatchUnameErrorResponseItem]? = nil, message: String? = nil, successful: [BatchUnameSuccessResponseItem]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchReinviteUserRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the Wickr network where users will be reinvited.
        public let networkId: String
        /// A list of user IDs identifying the users to be reinvited to the network. Maximum 50 users per batch request.
        public let userIds: [String]

        @inlinable
        public init(clientToken: String? = BatchReinviteUserRequest.idempotencyToken(), networkId: String, userIds: [String]) {
            self.clientToken = clientToken
            self.networkId = networkId
            self.userIds = userIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.userIds, forKey: .userIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.userIds.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 10)
                try validate($0, name: "userIds[]", parent: name, min: 1)
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userIds = "userIds"
        }
    }

    public struct BatchReinviteUserResponse: AWSDecodableShape {
        /// A list of reinvitation attempts that failed, including error details explaining why each user could not be reinvited.
        public let failed: [BatchUserErrorResponseItem]?
        /// A message indicating the overall result of the batch reinvitation operation.
        public let message: String?
        /// A list of user IDs that were successfully reinvited.
        public let successful: [BatchUserSuccessResponseItem]?

        @inlinable
        public init(failed: [BatchUserErrorResponseItem]? = nil, message: String? = nil, successful: [BatchUserSuccessResponseItem]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchResetDevicesForUserRequest: AWSEncodableShape {
        /// A list of application IDs identifying the specific devices to be reset for the user. Maximum 50 devices per batch request.
        public let appIds: [String]
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the Wickr network containing the user whose devices will be reset.
        public let networkId: String
        /// The ID of the user whose devices will be reset.
        public let userId: String

        @inlinable
        public init(appIds: [String], clientToken: String? = BatchResetDevicesForUserRequest.idempotencyToken(), networkId: String, userId: String) {
            self.appIds = appIds
            self.clientToken = clientToken
            self.networkId = networkId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appIds, forKey: .appIds)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.appIds.forEach {
                try validate($0, name: "appIds[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 10)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case appIds = "appIds"
        }
    }

    public struct BatchResetDevicesForUserResponse: AWSDecodableShape {
        /// A list of device reset attempts that failed, including error details explaining why each device could not be reset.
        public let failed: [BatchDeviceErrorResponseItem]?
        /// A message indicating the overall result of the batch device reset operation.
        public let message: String?
        /// A list of application IDs that were successfully reset.
        public let successful: [BatchDeviceSuccessResponseItem]?

        @inlinable
        public init(failed: [BatchDeviceErrorResponseItem]? = nil, message: String? = nil, successful: [BatchDeviceSuccessResponseItem]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchToggleUserSuspendStatusRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the Wickr network where users will be suspended or unsuspended.
        public let networkId: String
        /// A boolean value indicating whether to suspend (true) or unsuspend (false) the specified users.
        public let suspend: Bool
        /// A list of user IDs identifying the users whose suspend status will be toggled. Maximum 50 users per batch request.
        public let userIds: [String]

        @inlinable
        public init(clientToken: String? = BatchToggleUserSuspendStatusRequest.idempotencyToken(), networkId: String, suspend: Bool, userIds: [String]) {
            self.clientToken = clientToken
            self.networkId = networkId
            self.suspend = suspend
            self.userIds = userIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.suspend, key: "suspend")
            try container.encode(self.userIds, forKey: .userIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.userIds.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 10)
                try validate($0, name: "userIds[]", parent: name, min: 1)
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userIds = "userIds"
        }
    }

    public struct BatchToggleUserSuspendStatusResponse: AWSDecodableShape {
        /// A list of suspend status toggle attempts that failed, including error details explaining why each user's status could not be changed.
        public let failed: [BatchUserErrorResponseItem]?
        /// A message indicating the overall result of the batch suspend status toggle operation.
        public let message: String?
        /// A list of user IDs whose suspend status was successfully toggled.
        public let successful: [BatchUserSuccessResponseItem]?

        @inlinable
        public init(failed: [BatchUserErrorResponseItem]? = nil, message: String? = nil, successful: [BatchUserSuccessResponseItem]? = nil) {
            self.failed = failed
            self.message = message
            self.successful = successful
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case message = "message"
            case successful = "successful"
        }
    }

    public struct BatchUnameErrorResponseItem: AWSDecodableShape {
        /// The field that caused the error.
        public let field: String?
        /// A description of why the username hash lookup failed.
        public let reason: String?
        /// The username hash that failed to be looked up.
        public let uname: String

        @inlinable
        public init(field: String? = nil, reason: String? = nil, uname: String) {
            self.field = field
            self.reason = reason
            self.uname = uname
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case reason = "reason"
            case uname = "uname"
        }
    }

    public struct BatchUnameSuccessResponseItem: AWSDecodableShape {
        /// The username hash that was successfully resolved.
        public let uname: String
        /// The email address or username corresponding to the username hash.
        public let username: String

        @inlinable
        public init(uname: String, username: String) {
            self.uname = uname
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case uname = "uname"
            case username = "username"
        }
    }

    public struct BatchUserErrorResponseItem: AWSDecodableShape {
        /// The field that caused the error.
        public let field: String?
        /// A description of why the user operation failed.
        public let reason: String?
        /// The user ID associated with the failed operation.
        public let userId: String

        @inlinable
        public init(field: String? = nil, reason: String? = nil, userId: String) {
            self.field = field
            self.reason = reason
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case reason = "reason"
            case userId = "userId"
        }
    }

    public struct BatchUserSuccessResponseItem: AWSDecodableShape {
        /// The user ID that was successfully processed.
        public let userId: String

        @inlinable
        public init(userId: String) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct BlockedGuestUser: AWSDecodableShape {
        /// The username of the administrator who blocked this guest user.
        public let admin: String
        /// The timestamp when the guest user was blocked or last modified.
        public let modified: String
        /// The username of the blocked guest user.
        public let username: String
        /// The unique username hash identifier for the blocked guest user.
        public let usernameHash: String

        @inlinable
        public init(admin: String, modified: String, username: String, usernameHash: String) {
            self.admin = admin
            self.modified = modified
            self.username = username
            self.usernameHash = usernameHash
        }

        private enum CodingKeys: String, CodingKey {
            case admin = "admin"
            case modified = "modified"
            case username = "username"
            case usernameHash = "usernameHash"
        }
    }

    public struct Bot: AWSDecodableShape {
        /// The unique identifier of the bot.
        public let botId: String?
        /// The display name of the bot that is visible to users.
        public let displayName: String?
        /// The ID of the security group to which the bot belongs.
        public let groupId: String?
        /// Indicates whether the bot has a password set.
        public let hasChallenge: Bool?
        /// The timestamp of the bot's last login.
        public let lastLogin: String?
        /// The public key of the bot used for encryption.
        public let pubkey: String?
        /// The current status of the bot (1 for pending, 2 for active).
        public let status: BotStatus?
        /// Indicates whether the bot is currently suspended.
        public let suspended: Bool?
        /// The unique username hash identifier for the bot.
        public let uname: String?
        /// The username of the bot.
        public let username: String?

        @inlinable
        public init(botId: String? = nil, displayName: String? = nil, groupId: String? = nil, hasChallenge: Bool? = nil, lastLogin: String? = nil, pubkey: String? = nil, status: BotStatus? = nil, suspended: Bool? = nil, uname: String? = nil, username: String? = nil) {
            self.botId = botId
            self.displayName = displayName
            self.groupId = groupId
            self.hasChallenge = hasChallenge
            self.lastLogin = lastLogin
            self.pubkey = pubkey
            self.status = status
            self.suspended = suspended
            self.uname = uname
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case displayName = "displayName"
            case groupId = "groupId"
            case hasChallenge = "hasChallenge"
            case lastLogin = "lastLogin"
            case pubkey = "pubkey"
            case status = "status"
            case suspended = "suspended"
            case uname = "uname"
            case username = "username"
        }
    }

    public struct CallingSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether users can start one-to-one calls.
        public let canStart11Call: Bool?
        /// Specifies whether users can make video calls (as opposed to audio-only calls). Valid only when audio call(canStart11Call) is enabled.
        public let canVideoCall: Bool?
        /// When enabled, forces all calls to use TCP protocol instead of UDP for network traversal.
        public let forceTcpCall: Bool?

        @inlinable
        public init(canStart11Call: Bool? = nil, canVideoCall: Bool? = nil, forceTcpCall: Bool? = nil) {
            self.canStart11Call = canStart11Call
            self.canVideoCall = canVideoCall
            self.forceTcpCall = forceTcpCall
        }

        private enum CodingKeys: String, CodingKey {
            case canStart11Call = "canStart11Call"
            case canVideoCall = "canVideoCall"
            case forceTcpCall = "forceTcpCall"
        }
    }

    public struct CreateBotRequest: AWSEncodableShape {
        /// The password for the bot account.
        public let challenge: String
        /// The display name for the bot that will be visible to users in the network.
        public let displayName: String?
        /// The ID of the security group to which the bot will be assigned.
        public let groupId: String
        /// The ID of the Wickr network where the bot will be created.
        public let networkId: String
        /// The username for the bot. This must be unique within the network and follow the network's naming conventions.
        public let username: String

        @inlinable
        public init(challenge: String, displayName: String? = nil, groupId: String, networkId: String, username: String) {
            self.challenge = challenge
            self.displayName = displayName
            self.groupId = groupId
            self.networkId = networkId
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.challenge, forKey: .challenge)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encode(self.groupId, forKey: .groupId)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.username, forKey: .username)
        }

        public func validate(name: String) throws {
            try self.validate(self.challenge, name: "challenge", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case challenge = "challenge"
            case displayName = "displayName"
            case groupId = "groupId"
            case username = "username"
        }
    }

    public struct CreateBotResponse: AWSDecodableShape {
        /// The unique identifier assigned to the newly created bot.
        public let botId: String
        /// The display name of the newly created bot.
        public let displayName: String?
        /// The ID of the security group to which the bot was assigned.
        public let groupId: String?
        /// A message indicating the result of the bot creation operation.
        public let message: String?
        /// The ID of the network where the bot was created.
        public let networkId: String?
        /// The username of the newly created bot.
        public let username: String?

        @inlinable
        public init(botId: String, displayName: String? = nil, groupId: String? = nil, message: String? = nil, networkId: String? = nil, username: String? = nil) {
            self.botId = botId
            self.displayName = displayName
            self.groupId = groupId
            self.message = message
            self.networkId = networkId
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case displayName = "displayName"
            case groupId = "groupId"
            case message = "message"
            case networkId = "networkId"
            case username = "username"
        }
    }

    public struct CreateDataRetentionBotChallengeRequest: AWSEncodableShape {
        /// The ID of the Wickr network containing the data retention bot.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateDataRetentionBotChallengeResponse: AWSDecodableShape {
        /// The newly generated challenge password for the data retention bot.
        public let challenge: String

        @inlinable
        public init(challenge: String) {
            self.challenge = challenge
        }

        private enum CodingKeys: String, CodingKey {
            case challenge = "challenge"
        }
    }

    public struct CreateDataRetentionBotRequest: AWSEncodableShape {
        /// The ID of the Wickr network where the data retention bot will be created.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateDataRetentionBotResponse: AWSDecodableShape {
        /// A message indicating that the data retention bot was successfully provisioned.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct CreateNetworkRequest: AWSEncodableShape {
        /// The access level for the network. Valid values are STANDARD or PREMIUM, which determine the features and capabilities available to network members.
        public let accessLevel: AccessLevel
        /// Specifies whether to enable a premium free trial for the network. It is optional and has a default value as false. When set to true, the network starts with premium features for a limited trial period.
        public let enablePremiumFreeTrial: Bool?
        /// The ARN of the Amazon Web Services KMS customer managed key to use for encrypting sensitive data in the network.
        public let encryptionKeyArn: String?
        /// The name for the new network. Must be between 1 and 20 characters.
        public let networkName: String

        @inlinable
        public init(accessLevel: AccessLevel, enablePremiumFreeTrial: Bool? = nil, encryptionKeyArn: String? = nil, networkName: String) {
            self.accessLevel = accessLevel
            self.enablePremiumFreeTrial = enablePremiumFreeTrial
            self.encryptionKeyArn = encryptionKeyArn
            self.networkName = networkName
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkName, name: "networkName", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLevel = "accessLevel"
            case enablePremiumFreeTrial = "enablePremiumFreeTrial"
            case encryptionKeyArn = "encryptionKeyArn"
            case networkName = "networkName"
        }
    }

    public struct CreateNetworkResponse: AWSDecodableShape {
        /// The ARN of the KMS key being used to encrypt sensitive data in the network.
        public let encryptionKeyArn: String?
        /// The unique identifier assigned to the newly created network.
        public let networkId: String?
        /// The name of the newly created network.
        public let networkName: String?

        @inlinable
        public init(encryptionKeyArn: String? = nil, networkId: String? = nil, networkName: String? = nil) {
            self.encryptionKeyArn = encryptionKeyArn
            self.networkId = networkId
            self.networkName = networkName
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyArn = "encryptionKeyArn"
            case networkId = "networkId"
            case networkName = "networkName"
        }
    }

    public struct CreateSecurityGroupRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The name for the new security group.
        public let name: String
        /// The ID of the Wickr network where the security group will be created.
        public let networkId: String
        /// The configuration settings for the security group, including permissions, federation settings, and feature controls.
        public let securityGroupSettings: SecurityGroupSettingsRequest

        @inlinable
        public init(clientToken: String? = CreateSecurityGroupRequest.idempotencyToken(), name: String, networkId: String, securityGroupSettings: SecurityGroupSettingsRequest) {
            self.clientToken = clientToken
            self.name = name
            self.networkId = networkId
            self.securityGroupSettings = securityGroupSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.securityGroupSettings, forKey: .securityGroupSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.securityGroupSettings.validate(name: "\(name).securityGroupSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case securityGroupSettings = "securityGroupSettings"
        }
    }

    public struct CreateSecurityGroupResponse: AWSDecodableShape {
        /// The details of the newly created security group, including its ID, name, and settings.
        public let securityGroup: SecurityGroup

        @inlinable
        public init(securityGroup: SecurityGroup) {
            self.securityGroup = securityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroup = "securityGroup"
        }
    }

    public struct DeleteBotRequest: AWSEncodableShape {
        /// The unique identifier of the bot to be deleted.
        public let botId: String
        /// The ID of the Wickr network from which the bot will be deleted.
        public let networkId: String

        @inlinable
        public init(botId: String, networkId: String) {
            self.botId = botId
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotResponse: AWSDecodableShape {
        /// A message indicating the result of the bot deletion operation.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteDataRetentionBotRequest: AWSEncodableShape {
        /// The ID of the Wickr network from which the data retention bot will be deleted.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataRetentionBotResponse: AWSDecodableShape {
        /// A message indicating that the data retention bot and all associated data were successfully deleted.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteNetworkRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without attempting to delete the network again.
        public let clientToken: String?
        /// The ID of the Wickr network to delete.
        public let networkId: String

        @inlinable
        public init(clientToken: String? = DeleteNetworkRequest.idempotencyToken(), networkId: String) {
            self.clientToken = clientToken
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNetworkResponse: AWSDecodableShape {
        /// A message indicating that the network deletion has been initiated successfully.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteSecurityGroupRequest: AWSEncodableShape {
        /// The unique identifier of the security group to delete.
        public let groupId: String
        /// The ID of the Wickr network from which the security group will be deleted.
        public let networkId: String

        @inlinable
        public init(groupId: String, networkId: String) {
            self.groupId = groupId
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "groupId")
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSecurityGroupResponse: AWSDecodableShape {
        /// The ID of the security group that was deleted.
        public let groupId: String?
        /// A message indicating the result of the security group deletion operation.
        public let message: String?
        /// The ID of the network from which the security group was deleted.
        public let networkId: String?

        @inlinable
        public init(groupId: String? = nil, message: String? = nil, networkId: String? = nil) {
            self.groupId = groupId
            self.message = message
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
            case message = "message"
            case networkId = "networkId"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The name of the field that contains an error or warning.
        public let field: String?
        /// A detailed description of the error or warning.
        public let reason: String?

        @inlinable
        public init(field: String? = nil, reason: String? = nil) {
            self.field = field
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case reason = "reason"
        }
    }

    public struct GetBotRequest: AWSEncodableShape {
        /// The unique identifier of the bot to retrieve.
        public let botId: String
        /// The ID of the Wickr network containing the bot.
        public let networkId: String

        @inlinable
        public init(botId: String, networkId: String) {
            self.botId = botId
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBotResponse: AWSDecodableShape {
        /// The unique identifier of the bot.
        public let botId: String?
        /// The display name of the bot that is visible to users.
        public let displayName: String?
        /// The ID of the security group to which the bot belongs.
        public let groupId: String?
        /// Indicates whether the bot has a password set.
        public let hasChallenge: Bool?
        /// The timestamp of the bot's last login.
        public let lastLogin: String?
        /// The public key of the bot used for encryption.
        public let pubkey: String?
        /// The current status of the bot (1 for pending, 2 for active).
        public let status: BotStatus?
        /// Indicates whether the bot is currently suspended.
        public let suspended: Bool?
        /// The unique username hash identifier for the bot.
        public let uname: String?
        /// The username of the bot.
        public let username: String?

        @inlinable
        public init(botId: String? = nil, displayName: String? = nil, groupId: String? = nil, hasChallenge: Bool? = nil, lastLogin: String? = nil, pubkey: String? = nil, status: BotStatus? = nil, suspended: Bool? = nil, uname: String? = nil, username: String? = nil) {
            self.botId = botId
            self.displayName = displayName
            self.groupId = groupId
            self.hasChallenge = hasChallenge
            self.lastLogin = lastLogin
            self.pubkey = pubkey
            self.status = status
            self.suspended = suspended
            self.uname = uname
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case displayName = "displayName"
            case groupId = "groupId"
            case hasChallenge = "hasChallenge"
            case lastLogin = "lastLogin"
            case pubkey = "pubkey"
            case status = "status"
            case suspended = "suspended"
            case uname = "uname"
            case username = "username"
        }
    }

    public struct GetBotsCountRequest: AWSEncodableShape {
        /// The ID of the Wickr network for which to retrieve bot counts.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBotsCountResponse: AWSDecodableShape {
        /// The number of bots with active status.
        public let active: Int
        /// The number of bots with pending status (invited but not yet activated).
        public let pending: Int
        /// The total number of bots in the network (active and pending).
        public let total: Int

        @inlinable
        public init(active: Int, pending: Int, total: Int) {
            self.active = active
            self.pending = pending
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case pending = "pending"
            case total = "total"
        }
    }

    public struct GetDataRetentionBotRequest: AWSEncodableShape {
        /// The ID of the Wickr network containing the data retention bot.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataRetentionBotResponse: AWSDecodableShape {
        /// Indicates whether a data retention bot exists in the network.
        public let botExists: Bool?
        /// The name of the data retention bot.
        public let botName: String?
        /// Indicates whether the data retention bot is active and operational.
        public let isBotActive: Bool?
        /// Indicates whether the data retention bot has been registered with the network.
        public let isDataRetentionBotRegistered: Bool?
        /// Indicates whether the data retention service is enabled for the network.
        public let isDataRetentionServiceEnabled: Bool?
        /// Indicates whether the public key message has been acknowledged by the bot.
        public let isPubkeyMsgAcked: Bool?

        @inlinable
        public init(botExists: Bool? = nil, botName: String? = nil, isBotActive: Bool? = nil, isDataRetentionBotRegistered: Bool? = nil, isDataRetentionServiceEnabled: Bool? = nil, isPubkeyMsgAcked: Bool? = nil) {
            self.botExists = botExists
            self.botName = botName
            self.isBotActive = isBotActive
            self.isDataRetentionBotRegistered = isDataRetentionBotRegistered
            self.isDataRetentionServiceEnabled = isDataRetentionServiceEnabled
            self.isPubkeyMsgAcked = isPubkeyMsgAcked
        }

        private enum CodingKeys: String, CodingKey {
            case botExists = "botExists"
            case botName = "botName"
            case isBotActive = "isBotActive"
            case isDataRetentionBotRegistered = "isDataRetentionBotRegistered"
            case isDataRetentionServiceEnabled = "isDataRetentionServiceEnabled"
            case isPubkeyMsgAcked = "isPubkeyMsgAcked"
        }
    }

    public struct GetGuestUserHistoryCountRequest: AWSEncodableShape {
        /// The ID of the Wickr network for which to retrieve guest user history.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGuestUserHistoryCountResponse: AWSDecodableShape {
        /// A list of historical guest user counts, organized by month and billing period.
        public let history: [GuestUserHistoryCount]

        @inlinable
        public init(history: [GuestUserHistoryCount]) {
            self.history = history
        }

        private enum CodingKeys: String, CodingKey {
            case history = "history"
        }
    }

    public struct GetNetworkRequest: AWSEncodableShape {
        /// The ID of the Wickr network to retrieve.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResponse: AWSDecodableShape {
        /// The access level of the network (STANDARD or PREMIUM), which determines available features and capabilities.
        public let accessLevel: AccessLevel
        /// The Amazon Web Services account ID that owns the network.
        public let awsAccountId: String
        /// The ARN of the Amazon Web Services KMS customer managed key used for encrypting sensitive data in the network.
        public let encryptionKeyArn: String?
        /// The expiration date and time for the network's free trial period, if applicable.
        public let freeTrialExpiration: String?
        /// The SSO redirect URI migration state, managed by the SSO redirect migration wizard. Values: 0 (not started), 1 (in progress), or 2 (completed).
        public let migrationState: Int?
        /// The Amazon Resource Name (ARN) of the network.
        public let networkArn: String
        /// The unique identifier of the network.
        public let networkId: String
        /// The name of the network.
        public let networkName: String
        /// The current standing or status of the network.
        public let standing: Int?

        @inlinable
        public init(accessLevel: AccessLevel, awsAccountId: String, encryptionKeyArn: String? = nil, freeTrialExpiration: String? = nil, migrationState: Int? = nil, networkArn: String, networkId: String, networkName: String, standing: Int? = nil) {
            self.accessLevel = accessLevel
            self.awsAccountId = awsAccountId
            self.encryptionKeyArn = encryptionKeyArn
            self.freeTrialExpiration = freeTrialExpiration
            self.migrationState = migrationState
            self.networkArn = networkArn
            self.networkId = networkId
            self.networkName = networkName
            self.standing = standing
        }

        private enum CodingKeys: String, CodingKey {
            case accessLevel = "accessLevel"
            case awsAccountId = "awsAccountId"
            case encryptionKeyArn = "encryptionKeyArn"
            case freeTrialExpiration = "freeTrialExpiration"
            case migrationState = "migrationState"
            case networkArn = "networkArn"
            case networkId = "networkId"
            case networkName = "networkName"
            case standing = "standing"
        }
    }

    public struct GetNetworkSettingsRequest: AWSEncodableShape {
        /// The ID of the Wickr network whose settings will be retrieved.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkSettingsResponse: AWSDecodableShape {
        /// A list of network settings, where each setting includes a name, value, and type.
        public let settings: [Setting]

        @inlinable
        public init(settings: [Setting]) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
        }
    }

    public struct GetOidcInfoRequest: AWSEncodableShape {
        /// The CA certificate for secure communication with the OIDC provider (optional).
        public let certificate: String?
        /// The OAuth client ID for retrieving access tokens (optional).
        public let clientId: String?
        /// The OAuth client secret for retrieving access tokens (optional).
        public let clientSecret: String?
        /// The authorization code for retrieving access tokens (optional).
        public let code: String?
        /// The PKCE code verifier for enhanced security in the OAuth flow (optional).
        public let codeVerifier: String?
        /// The OAuth grant type for retrieving access tokens (optional).
        public let grantType: String?
        /// The ID of the Wickr network whose OIDC configuration will be retrieved.
        public let networkId: String
        /// The redirect URI for the OAuth flow (optional).
        public let redirectUri: String?
        /// The URL for the OIDC provider (optional).
        public let url: String?

        @inlinable
        public init(certificate: String? = nil, clientId: String? = nil, clientSecret: String? = nil, code: String? = nil, codeVerifier: String? = nil, grantType: String? = nil, networkId: String, redirectUri: String? = nil, url: String? = nil) {
            self.certificate = certificate
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.code = code
            self.codeVerifier = codeVerifier
            self.grantType = grantType
            self.networkId = networkId
            self.redirectUri = redirectUri
            self.url = url
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.certificate, key: "certificate")
            request.encodeQuery(self.clientId, key: "clientId")
            request.encodeQuery(self.clientSecret, key: "clientSecret")
            request.encodeQuery(self.code, key: "code")
            request.encodeQuery(self.codeVerifier, key: "codeVerifier")
            request.encodeQuery(self.grantType, key: "grantType")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.redirectUri, key: "redirectUri")
            request.encodeQuery(self.url, key: "url")
        }

        public func validate(name: String) throws {
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.code, name: "code", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.codeVerifier, name: "codeVerifier", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.grantType, name: "grantType", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.url, name: "url", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOidcInfoResponse: AWSDecodableShape {
        /// The OpenID Connect configuration information for the network, including issuer, client ID, scopes, and other SSO settings.
        public let openidConnectInfo: OidcConfigInfo?
        /// OAuth token information including access token, refresh token, and expiration details (only present if token parameters were provided in the request).
        public let tokenInfo: OidcTokenInfo?

        @inlinable
        public init(openidConnectInfo: OidcConfigInfo? = nil, tokenInfo: OidcTokenInfo? = nil) {
            self.openidConnectInfo = openidConnectInfo
            self.tokenInfo = tokenInfo
        }

        private enum CodingKeys: String, CodingKey {
            case openidConnectInfo = "openidConnectInfo"
            case tokenInfo = "tokenInfo"
        }
    }

    public struct GetSecurityGroupRequest: AWSEncodableShape {
        /// The unique identifier of the security group to retrieve.
        public let groupId: String
        /// The ID of the Wickr network containing the security group.
        public let networkId: String

        @inlinable
        public init(groupId: String, networkId: String) {
            self.groupId = groupId
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "groupId")
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSecurityGroupResponse: AWSDecodableShape {
        /// The detailed information about the security group, including all its settings and member counts.
        public let securityGroup: SecurityGroup

        @inlinable
        public init(securityGroup: SecurityGroup) {
            self.securityGroup = securityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroup = "securityGroup"
        }
    }

    public struct GetUserRequest: AWSEncodableShape {
        /// The end time for filtering the user's last activity. Only activity before this timestamp will be considered. Time is specified in epoch seconds.
        public let endTime: Date?
        /// The ID of the Wickr network containing the user.
        public let networkId: String
        /// The start time for filtering the user's last activity. Only activity after this timestamp will be considered. Time is specified in epoch seconds.
        public let startTime: Date?
        /// The unique identifier of the user to retrieve.
        public let userId: String

        @inlinable
        public init(endTime: Date? = nil, networkId: String, startTime: Date? = nil, userId: String) {
            self.endTime = endTime
            self.networkId = networkId
            self.startTime = startTime
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.startTime, key: "startTime")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 10)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserResponse: AWSDecodableShape {
        /// The first name of the user.
        public let firstName: String?
        /// Indicates whether the user has administrator privileges in the network.
        public let isAdmin: Bool?
        /// The timestamp of the user's last activity in the network, specified in epoch seconds.
        public let lastActivity: Int?
        /// The timestamp of the user's last login to the network, specified in epoch seconds.
        public let lastLogin: Int?
        /// The last name of the user.
        public let lastName: String?
        /// A list of security group IDs to which the user belongs.
        public let securityGroupIds: [String]?
        /// The current status of the user (1 for pending, 2 for active).
        public let status: Int?
        /// Indicates whether the user is currently suspended.
        public let suspended: Bool?
        /// The unique identifier of the user.
        public let userId: String
        /// The email address or username of the user.
        public let username: String?

        @inlinable
        public init(firstName: String? = nil, isAdmin: Bool? = nil, lastActivity: Int? = nil, lastLogin: Int? = nil, lastName: String? = nil, securityGroupIds: [String]? = nil, status: Int? = nil, suspended: Bool? = nil, userId: String, username: String? = nil) {
            self.firstName = firstName
            self.isAdmin = isAdmin
            self.lastActivity = lastActivity
            self.lastLogin = lastLogin
            self.lastName = lastName
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.suspended = suspended
            self.userId = userId
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "firstName"
            case isAdmin = "isAdmin"
            case lastActivity = "lastActivity"
            case lastLogin = "lastLogin"
            case lastName = "lastName"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case suspended = "suspended"
            case userId = "userId"
            case username = "username"
        }
    }

    public struct GetUsersCountRequest: AWSEncodableShape {
        /// The ID of the Wickr network for which to retrieve user counts.
        public let networkId: String

        @inlinable
        public init(networkId: String) {
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUsersCountResponse: AWSDecodableShape {
        /// The number of users with active status in the network.
        public let active: Int
        /// The number of users with pending status (invited but not yet accepted).
        public let pending: Int
        /// The number of users who have rejected network invitations.
        public let rejected: Int
        /// The number of additional users that can be added to the network while maintaining premium free trial eligibility.
        public let remaining: Int
        /// The total number of users in the network (active and pending combined).
        public let total: Int

        @inlinable
        public init(active: Int, pending: Int, rejected: Int, remaining: Int, total: Int) {
            self.active = active
            self.pending = pending
            self.rejected = rejected
            self.remaining = remaining
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case pending = "pending"
            case rejected = "rejected"
            case remaining = "remaining"
            case total = "total"
        }
    }

    public struct GuestUser: AWSDecodableShape {
        /// The billing period when this guest user accessed the network (e.g., '2024-01').
        public let billingPeriod: String
        /// The username of the guest user.
        public let username: String
        /// The unique username hash identifier for the guest user.
        public let usernameHash: String

        @inlinable
        public init(billingPeriod: String, username: String, usernameHash: String) {
            self.billingPeriod = billingPeriod
            self.username = username
            self.usernameHash = usernameHash
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "billingPeriod"
            case username = "username"
            case usernameHash = "usernameHash"
        }
    }

    public struct GuestUserHistoryCount: AWSDecodableShape {
        /// The number of guest users who have communicated with your Wickr network during this billing period.
        public let count: String
        /// The month and billing period in YYYY_MM format (e.g., '2024_01').
        public let month: String

        @inlinable
        public init(count: String, month: String) {
            self.count = count
            self.month = month
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case month = "month"
        }
    }

    public struct ListBlockedGuestUsersRequest: AWSEncodableShape {
        /// Filter results to only include blocked guest users that were blocked by this administrator.
        public let admin: String?
        /// The maximum number of blocked guest users to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network from which to list blocked guest users.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The field to sort blocked guest users by. Accepted values include 'username', 'admin', and 'modified'.
        public let sortFields: String?
        /// Filter results to only include blocked guest users with usernames matching this value.
        public let username: String?

        @inlinable
        public init(admin: String? = nil, maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil, username: String? = nil) {
            self.admin = admin
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.admin, key: "admin")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
            request.encodeQuery(self.username, key: "username")
        }

        public func validate(name: String) throws {
            try self.validate(self.admin, name: "admin", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBlockedGuestUsersResponse: AWSDecodableShape {
        /// A list of blocked guest user objects within the current page.
        public let blocklist: [BlockedGuestUser]
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?

        @inlinable
        public init(blocklist: [BlockedGuestUser], nextToken: String? = nil) {
            self.blocklist = blocklist
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blocklist = "blocklist"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotsRequest: AWSEncodableShape {
        /// Filter results to only include bots with display names matching this value.
        public let displayName: String?
        /// Filter results to only include bots belonging to this security group.
        public let groupId: String?
        /// The maximum number of bots to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network from which to list bots.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The fields to sort bots by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', 'displayName', 'status', and 'groupId'.
        public let sortFields: String?
        /// Filter results to only include bots with this status (1 for pending, 2 for active).
        public let status: BotStatus?
        /// Filter results to only include bots with usernames matching this value.
        public let username: String?

        @inlinable
        public init(displayName: String? = nil, groupId: String? = nil, maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil, status: BotStatus? = nil, username: String? = nil) {
            self.displayName = displayName
            self.groupId = groupId
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
            self.status = status
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.displayName, key: "displayName")
            request.encodeQuery(self.groupId, key: "groupId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.username, key: "username")
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBotsResponse: AWSDecodableShape {
        /// A list of bot objects matching the specified filters and within the current page.
        public let bots: [Bot]
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?

        @inlinable
        public init(bots: [Bot], nextToken: String? = nil) {
            self.bots = bots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case bots = "bots"
            case nextToken = "nextToken"
        }
    }

    public struct ListDevicesForUserRequest: AWSEncodableShape {
        /// The maximum number of devices to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network containing the user.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The fields to sort devices by. Multiple fields can be specified by separating them with '+'. Accepted values include 'lastlogin', 'type', 'suspend', and 'created'.
        public let sortFields: String?
        /// The unique identifier of the user whose devices will be listed.
        public let userId: String

        @inlinable
        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil, userId: String) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.userId, name: "userId", parent: name, max: 10)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesForUserResponse: AWSDecodableShape {
        /// A list of device objects associated with the user within the current page.
        public let devices: [BasicDeviceObject]
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?

        @inlinable
        public init(devices: [BasicDeviceObject], nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct ListGuestUsersRequest: AWSEncodableShape {
        /// Filter results to only include guest users from this billing period (e.g., '2024-01').
        public let billingPeriod: String?
        /// The maximum number of guest users to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network from which to list guest users.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The field to sort guest users by. Accepted values include 'username' and 'billingPeriod'.
        public let sortFields: String?
        /// Filter results to only include guest users with usernames matching this value.
        public let username: String?

        @inlinable
        public init(billingPeriod: String? = nil, maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil, username: String? = nil) {
            self.billingPeriod = billingPeriod
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.billingPeriod, key: "billingPeriod")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
            request.encodeQuery(self.username, key: "username")
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGuestUsersResponse: AWSDecodableShape {
        /// A list of guest user objects within the current page.
        public let guestlist: [GuestUser]
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?

        @inlinable
        public init(guestlist: [GuestUser], nextToken: String? = nil) {
            self.guestlist = guestlist
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case guestlist = "guestlist"
            case nextToken = "nextToken"
        }
    }

    public struct ListNetworksRequest: AWSEncodableShape {
        /// The maximum number of networks to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The field to sort networks by. Accepted values are 'networkId' and 'networkName'. Default is 'networkId'.
        public let sortFields: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworksResponse: AWSDecodableShape {
        /// A list of network objects for the Amazon Web Services account.
        public let networks: [Network]
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?

        @inlinable
        public init(networks: [Network], nextToken: String? = nil) {
            self.networks = networks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networks = "networks"
            case nextToken = "nextToken"
        }
    }

    public struct ListSecurityGroupUsersRequest: AWSEncodableShape {
        /// The unique identifier of the security group whose users will be listed.
        public let groupId: String
        /// The maximum number of users to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network containing the security group.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The field to sort users by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', and 'lastName'.
        public let sortFields: String?

        @inlinable
        public init(groupId: String, maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil) {
            self.groupId = groupId
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "groupId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityGroupUsersResponse: AWSDecodableShape {
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?
        /// A list of user objects belonging to the security group within the current page.
        public let users: [User]

        @inlinable
        public init(nextToken: String? = nil, users: [User]) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case users = "users"
        }
    }

    public struct ListSecurityGroupsRequest: AWSEncodableShape {
        /// The maximum number of security groups to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network from which to list security groups.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The field to sort security groups by. Accepted values include 'id' and 'name'.
        public let sortFields: String?

        @inlinable
        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityGroupsResponse: AWSDecodableShape {
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?
        /// A list of security group objects in the current page.
        public let securityGroups: [SecurityGroup]?

        @inlinable
        public init(nextToken: String? = nil, securityGroups: [SecurityGroup]? = nil) {
            self.nextToken = nextToken
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case securityGroups = "securityGroups"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        /// Filter results to only include users with first names matching this value.
        public let firstName: String?
        /// Filter results to only include users belonging to this security group.
        public let groupId: String?
        /// Filter results to only include users with last names matching this value.
        public let lastName: String?
        /// The maximum number of users to return in a single page. Valid range is 1-100. Default is 10.
        public let maxResults: Int?
        /// The ID of the Wickr network from which to list users.
        public let networkId: String
        /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
        public let nextToken: String?
        /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
        public let sortDirection: SortDirection?
        /// The fields to sort users by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', 'lastName', 'status', and 'groupId'.
        public let sortFields: String?
        /// Filter results to only include users with this status (1 for pending, 2 for active).
        public let status: UserStatus?
        /// Filter results to only include users with usernames matching this value.
        public let username: String?

        @inlinable
        public init(firstName: String? = nil, groupId: String? = nil, lastName: String? = nil, maxResults: Int? = nil, networkId: String, nextToken: String? = nil, sortDirection: SortDirection? = nil, sortFields: String? = nil, status: UserStatus? = nil, username: String? = nil) {
            self.firstName = firstName
            self.groupId = groupId
            self.lastName = lastName
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.sortDirection = sortDirection
            self.sortFields = sortFields
            self.status = status
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.firstName, key: "firstName")
            request.encodeQuery(self.groupId, key: "groupId")
            request.encodeQuery(self.lastName, key: "lastName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.networkId, key: "networkId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortDirection, key: "sortDirection")
            request.encodeQuery(self.sortFields, key: "sortFields")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.username, key: "username")
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.sortFields, name: "sortFields", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
        public let nextToken: String?
        /// A list of user objects matching the specified filters and within the current page.
        public let users: [User]?

        @inlinable
        public init(nextToken: String? = nil, users: [User]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case users = "users"
        }
    }

    public struct Network: AWSDecodableShape {
        /// The access level of the network (STANDARD or PREMIUM), which determines available features and capabilities.
        public let accessLevel: AccessLevel
        /// The Amazon Web Services account ID that owns the network.
        public let awsAccountId: String
        /// The ARN of the Amazon Web Services KMS customer managed key used for encrypting sensitive data in the network.
        public let encryptionKeyArn: String?
        /// The expiration date and time for the network's free trial period, if applicable.
        public let freeTrialExpiration: String?
        /// The SSO redirect URI migration state, managed by the SSO redirect migration wizard. Values: 0 (not started), 1 (in progress), or 2 (completed).
        public let migrationState: Int?
        /// The Amazon Resource Name (ARN) of the network.
        public let networkArn: String
        /// The unique identifier of the network.
        public let networkId: String
        /// The name of the network.
        public let networkName: String
        /// The current standing or status of the network.
        public let standing: Int?

        @inlinable
        public init(accessLevel: AccessLevel, awsAccountId: String, encryptionKeyArn: String? = nil, freeTrialExpiration: String? = nil, migrationState: Int? = nil, networkArn: String, networkId: String, networkName: String, standing: Int? = nil) {
            self.accessLevel = accessLevel
            self.awsAccountId = awsAccountId
            self.encryptionKeyArn = encryptionKeyArn
            self.freeTrialExpiration = freeTrialExpiration
            self.migrationState = migrationState
            self.networkArn = networkArn
            self.networkId = networkId
            self.networkName = networkName
            self.standing = standing
        }

        private enum CodingKeys: String, CodingKey {
            case accessLevel = "accessLevel"
            case awsAccountId = "awsAccountId"
            case encryptionKeyArn = "encryptionKeyArn"
            case freeTrialExpiration = "freeTrialExpiration"
            case migrationState = "migrationState"
            case networkArn = "networkArn"
            case networkId = "networkId"
            case networkName = "networkName"
            case standing = "standing"
        }
    }

    public struct NetworkSettings: AWSEncodableShape {
        /// Indicates whether the data retention feature is enabled for the network. When true, messages are captured by the data retention bot for compliance and archiving purposes.
        public let dataRetention: Bool?
        /// Allows Wickr clients to send anonymized performance and usage metrics to the Wickr backend server for service improvement and troubleshooting.
        public let enableClientMetrics: Bool?
        /// Configuration for read receipts at the network level, controlling the default behavior for whether senders can see when their messages have been read.
        public let readReceiptConfig: ReadReceiptConfig?

        @inlinable
        public init(dataRetention: Bool? = nil, enableClientMetrics: Bool? = nil, readReceiptConfig: ReadReceiptConfig? = nil) {
            self.dataRetention = dataRetention
            self.enableClientMetrics = enableClientMetrics
            self.readReceiptConfig = readReceiptConfig
        }

        private enum CodingKeys: String, CodingKey {
            case dataRetention = "dataRetention"
            case enableClientMetrics = "enableClientMetrics"
            case readReceiptConfig = "readReceiptConfig"
        }
    }

    public struct OidcConfigInfo: AWSDecodableShape {
        /// The unique identifier for the registered OIDC application. Valid range is 1-10.
        public let applicationId: Int?
        /// The name of the OIDC application as registered with the identity provider.
        public let applicationName: String?
        /// The X.509 CA certificate for validating SSL/TLS connections to the identity provider when using self-signed or enterprise certificates.
        public let caCertificate: String?
        /// The OAuth client ID assigned by the identity provider for authentication requests.
        public let clientId: String?
        /// The OAuth client secret used to authenticate the application with the identity provider.
        public let clientSecret: String?
        /// Custom identifier your end users will use to sign in with SSO.
        public let companyId: String
        /// A custom field mapping to extract the username from the OIDC token when the standard username claim is insufficient.
        public let customUsername: String?
        /// Additional authentication parameters to include in the OIDC authorization request as a query string. Useful for provider-specific extensions.
        public let extraAuthParams: String?
        /// The issuer URL of the identity provider, which serves as the base URL for OIDC endpoints and configuration discovery.
        public let issuer: String
        /// The callback URL where the identity provider redirects users after successful authentication. This URL must be registered with the identity provider.
        public let redirectUrl: String?
        /// The OAuth scopes requested from the identity provider, which determine what user information is accessible (e.g., 'openid profile email').
        public let scopes: String
        /// An additional secret credential used by the identity provider for authentication.
        public let secret: String?
        /// The grace period in minutes before the SSO token expires when the system should proactively refresh the token to maintain seamless user access.
        public let ssoTokenBufferMinutes: Int?
        /// The claim field from the OIDC token to use as the unique user identifier (e.g., 'email', 'sub', or a custom claim).
        public let userId: String?

        @inlinable
        public init(applicationId: Int? = nil, applicationName: String? = nil, caCertificate: String? = nil, clientId: String? = nil, clientSecret: String? = nil, companyId: String, customUsername: String? = nil, extraAuthParams: String? = nil, issuer: String, redirectUrl: String? = nil, scopes: String, secret: String? = nil, ssoTokenBufferMinutes: Int? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.applicationName = applicationName
            self.caCertificate = caCertificate
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.companyId = companyId
            self.customUsername = customUsername
            self.extraAuthParams = extraAuthParams
            self.issuer = issuer
            self.redirectUrl = redirectUrl
            self.scopes = scopes
            self.secret = secret
            self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case applicationName = "applicationName"
            case caCertificate = "caCertificate"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case companyId = "companyId"
            case customUsername = "customUsername"
            case extraAuthParams = "extraAuthParams"
            case issuer = "issuer"
            case redirectUrl = "redirectUrl"
            case scopes = "scopes"
            case secret = "secret"
            case ssoTokenBufferMinutes = "ssoTokenBufferMinutes"
            case userId = "userId"
        }
    }

    public struct OidcTokenInfo: AWSDecodableShape {
        /// The OAuth access token that can be used to access protected resources on behalf of the authenticated user.
        public let accessToken: String?
        /// The PKCE code challenge, a transformed version of the code verifier sent during the authorization request for verification.
        public let codeChallenge: String?
        /// The PKCE (Proof Key for Code Exchange) code verifier, a cryptographically random string used to enhance security in the OAuth flow.
        public let codeVerifier: String?
        /// The lifetime of the access token in seconds, indicating when the token will expire and need to be refreshed.
        public let expiresIn: Int64?
        /// The OpenID Connect ID token containing user identity information and authentication context as a signed JWT.
        public let idToken: String?
        /// The OAuth refresh token that can be used to obtain new access tokens without requiring the user to re-authenticate.
        public let refreshToken: String?
        /// The type of access token issued, typically 'Bearer', which indicates how the token should be used in API requests.
        public let tokenType: String?

        @inlinable
        public init(accessToken: String? = nil, codeChallenge: String? = nil, codeVerifier: String? = nil, expiresIn: Int64? = nil, idToken: String? = nil, refreshToken: String? = nil, tokenType: String? = nil) {
            self.accessToken = accessToken
            self.codeChallenge = codeChallenge
            self.codeVerifier = codeVerifier
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.tokenType = tokenType
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case codeChallenge = "codeChallenge"
            case codeVerifier = "codeVerifier"
            case expiresIn = "expiresIn"
            case idToken = "idToken"
            case refreshToken = "refreshToken"
            case tokenType = "tokenType"
        }
    }

    public struct PasswordRequirements: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of lowercase letters required in passwords.
        public let lowercase: Int?
        /// The minimum password length in characters.
        public let minLength: Int?
        /// The minimum number of numeric characters required in passwords.
        public let numbers: Int?
        /// The minimum number of special symbol characters required in passwords.
        public let symbols: Int?
        /// The minimum number of uppercase letters required in passwords.
        public let uppercase: Int?

        @inlinable
        public init(lowercase: Int? = nil, minLength: Int? = nil, numbers: Int? = nil, symbols: Int? = nil, uppercase: Int? = nil) {
            self.lowercase = lowercase
            self.minLength = minLength
            self.numbers = numbers
            self.symbols = symbols
            self.uppercase = uppercase
        }

        private enum CodingKeys: String, CodingKey {
            case lowercase = "lowercase"
            case minLength = "minLength"
            case numbers = "numbers"
            case symbols = "symbols"
            case uppercase = "uppercase"
        }
    }

    public struct PermittedWickrEnterpriseNetwork: AWSEncodableShape & AWSDecodableShape {
        /// The domain identifier for the permitted Wickr enterprise network.
        public let domain: String
        /// The network ID of the permitted Wickr enterprise network.
        public let networkId: String

        @inlinable
        public init(domain: String, networkId: String) {
            self.domain = domain
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case networkId = "networkId"
        }
    }

    public struct ReadReceiptConfig: AWSEncodableShape {
        /// The read receipt status mode for the network.
        public let status: Status?

        @inlinable
        public init(status: Status? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct RegisterOidcConfigRequest: AWSEncodableShape {
        /// Custom identifier your end users will use to sign in with SSO.
        public let companyId: String
        /// A custom field mapping to extract the username from the OIDC token (optional).   The customUsername is only required if you use something other than email as the username field.
        public let customUsername: String?
        /// Additional authentication parameters to include in the OIDC flow (optional).
        public let extraAuthParams: String?
        /// The issuer URL of the OIDC provider (e.g., 'https://login.example.com').
        public let issuer: String
        /// The ID of the Wickr network for which OIDC will be configured.
        public let networkId: String
        /// The OAuth scopes to request from the OIDC provider (e.g., 'openid profile email').
        public let scopes: String
        /// The client secret for authenticating with the OIDC provider (optional).
        public let secret: String?
        /// The buffer time in minutes before the SSO token expires to refresh it (optional).
        public let ssoTokenBufferMinutes: Int?
        /// Unique identifier provided by your identity provider to authenticate the access request. Also referred to as clientID.
        public let userId: String?

        @inlinable
        public init(companyId: String, customUsername: String? = nil, extraAuthParams: String? = nil, issuer: String, networkId: String, scopes: String, secret: String? = nil, ssoTokenBufferMinutes: Int? = nil, userId: String? = nil) {
            self.companyId = companyId
            self.customUsername = customUsername
            self.extraAuthParams = extraAuthParams
            self.issuer = issuer
            self.networkId = networkId
            self.scopes = scopes
            self.secret = secret
            self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.companyId, forKey: .companyId)
            try container.encodeIfPresent(self.customUsername, forKey: .customUsername)
            try container.encodeIfPresent(self.extraAuthParams, forKey: .extraAuthParams)
            try container.encode(self.issuer, forKey: .issuer)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.scopes, forKey: .scopes)
            try container.encodeIfPresent(self.secret, forKey: .secret)
            try container.encodeIfPresent(self.ssoTokenBufferMinutes, forKey: .ssoTokenBufferMinutes)
            try container.encodeIfPresent(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.companyId, name: "companyId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.customUsername, name: "customUsername", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.extraAuthParams, name: "extraAuthParams", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.scopes, name: "scopes", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.secret, name: "secret", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case companyId = "companyId"
            case customUsername = "customUsername"
            case extraAuthParams = "extraAuthParams"
            case issuer = "issuer"
            case scopes = "scopes"
            case secret = "secret"
            case ssoTokenBufferMinutes = "ssoTokenBufferMinutes"
            case userId = "userId"
        }
    }

    public struct RegisterOidcConfigResponse: AWSDecodableShape {
        /// The unique identifier for the registered OIDC application.
        public let applicationId: Int?
        /// The name of the registered OIDC application.
        public let applicationName: String?
        /// The CA certificate used for secure communication with the OIDC provider.
        public let caCertificate: String?
        /// The OAuth client ID assigned to the application.
        public let clientId: String?
        /// The OAuth client secret for the application.
        public let clientSecret: String?
        /// Custom identifier your end users will use to sign in with SSO.
        public let companyId: String
        /// The custom field mapping used for extracting the username.
        public let customUsername: String?
        /// The additional authentication parameters configured for the OIDC flow.
        public let extraAuthParams: String?
        /// The issuer URL of the OIDC provider.
        public let issuer: String
        /// The redirect URL configured for the OAuth flow.
        public let redirectUrl: String?
        /// The OAuth scopes configured for the application.
        public let scopes: String
        /// The client secret for authenticating with the OIDC provider.
        public let secret: String?
        /// The buffer time in minutes before the SSO token expires.
        public let ssoTokenBufferMinutes: Int?
        /// The claim field being used as the user identifier.
        public let userId: String?

        @inlinable
        public init(applicationId: Int? = nil, applicationName: String? = nil, caCertificate: String? = nil, clientId: String? = nil, clientSecret: String? = nil, companyId: String, customUsername: String? = nil, extraAuthParams: String? = nil, issuer: String, redirectUrl: String? = nil, scopes: String, secret: String? = nil, ssoTokenBufferMinutes: Int? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.applicationName = applicationName
            self.caCertificate = caCertificate
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.companyId = companyId
            self.customUsername = customUsername
            self.extraAuthParams = extraAuthParams
            self.issuer = issuer
            self.redirectUrl = redirectUrl
            self.scopes = scopes
            self.secret = secret
            self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case applicationName = "applicationName"
            case caCertificate = "caCertificate"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case companyId = "companyId"
            case customUsername = "customUsername"
            case extraAuthParams = "extraAuthParams"
            case issuer = "issuer"
            case redirectUrl = "redirectUrl"
            case scopes = "scopes"
            case secret = "secret"
            case ssoTokenBufferMinutes = "ssoTokenBufferMinutes"
            case userId = "userId"
        }
    }

    public struct RegisterOidcConfigTestRequest: AWSEncodableShape {
        /// The CA certificate for secure communication with the OIDC provider (optional).
        public let certificate: String?
        /// Additional authentication parameters to include in the test (optional).
        public let extraAuthParams: String?
        /// The issuer URL of the OIDC provider to test.
        public let issuer: String
        /// The ID of the Wickr network for which the OIDC configuration will be tested.
        public let networkId: String
        /// The OAuth scopes to test with the OIDC provider.
        public let scopes: String

        @inlinable
        public init(certificate: String? = nil, extraAuthParams: String? = nil, issuer: String, networkId: String, scopes: String) {
            self.certificate = certificate
            self.extraAuthParams = extraAuthParams
            self.issuer = issuer
            self.networkId = networkId
            self.scopes = scopes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.certificate, forKey: .certificate)
            try container.encodeIfPresent(self.extraAuthParams, forKey: .extraAuthParams)
            try container.encode(self.issuer, forKey: .issuer)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.scopes, forKey: .scopes)
        }

        public func validate(name: String) throws {
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.extraAuthParams, name: "extraAuthParams", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.scopes, name: "scopes", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case extraAuthParams = "extraAuthParams"
            case issuer = "issuer"
            case scopes = "scopes"
        }
    }

    public struct RegisterOidcConfigTestResponse: AWSDecodableShape {
        /// The authorization endpoint URL discovered from the OIDC provider.
        public let authorizationEndpoint: String?
        /// The end session endpoint URL for logging out users from the OIDC provider.
        public let endSessionEndpoint: String?
        /// The OAuth grant types supported by the OIDC provider.
        public let grantTypesSupported: [String]?
        /// The issuer URL confirmed by the OIDC provider.
        public let issuer: String?
        /// The logout endpoint URL for terminating user sessions.
        public let logoutEndpoint: String?
        /// Indicates whether the provider supports Microsoft multi-refresh tokens.
        public let microsoftMultiRefreshToken: Bool?
        /// The OAuth response types supported by the OIDC provider.
        public let responseTypesSupported: [String]?
        /// The token revocation endpoint URL for invalidating tokens.
        public let revocationEndpoint: String?
        /// The OAuth scopes supported by the OIDC provider.
        public let scopesSupported: [String]?
        /// The token endpoint URL discovered from the OIDC provider.
        public let tokenEndpoint: String?
        /// The authentication methods supported by the token endpoint.
        public let tokenEndpointAuthMethodsSupported: [String]?
        /// The user info endpoint URL discovered from the OIDC provider.
        public let userinfoEndpoint: String?

        @inlinable
        public init(authorizationEndpoint: String? = nil, endSessionEndpoint: String? = nil, grantTypesSupported: [String]? = nil, issuer: String? = nil, logoutEndpoint: String? = nil, microsoftMultiRefreshToken: Bool? = nil, responseTypesSupported: [String]? = nil, revocationEndpoint: String? = nil, scopesSupported: [String]? = nil, tokenEndpoint: String? = nil, tokenEndpointAuthMethodsSupported: [String]? = nil, userinfoEndpoint: String? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.endSessionEndpoint = endSessionEndpoint
            self.grantTypesSupported = grantTypesSupported
            self.issuer = issuer
            self.logoutEndpoint = logoutEndpoint
            self.microsoftMultiRefreshToken = microsoftMultiRefreshToken
            self.responseTypesSupported = responseTypesSupported
            self.revocationEndpoint = revocationEndpoint
            self.scopesSupported = scopesSupported
            self.tokenEndpoint = tokenEndpoint
            self.tokenEndpointAuthMethodsSupported = tokenEndpointAuthMethodsSupported
            self.userinfoEndpoint = userinfoEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case endSessionEndpoint = "endSessionEndpoint"
            case grantTypesSupported = "grantTypesSupported"
            case issuer = "issuer"
            case logoutEndpoint = "logoutEndpoint"
            case microsoftMultiRefreshToken = "microsoftMultiRefreshToken"
            case responseTypesSupported = "responseTypesSupported"
            case revocationEndpoint = "revocationEndpoint"
            case scopesSupported = "scopesSupported"
            case tokenEndpoint = "tokenEndpoint"
            case tokenEndpointAuthMethodsSupported = "tokenEndpointAuthMethodsSupported"
            case userinfoEndpoint = "userinfoEndpoint"
        }
    }

    public struct SecurityGroup: AWSDecodableShape {
        /// The GUID of the Active Directory group associated with this security group, if synchronized with LDAP.
        public let activeDirectoryGuid: String?
        /// The number of active user members currently in the security group.
        public let activeMembers: Int
        /// The number of bot members currently in the security group.
        public let botMembers: Int
        /// The unique identifier of the security group.
        public let id: String
        /// Indicates whether this is the default security group for the network. Each network has only one default group.
        public let isDefault: Bool
        /// The timestamp when the security group was last modified, specified in epoch seconds.
        public let modified: Int
        /// The human-readable name of the security group.
        public let name: String
        /// The comprehensive configuration settings that define capabilities and restrictions for members of this security group.
        public let securityGroupSettings: SecurityGroupSettings

        @inlinable
        public init(activeDirectoryGuid: String? = nil, activeMembers: Int, botMembers: Int, id: String, isDefault: Bool, modified: Int, name: String, securityGroupSettings: SecurityGroupSettings) {
            self.activeDirectoryGuid = activeDirectoryGuid
            self.activeMembers = activeMembers
            self.botMembers = botMembers
            self.id = id
            self.isDefault = isDefault
            self.modified = modified
            self.name = name
            self.securityGroupSettings = securityGroupSettings
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryGuid = "activeDirectoryGuid"
            case activeMembers = "activeMembers"
            case botMembers = "botMembers"
            case id = "id"
            case isDefault = "isDefault"
            case modified = "modified"
            case name = "name"
            case securityGroupSettings = "securityGroupSettings"
        }
    }

    public struct SecurityGroupSettings: AWSEncodableShape & AWSDecodableShape {
        /// Requires users to reauthenticate every time they return to the application, providing an additional layer of security.
        public let alwaysReauthenticate: Bool?
        /// Configuration values for ATAK (Android Team Awareness Kit) package integration, when ATAK is enabled.
        public let atakPackageValues: [String]?
        /// The calling feature permissions and settings that control what types of calls users can initiate and participate in.
        public let calling: CallingSettings?
        /// Enables automatic checking for Wickr client updates to ensure users stay current with the latest version.
        public let checkForUpdates: Bool?
        /// Enables ATAK (Android Team Awareness Kit) integration for tactical communication and situational awareness.
        public let enableAtak: Bool?
        /// Allow users to report crashes.
        public let enableCrashReports: Bool?
        /// Specifies whether users can download files from messages to their devices.
        public let enableFileDownload: Bool?
        /// Allows users to communicate with guest users from other Wickr networks and federated external networks.
        public let enableGuestFederation: Bool?
        /// Enables message preview text in push notifications, allowing users to see message content before opening the app.
        public let enableNotificationPreview: Bool?
        ///  Allow users to avoid censorship when they are geo-blocked or have network limitations.
        public let enableOpenAccessOption: Bool?
        /// Enables restricted global federation, limiting external communication to only specified permitted networks.
        public let enableRestrictedGlobalFederation: Bool?
        /// The local federation mode controlling how users can communicate with other networks. Values: 0 (none), 1 (federated), 2 (restricted).
        public let federationMode: Int?
        /// Enables file sharing capabilities, allowing users to send and receive files in conversations.
        public let filesEnabled: Bool?
        ///  Defines the number of failed login attempts before data stored on the device is reset. Should be less than lockoutThreshold.
        public let forceDeviceLockout: Int?
        /// Automatically enable and enforce Wickr open access on all devices. Valid only if enableOpenAccessOption settings is enabled.
        public let forceOpenAccess: Bool?
        /// Allow user approved bots to read messages in rooms without using a slash command.
        public let forceReadReceipts: Bool?
        /// Allows users to communicate with users on other Wickr instances (Wickr Enterprise) outside the current network.
        public let globalFederation: Bool?
        /// Enforces a two-factor authentication when a user adds a new device to their account.
        public let isAtoEnabled: Bool?
        /// Enables automatic preview of links shared in messages, showing webpage thumbnails and descriptions.
        public let isLinkPreviewEnabled: Bool?
        /// Allows map integration in location sharing, enabling users to view shared locations on interactive maps. Only allowed when location setting is enabled.
        public let locationAllowMaps: Bool?
        /// Enables location sharing features, allowing users to share their current location with others.
        public let locationEnabled: Bool?
        /// The number of failed password attempts before a user account is locked out.
        public let lockoutThreshold: Int?
        /// The maximum file size in bytes that will be automatically downloaded without user confirmation. Only allowed if fileDownload is enabled. Valid Values [512000 (low_quality), 7340032 (high_quality) ]
        public let maxAutoDownloadSize: Int64?
        /// The maximum burn-on-read (BOR) time in seconds, which determines how long messages remain visible before auto-deletion after being read.
        public let maxBor: Int?
        /// The maximum time-to-live (TTL) in seconds for messages, after which they will be automatically deleted from all devices.
        public let maxTtl: Int64?
        /// Enables message forwarding, allowing users to forward messages from one conversation to another.
        public let messageForwardingEnabled: Bool?
        /// The password complexity requirements that users must follow when creating or changing passwords.
        public let passwordRequirements: PasswordRequirements?
        /// A list of network IDs that are permitted for local federation when federation mode is set to restricted.
        public let permittedNetworks: [String]?
        /// A list of permitted Wickr networks for global federation, restricting communication to specific approved networks.
        public let permittedWickrAwsNetworks: [WickrAwsNetworks]?
        /// A list of permitted Wickr Enterprise networks for global federation, restricting communication to specific approved networks.
        public let permittedWickrEnterpriseNetworks: [PermittedWickrEnterpriseNetwork]?
        /// Enables presence indicators that show whether users are online, away, or offline.
        public let presenceEnabled: Bool?
        /// A list of pre-defined quick response message templates that users can send with a single tap.
        public let quickResponses: [String]?
        /// Users will get a master recovery key that can be used to securely sign in to their Wickr account without having access to their primary device for authentication. Available in SSO enabled network.
        public let showMasterRecoveryKey: Bool?
        /// The message shredder configuration that controls secure deletion of messages and files from devices.
        public let shredder: ShredderSettings?
        /// The duration for which users SSO session remains inactive before automatically logging them out for security. Available in SSO enabled network.
        public let ssoMaxIdleMinutes: Int?

        @inlinable
        public init(alwaysReauthenticate: Bool? = nil, atakPackageValues: [String]? = nil, calling: CallingSettings? = nil, checkForUpdates: Bool? = nil, enableAtak: Bool? = nil, enableCrashReports: Bool? = nil, enableFileDownload: Bool? = nil, enableGuestFederation: Bool? = nil, enableNotificationPreview: Bool? = nil, enableOpenAccessOption: Bool? = nil, enableRestrictedGlobalFederation: Bool? = nil, federationMode: Int? = nil, filesEnabled: Bool? = nil, forceDeviceLockout: Int? = nil, forceOpenAccess: Bool? = nil, forceReadReceipts: Bool? = nil, globalFederation: Bool? = nil, isAtoEnabled: Bool? = nil, isLinkPreviewEnabled: Bool? = nil, locationAllowMaps: Bool? = nil, locationEnabled: Bool? = nil, lockoutThreshold: Int? = nil, maxAutoDownloadSize: Int64? = nil, maxBor: Int? = nil, maxTtl: Int64? = nil, messageForwardingEnabled: Bool? = nil, passwordRequirements: PasswordRequirements? = nil, permittedNetworks: [String]? = nil, permittedWickrAwsNetworks: [WickrAwsNetworks]? = nil, permittedWickrEnterpriseNetworks: [PermittedWickrEnterpriseNetwork]? = nil, presenceEnabled: Bool? = nil, quickResponses: [String]? = nil, showMasterRecoveryKey: Bool? = nil, shredder: ShredderSettings? = nil, ssoMaxIdleMinutes: Int? = nil) {
            self.alwaysReauthenticate = alwaysReauthenticate
            self.atakPackageValues = atakPackageValues
            self.calling = calling
            self.checkForUpdates = checkForUpdates
            self.enableAtak = enableAtak
            self.enableCrashReports = enableCrashReports
            self.enableFileDownload = enableFileDownload
            self.enableGuestFederation = enableGuestFederation
            self.enableNotificationPreview = enableNotificationPreview
            self.enableOpenAccessOption = enableOpenAccessOption
            self.enableRestrictedGlobalFederation = enableRestrictedGlobalFederation
            self.federationMode = federationMode
            self.filesEnabled = filesEnabled
            self.forceDeviceLockout = forceDeviceLockout
            self.forceOpenAccess = forceOpenAccess
            self.forceReadReceipts = forceReadReceipts
            self.globalFederation = globalFederation
            self.isAtoEnabled = isAtoEnabled
            self.isLinkPreviewEnabled = isLinkPreviewEnabled
            self.locationAllowMaps = locationAllowMaps
            self.locationEnabled = locationEnabled
            self.lockoutThreshold = lockoutThreshold
            self.maxAutoDownloadSize = maxAutoDownloadSize
            self.maxBor = maxBor
            self.maxTtl = maxTtl
            self.messageForwardingEnabled = messageForwardingEnabled
            self.passwordRequirements = passwordRequirements
            self.permittedNetworks = permittedNetworks
            self.permittedWickrAwsNetworks = permittedWickrAwsNetworks
            self.permittedWickrEnterpriseNetworks = permittedWickrEnterpriseNetworks
            self.presenceEnabled = presenceEnabled
            self.quickResponses = quickResponses
            self.showMasterRecoveryKey = showMasterRecoveryKey
            self.shredder = shredder
            self.ssoMaxIdleMinutes = ssoMaxIdleMinutes
        }

        public func validate(name: String) throws {
            try self.atakPackageValues?.forEach {
                try validate($0, name: "atakPackageValues[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.permittedNetworks?.forEach {
                try validate($0, name: "permittedNetworks[]", parent: name, max: 8)
                try validate($0, name: "permittedNetworks[]", parent: name, min: 8)
                try validate($0, name: "permittedNetworks[]", parent: name, pattern: "^[0-9]{8}$")
            }
            try self.permittedWickrAwsNetworks?.forEach {
                try $0.validate(name: "\(name).permittedWickrAwsNetworks[]")
            }
            try self.permittedWickrEnterpriseNetworks?.forEach {
                try $0.validate(name: "\(name).permittedWickrEnterpriseNetworks[]")
            }
            try self.quickResponses?.forEach {
                try validate($0, name: "quickResponses[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case alwaysReauthenticate = "alwaysReauthenticate"
            case atakPackageValues = "atakPackageValues"
            case calling = "calling"
            case checkForUpdates = "checkForUpdates"
            case enableAtak = "enableAtak"
            case enableCrashReports = "enableCrashReports"
            case enableFileDownload = "enableFileDownload"
            case enableGuestFederation = "enableGuestFederation"
            case enableNotificationPreview = "enableNotificationPreview"
            case enableOpenAccessOption = "enableOpenAccessOption"
            case enableRestrictedGlobalFederation = "enableRestrictedGlobalFederation"
            case federationMode = "federationMode"
            case filesEnabled = "filesEnabled"
            case forceDeviceLockout = "forceDeviceLockout"
            case forceOpenAccess = "forceOpenAccess"
            case forceReadReceipts = "forceReadReceipts"
            case globalFederation = "globalFederation"
            case isAtoEnabled = "isAtoEnabled"
            case isLinkPreviewEnabled = "isLinkPreviewEnabled"
            case locationAllowMaps = "locationAllowMaps"
            case locationEnabled = "locationEnabled"
            case lockoutThreshold = "lockoutThreshold"
            case maxAutoDownloadSize = "maxAutoDownloadSize"
            case maxBor = "maxBor"
            case maxTtl = "maxTtl"
            case messageForwardingEnabled = "messageForwardingEnabled"
            case passwordRequirements = "passwordRequirements"
            case permittedNetworks = "permittedNetworks"
            case permittedWickrAwsNetworks = "permittedWickrAwsNetworks"
            case permittedWickrEnterpriseNetworks = "permittedWickrEnterpriseNetworks"
            case presenceEnabled = "presenceEnabled"
            case quickResponses = "quickResponses"
            case showMasterRecoveryKey = "showMasterRecoveryKey"
            case shredder = "shredder"
            case ssoMaxIdleMinutes = "ssoMaxIdleMinutes"
        }
    }

    public struct SecurityGroupSettingsRequest: AWSEncodableShape {
        /// Guest users let you work with people outside your organization that only have limited access to Wickr. Only valid when federationMode is set to Global.
        public let enableGuestFederation: Bool?
        /// Enables restricted global federation to limit communication to specific permitted networks only. Requires globalFederation to be enabled.
        public let enableRestrictedGlobalFederation: Bool?
        /// The local federation mode. Values: 0 (none), 1 (federated - all networks), 2 (restricted - only permitted networks).
        public let federationMode: Int?
        /// Allow users to securely federate with all Amazon Web Services Wickr networks and Amazon Web Services Enterprise networks.
        public let globalFederation: Bool?
        /// The number of failed password attempts before a user account is locked out.
        public let lockoutThreshold: Int?
        /// A list of network IDs that are permitted for local federation when federation mode is set to restricted.
        public let permittedNetworks: [String]?
        /// A list of permitted Amazon Web Services Wickr networks for restricted global federation.
        public let permittedWickrAwsNetworks: [WickrAwsNetworks]?
        /// A list of permitted Wickr Enterprise networks for restricted global federation.
        public let permittedWickrEnterpriseNetworks: [PermittedWickrEnterpriseNetwork]?

        @inlinable
        public init(enableGuestFederation: Bool? = nil, enableRestrictedGlobalFederation: Bool? = nil, federationMode: Int? = nil, globalFederation: Bool? = nil, lockoutThreshold: Int? = nil, permittedNetworks: [String]? = nil, permittedWickrAwsNetworks: [WickrAwsNetworks]? = nil, permittedWickrEnterpriseNetworks: [PermittedWickrEnterpriseNetwork]? = nil) {
            self.enableGuestFederation = enableGuestFederation
            self.enableRestrictedGlobalFederation = enableRestrictedGlobalFederation
            self.federationMode = federationMode
            self.globalFederation = globalFederation
            self.lockoutThreshold = lockoutThreshold
            self.permittedNetworks = permittedNetworks
            self.permittedWickrAwsNetworks = permittedWickrAwsNetworks
            self.permittedWickrEnterpriseNetworks = permittedWickrEnterpriseNetworks
        }

        public func validate(name: String) throws {
            try self.permittedNetworks?.forEach {
                try validate($0, name: "permittedNetworks[]", parent: name, max: 8)
                try validate($0, name: "permittedNetworks[]", parent: name, min: 8)
                try validate($0, name: "permittedNetworks[]", parent: name, pattern: "^[0-9]{8}$")
            }
            try self.permittedWickrAwsNetworks?.forEach {
                try $0.validate(name: "\(name).permittedWickrAwsNetworks[]")
            }
            try self.permittedWickrEnterpriseNetworks?.forEach {
                try $0.validate(name: "\(name).permittedWickrEnterpriseNetworks[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enableGuestFederation = "enableGuestFederation"
            case enableRestrictedGlobalFederation = "enableRestrictedGlobalFederation"
            case federationMode = "federationMode"
            case globalFederation = "globalFederation"
            case lockoutThreshold = "lockoutThreshold"
            case permittedNetworks = "permittedNetworks"
            case permittedWickrAwsNetworks = "permittedWickrAwsNetworks"
            case permittedWickrEnterpriseNetworks = "permittedWickrEnterpriseNetworks"
        }
    }

    public struct Setting: AWSDecodableShape {
        /// The name of the network setting (e.g., 'enableClientMetrics', 'dataRetention').
        public let optionName: String
        /// The data type of the setting value (e.g., 'boolean', 'string', 'number').
        public let type: String
        /// The current value of the setting as a string. Boolean values are represented as 'true' or 'false'.
        public let value: String

        @inlinable
        public init(optionName: String, type: String, value: String) {
            self.optionName = optionName
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case optionName = "optionName"
            case type = "type"
            case value = "value"
        }
    }

    public struct ShredderSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether users can manually trigger the shredder to delete content.
        public let canProcessManually: Bool?
        /// Prevents Wickr data from being recovered by overwriting deleted Wickr data. Valid Values: Must be one of [0, 20, 60, 100]
        public let intensity: Int?

        @inlinable
        public init(canProcessManually: Bool? = nil, intensity: Int? = nil) {
            self.canProcessManually = canProcessManually
            self.intensity = intensity
        }

        private enum CodingKeys: String, CodingKey {
            case canProcessManually = "canProcessManually"
            case intensity = "intensity"
        }
    }

    public struct UpdateBotRequest: AWSEncodableShape {
        /// The unique identifier of the bot to update.
        public let botId: String
        /// The new password for the bot account.
        public let challenge: String?
        /// The new display name for the bot.
        public let displayName: String?
        /// The ID of the new security group to assign the bot to.
        public let groupId: String?
        /// The ID of the Wickr network containing the bot to update.
        public let networkId: String
        /// Set to true to suspend the bot or false to unsuspend it. Omit this field for standard updates that don't affect suspension status.
        public let suspend: Bool?

        @inlinable
        public init(botId: String, challenge: String? = nil, displayName: String? = nil, groupId: String? = nil, networkId: String, suspend: Bool? = nil) {
            self.botId = botId
            self.challenge = challenge
            self.displayName = displayName
            self.groupId = groupId
            self.networkId = networkId
            self.suspend = suspend
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.challenge, forKey: .challenge)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.groupId, forKey: .groupId)
            request.encodePath(self.networkId, key: "networkId")
            try container.encodeIfPresent(self.suspend, forKey: .suspend)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.challenge, name: "challenge", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: String, CodingKey {
            case challenge = "challenge"
            case displayName = "displayName"
            case groupId = "groupId"
            case suspend = "suspend"
        }
    }

    public struct UpdateBotResponse: AWSDecodableShape {
        /// A message indicating the result of the bot update operation.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UpdateDataRetentionRequest: AWSEncodableShape {
        /// The action to perform. Valid values are 'ENABLE' (to enable the data retention service), 'DISABLE' (to disable the service), or 'PUBKEY_MSG_ACK' (to acknowledge the public key message).
        public let actionType: DataRetentionActionType
        /// The ID of the Wickr network containing the data retention bot.
        public let networkId: String

        @inlinable
        public init(actionType: DataRetentionActionType, networkId: String) {
            self.actionType = actionType
            self.networkId = networkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actionType, forKey: .actionType)
            request.encodePath(self.networkId, key: "networkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
        }
    }

    public struct UpdateDataRetentionResponse: AWSDecodableShape {
        /// A message indicating the result of the update operation.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UpdateGuestUserRequest: AWSEncodableShape {
        /// Set to true to block the guest user or false to unblock them.
        public let block: Bool
        /// The ID of the Wickr network where the guest user's status will be updated.
        public let networkId: String
        /// The username hash (unique identifier) of the guest user to update.
        public let usernameHash: String

        @inlinable
        public init(block: Bool, networkId: String, usernameHash: String) {
            self.block = block
            self.networkId = networkId
            self.usernameHash = usernameHash
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.block, forKey: .block)
            request.encodePath(self.networkId, key: "networkId")
            request.encodePath(self.usernameHash, key: "usernameHash")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.usernameHash, name: "usernameHash", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case block = "block"
        }
    }

    public struct UpdateGuestUserResponse: AWSDecodableShape {
        /// A message indicating the result of the update operation.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UpdateNetworkRequest: AWSEncodableShape {
        /// A unique identifier for this request to ensure idempotency.
        public let clientToken: String?
        /// The ARN of the Amazon Web Services KMS customer managed key to use for encrypting sensitive data in the network.
        public let encryptionKeyArn: String?
        /// The ID of the Wickr network to update.
        public let networkId: String
        /// The new name for the network. Must be between 1 and 20 characters.
        public let networkName: String

        @inlinable
        public init(clientToken: String? = UpdateNetworkRequest.idempotencyToken(), encryptionKeyArn: String? = nil, networkId: String, networkName: String) {
            self.clientToken = clientToken
            self.encryptionKeyArn = encryptionKeyArn
            self.networkId = networkId
            self.networkName = networkName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Client-Token")
            try container.encodeIfPresent(self.encryptionKeyArn, forKey: .encryptionKeyArn)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.networkName, forKey: .networkName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_:]+$")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.networkName, name: "networkName", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyArn = "encryptionKeyArn"
            case networkName = "networkName"
        }
    }

    public struct UpdateNetworkResponse: AWSDecodableShape {
        /// A message indicating that the network was updated successfully.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UpdateNetworkSettingsRequest: AWSEncodableShape {
        /// The ID of the Wickr network whose settings will be updated.
        public let networkId: String
        /// A map of setting names to their new values. Each setting should be provided with its appropriate type (boolean, string, number, etc.).
        public let settings: NetworkSettings

        @inlinable
        public init(networkId: String, settings: NetworkSettings) {
            self.networkId = networkId
            self.settings = settings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
            try container.encode(self.settings, forKey: .settings)
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
        }
    }

    public struct UpdateNetworkSettingsResponse: AWSDecodableShape {
        /// A list of the updated network settings, showing the new values for each modified setting.
        public let settings: [Setting]

        @inlinable
        public init(settings: [Setting]) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
        }
    }

    public struct UpdateSecurityGroupRequest: AWSEncodableShape {
        /// The unique identifier of the security group to update.
        public let groupId: String
        /// The new name for the security group.
        public let name: String?
        /// The ID of the Wickr network containing the security group to update.
        public let networkId: String
        /// The updated configuration settings for the security group. Federation mode - 0 (Local federation), 1 (Restricted federation), 2 (Global federation)
        public let securityGroupSettings: SecurityGroupSettings?

        @inlinable
        public init(groupId: String, name: String? = nil, networkId: String, securityGroupSettings: SecurityGroupSettings? = nil) {
            self.groupId = groupId
            self.name = name
            self.networkId = networkId
            self.securityGroupSettings = securityGroupSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "groupId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.networkId, key: "networkId")
            try container.encodeIfPresent(self.securityGroupSettings, forKey: .securityGroupSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.securityGroupSettings?.validate(name: "\(name).securityGroupSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case securityGroupSettings = "securityGroupSettings"
        }
    }

    public struct UpdateSecurityGroupResponse: AWSDecodableShape {
        /// The updated security group details, including the new settings.
        public let securityGroup: SecurityGroup

        @inlinable
        public init(securityGroup: SecurityGroup) {
            self.securityGroup = securityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroup = "securityGroup"
        }
    }

    public struct UpdateUserDetails: AWSEncodableShape {
        /// Indicates whether the user can be verified through a custom invite code.
        public let codeValidation: Bool?
        /// The new first name for the user.
        public let firstName: String?
        /// A new custom invite code for the user.
        public let inviteCode: String?
        /// The new time-to-live for the invite code in days.
        public let inviteCodeTtl: Int?
        /// The new last name for the user.
        public let lastName: String?
        /// The updated list of security group IDs to which the user should belong.
        public let securityGroupIds: [String]?
        /// The new username or email address for the user.
        public let username: String?

        @inlinable
        public init(codeValidation: Bool? = nil, firstName: String? = nil, inviteCode: String? = nil, inviteCodeTtl: Int? = nil, lastName: String? = nil, securityGroupIds: [String]? = nil, username: String? = nil) {
            self.codeValidation = codeValidation
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.inviteCodeTtl = inviteCodeTtl
            self.lastName = lastName
            self.securityGroupIds = securityGroupIds
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.inviteCode, name: "inviteCode", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[\\S\\s]*$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeValidation = "codeValidation"
            case firstName = "firstName"
            case inviteCode = "inviteCode"
            case inviteCodeTtl = "inviteCodeTtl"
            case lastName = "lastName"
            case securityGroupIds = "securityGroupIds"
            case username = "username"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// The ID of the Wickr network containing the user to update.
        public let networkId: String
        /// An object containing the user details to be updated, such as name, password, security groups, and invite code settings.
        public let userDetails: UpdateUserDetails?
        /// The unique identifier of the user to update.
        public let userId: String

        @inlinable
        public init(networkId: String, userDetails: UpdateUserDetails? = nil, userId: String) {
            self.networkId = networkId
            self.userDetails = userDetails
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkId, key: "networkId")
            try container.encodeIfPresent(self.userDetails, forKey: .userDetails)
            try container.encode(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.userDetails?.validate(name: "\(name).userDetails")
            try self.validate(self.userId, name: "userId", parent: name, max: 10)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case userDetails = "userDetails"
            case userId = "userId"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// Indicates whether the user can be verified through a custom invite code.
        public let codeValidation: Bool?
        /// The updated first name of the user.
        public let firstName: String?
        /// The updated invite code for the user, if applicable.
        public let inviteCode: String?
        /// The expiration time of the user's invite code, specified in epoch seconds.
        public let inviteExpiration: Int?
        /// The updated last name of the user.
        public let lastName: String?
        /// The middle name of the user (currently not used).
        public let middleName: String?
        /// The timestamp when the user was last modified, specified in epoch seconds.
        public let modified: Int?
        /// The ID of the network where the user was updated.
        public let networkId: String
        /// The list of security group IDs to which the user now belongs after the update.
        public let securityGroupIds: [String]?
        /// The user's status after the update.
        public let status: Int?
        /// Indicates whether the user is suspended after the update.
        public let suspended: Bool
        /// The unique identifier of the updated user.
        public let userId: String

        @inlinable
        public init(codeValidation: Bool? = nil, firstName: String? = nil, inviteCode: String? = nil, inviteExpiration: Int? = nil, lastName: String? = nil, middleName: String? = nil, modified: Int? = nil, networkId: String, securityGroupIds: [String]? = nil, status: Int? = nil, suspended: Bool, userId: String) {
            self.codeValidation = codeValidation
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.inviteExpiration = inviteExpiration
            self.lastName = lastName
            self.middleName = middleName
            self.modified = modified
            self.networkId = networkId
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.suspended = suspended
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case codeValidation = "codeValidation"
            case firstName = "firstName"
            case inviteCode = "inviteCode"
            case inviteExpiration = "inviteExpiration"
            case lastName = "lastName"
            case middleName = "middleName"
            case modified = "modified"
            case networkId = "networkId"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case suspended = "suspended"
            case userId = "userId"
        }
    }

    public struct User: AWSDecodableShape {
        /// The phone number minus country code, used for cloud deployments.
        public let cell: String?
        /// The number of failed password attempts for enterprise deployments, used for account lockout policies.
        public let challengeFailures: Int?
        /// Indicates whether the user can be verified through a custom invite code.
        public let codeValidation: Bool?
        /// The country code for the user's phone number, used for cloud deployments.
        public let countryCode: String?
        /// The first name of the user.
        public let firstName: String?
        /// The invitation code for this user, used during registration to join the network.
        public let inviteCode: String?
        /// Indicates whether the user has administrator privileges in the network.
        public let isAdmin: Bool?
        /// Indicates whether the user's email invitation code has expired, applicable to cloud deployments.
        public let isInviteExpired: Bool?
        /// Indicates whether this account is a user (as opposed to a bot or other account type).
        public let isUser: Bool?
        /// The last name of the user.
        public let lastName: String?
        /// Indicates whether one-time password (OTP) authentication is enabled for the user.
        public let otpEnabled: Bool?
        /// The SCIM (System for Cross-domain Identity Management) identifier for the user, used for identity synchronization. Currently not used.
        public let scimId: String?
        /// A list of security group IDs to which the user is assigned, determining their permissions and feature access.
        public let securityGroups: [String]?
        /// The current status of the user (1 for pending invitation, 2 for active).
        public let status: Int?
        /// Indicates whether the user is currently suspended and unable to access the network.
        public let suspended: Bool?
        /// The descriptive type of the user account (e.g., 'user').
        public let type: String?
        /// The unique identifier for the user.
        public let uname: String?
        /// The unique identifier for the user within the network.
        public let userId: String?
        /// The email address or username of the user. For bots, this must end in 'bot'.
        public let username: String?

        @inlinable
        public init(cell: String? = nil, challengeFailures: Int? = nil, codeValidation: Bool? = nil, countryCode: String? = nil, firstName: String? = nil, inviteCode: String? = nil, isAdmin: Bool? = nil, isInviteExpired: Bool? = nil, isUser: Bool? = nil, lastName: String? = nil, otpEnabled: Bool? = nil, scimId: String? = nil, securityGroups: [String]? = nil, status: Int? = nil, suspended: Bool? = nil, type: String? = nil, uname: String? = nil, userId: String? = nil, username: String? = nil) {
            self.cell = cell
            self.challengeFailures = challengeFailures
            self.codeValidation = codeValidation
            self.countryCode = countryCode
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.isAdmin = isAdmin
            self.isInviteExpired = isInviteExpired
            self.isUser = isUser
            self.lastName = lastName
            self.otpEnabled = otpEnabled
            self.scimId = scimId
            self.securityGroups = securityGroups
            self.status = status
            self.suspended = suspended
            self.type = type
            self.uname = uname
            self.userId = userId
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case cell = "cell"
            case challengeFailures = "challengeFailures"
            case codeValidation = "codeValidation"
            case countryCode = "countryCode"
            case firstName = "firstName"
            case inviteCode = "inviteCode"
            case isAdmin = "isAdmin"
            case isInviteExpired = "isInviteExpired"
            case isUser = "isUser"
            case lastName = "lastName"
            case otpEnabled = "otpEnabled"
            case scimId = "scimId"
            case securityGroups = "securityGroups"
            case status = "status"
            case suspended = "suspended"
            case type = "type"
            case uname = "uname"
            case userId = "userId"
            case username = "username"
        }
    }

    public struct ValidationError: AWSErrorShape {
        /// A list of validation error details, where each item identifies a specific field that failed validation and explains the reason for the failure.
        public let reasons: [ErrorDetail]?

        @inlinable
        public init(reasons: [ErrorDetail]? = nil) {
            self.reasons = reasons
        }

        private enum CodingKeys: String, CodingKey {
            case reasons = "reasons"
        }
    }

    public struct WickrAwsNetworks: AWSEncodableShape & AWSDecodableShape {
        /// The network ID of the Wickr Amazon Web Services network.
        public let networkId: String
        /// The Amazon Web Services region identifier where the network is hosted (e.g., 'us-east-1').
        public let region: String

        @inlinable
        public init(networkId: String, region: String) {
            self.networkId = networkId
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 8)
            try self.validate(self.networkId, name: "networkId", parent: name, pattern: "^[0-9]{8}$")
            try self.validate(self.region, name: "region", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case networkId = "networkId"
            case region = "region"
        }
    }
}

// MARK: - Errors

/// Error enum for Wickr
public struct WickrErrorType: AWSErrorType {
    enum Code: String {
        case badRequestError = "BadRequestError"
        case forbiddenError = "ForbiddenError"
        case internalServerError = "InternalServerError"
        case rateLimitError = "RateLimitError"
        case resourceNotFoundError = "ResourceNotFoundError"
        case unauthorizedError = "UnauthorizedError"
        case validationError = "ValidationError"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Wickr
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was invalid or malformed. This error occurs when the request parameters do not meet the API requirements, such as invalid field values, missing required parameters, or improperly formatted data.
    public static var badRequestError: Self { .init(.badRequestError) }
    /// Access to the requested resource is forbidden. This error occurs when the authenticated user does not have the necessary permissions to perform the requested operation, even though they are authenticated.
    public static var forbiddenError: Self { .init(.forbiddenError) }
    /// An unexpected error occurred on the server while processing the request. This indicates a problem with the Wickr service itself rather than with the request. If this error persists, contact Amazon Web Services Support.
    public static var internalServerError: Self { .init(.internalServerError) }
    /// The request was throttled because too many requests were sent in a short period of time. Wait a moment and retry the request. Consider implementing exponential backoff in your application.
    public static var rateLimitError: Self { .init(.rateLimitError) }
    /// The requested resource could not be found. This error occurs when you try to access or modify a network, user, bot, security group, or other resource that doesn't exist or has been deleted.
    public static var resourceNotFoundError: Self { .init(.resourceNotFoundError) }
    /// The request was not authenticated or the authentication credentials were invalid. This error occurs when the request lacks valid authentication credentials or the credentials have expired.
    public static var unauthorizedError: Self { .init(.unauthorizedError) }
    /// One or more fields in the request failed validation. This error provides detailed information about which fields were invalid and why, allowing you to correct the request and retry.
    public static var validationError: Self { .init(.validationError) }
}

extension WickrErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationError": Wickr.ValidationError.self
    ]
}

extension WickrErrorType: Equatable {
    public static func == (lhs: WickrErrorType, rhs: WickrErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WickrErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
