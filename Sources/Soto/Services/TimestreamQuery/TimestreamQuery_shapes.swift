//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension TimestreamQuery {
    // MARK: Enums

    public enum DimensionValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum MeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case multi = "MULTI"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sseKms = "SSE_KMS"
        case sseS3 = "SSE_S3"
        public var description: String { return self.rawValue }
    }

    public enum ScalarMeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case timestamp = "TIMESTAMP"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum ScalarType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case date = "DATE"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case intervalDayToSecond = "INTERVAL_DAY_TO_SECOND"
        case intervalYearToMonth = "INTERVAL_YEAR_TO_MONTH"
        case time = "TIME"
        case timestamp = "TIMESTAMP"
        case unknown = "UNKNOWN"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledQueryRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoTriggerFailure = "AUTO_TRIGGER_FAILURE"
        case autoTriggerSuccess = "AUTO_TRIGGER_SUCCESS"
        case manualTriggerFailure = "MANUAL_TRIGGER_FAILURE"
        case manualTriggerSuccess = "MANUAL_TRIGGER_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledQueryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CancelQueryRequest: AWSEncodableShape {
        ///  The ID of the query that needs to be cancelled. QueryID is returned as part of the query result.
        public let queryId: String

        public init(queryId: String) {
            self.queryId = queryId
        }

        public func validate(name: String) throws {
            try self.validate(self.queryId, name: "queryId", parent: name, max: 64)
            try self.validate(self.queryId, name: "queryId", parent: name, min: 1)
            try self.validate(self.queryId, name: "queryId", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "QueryId"
        }
    }

    public struct CancelQueryResponse: AWSDecodableShape {
        ///  A CancellationMessage is returned when a CancelQuery request for the query specified by QueryId has already been issued.
        public let cancellationMessage: String?

        public init(cancellationMessage: String? = nil) {
            self.cancellationMessage = cancellationMessage
        }

        private enum CodingKeys: String, CodingKey {
            case cancellationMessage = "CancellationMessage"
        }
    }

    public final class ColumnInfo: AWSDecodableShape {
        ///  The name of the result set column. The name of the result set is available for columns of all data types except for arrays.
        public let name: String?
        /// The data type of the result set column. The data type can be a scalar or complex. Scalar data types are integers, strings, doubles, Booleans, and others. Complex data types are types such as arrays, rows, and others.
        public let type: `Type`

        public init(name: String? = nil, type: `Type`) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct CreateScheduledQueryRequest: AWSEncodableShape {
        /// Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request.    If CreateScheduledQuery is called without a ClientToken, the Query SDK generates a ClientToken on your behalf.   After 8 hours, any request with the same ClientToken is treated as a new request.
        public let clientToken: String?
        /// Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
        public let errorReportConfiguration: ErrorReportConfiguration
        /// The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with alias/  If ErrorReportConfiguration uses SSE_KMS as encryption type, the same KmsKeyId is used to encrypt the error report at rest.
        public let kmsKeyId: String?
        /// Name of the scheduled query.
        public let name: String
        /// Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
        public let notificationConfiguration: NotificationConfiguration
        /// The query string to run. Parameter names can be specified in the query string @ character followed by an identifier. The named Parameter @scheduled_runtime is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of @scheduled_runtime paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the @scheduled_runtime parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
        public let queryString: String
        /// The schedule configuration for the query.
        public let scheduleConfiguration: ScheduleConfiguration
        /// The ARN for the IAM role that Timestream will assume when running the scheduled query.
        public let scheduledQueryExecutionRoleArn: String
        /// A list of key-value pairs to label the scheduled query.
        public let tags: [Tag]?
        /// Configuration used for writing the result of a query.
        public let targetConfiguration: TargetConfiguration?

        public init(clientToken: String? = CreateScheduledQueryRequest.idempotencyToken(), errorReportConfiguration: ErrorReportConfiguration, kmsKeyId: String? = nil, name: String, notificationConfiguration: NotificationConfiguration, queryString: String, scheduleConfiguration: ScheduleConfiguration, scheduledQueryExecutionRoleArn: String, tags: [Tag]? = nil, targetConfiguration: TargetConfiguration? = nil) {
            self.clientToken = clientToken
            self.errorReportConfiguration = errorReportConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.notificationConfiguration = notificationConfiguration
            self.queryString = queryString
            self.scheduleConfiguration = scheduleConfiguration
            self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
            self.tags = tags
            self.targetConfiguration = targetConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.errorReportConfiguration.validate(name: "\(name).errorReportConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.notificationConfiguration.validate(name: "\(name).notificationConfiguration")
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
            try self.scheduleConfiguration.validate(name: "\(name).scheduleConfiguration")
            try self.validate(self.scheduledQueryExecutionRoleArn, name: "scheduledQueryExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryExecutionRoleArn, name: "scheduledQueryExecutionRoleArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.targetConfiguration?.validate(name: "\(name).targetConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case notificationConfiguration = "NotificationConfiguration"
            case queryString = "QueryString"
            case scheduleConfiguration = "ScheduleConfiguration"
            case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
            case tags = "Tags"
            case targetConfiguration = "TargetConfiguration"
        }
    }

    public struct CreateScheduledQueryResponse: AWSDecodableShape {
        /// ARN for the created scheduled query.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct Datum: AWSDecodableShape {
        ///  Indicates if the data point is an array.
        public let arrayValue: [Datum]?
        ///  Indicates if the data point is null.
        public let nullValue: Bool?
        ///  Indicates if the data point is a row.
        public let rowValue: Row?
        ///  Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public let scalarValue: String?
        ///  Indicates if the data point is a timeseries data type.
        public let timeSeriesValue: [TimeSeriesDataPoint]?

        public init(arrayValue: [Datum]? = nil, nullValue: Bool? = nil, rowValue: Row? = nil, scalarValue: String? = nil, timeSeriesValue: [TimeSeriesDataPoint]? = nil) {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
            self.timeSeriesValue = timeSeriesValue
        }

        private enum CodingKeys: String, CodingKey {
            case arrayValue = "ArrayValue"
            case nullValue = "NullValue"
            case rowValue = "RowValue"
            case scalarValue = "ScalarValue"
            case timeSeriesValue = "TimeSeriesValue"
        }
    }

    public struct DeleteScheduledQueryRequest: AWSEncodableShape {
        /// The ARN of the scheduled query.
        public let scheduledQueryArn: String

        public init(scheduledQueryArn: String) {
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct DescribeEndpointsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// An Endpoints object is returned when a DescribeEndpoints request is made.
        public let endpoints: [Endpoint]

        public init(endpoints: [Endpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct DescribeScheduledQueryRequest: AWSEncodableShape {
        /// The ARN of the scheduled query.
        public let scheduledQueryArn: String

        public init(scheduledQueryArn: String) {
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct DescribeScheduledQueryResponse: AWSDecodableShape {
        /// The scheduled query.
        public let scheduledQuery: ScheduledQueryDescription

        public init(scheduledQuery: ScheduledQueryDescription) {
            self.scheduledQuery = scheduledQuery
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQuery = "ScheduledQuery"
        }
    }

    public struct DimensionMapping: AWSEncodableShape & AWSDecodableShape {
        /// Type for the dimension.
        public let dimensionValueType: DimensionValueType
        /// Column name from query result.
        public let name: String

        public init(dimensionValueType: DimensionValueType, name: String) {
            self.dimensionValueType = dimensionValueType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueType = "DimensionValueType"
            case name = "Name"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// An endpoint address.
        public let address: String
        /// The TTL for the endpoint, in minutes.
        public let cachePeriodInMinutes: Int64

        public init(address: String, cachePeriodInMinutes: Int64) {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case cachePeriodInMinutes = "CachePeriodInMinutes"
        }
    }

    public struct ErrorReportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 configuration for the error reports.
        public let s3Configuration: S3Configuration

        public init(s3Configuration: S3Configuration) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }

    public struct ErrorReportLocation: AWSDecodableShape {
        /// The S3 location where error reports are written.
        public let s3ReportLocation: S3ReportLocation?

        public init(s3ReportLocation: S3ReportLocation? = nil) {
            self.s3ReportLocation = s3ReportLocation
        }

        private enum CodingKeys: String, CodingKey {
            case s3ReportLocation = "S3ReportLocation"
        }
    }

    public struct ExecuteScheduledQueryRequest: AWSEncodableShape {
        /// Not used.
        public let clientToken: String?
        /// The timestamp in UTC. Query will be run as if it was invoked at this timestamp.
        public let invocationTime: Date
        /// ARN of the scheduled query.
        public let scheduledQueryArn: String

        public init(clientToken: String? = ExecuteScheduledQueryRequest.idempotencyToken(), invocationTime: Date, scheduledQueryArn: String) {
            self.clientToken = clientToken
            self.invocationTime = invocationTime
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case invocationTime = "InvocationTime"
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct ExecutionStats: AWSDecodableShape {
        /// Bytes metered for a single scheduled query run.
        public let bytesMetered: Int64?
        /// Data writes metered for records ingested in a single scheduled query run.
        public let dataWrites: Int64?
        /// Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        public let executionTimeInMillis: Int64?
        /// Number of rows present in the output from running a query before ingestion to destination data source.
        public let queryResultRows: Int64?
        /// The number of records ingested for a single scheduled query run.
        public let recordsIngested: Int64?

        public init(bytesMetered: Int64? = nil, dataWrites: Int64? = nil, executionTimeInMillis: Int64? = nil, queryResultRows: Int64? = nil, recordsIngested: Int64? = nil) {
            self.bytesMetered = bytesMetered
            self.dataWrites = dataWrites
            self.executionTimeInMillis = executionTimeInMillis
            self.queryResultRows = queryResultRows
            self.recordsIngested = recordsIngested
        }

        private enum CodingKeys: String, CodingKey {
            case bytesMetered = "BytesMetered"
            case dataWrites = "DataWrites"
            case executionTimeInMillis = "ExecutionTimeInMillis"
            case queryResultRows = "QueryResultRows"
            case recordsIngested = "RecordsIngested"
        }
    }

    public struct ListScheduledQueriesRequest: AWSEncodableShape {
        /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as the argument to the subsequent call to ListScheduledQueriesRequest.
        public let maxResults: Int?
        ///  A pagination token to resume pagination.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListScheduledQueriesResponse: AWSDecodableShape {
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// A list of scheduled queries.
        public let scheduledQueries: [ScheduledQuery]

        public init(nextToken: String? = nil, scheduledQueries: [ScheduledQuery]) {
            self.nextToken = nextToken
            self.scheduledQueries = scheduledQueries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case scheduledQueries = "ScheduledQueries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of tags to return.
        public let maxResults: Int?
        /// A pagination token to resume pagination.
        public let nextToken: String?
        /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A pagination token to resume pagination with a subsequent call to ListTagsForResourceResponse.
        public let nextToken: String?
        /// The tags currently associated with the Timestream resource.
        public let tags: [Tag]

        public init(nextToken: String? = nil, tags: [Tag]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MixedMeasureMapping: AWSEncodableShape & AWSDecodableShape {
        /// Refers to the value of measure_name in a result row. This field is required if MeasureNameColumn is provided.
        public let measureName: String?
        /// Type of the value that is to be read from sourceColumn. If the mapping is for MULTI, use MeasureValueType.MULTI.
        public let measureValueType: MeasureValueType
        /// Required when measureValueType is MULTI. Attribute mappings for MULTI value measures.
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]?
        /// This field refers to the source column from which measure-value is to be read for result materialization.
        public let sourceColumn: String?
        /// Target measure name to be used. If not provided, the target measure name by default would be measure-name if provided, or sourceColumn otherwise.
        public let targetMeasureName: String?

        public init(measureName: String? = nil, measureValueType: MeasureValueType, multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]? = nil, sourceColumn: String? = nil, targetMeasureName: String? = nil) {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }

        public func validate(name: String) throws {
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case measureName = "MeasureName"
            case measureValueType = "MeasureValueType"
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case sourceColumn = "SourceColumn"
            case targetMeasureName = "TargetMeasureName"
        }
    }

    public struct MultiMeasureAttributeMapping: AWSEncodableShape & AWSDecodableShape {
        /// Type of the attribute to be read from the source column.
        public let measureValueType: ScalarMeasureValueType
        /// Source column from where the attribute value is to be read.
        public let sourceColumn: String
        /// Custom name to be used for attribute name in derived table. If not provided, source column name would be used.
        public let targetMultiMeasureAttributeName: String?

        public init(measureValueType: ScalarMeasureValueType, sourceColumn: String, targetMultiMeasureAttributeName: String? = nil) {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case measureValueType = "MeasureValueType"
            case sourceColumn = "SourceColumn"
            case targetMultiMeasureAttributeName = "TargetMultiMeasureAttributeName"
        }
    }

    public struct MultiMeasureMappings: AWSEncodableShape & AWSDecodableShape {
        /// Required. Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes.
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]
        /// The name of the target multi-measure name in the derived table. This input is required when measureNameColumn is not provided. If MeasureNameColumn is provided, then value from that column will be used as multi-measure name.
        public let targetMultiMeasureName: String?

        public init(multiMeasureAttributeMappings: [MultiMeasureAttributeMapping], targetMultiMeasureName: String? = nil) {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }

        public func validate(name: String) throws {
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case targetMultiMeasureName = "TargetMultiMeasureName"
        }
    }

    public struct NotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details on SNS configuration.
        public let snsConfiguration: SnsConfiguration

        public init(snsConfiguration: SnsConfiguration) {
            self.snsConfiguration = snsConfiguration
        }

        public func validate(name: String) throws {
            try self.snsConfiguration.validate(name: "\(name).snsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case snsConfiguration = "SnsConfiguration"
        }
    }

    public struct ParameterMapping: AWSDecodableShape {
        /// Parameter name.
        public let name: String
        public let type: `Type`

        public init(name: String, type: `Type`) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct PrepareQueryRequest: AWSEncodableShape {
        /// The Timestream query string that you want to use as a prepared statement. Parameter names can be specified in the query string @ character followed by an identifier.
        public let queryString: String
        /// By setting this value to true, Timestream will only validate that the query string is a valid Timestream query, and not store the prepared query for later use.
        public let validateOnly: Bool?

        public init(queryString: String, validateOnly: Bool? = nil) {
            self.queryString = queryString
            self.validateOnly = validateOnly
        }

        public func validate(name: String) throws {
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queryString = "QueryString"
            case validateOnly = "ValidateOnly"
        }
    }

    public struct PrepareQueryResponse: AWSDecodableShape {
        /// A list of SELECT clause columns of the submitted query string.
        public let columns: [SelectColumn]
        /// A list of parameters used in the submitted query string.
        public let parameters: [ParameterMapping]
        /// The query string that you want prepare.
        public let queryString: String

        public init(columns: [SelectColumn], parameters: [ParameterMapping], queryString: String) {
            self.columns = columns
            self.parameters = parameters
            self.queryString = queryString
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case parameters = "Parameters"
            case queryString = "QueryString"
        }
    }

    public struct QueryRequest: AWSEncodableShape {
        ///  Unique, case-sensitive string of up to 64 ASCII characters specified when a Query request is made. Providing a ClientToken makes the call to Query idempotent. This means that running the same query repeatedly will produce the same result. In other words, making multiple identical Query requests has the same effect as making a single request. When using ClientToken in a query, note the following:    If the Query API is instantiated without a ClientToken, the Query SDK generates a ClientToken on your behalf.   If the Query invocation only contains the ClientToken but does not include a NextToken, that invocation of Query is assumed to be a new query run.   If the invocation contains NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to the Query API, and a result set is returned.   After 4 hours, any request with the same ClientToken is treated as a new request.
        public let clientToken: String?
        ///  The total number of rows to be returned in the Query output. The initial run of Query with a MaxRows value specified will return the result set of the query in two cases:    The size of the result is less than 1MB.   The number of rows in the result set is less than the value of maxRows.   Otherwise, the initial invocation of Query only returns a NextToken, which can then be used in subsequent calls to fetch the result set. To resume pagination, provide the NextToken value in the subsequent command. If the row size is large (e.g. a row has many columns), Timestream may return fewer rows to keep the response size from exceeding the 1 MB limit. If MaxRows is not provided, Timestream will send the necessary number of rows to meet the 1 MB limit.
        public let maxRows: Int?
        ///  A pagination token used to return a set of results. When the Query API is invoked using NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to Query, and a result set is returned. However, if the Query invocation only contains the ClientToken, that invocation of Query is assumed to be a new query run.  Note the following when using NextToken in a query:   A pagination token can be used for up to five Query invocations, OR for a duration of up to 1 hour – whichever comes first.   Using the same NextToken will return the same set of records. To keep paginating through the result set, you must to use the most recent nextToken.   Suppose a Query invocation returns two NextToken values, TokenA and TokenB. If TokenB is used in a subsequent Query invocation, then TokenA is invalidated and cannot be reused.   To request a previous result set from a query after pagination has begun, you must re-invoke the Query API.   The latest NextToken should be used to paginate until null is returned, at which point a new NextToken should be used.   If the IAM principal of the query initiator and the result reader are not the same and/or the query initiator and the result reader do not have the same query string in the query requests, the query will fail with an Invalid pagination token error.
        public let nextToken: String?
        ///  The query to be run by Timestream.
        public let queryString: String

        public init(clientToken: String? = QueryRequest.idempotencyToken(), maxRows: Int? = nil, nextToken: String? = nil, queryString: String) {
            self.clientToken = clientToken
            self.maxRows = maxRows
            self.nextToken = nextToken
            self.queryString = queryString
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.maxRows, name: "maxRows", parent: name, max: 1000)
            try self.validate(self.maxRows, name: "maxRows", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case maxRows = "MaxRows"
            case nextToken = "NextToken"
            case queryString = "QueryString"
        }
    }

    public struct QueryResponse: AWSDecodableShape {
        ///  The column data types of the returned result set.
        public let columnInfo: [ColumnInfo]
        ///  A pagination token that can be used again on a Query call to get the next set of results.
        public let nextToken: String?
        ///  A unique ID for the given query.
        public let queryId: String
        /// Information about the status of the query, including progress and bytes scanned.
        public let queryStatus: QueryStatus?
        ///  The result set rows returned by the query.
        public let rows: [Row]

        public init(columnInfo: [ColumnInfo], nextToken: String? = nil, queryId: String, queryStatus: QueryStatus? = nil, rows: [Row]) {
            self.columnInfo = columnInfo
            self.nextToken = nextToken
            self.queryId = queryId
            self.queryStatus = queryStatus
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columnInfo = "ColumnInfo"
            case nextToken = "NextToken"
            case queryId = "QueryId"
            case queryStatus = "QueryStatus"
            case rows = "Rows"
        }
    }

    public struct QueryStatus: AWSDecodableShape {
        /// The amount of data scanned by the query in bytes that you will be charged for. This is a cumulative sum and represents the total amount of data that you will be charged for since the query was started. The charge is applied only once and is either applied when the query completes running or when the query is cancelled.
        public let cumulativeBytesMetered: Int64?
        /// The amount of data scanned by the query in bytes. This is a cumulative sum and represents the total amount of bytes scanned since the query was started.
        public let cumulativeBytesScanned: Int64?
        /// The progress of the query, expressed as a percentage.
        public let progressPercentage: Double?

        public init(cumulativeBytesMetered: Int64? = nil, cumulativeBytesScanned: Int64? = nil, progressPercentage: Double? = nil) {
            self.cumulativeBytesMetered = cumulativeBytesMetered
            self.cumulativeBytesScanned = cumulativeBytesScanned
            self.progressPercentage = progressPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cumulativeBytesMetered = "CumulativeBytesMetered"
            case cumulativeBytesScanned = "CumulativeBytesScanned"
            case progressPercentage = "ProgressPercentage"
        }
    }

    public struct Row: AWSDecodableShape {
        /// List of data points in a single row of the result set.
        public let data: [Datum]

        public init(data: [Datum]) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        ///  Name of the S3 bucket under which error reports will be created.
        public let bucketName: String
        ///  Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose SSE_S3 as default.
        public let encryptionOption: S3EncryptionOption?
        ///  Prefix for the error report key. Timestream by default adds the following prefix to the error report path.
        public let objectKeyPrefix: String?

        public init(bucketName: String, encryptionOption: S3EncryptionOption? = nil, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 896)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case encryptionOption = "EncryptionOption"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct S3ReportLocation: AWSDecodableShape {
        ///  S3 bucket name.
        public let bucketName: String?
        /// S3 key.
        public let objectKey: String?

        public init(bucketName: String? = nil, objectKey: String? = nil) {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKey = "ObjectKey"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An expression that denotes when to trigger the scheduled query run. This can be a cron expression or a rate expression.
        public let scheduleExpression: String

        public init(scheduleExpression: String) {
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct ScheduledQuery: AWSDecodableShape {
        /// The Amazon Resource Name.
        public let arn: String
        /// The creation time of the scheduled query.
        public let creationTime: Date?
        /// Configuration for scheduled query error reporting.
        public let errorReportConfiguration: ErrorReportConfiguration?
        /// Status of the last scheduled query run.
        public let lastRunStatus: ScheduledQueryRunStatus?
        /// The name of the scheduled query.
        public let name: String
        /// The next time the scheduled query is to be run.
        public let nextInvocationTime: Date?
        /// The last time the scheduled query was run.
        public let previousInvocationTime: Date?
        /// State of scheduled query.
        public let state: ScheduledQueryState
        /// Target data source where final scheduled query result will be written.
        public let targetDestination: TargetDestination?

        public init(arn: String, creationTime: Date? = nil, errorReportConfiguration: ErrorReportConfiguration? = nil, lastRunStatus: ScheduledQueryRunStatus? = nil, name: String, nextInvocationTime: Date? = nil, previousInvocationTime: Date? = nil, state: ScheduledQueryState, targetDestination: TargetDestination? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.previousInvocationTime = previousInvocationTime
            self.state = state
            self.targetDestination = targetDestination
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case lastRunStatus = "LastRunStatus"
            case name = "Name"
            case nextInvocationTime = "NextInvocationTime"
            case previousInvocationTime = "PreviousInvocationTime"
            case state = "State"
            case targetDestination = "TargetDestination"
        }
    }

    public struct ScheduledQueryDescription: AWSDecodableShape {
        /// Scheduled query ARN.
        public let arn: String
        /// Creation time of the scheduled query.
        public let creationTime: Date?
        /// Error-reporting configuration for the scheduled query.
        public let errorReportConfiguration: ErrorReportConfiguration?
        /// A customer provided KMS key used to encrypt the scheduled query resource.
        public let kmsKeyId: String?
        /// Runtime summary for the last scheduled query run.
        public let lastRunSummary: ScheduledQueryRunSummary?
        /// Name of the scheduled query.
        public let name: String
        /// The next time the scheduled query is scheduled to run.
        public let nextInvocationTime: Date?
        /// Notification configuration.
        public let notificationConfiguration: NotificationConfiguration
        /// Last time the query was run.
        public let previousInvocationTime: Date?
        /// The query to be run.
        public let queryString: String
        /// Runtime summary for the last five failed scheduled query runs.
        public let recentlyFailedRuns: [ScheduledQueryRunSummary]?
        /// Schedule configuration.
        public let scheduleConfiguration: ScheduleConfiguration
        /// IAM role that Timestream uses to run the schedule query.
        public let scheduledQueryExecutionRoleArn: String?
        /// State of the scheduled query.
        public let state: ScheduledQueryState
        /// Scheduled query target store configuration.
        public let targetConfiguration: TargetConfiguration?

        public init(arn: String, creationTime: Date? = nil, errorReportConfiguration: ErrorReportConfiguration? = nil, kmsKeyId: String? = nil, lastRunSummary: ScheduledQueryRunSummary? = nil, name: String, nextInvocationTime: Date? = nil, notificationConfiguration: NotificationConfiguration, previousInvocationTime: Date? = nil, queryString: String, recentlyFailedRuns: [ScheduledQueryRunSummary]? = nil, scheduleConfiguration: ScheduleConfiguration, scheduledQueryExecutionRoleArn: String? = nil, state: ScheduledQueryState, targetConfiguration: TargetConfiguration? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.kmsKeyId = kmsKeyId
            self.lastRunSummary = lastRunSummary
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.notificationConfiguration = notificationConfiguration
            self.previousInvocationTime = previousInvocationTime
            self.queryString = queryString
            self.recentlyFailedRuns = recentlyFailedRuns
            self.scheduleConfiguration = scheduleConfiguration
            self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
            self.state = state
            self.targetConfiguration = targetConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case kmsKeyId = "KmsKeyId"
            case lastRunSummary = "LastRunSummary"
            case name = "Name"
            case nextInvocationTime = "NextInvocationTime"
            case notificationConfiguration = "NotificationConfiguration"
            case previousInvocationTime = "PreviousInvocationTime"
            case queryString = "QueryString"
            case recentlyFailedRuns = "RecentlyFailedRuns"
            case scheduleConfiguration = "ScheduleConfiguration"
            case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
            case state = "State"
            case targetConfiguration = "TargetConfiguration"
        }
    }

    public struct ScheduledQueryRunSummary: AWSDecodableShape {
        /// S3 location for error report.
        public let errorReportLocation: ErrorReportLocation?
        /// Runtime statistics for a scheduled run.
        public let executionStats: ExecutionStats?
        /// Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        public let failureReason: String?
        /// InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter @scheduled_runtime can be used in the query to get the value.
        public let invocationTime: Date?
        /// The status of a scheduled query run.
        public let runStatus: ScheduledQueryRunStatus?
        /// The actual time when the query was run.
        public let triggerTime: Date?

        public init(errorReportLocation: ErrorReportLocation? = nil, executionStats: ExecutionStats? = nil, failureReason: String? = nil, invocationTime: Date? = nil, runStatus: ScheduledQueryRunStatus? = nil, triggerTime: Date? = nil) {
            self.errorReportLocation = errorReportLocation
            self.executionStats = executionStats
            self.failureReason = failureReason
            self.invocationTime = invocationTime
            self.runStatus = runStatus
            self.triggerTime = triggerTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorReportLocation = "ErrorReportLocation"
            case executionStats = "ExecutionStats"
            case failureReason = "FailureReason"
            case invocationTime = "InvocationTime"
            case runStatus = "RunStatus"
            case triggerTime = "TriggerTime"
        }
    }

    public struct SelectColumn: AWSDecodableShape {
        /// True, if the column name was aliased by the query. False otherwise.
        public let aliased: Bool?
        ///  Database that has this column.
        public let databaseName: String?
        /// Name of the column.
        public let name: String?
        /// Table within the database that has this column.
        public let tableName: String?
        public let type: `Type`?

        public init(aliased: Bool? = nil, databaseName: String? = nil, name: String? = nil, tableName: String? = nil, type: `Type`? = nil) {
            self.aliased = aliased
            self.databaseName = databaseName
            self.name = name
            self.tableName = tableName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aliased = "Aliased"
            case databaseName = "DatabaseName"
            case name = "Name"
            case tableName = "TableName"
            case type = "Type"
        }
    }

    public struct SnsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// SNS topic ARN that the scheduled query status notifications will be sent to.
        public let topicArn: String

        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 2048)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag. Tag keys are case sensitive.
        public let key: String
        /// The value of the tag. Tag values are case sensitive and can be null.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        /// The tags to be assigned to the Timestream resource.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration needed to write data into the Timestream database and table.
        public let timestreamConfiguration: TimestreamConfiguration

        public init(timestreamConfiguration: TimestreamConfiguration) {
            self.timestreamConfiguration = timestreamConfiguration
        }

        public func validate(name: String) throws {
            try self.timestreamConfiguration.validate(name: "\(name).timestreamConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamConfiguration = "TimestreamConfiguration"
        }
    }

    public struct TargetDestination: AWSDecodableShape {
        /// Query result destination details for Timestream data source.
        public let timestreamDestination: TimestreamDestination?

        public init(timestreamDestination: TimestreamDestination? = nil) {
            self.timestreamDestination = timestreamDestination
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamDestination = "TimestreamDestination"
        }
    }

    public struct TimeSeriesDataPoint: AWSDecodableShape {
        /// The timestamp when the measure value was collected.
        public let time: String
        /// The measure value for the data point.
        public let value: Datum

        public init(time: String, value: Datum) {
            self.time = time
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case time = "Time"
            case value = "Value"
        }
    }

    public struct TimestreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Name of Timestream database to which the query result will be written.
        public let databaseName: String
        ///  This is to allow mapping column(s) from the query result to the dimension in the destination table.
        public let dimensionMappings: [DimensionMapping]
        /// Name of the measure column.
        public let measureNameColumn: String?
        /// Specifies how to map measures to multi-measure records.
        public let mixedMeasureMappings: [MixedMeasureMapping]?
        /// Multi-measure mappings.
        public let multiMeasureMappings: MultiMeasureMappings?
        /// Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        public let tableName: String
        /// Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        public let timeColumn: String

        public init(databaseName: String, dimensionMappings: [DimensionMapping], measureNameColumn: String? = nil, mixedMeasureMappings: [MixedMeasureMapping]? = nil, multiMeasureMappings: MultiMeasureMappings? = nil, tableName: String, timeColumn: String) {
            self.databaseName = databaseName
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.tableName = tableName
            self.timeColumn = timeColumn
        }

        public func validate(name: String) throws {
            try self.mixedMeasureMappings?.forEach {
                try $0.validate(name: "\(name).mixedMeasureMappings[]")
            }
            try self.validate(self.mixedMeasureMappings, name: "mixedMeasureMappings", parent: name, min: 1)
            try self.multiMeasureMappings?.validate(name: "\(name).multiMeasureMappings")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case dimensionMappings = "DimensionMappings"
            case measureNameColumn = "MeasureNameColumn"
            case mixedMeasureMappings = "MixedMeasureMappings"
            case multiMeasureMappings = "MultiMeasureMappings"
            case tableName = "TableName"
            case timeColumn = "TimeColumn"
        }
    }

    public struct TimestreamDestination: AWSDecodableShape {
        /// Timestream database name.
        public let databaseName: String?
        /// Timestream table name.
        public let tableName: String?

        public init(databaseName: String? = nil, tableName: String? = nil) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public final class `Type`: AWSDecodableShape {
        /// Indicates if the column is an array.
        public let arrayColumnInfo: ColumnInfo?
        /// Indicates if the column is a row.
        public let rowColumnInfo: [ColumnInfo]?
        /// Indicates if the column is of type string, integer, Boolean, double, timestamp, date, time. For more information, see Supported data types.
        public let scalarType: ScalarType?
        /// Indicates if the column is a timeseries data type.
        public let timeSeriesMeasureValueColumnInfo: ColumnInfo?

        public init(arrayColumnInfo: ColumnInfo? = nil, rowColumnInfo: [ColumnInfo]? = nil, scalarType: ScalarType? = nil, timeSeriesMeasureValueColumnInfo: ColumnInfo? = nil) {
            self.arrayColumnInfo = arrayColumnInfo
            self.rowColumnInfo = rowColumnInfo
            self.scalarType = scalarType
            self.timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo
        }

        private enum CodingKeys: String, CodingKey {
            case arrayColumnInfo = "ArrayColumnInfo"
            case rowColumnInfo = "RowColumnInfo"
            case scalarType = "ScalarType"
            case timeSeriesMeasureValueColumnInfo = "TimeSeriesMeasureValueColumnInfo"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        /// A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateScheduledQueryRequest: AWSEncodableShape {
        /// ARN of the scheuled query.
        public let scheduledQueryArn: String
        /// State of the scheduled query.
        public let state: ScheduledQueryState

        public init(scheduledQueryArn: String, state: ScheduledQueryState) {
            self.scheduledQueryArn = scheduledQueryArn
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
            case state = "State"
        }
    }
}

// MARK: - Errors

/// Error enum for TimestreamQuery
public struct TimestreamQueryErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidEndpointException = "InvalidEndpointException"
        case queryExecutionException = "QueryExecutionException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize TimestreamQuery
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You are not authorized to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  Unable to poll results for a cancelled query.
    public static var conflictException: Self { .init(.conflictException) }
    ///  Timestream was unable to fully process this request because of an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested endpoint was not valid.
    public static var invalidEndpointException: Self { .init(.invalidEndpointException) }
    ///  Timestream was unable to run the query successfully.
    public static var queryExecutionException: Self { .init(.queryExecutionException) }
    /// The requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  Invalid or malformed request.
    public static var validationException: Self { .init(.validationException) }
}

extension TimestreamQueryErrorType: Equatable {
    public static func == (lhs: TimestreamQueryErrorType, rhs: TimestreamQueryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TimestreamQueryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
