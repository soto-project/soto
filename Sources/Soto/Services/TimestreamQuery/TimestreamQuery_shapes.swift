//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension TimestreamQuery {
    // MARK: Enums

    public enum ComputeMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "ON_DEMAND"
        case provisioned = "PROVISIONED"
        public var description: String { return self.rawValue }
    }

    public enum DimensionValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum MeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case multi = "MULTI"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum QueryInsightsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabledWithRateControl = "ENABLED_WITH_RATE_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum QueryPricingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bytesScanned = "BYTES_SCANNED"
        case computeUnits = "COMPUTE_UNITS"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sseKms = "SSE_KMS"
        case sseS3 = "SSE_S3"
        public var description: String { return self.rawValue }
    }

    public enum ScalarMeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case timestamp = "TIMESTAMP"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum ScalarType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case date = "DATE"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case intervalDayToSecond = "INTERVAL_DAY_TO_SECOND"
        case intervalYearToMonth = "INTERVAL_YEAR_TO_MONTH"
        case time = "TIME"
        case timestamp = "TIMESTAMP"
        case unknown = "UNKNOWN"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledQueryInsightsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabledWithRateControl = "ENABLED_WITH_RATE_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledQueryRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoTriggerFailure = "AUTO_TRIGGER_FAILURE"
        case autoTriggerSuccess = "AUTO_TRIGGER_SUCCESS"
        case manualTriggerFailure = "MANUAL_TRIGGER_FAILURE"
        case manualTriggerSuccess = "MANUAL_TRIGGER_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledQueryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountSettingsNotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that grants Timestream permission to publish notifications. This field is only visible if SNS Topic is provided when updating the account settings.
        public let roleArn: String
        public let snsConfiguration: SnsConfiguration?

        @inlinable
        public init(roleArn: String, snsConfiguration: SnsConfiguration? = nil) {
            self.roleArn = roleArn
            self.snsConfiguration = snsConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.snsConfiguration?.validate(name: "\(name).snsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case snsConfiguration = "SnsConfiguration"
        }
    }

    public struct CancelQueryRequest: AWSEncodableShape {
        ///  The ID of the query that needs to be cancelled. QueryID is returned as part of the query result.
        public let queryId: String

        @inlinable
        public init(queryId: String) {
            self.queryId = queryId
        }

        public func validate(name: String) throws {
            try self.validate(self.queryId, name: "queryId", parent: name, max: 64)
            try self.validate(self.queryId, name: "queryId", parent: name, min: 1)
            try self.validate(self.queryId, name: "queryId", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "QueryId"
        }
    }

    public struct CancelQueryResponse: AWSDecodableShape {
        ///  A CancellationMessage is returned when a CancelQuery request for the query specified by QueryId has already been issued.
        public let cancellationMessage: String?

        @inlinable
        public init(cancellationMessage: String? = nil) {
            self.cancellationMessage = cancellationMessage
        }

        private enum CodingKeys: String, CodingKey {
            case cancellationMessage = "CancellationMessage"
        }
    }

    public final class ColumnInfo: AWSDecodableShape {
        ///  The name of the result set column. The name of the result set is available for columns of all data types except for arrays.
        public let name: String?
        /// The data type of the result set column. The data type can be a scalar or complex. Scalar data types are integers, strings, doubles, Booleans, and others. Complex data types are types such as arrays, rows, and others.
        public let type: `Type`

        @inlinable
        public init(name: String? = nil, type: `Type`) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct CreateScheduledQueryRequest: AWSEncodableShape {
        /// Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request.    If CreateScheduledQuery is called without a ClientToken, the Query SDK generates a ClientToken on your behalf.   After 8 hours, any request with the same ClientToken is treated as a new request.
        public let clientToken: String?
        /// Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
        public let errorReportConfiguration: ErrorReportConfiguration
        /// The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with alias/  If ErrorReportConfiguration uses SSE_KMS as encryption type, the same KmsKeyId is used to encrypt the error report at rest.
        public let kmsKeyId: String?
        /// Name of the scheduled query.
        public let name: String
        /// Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
        public let notificationConfiguration: NotificationConfiguration
        /// The query string to run. Parameter names can be specified in the query string @ character followed by an identifier. The named Parameter @scheduled_runtime is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of @scheduled_runtime paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the @scheduled_runtime parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
        public let queryString: String
        /// The schedule configuration for the query.
        public let scheduleConfiguration: ScheduleConfiguration
        /// The ARN for the IAM role that Timestream will assume when running the scheduled query.
        public let scheduledQueryExecutionRoleArn: String
        /// A list of key-value pairs to label the scheduled query.
        public let tags: [Tag]?
        /// Configuration used for writing the result of a query.
        public let targetConfiguration: TargetConfiguration?

        @inlinable
        public init(clientToken: String? = CreateScheduledQueryRequest.idempotencyToken(), errorReportConfiguration: ErrorReportConfiguration, kmsKeyId: String? = nil, name: String, notificationConfiguration: NotificationConfiguration, queryString: String, scheduleConfiguration: ScheduleConfiguration, scheduledQueryExecutionRoleArn: String, tags: [Tag]? = nil, targetConfiguration: TargetConfiguration? = nil) {
            self.clientToken = clientToken
            self.errorReportConfiguration = errorReportConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.notificationConfiguration = notificationConfiguration
            self.queryString = queryString
            self.scheduleConfiguration = scheduleConfiguration
            self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
            self.tags = tags
            self.targetConfiguration = targetConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.errorReportConfiguration.validate(name: "\(name).errorReportConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
            try self.notificationConfiguration.validate(name: "\(name).notificationConfiguration")
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
            try self.scheduleConfiguration.validate(name: "\(name).scheduleConfiguration")
            try self.validate(self.scheduledQueryExecutionRoleArn, name: "scheduledQueryExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryExecutionRoleArn, name: "scheduledQueryExecutionRoleArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.targetConfiguration?.validate(name: "\(name).targetConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case notificationConfiguration = "NotificationConfiguration"
            case queryString = "QueryString"
            case scheduleConfiguration = "ScheduleConfiguration"
            case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
            case tags = "Tags"
            case targetConfiguration = "TargetConfiguration"
        }
    }

    public struct CreateScheduledQueryResponse: AWSDecodableShape {
        /// ARN for the created scheduled query.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct Datum: AWSDecodableShape {
        ///  Indicates if the data point is an array.
        public let arrayValue: [Datum]?
        ///  Indicates if the data point is null.
        public let nullValue: Bool?
        ///  Indicates if the data point is a row.
        public let rowValue: Row?
        ///  Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public let scalarValue: String?
        ///  Indicates if the data point is a timeseries data type.
        public let timeSeriesValue: [TimeSeriesDataPoint]?

        @inlinable
        public init(arrayValue: [Datum]? = nil, nullValue: Bool? = nil, rowValue: Row? = nil, scalarValue: String? = nil, timeSeriesValue: [TimeSeriesDataPoint]? = nil) {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
            self.timeSeriesValue = timeSeriesValue
        }

        private enum CodingKeys: String, CodingKey {
            case arrayValue = "ArrayValue"
            case nullValue = "NullValue"
            case rowValue = "RowValue"
            case scalarValue = "ScalarValue"
            case timeSeriesValue = "TimeSeriesValue"
        }
    }

    public struct DeleteScheduledQueryRequest: AWSEncodableShape {
        /// The ARN of the scheduled query.
        public let scheduledQueryArn: String

        @inlinable
        public init(scheduledQueryArn: String) {
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct DescribeAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeAccountSettingsResponse: AWSDecodableShape {
        /// The maximum number of Timestream compute units (TCUs) the service will use at any point in time to serve your queries. To run queries, you must set a minimum capacity of 4 TCU. You can set the maximum number of TCU in multiples of 4, for example, 4, 8, 16, 32, and so on. This configuration is applicable only for on-demand usage of (TCUs).
        public let maxQueryTCU: Int?
        /// An object that contains the usage settings for Timestream Compute Units (TCUs) in your account for the query workload.
        public let queryCompute: QueryComputeResponse?
        /// The pricing model for queries in your account.  The QueryPricingModel parameter is used by several Timestream operations; however, the UpdateAccountSettings API operation doesn't recognize any values other than COMPUTE_UNITS.
        public let queryPricingModel: QueryPricingModel?

        @inlinable
        public init(maxQueryTCU: Int? = nil, queryCompute: QueryComputeResponse? = nil, queryPricingModel: QueryPricingModel? = nil) {
            self.maxQueryTCU = maxQueryTCU
            self.queryCompute = queryCompute
            self.queryPricingModel = queryPricingModel
        }

        private enum CodingKeys: String, CodingKey {
            case maxQueryTCU = "MaxQueryTCU"
            case queryCompute = "QueryCompute"
            case queryPricingModel = "QueryPricingModel"
        }
    }

    public struct DescribeEndpointsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// An Endpoints object is returned when a DescribeEndpoints request is made.
        public let endpoints: [Endpoint]

        @inlinable
        public init(endpoints: [Endpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct DescribeScheduledQueryRequest: AWSEncodableShape {
        /// The ARN of the scheduled query.
        public let scheduledQueryArn: String

        @inlinable
        public init(scheduledQueryArn: String) {
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct DescribeScheduledQueryResponse: AWSDecodableShape {
        /// The scheduled query.
        public let scheduledQuery: ScheduledQueryDescription

        @inlinable
        public init(scheduledQuery: ScheduledQueryDescription) {
            self.scheduledQuery = scheduledQuery
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQuery = "ScheduledQuery"
        }
    }

    public struct DimensionMapping: AWSEncodableShape & AWSDecodableShape {
        /// Type for the dimension.
        public let dimensionValueType: DimensionValueType
        /// Column name from query result.
        public let name: String

        @inlinable
        public init(dimensionValueType: DimensionValueType, name: String) {
            self.dimensionValueType = dimensionValueType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueType = "DimensionValueType"
            case name = "Name"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// An endpoint address.
        public let address: String
        /// The TTL for the endpoint, in minutes.
        public let cachePeriodInMinutes: Int64

        @inlinable
        public init(address: String, cachePeriodInMinutes: Int64) {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case cachePeriodInMinutes = "CachePeriodInMinutes"
        }
    }

    public struct ErrorReportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 configuration for the error reports.
        public let s3Configuration: S3Configuration

        @inlinable
        public init(s3Configuration: S3Configuration) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }

    public struct ErrorReportLocation: AWSDecodableShape {
        /// The S3 location where error reports are written.
        public let s3ReportLocation: S3ReportLocation?

        @inlinable
        public init(s3ReportLocation: S3ReportLocation? = nil) {
            self.s3ReportLocation = s3ReportLocation
        }

        private enum CodingKeys: String, CodingKey {
            case s3ReportLocation = "S3ReportLocation"
        }
    }

    public struct ExecuteScheduledQueryRequest: AWSEncodableShape {
        /// Not used.
        public let clientToken: String?
        /// The timestamp in UTC. Query will be run as if it was invoked at this timestamp.
        public let invocationTime: Date
        /// Encapsulates settings for enabling QueryInsights. Enabling QueryInsights returns insights and metrics as a part of the Amazon SNS notification for the query that you executed. You can use QueryInsights to tune your query performance and cost.
        public let queryInsights: ScheduledQueryInsights?
        /// ARN of the scheduled query.
        public let scheduledQueryArn: String

        @inlinable
        public init(clientToken: String? = ExecuteScheduledQueryRequest.idempotencyToken(), invocationTime: Date, queryInsights: ScheduledQueryInsights? = nil, scheduledQueryArn: String) {
            self.clientToken = clientToken
            self.invocationTime = invocationTime
            self.queryInsights = queryInsights
            self.scheduledQueryArn = scheduledQueryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case invocationTime = "InvocationTime"
            case queryInsights = "QueryInsights"
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct ExecutionStats: AWSDecodableShape {
        /// Bytes metered for a single scheduled query run.
        public let bytesMetered: Int64?
        /// Bytes scanned for a single scheduled query run.
        public let cumulativeBytesScanned: Int64?
        /// Data writes metered for records ingested in a single scheduled query run.
        public let dataWrites: Int64?
        /// Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        public let executionTimeInMillis: Int64?
        /// Number of rows present in the output from running a query before ingestion to destination data source.
        public let queryResultRows: Int64?
        /// The number of records ingested for a single scheduled query run.
        public let recordsIngested: Int64?

        @inlinable
        public init(bytesMetered: Int64? = nil, cumulativeBytesScanned: Int64? = nil, dataWrites: Int64? = nil, executionTimeInMillis: Int64? = nil, queryResultRows: Int64? = nil, recordsIngested: Int64? = nil) {
            self.bytesMetered = bytesMetered
            self.cumulativeBytesScanned = cumulativeBytesScanned
            self.dataWrites = dataWrites
            self.executionTimeInMillis = executionTimeInMillis
            self.queryResultRows = queryResultRows
            self.recordsIngested = recordsIngested
        }

        private enum CodingKeys: String, CodingKey {
            case bytesMetered = "BytesMetered"
            case cumulativeBytesScanned = "CumulativeBytesScanned"
            case dataWrites = "DataWrites"
            case executionTimeInMillis = "ExecutionTimeInMillis"
            case queryResultRows = "QueryResultRows"
            case recordsIngested = "RecordsIngested"
        }
    }

    public struct LastUpdate: AWSDecodableShape {
        /// The status of the last update. Can be either PENDING, FAILED, or SUCCEEDED.
        public let status: LastUpdateStatus?
        /// Error message describing the last account settings update status, visible only if an error occurred.
        public let statusMessage: String?
        /// The number of TimeStream Compute Units (TCUs) requested in the last account settings update.
        public let targetQueryTCU: Int?

        @inlinable
        public init(status: LastUpdateStatus? = nil, statusMessage: String? = nil, targetQueryTCU: Int? = nil) {
            self.status = status
            self.statusMessage = statusMessage
            self.targetQueryTCU = targetQueryTCU
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case statusMessage = "StatusMessage"
            case targetQueryTCU = "TargetQueryTCU"
        }
    }

    public struct ListScheduledQueriesRequest: AWSEncodableShape {
        /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as the argument to the subsequent call to ListScheduledQueriesRequest.
        public let maxResults: Int?
        ///  A pagination token to resume pagination.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListScheduledQueriesResponse: AWSDecodableShape {
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// A list of scheduled queries.
        public let scheduledQueries: [ScheduledQuery]

        @inlinable
        public init(nextToken: String? = nil, scheduledQueries: [ScheduledQuery]) {
            self.nextToken = nextToken
            self.scheduledQueries = scheduledQueries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case scheduledQueries = "ScheduledQueries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of tags to return.
        public let maxResults: Int?
        /// A pagination token to resume pagination.
        public let nextToken: String?
        /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A pagination token to resume pagination with a subsequent call to ListTagsForResourceResponse.
        public let nextToken: String?
        /// The tags currently associated with the Timestream resource.
        public let tags: [Tag]

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MixedMeasureMapping: AWSEncodableShape & AWSDecodableShape {
        /// Refers to the value of measure_name in a result row. This field is required if MeasureNameColumn is provided.
        public let measureName: String?
        /// Type of the value that is to be read from sourceColumn. If the mapping is for MULTI, use MeasureValueType.MULTI.
        public let measureValueType: MeasureValueType
        /// Required when measureValueType is MULTI. Attribute mappings for MULTI value measures.
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]?
        /// This field refers to the source column from which measure-value is to be read for result materialization.
        public let sourceColumn: String?
        /// Target measure name to be used. If not provided, the target measure name by default would be measure-name if provided, or sourceColumn otherwise.
        public let targetMeasureName: String?

        @inlinable
        public init(measureName: String? = nil, measureValueType: MeasureValueType, multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]? = nil, sourceColumn: String? = nil, targetMeasureName: String? = nil) {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }

        public func validate(name: String) throws {
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case measureName = "MeasureName"
            case measureValueType = "MeasureValueType"
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case sourceColumn = "SourceColumn"
            case targetMeasureName = "TargetMeasureName"
        }
    }

    public struct MultiMeasureAttributeMapping: AWSEncodableShape & AWSDecodableShape {
        /// Type of the attribute to be read from the source column.
        public let measureValueType: ScalarMeasureValueType
        /// Source column from where the attribute value is to be read.
        public let sourceColumn: String
        /// Custom name to be used for attribute name in derived table. If not provided, source column name would be used.
        public let targetMultiMeasureAttributeName: String?

        @inlinable
        public init(measureValueType: ScalarMeasureValueType, sourceColumn: String, targetMultiMeasureAttributeName: String? = nil) {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case measureValueType = "MeasureValueType"
            case sourceColumn = "SourceColumn"
            case targetMultiMeasureAttributeName = "TargetMultiMeasureAttributeName"
        }
    }

    public struct MultiMeasureMappings: AWSEncodableShape & AWSDecodableShape {
        /// Required. Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes.
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]
        /// The name of the target multi-measure name in the derived table. This input is required when measureNameColumn is not provided. If MeasureNameColumn is provided, then value from that column will be used as multi-measure name.
        public let targetMultiMeasureName: String?

        @inlinable
        public init(multiMeasureAttributeMappings: [MultiMeasureAttributeMapping], targetMultiMeasureName: String? = nil) {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }

        public func validate(name: String) throws {
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case targetMultiMeasureName = "TargetMultiMeasureName"
        }
    }

    public struct NotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about the Amazon Simple Notification Service (SNS) configuration. This field is visible only when SNS Topic is provided when updating the account settings.
        public let snsConfiguration: SnsConfiguration

        @inlinable
        public init(snsConfiguration: SnsConfiguration) {
            self.snsConfiguration = snsConfiguration
        }

        public func validate(name: String) throws {
            try self.snsConfiguration.validate(name: "\(name).snsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case snsConfiguration = "SnsConfiguration"
        }
    }

    public struct ParameterMapping: AWSDecodableShape {
        /// Parameter name.
        public let name: String
        public let type: `Type`

        @inlinable
        public init(name: String, type: `Type`) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct PrepareQueryRequest: AWSEncodableShape {
        /// The Timestream query string that you want to use as a prepared statement. Parameter names can be specified in the query string @ character followed by an identifier.
        public let queryString: String
        /// By setting this value to true, Timestream will only validate that the query string is a valid Timestream query, and not store the prepared query for later use.
        public let validateOnly: Bool?

        @inlinable
        public init(queryString: String, validateOnly: Bool? = nil) {
            self.queryString = queryString
            self.validateOnly = validateOnly
        }

        public func validate(name: String) throws {
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queryString = "QueryString"
            case validateOnly = "ValidateOnly"
        }
    }

    public struct PrepareQueryResponse: AWSDecodableShape {
        /// A list of SELECT clause columns of the submitted query string.
        public let columns: [SelectColumn]
        /// A list of parameters used in the submitted query string.
        public let parameters: [ParameterMapping]
        /// The query string that you want prepare.
        public let queryString: String

        @inlinable
        public init(columns: [SelectColumn], parameters: [ParameterMapping], queryString: String) {
            self.columns = columns
            self.parameters = parameters
            self.queryString = queryString
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case parameters = "Parameters"
            case queryString = "QueryString"
        }
    }

    public struct ProvisionedCapacityRequest: AWSEncodableShape {
        /// Configuration settings for notifications related to the provisioned capacity update.
        public let notificationConfiguration: AccountSettingsNotificationConfiguration?
        /// The target compute capacity for querying data, specified in Timestream Compute Units (TCUs).
        public let targetQueryTCU: Int

        @inlinable
        public init(notificationConfiguration: AccountSettingsNotificationConfiguration? = nil, targetQueryTCU: Int) {
            self.notificationConfiguration = notificationConfiguration
            self.targetQueryTCU = targetQueryTCU
        }

        public func validate(name: String) throws {
            try self.notificationConfiguration?.validate(name: "\(name).notificationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration = "NotificationConfiguration"
            case targetQueryTCU = "TargetQueryTCU"
        }
    }

    public struct ProvisionedCapacityResponse: AWSDecodableShape {
        /// The number of Timestream Compute Units (TCUs) provisioned in the account. This field is only visible when the compute mode is PROVISIONED.
        public let activeQueryTCU: Int?
        /// Information about the last update to the provisioned capacity settings.
        public let lastUpdate: LastUpdate?
        /// An object that contains settings for notifications that are sent whenever the provisioned capacity settings are modified. This field is only visible when the compute mode is PROVISIONED.
        public let notificationConfiguration: AccountSettingsNotificationConfiguration?

        @inlinable
        public init(activeQueryTCU: Int? = nil, lastUpdate: LastUpdate? = nil, notificationConfiguration: AccountSettingsNotificationConfiguration? = nil) {
            self.activeQueryTCU = activeQueryTCU
            self.lastUpdate = lastUpdate
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case activeQueryTCU = "ActiveQueryTCU"
            case lastUpdate = "LastUpdate"
            case notificationConfiguration = "NotificationConfiguration"
        }
    }

    public struct QueryComputeRequest: AWSEncodableShape {
        /// The mode in which Timestream Compute Units (TCUs) are allocated and utilized within an account. Note that in the Asia Pacific (Mumbai)  region, the API operation only recognizes the value PROVISIONED.
        public let computeMode: ComputeMode?
        /// Configuration object that contains settings for provisioned Timestream Compute Units (TCUs) in your account.
        public let provisionedCapacity: ProvisionedCapacityRequest?

        @inlinable
        public init(computeMode: ComputeMode? = nil, provisionedCapacity: ProvisionedCapacityRequest? = nil) {
            self.computeMode = computeMode
            self.provisionedCapacity = provisionedCapacity
        }

        public func validate(name: String) throws {
            try self.provisionedCapacity?.validate(name: "\(name).provisionedCapacity")
        }

        private enum CodingKeys: String, CodingKey {
            case computeMode = "ComputeMode"
            case provisionedCapacity = "ProvisionedCapacity"
        }
    }

    public struct QueryComputeResponse: AWSDecodableShape {
        /// The mode in which Timestream Compute Units (TCUs) are allocated and utilized within an account. Note that in the Asia Pacific (Mumbai)  region, the API operation only recognizes the value PROVISIONED.
        public let computeMode: ComputeMode?
        /// Configuration object that contains settings for provisioned Timestream Compute Units (TCUs) in your account.
        public let provisionedCapacity: ProvisionedCapacityResponse?

        @inlinable
        public init(computeMode: ComputeMode? = nil, provisionedCapacity: ProvisionedCapacityResponse? = nil) {
            self.computeMode = computeMode
            self.provisionedCapacity = provisionedCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case computeMode = "ComputeMode"
            case provisionedCapacity = "ProvisionedCapacity"
        }
    }

    public struct QueryInsights: AWSEncodableShape {
        /// Provides the following modes to enable QueryInsights:    ENABLED_WITH_RATE_CONTROL – Enables QueryInsights for the queries being processed. This mode also includes a rate control mechanism, which limits the QueryInsights feature to 1 query per second (QPS).    DISABLED – Disables QueryInsights.
        public let mode: QueryInsightsMode

        @inlinable
        public init(mode: QueryInsightsMode) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct QueryInsightsResponse: AWSDecodableShape {
        /// Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        public let outputBytes: Int64?
        /// Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        public let outputRows: Int64?
        /// Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        public let querySpatialCoverage: QuerySpatialCoverage?
        /// Indicates the number of tables in the query.
        public let queryTableCount: Int64?
        /// Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:   Add missing time-predicates.   Remove functions around the time predicates.   Add time predicates to all the sub-queries.
        public let queryTemporalRange: QueryTemporalRange?
        /// Indicates the partitions created by the Unload operation.
        public let unloadPartitionCount: Int64?
        /// Indicates the size, in bytes, written by the Unload operation.
        public let unloadWrittenBytes: Int64?
        /// Indicates the rows written by the Unload query.
        public let unloadWrittenRows: Int64?

        @inlinable
        public init(outputBytes: Int64? = nil, outputRows: Int64? = nil, querySpatialCoverage: QuerySpatialCoverage? = nil, queryTableCount: Int64? = nil, queryTemporalRange: QueryTemporalRange? = nil, unloadPartitionCount: Int64? = nil, unloadWrittenBytes: Int64? = nil, unloadWrittenRows: Int64? = nil) {
            self.outputBytes = outputBytes
            self.outputRows = outputRows
            self.querySpatialCoverage = querySpatialCoverage
            self.queryTableCount = queryTableCount
            self.queryTemporalRange = queryTemporalRange
            self.unloadPartitionCount = unloadPartitionCount
            self.unloadWrittenBytes = unloadWrittenBytes
            self.unloadWrittenRows = unloadWrittenRows
        }

        private enum CodingKeys: String, CodingKey {
            case outputBytes = "OutputBytes"
            case outputRows = "OutputRows"
            case querySpatialCoverage = "QuerySpatialCoverage"
            case queryTableCount = "QueryTableCount"
            case queryTemporalRange = "QueryTemporalRange"
            case unloadPartitionCount = "UnloadPartitionCount"
            case unloadWrittenBytes = "UnloadWrittenBytes"
            case unloadWrittenRows = "UnloadWrittenRows"
        }
    }

    public struct QueryRequest: AWSEncodableShape {
        ///  Unique, case-sensitive string of up to 64 ASCII characters specified when a Query request is made. Providing a ClientToken makes the call to Query idempotent. This means that running the same query repeatedly will produce the same result. In other words, making multiple identical Query requests has the same effect as making a single request. When using ClientToken in a query, note the following:    If the Query API is instantiated without a ClientToken, the Query SDK generates a ClientToken on your behalf.   If the Query invocation only contains the ClientToken but does not include a NextToken, that invocation of Query is assumed to be a new query run.   If the invocation contains NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to the Query API, and a result set is returned.   After 4 hours, any request with the same ClientToken is treated as a new request.
        public let clientToken: String?
        ///  The total number of rows to be returned in the Query output. The initial run of Query with a MaxRows value specified will return the result set of the query in two cases:    The size of the result is less than 1MB.   The number of rows in the result set is less than the value of maxRows.   Otherwise, the initial invocation of Query only returns a NextToken, which can then be used in subsequent calls to fetch the result set. To resume pagination, provide the NextToken value in the subsequent command. If the row size is large (e.g. a row has many columns), Timestream may return fewer rows to keep the response size from exceeding the 1 MB limit. If MaxRows is not provided, Timestream will send the necessary number of rows to meet the 1 MB limit.
        public let maxRows: Int?
        ///  A pagination token used to return a set of results. When the Query API is invoked using NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to Query, and a result set is returned. However, if the Query invocation only contains the ClientToken, that invocation of Query is assumed to be a new query run.  Note the following when using NextToken in a query:   A pagination token can be used for up to five Query invocations, OR for a duration of up to 1 hour – whichever comes first.   Using the same NextToken will return the same set of records. To keep paginating through the result set, you must to use the most recent nextToken.   Suppose a Query invocation returns two NextToken values, TokenA and TokenB. If TokenB is used in a subsequent Query invocation, then TokenA is invalidated and cannot be reused.   To request a previous result set from a query after pagination has begun, you must re-invoke the Query API.   The latest NextToken should be used to paginate until null is returned, at which point a new NextToken should be used.   If the IAM principal of the query initiator and the result reader are not the same and/or the query initiator and the result reader do not have the same query string in the query requests, the query will fail with an Invalid pagination token error.
        public let nextToken: String?
        /// Encapsulates settings for enabling QueryInsights. Enabling QueryInsights returns insights and metrics in addition to query results for the query that you executed. You can use QueryInsights to tune your query performance.
        public let queryInsights: QueryInsights?
        ///  The query to be run by Timestream.
        public let queryString: String

        @inlinable
        public init(clientToken: String? = QueryRequest.idempotencyToken(), maxRows: Int? = nil, nextToken: String? = nil, queryInsights: QueryInsights? = nil, queryString: String) {
            self.clientToken = clientToken
            self.maxRows = maxRows
            self.nextToken = nextToken
            self.queryInsights = queryInsights
            self.queryString = queryString
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.maxRows, name: "maxRows", parent: name, max: 1000)
            try self.validate(self.maxRows, name: "maxRows", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.queryString, name: "queryString", parent: name, max: 262144)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case maxRows = "MaxRows"
            case nextToken = "NextToken"
            case queryInsights = "QueryInsights"
            case queryString = "QueryString"
        }
    }

    public struct QueryResponse: AWSDecodableShape {
        ///  The column data types of the returned result set.
        public let columnInfo: [ColumnInfo]
        ///  A pagination token that can be used again on a Query call to get the next set of results.
        public let nextToken: String?
        ///  A unique ID for the given query.
        public let queryId: String
        /// Encapsulates QueryInsights containing insights and metrics related to the query that you executed.
        public let queryInsightsResponse: QueryInsightsResponse?
        /// Information about the status of the query, including progress and bytes scanned.
        public let queryStatus: QueryStatus?
        ///  The result set rows returned by the query.
        public let rows: [Row]

        @inlinable
        public init(columnInfo: [ColumnInfo], nextToken: String? = nil, queryId: String, queryInsightsResponse: QueryInsightsResponse? = nil, queryStatus: QueryStatus? = nil, rows: [Row]) {
            self.columnInfo = columnInfo
            self.nextToken = nextToken
            self.queryId = queryId
            self.queryInsightsResponse = queryInsightsResponse
            self.queryStatus = queryStatus
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columnInfo = "ColumnInfo"
            case nextToken = "NextToken"
            case queryId = "QueryId"
            case queryInsightsResponse = "QueryInsightsResponse"
            case queryStatus = "QueryStatus"
            case rows = "Rows"
        }
    }

    public struct QuerySpatialCoverage: AWSDecodableShape {
        /// Provides insights into the spatial coverage of the executed query and the table with the most inefficient spatial pruning.    Value – The maximum ratio of spatial coverage.    TableArn – The Amazon Resource Name (ARN) of the table with sub-optimal spatial pruning.    PartitionKey – The partition key used for partitioning, which can be a default measure_name or a CDPK.
        public let max: QuerySpatialCoverageMax?

        @inlinable
        public init(max: QuerySpatialCoverageMax? = nil) {
            self.max = max
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
        }
    }

    public struct QuerySpatialCoverageMax: AWSDecodableShape {
        /// The partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        public let partitionKey: [String]?
        /// The Amazon Resource Name (ARN) of the table with the most sub-optimal spatial pruning.
        public let tableArn: String?
        /// The maximum ratio of spatial coverage.
        public let value: Double?

        @inlinable
        public init(partitionKey: [String]? = nil, tableArn: String? = nil, value: Double? = nil) {
            self.partitionKey = partitionKey
            self.tableArn = tableArn
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case partitionKey = "PartitionKey"
            case tableArn = "TableArn"
            case value = "Value"
        }
    }

    public struct QueryStatus: AWSDecodableShape {
        /// The amount of data scanned by the query in bytes that you will be charged for. This is a cumulative sum and represents the total amount of data that you will be charged for since the query was started. The charge is applied only once and is either applied when the query completes running or when the query is cancelled.
        public let cumulativeBytesMetered: Int64?
        /// The amount of data scanned by the query in bytes. This is a cumulative sum and represents the total amount of bytes scanned since the query was started.
        public let cumulativeBytesScanned: Int64?
        /// The progress of the query, expressed as a percentage.
        public let progressPercentage: Double?

        @inlinable
        public init(cumulativeBytesMetered: Int64? = nil, cumulativeBytesScanned: Int64? = nil, progressPercentage: Double? = nil) {
            self.cumulativeBytesMetered = cumulativeBytesMetered
            self.cumulativeBytesScanned = cumulativeBytesScanned
            self.progressPercentage = progressPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cumulativeBytesMetered = "CumulativeBytesMetered"
            case cumulativeBytesScanned = "CumulativeBytesScanned"
            case progressPercentage = "ProgressPercentage"
        }
    }

    public struct QueryTemporalRange: AWSDecodableShape {
        /// Encapsulates the following properties that provide insights into the most sub-optimal performing table on the temporal axis:    Value – The maximum duration in nanoseconds between the start and end of the query.    TableArn – The Amazon Resource Name (ARN) of the table which is queried with the largest time range.
        public let max: QueryTemporalRangeMax?

        @inlinable
        public init(max: QueryTemporalRangeMax? = nil) {
            self.max = max
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
        }
    }

    public struct QueryTemporalRangeMax: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the table which is queried with the largest time range.
        public let tableArn: String?
        /// The maximum duration in nanoseconds between the start and end of the query.
        public let value: Int64?

        @inlinable
        public init(tableArn: String? = nil, value: Int64? = nil) {
            self.tableArn = tableArn
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case tableArn = "TableArn"
            case value = "Value"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The ARN of the scheduled query.
        public let scheduledQueryArn: String?

        @inlinable
        public init(message: String? = nil, scheduledQueryArn: String? = nil) {
            self.message = message
            self.scheduledQueryArn = scheduledQueryArn
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case scheduledQueryArn = "ScheduledQueryArn"
        }
    }

    public struct Row: AWSDecodableShape {
        /// List of data points in a single row of the result set.
        public let data: [Datum]

        @inlinable
        public init(data: [Datum]) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        ///  Name of the S3 bucket under which error reports will be created.
        public let bucketName: String
        ///  Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose SSE_S3 as default.
        public let encryptionOption: S3EncryptionOption?
        ///  Prefix for the error report key. Timestream by default adds the following prefix to the error report path.
        public let objectKeyPrefix: String?

        @inlinable
        public init(bucketName: String, encryptionOption: S3EncryptionOption? = nil, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 896)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case encryptionOption = "EncryptionOption"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct S3ReportLocation: AWSDecodableShape {
        ///  S3 bucket name.
        public let bucketName: String?
        /// S3 key.
        public let objectKey: String?

        @inlinable
        public init(bucketName: String? = nil, objectKey: String? = nil) {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKey = "ObjectKey"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An expression that denotes when to trigger the scheduled query run. This can be a cron expression or a rate expression.
        public let scheduleExpression: String

        @inlinable
        public init(scheduleExpression: String) {
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct ScheduledQuery: AWSDecodableShape {
        /// The Amazon Resource Name.
        public let arn: String
        /// The creation time of the scheduled query.
        public let creationTime: Date?
        /// Configuration for scheduled query error reporting.
        public let errorReportConfiguration: ErrorReportConfiguration?
        /// Status of the last scheduled query run.
        public let lastRunStatus: ScheduledQueryRunStatus?
        /// The name of the scheduled query.
        public let name: String
        /// The next time the scheduled query is to be run.
        public let nextInvocationTime: Date?
        /// The last time the scheduled query was run.
        public let previousInvocationTime: Date?
        /// State of scheduled query.
        public let state: ScheduledQueryState
        /// Target data source where final scheduled query result will be written.
        public let targetDestination: TargetDestination?

        @inlinable
        public init(arn: String, creationTime: Date? = nil, errorReportConfiguration: ErrorReportConfiguration? = nil, lastRunStatus: ScheduledQueryRunStatus? = nil, name: String, nextInvocationTime: Date? = nil, previousInvocationTime: Date? = nil, state: ScheduledQueryState, targetDestination: TargetDestination? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.previousInvocationTime = previousInvocationTime
            self.state = state
            self.targetDestination = targetDestination
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case lastRunStatus = "LastRunStatus"
            case name = "Name"
            case nextInvocationTime = "NextInvocationTime"
            case previousInvocationTime = "PreviousInvocationTime"
            case state = "State"
            case targetDestination = "TargetDestination"
        }
    }

    public struct ScheduledQueryDescription: AWSDecodableShape {
        /// Scheduled query ARN.
        public let arn: String
        /// Creation time of the scheduled query.
        public let creationTime: Date?
        /// Error-reporting configuration for the scheduled query.
        public let errorReportConfiguration: ErrorReportConfiguration?
        /// A customer provided KMS key used to encrypt the scheduled query resource.
        public let kmsKeyId: String?
        /// Runtime summary for the last scheduled query run.
        public let lastRunSummary: ScheduledQueryRunSummary?
        /// Name of the scheduled query.
        public let name: String
        /// The next time the scheduled query is scheduled to run.
        public let nextInvocationTime: Date?
        /// Notification configuration.
        public let notificationConfiguration: NotificationConfiguration
        /// Last time the query was run.
        public let previousInvocationTime: Date?
        /// The query to be run.
        public let queryString: String
        /// Runtime summary for the last five failed scheduled query runs.
        public let recentlyFailedRuns: [ScheduledQueryRunSummary]?
        /// Schedule configuration.
        public let scheduleConfiguration: ScheduleConfiguration
        /// IAM role that Timestream uses to run the schedule query.
        public let scheduledQueryExecutionRoleArn: String?
        /// State of the scheduled query.
        public let state: ScheduledQueryState
        /// Scheduled query target store configuration.
        public let targetConfiguration: TargetConfiguration?

        @inlinable
        public init(arn: String, creationTime: Date? = nil, errorReportConfiguration: ErrorReportConfiguration? = nil, kmsKeyId: String? = nil, lastRunSummary: ScheduledQueryRunSummary? = nil, name: String, nextInvocationTime: Date? = nil, notificationConfiguration: NotificationConfiguration, previousInvocationTime: Date? = nil, queryString: String, recentlyFailedRuns: [ScheduledQueryRunSummary]? = nil, scheduleConfiguration: ScheduleConfiguration, scheduledQueryExecutionRoleArn: String? = nil, state: ScheduledQueryState, targetConfiguration: TargetConfiguration? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.kmsKeyId = kmsKeyId
            self.lastRunSummary = lastRunSummary
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.notificationConfiguration = notificationConfiguration
            self.previousInvocationTime = previousInvocationTime
            self.queryString = queryString
            self.recentlyFailedRuns = recentlyFailedRuns
            self.scheduleConfiguration = scheduleConfiguration
            self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
            self.state = state
            self.targetConfiguration = targetConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case errorReportConfiguration = "ErrorReportConfiguration"
            case kmsKeyId = "KmsKeyId"
            case lastRunSummary = "LastRunSummary"
            case name = "Name"
            case nextInvocationTime = "NextInvocationTime"
            case notificationConfiguration = "NotificationConfiguration"
            case previousInvocationTime = "PreviousInvocationTime"
            case queryString = "QueryString"
            case recentlyFailedRuns = "RecentlyFailedRuns"
            case scheduleConfiguration = "ScheduleConfiguration"
            case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
            case state = "State"
            case targetConfiguration = "TargetConfiguration"
        }
    }

    public struct ScheduledQueryInsights: AWSEncodableShape {
        /// Provides the following modes to enable ScheduledQueryInsights:    ENABLED_WITH_RATE_CONTROL – Enables ScheduledQueryInsights for the queries being processed. This mode also includes a rate control mechanism, which limits the QueryInsights feature to 1 query per second (QPS).    DISABLED – Disables ScheduledQueryInsights.
        public let mode: ScheduledQueryInsightsMode

        @inlinable
        public init(mode: ScheduledQueryInsightsMode) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct ScheduledQueryInsightsResponse: AWSDecodableShape {
        /// Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        public let outputBytes: Int64?
        /// Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        public let outputRows: Int64?
        /// Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        public let querySpatialCoverage: QuerySpatialCoverage?
        /// Indicates the number of tables in the query.
        public let queryTableCount: Int64?
        /// Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:   Add missing time-predicates.   Remove functions around the time predicates.   Add time predicates to all the sub-queries.
        public let queryTemporalRange: QueryTemporalRange?

        @inlinable
        public init(outputBytes: Int64? = nil, outputRows: Int64? = nil, querySpatialCoverage: QuerySpatialCoverage? = nil, queryTableCount: Int64? = nil, queryTemporalRange: QueryTemporalRange? = nil) {
            self.outputBytes = outputBytes
            self.outputRows = outputRows
            self.querySpatialCoverage = querySpatialCoverage
            self.queryTableCount = queryTableCount
            self.queryTemporalRange = queryTemporalRange
        }

        private enum CodingKeys: String, CodingKey {
            case outputBytes = "OutputBytes"
            case outputRows = "OutputRows"
            case querySpatialCoverage = "QuerySpatialCoverage"
            case queryTableCount = "QueryTableCount"
            case queryTemporalRange = "QueryTemporalRange"
        }
    }

    public struct ScheduledQueryRunSummary: AWSDecodableShape {
        /// S3 location for error report.
        public let errorReportLocation: ErrorReportLocation?
        /// Runtime statistics for a scheduled run.
        public let executionStats: ExecutionStats?
        /// Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        public let failureReason: String?
        /// InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter @scheduled_runtime can be used in the query to get the value.
        public let invocationTime: Date?
        /// Provides various insights and metrics related to the run summary of the scheduled query.
        public let queryInsightsResponse: ScheduledQueryInsightsResponse?
        /// The status of a scheduled query run.
        public let runStatus: ScheduledQueryRunStatus?
        /// The actual time when the query was run.
        public let triggerTime: Date?

        @inlinable
        public init(errorReportLocation: ErrorReportLocation? = nil, executionStats: ExecutionStats? = nil, failureReason: String? = nil, invocationTime: Date? = nil, queryInsightsResponse: ScheduledQueryInsightsResponse? = nil, runStatus: ScheduledQueryRunStatus? = nil, triggerTime: Date? = nil) {
            self.errorReportLocation = errorReportLocation
            self.executionStats = executionStats
            self.failureReason = failureReason
            self.invocationTime = invocationTime
            self.queryInsightsResponse = queryInsightsResponse
            self.runStatus = runStatus
            self.triggerTime = triggerTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorReportLocation = "ErrorReportLocation"
            case executionStats = "ExecutionStats"
            case failureReason = "FailureReason"
            case invocationTime = "InvocationTime"
            case queryInsightsResponse = "QueryInsightsResponse"
            case runStatus = "RunStatus"
            case triggerTime = "TriggerTime"
        }
    }

    public struct SelectColumn: AWSDecodableShape {
        /// True, if the column name was aliased by the query. False otherwise.
        public let aliased: Bool?
        ///  Database that has this column.
        public let databaseName: String?
        /// Name of the column.
        public let name: String?
        /// Table within the database that has this column.
        public let tableName: String?
        public let type: `Type`?

        @inlinable
        public init(aliased: Bool? = nil, databaseName: String? = nil, name: String? = nil, tableName: String? = nil, type: `Type`? = nil) {
            self.aliased = aliased
            self.databaseName = databaseName
            self.name = name
            self.tableName = tableName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aliased = "Aliased"
            case databaseName = "DatabaseName"
            case name = "Name"
            case tableName = "TableName"
            case type = "Type"
        }
    }

    public struct SnsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// SNS topic ARN that the scheduled query status notifications will be sent to.
        public let topicArn: String

        @inlinable
        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 2048)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag. Tag keys are case sensitive.
        public let key: String
        /// The value of the tag. Tag values are case sensitive and can be null.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        /// The tags to be assigned to the Timestream resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration needed to write data into the Timestream database and table.
        public let timestreamConfiguration: TimestreamConfiguration

        @inlinable
        public init(timestreamConfiguration: TimestreamConfiguration) {
            self.timestreamConfiguration = timestreamConfiguration
        }

        public func validate(name: String) throws {
            try self.timestreamConfiguration.validate(name: "\(name).timestreamConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamConfiguration = "TimestreamConfiguration"
        }
    }

    public struct TargetDestination: AWSDecodableShape {
        /// Query result destination details for Timestream data source.
        public let timestreamDestination: TimestreamDestination?

        @inlinable
        public init(timestreamDestination: TimestreamDestination? = nil) {
            self.timestreamDestination = timestreamDestination
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamDestination = "TimestreamDestination"
        }
    }

    public struct TimeSeriesDataPoint: AWSDecodableShape {
        /// The timestamp when the measure value was collected.
        public let time: String
        /// The measure value for the data point.
        public let value: Datum

        @inlinable
        public init(time: String, value: Datum) {
            self.time = time
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case time = "Time"
            case value = "Value"
        }
    }

    public struct TimestreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Name of Timestream database to which the query result will be written.
        public let databaseName: String
        ///  This is to allow mapping column(s) from the query result to the dimension in the destination table.
        public let dimensionMappings: [DimensionMapping]
        /// Name of the measure column.
        public let measureNameColumn: String?
        /// Specifies how to map measures to multi-measure records.
        public let mixedMeasureMappings: [MixedMeasureMapping]?
        /// Multi-measure mappings.
        public let multiMeasureMappings: MultiMeasureMappings?
        /// Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        public let tableName: String
        /// Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        public let timeColumn: String

        @inlinable
        public init(databaseName: String, dimensionMappings: [DimensionMapping], measureNameColumn: String? = nil, mixedMeasureMappings: [MixedMeasureMapping]? = nil, multiMeasureMappings: MultiMeasureMappings? = nil, tableName: String, timeColumn: String) {
            self.databaseName = databaseName
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.tableName = tableName
            self.timeColumn = timeColumn
        }

        public func validate(name: String) throws {
            try self.mixedMeasureMappings?.forEach {
                try $0.validate(name: "\(name).mixedMeasureMappings[]")
            }
            try self.validate(self.mixedMeasureMappings, name: "mixedMeasureMappings", parent: name, min: 1)
            try self.multiMeasureMappings?.validate(name: "\(name).multiMeasureMappings")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case dimensionMappings = "DimensionMappings"
            case measureNameColumn = "MeasureNameColumn"
            case mixedMeasureMappings = "MixedMeasureMappings"
            case multiMeasureMappings = "MultiMeasureMappings"
            case tableName = "TableName"
            case timeColumn = "TimeColumn"
        }
    }

    public struct TimestreamDestination: AWSDecodableShape {
        /// Timestream database name.
        public let databaseName: String?
        /// Timestream table name.
        public let tableName: String?

        @inlinable
        public init(databaseName: String? = nil, tableName: String? = nil) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public final class `Type`: AWSDecodableShape {
        /// Indicates if the column is an array.
        public let arrayColumnInfo: ColumnInfo?
        /// Indicates if the column is a row.
        public let rowColumnInfo: [ColumnInfo]?
        /// Indicates if the column is of type string, integer, Boolean, double, timestamp, date, time. For more information, see Supported data types.
        public let scalarType: ScalarType?
        /// Indicates if the column is a timeseries data type.
        public let timeSeriesMeasureValueColumnInfo: ColumnInfo?

        @inlinable
        public init(arrayColumnInfo: ColumnInfo? = nil, rowColumnInfo: [ColumnInfo]? = nil, scalarType: ScalarType? = nil, timeSeriesMeasureValueColumnInfo: ColumnInfo? = nil) {
            self.arrayColumnInfo = arrayColumnInfo
            self.rowColumnInfo = rowColumnInfo
            self.scalarType = scalarType
            self.timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo
        }

        private enum CodingKeys: String, CodingKey {
            case arrayColumnInfo = "ArrayColumnInfo"
            case rowColumnInfo = "RowColumnInfo"
            case scalarType = "ScalarType"
            case timeSeriesMeasureValueColumnInfo = "TimeSeriesMeasureValueColumnInfo"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        /// A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        /// The maximum number of compute units the service will use at any point in time to serve your queries. To run queries, you must set a minimum capacity of 4 TCU. You can set the maximum number of TCU in multiples of 4, for example, 4, 8, 16, 32, and so on. The maximum value supported for MaxQueryTCU is 1000. To request an increase to this soft limit, contact Amazon Web Services Support. For information about the default quota for maxQueryTCU, see Default quotas. This configuration is applicable only for on-demand usage of Timestream Compute Units (TCUs). The maximum value supported for MaxQueryTCU is 1000. To request an increase to this soft limit, contact Amazon Web Services Support. For information about the default quota for maxQueryTCU, see Default quotas.
        public let maxQueryTCU: Int?
        /// Modifies the query compute settings configured in your account, including the query pricing model and provisioned Timestream Compute Units (TCUs) in your account.  This API is idempotent, meaning that making the same request multiple times will have the same effect as making the request once.
        public let queryCompute: QueryComputeRequest?
        /// The pricing model for queries in an account.  The QueryPricingModel parameter is used by several Timestream operations; however, the UpdateAccountSettings API operation doesn't recognize any values other than COMPUTE_UNITS.
        public let queryPricingModel: QueryPricingModel?

        @inlinable
        public init(maxQueryTCU: Int? = nil, queryCompute: QueryComputeRequest? = nil, queryPricingModel: QueryPricingModel? = nil) {
            self.maxQueryTCU = maxQueryTCU
            self.queryCompute = queryCompute
            self.queryPricingModel = queryPricingModel
        }

        public func validate(name: String) throws {
            try self.queryCompute?.validate(name: "\(name).queryCompute")
        }

        private enum CodingKeys: String, CodingKey {
            case maxQueryTCU = "MaxQueryTCU"
            case queryCompute = "QueryCompute"
            case queryPricingModel = "QueryPricingModel"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        /// The configured maximum number of compute units the service will use at any point in time to serve your queries.
        public let maxQueryTCU: Int?
        /// Confirms the updated account settings for querying data in your account.
        public let queryCompute: QueryComputeResponse?
        /// The pricing model for an account.
        public let queryPricingModel: QueryPricingModel?

        @inlinable
        public init(maxQueryTCU: Int? = nil, queryCompute: QueryComputeResponse? = nil, queryPricingModel: QueryPricingModel? = nil) {
            self.maxQueryTCU = maxQueryTCU
            self.queryCompute = queryCompute
            self.queryPricingModel = queryPricingModel
        }

        private enum CodingKeys: String, CodingKey {
            case maxQueryTCU = "MaxQueryTCU"
            case queryCompute = "QueryCompute"
            case queryPricingModel = "QueryPricingModel"
        }
    }

    public struct UpdateScheduledQueryRequest: AWSEncodableShape {
        /// ARN of the scheuled query.
        public let scheduledQueryArn: String
        /// State of the scheduled query.
        public let state: ScheduledQueryState

        @inlinable
        public init(scheduledQueryArn: String, state: ScheduledQueryState) {
            self.scheduledQueryArn = scheduledQueryArn
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, max: 2048)
            try self.validate(self.scheduledQueryArn, name: "scheduledQueryArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledQueryArn = "ScheduledQueryArn"
            case state = "State"
        }
    }
}

// MARK: - Errors

/// Error enum for TimestreamQuery
public struct TimestreamQueryErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidEndpointException = "InvalidEndpointException"
        case queryExecutionException = "QueryExecutionException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize TimestreamQuery
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have the necessary permissions to access the account settings.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  Unable to poll results for a cancelled query.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested endpoint is invalid.
    public static var invalidEndpointException: Self { .init(.invalidEndpointException) }
    ///  Timestream was unable to run the query successfully.
    public static var queryExecutionException: Self { .init(.queryExecutionException) }
    /// The requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled due to excessive requests.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  Invalid or malformed request.
    public static var validationException: Self { .init(.validationException) }
}

extension TimestreamQueryErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": TimestreamQuery.ResourceNotFoundException.self
    ]
}

extension TimestreamQueryErrorType: Equatable {
    public static func == (lhs: TimestreamQueryErrorType, rhs: TimestreamQueryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TimestreamQueryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
