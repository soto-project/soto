//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension TimestreamWrite {
    // MARK: Enums

    public enum DimensionValueType: String, CustomStringConvertible, Codable, _SotoSendable {
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum MeasureValueType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case multi = "MULTI"
        case timestamp = "TIMESTAMP"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case sseKms = "SSE_KMS"
        case sseS3 = "SSE_S3"
        public var description: String { return self.rawValue }
    }

    public enum TableStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum TimeUnit: String, CustomStringConvertible, Codable, _SotoSendable {
        case microseconds = "MICROSECONDS"
        case milliseconds = "MILLISECONDS"
        case nanoseconds = "NANOSECONDS"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// The KMS key for the database.  If the KMS key is not specified, the database will be encrypted with a Timestream managed KMS key located in your account.  Refer to Amazon Web Services managed KMS keys for more info.
        public let kmsKeyId: String?
        ///  A list of key-value pairs to label the table.
        public let tags: [Tag]?

        public init(databaseName: String, kmsKeyId: String? = nil, tags: [Tag]? = nil) {
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
            case tags = "Tags"
        }
    }

    public struct CreateDatabaseResponse: AWSDecodableShape {
        /// The newly created Timestream database.
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct CreateTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The duration for which your time series data must be stored in the memory store and the magnetic store.
        public let retentionProperties: RetentionProperties?
        /// The name of the Timestream table.
        public let tableName: String
        ///  A list of key-value pairs to label the table.
        public let tags: [Tag]?

        public init(databaseName: String, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, tableName: String, tags: [Tag]? = nil) {
            self.databaseName = databaseName
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.tableName = tableName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.magneticStoreWriteProperties?.validate(name: "\(name).magneticStoreWriteProperties")
            try self.retentionProperties?.validate(name: "\(name).retentionProperties")
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case tableName = "TableName"
            case tags = "Tags"
        }
    }

    public struct CreateTableResponse: AWSDecodableShape {
        /// The newly created Timestream table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct Database: AWSDecodableShape {
        /// The Amazon Resource Name that uniquely identifies this database.
        public let arn: String?
        /// The time when the database was created, calculated from the Unix epoch time.
        public let creationTime: Date?
        /// The name of the Timestream database.
        public let databaseName: String?
        /// The identifier of the KMS key used to encrypt the data stored in the database.
        public let kmsKeyId: String?
        ///  The last time that this database was updated.
        public let lastUpdatedTime: Date?
        /// The total number of tables found within a Timestream database.
        public let tableCount: Int64?

        public init(arn: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, kmsKeyId: String? = nil, lastUpdatedTime: Date? = nil, tableCount: Int64? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.lastUpdatedTime = lastUpdatedTime
            self.tableCount = tableCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
            case lastUpdatedTime = "LastUpdatedTime"
            case tableCount = "TableCount"
        }
    }

    public struct DeleteDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database to be deleted.
        public let databaseName: String

        public init(databaseName: String) {
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
        }
    }

    public struct DeleteTableRequest: AWSEncodableShape {
        /// The name of the database where the Timestream database is to be deleted.
        public let databaseName: String
        /// The name of the Timestream table to be deleted.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DescribeDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String

        public init(databaseName: String) {
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
        }
    }

    public struct DescribeDatabaseResponse: AWSDecodableShape {
        /// The name of the Timestream table.
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct DescribeEndpointsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// An Endpoints object is returned when a DescribeEndpoints request is made.
        public let endpoints: [Endpoint]

        public init(endpoints: [Endpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct DescribeTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// The name of the Timestream table.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DescribeTableResponse: AWSDecodableShape {
        /// The Timestream table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct Dimension: AWSEncodableShape {
        /// The data type of the dimension for the time series data point.
        public let dimensionValueType: DimensionValueType?
        ///  Dimension represents the meta data attributes of the time series.  For example, the name and availability zone of an EC2 instance or  the name of the manufacturer of a wind turbine are dimensions.   For constraints on Dimension names,  see Naming Constraints.
        public let name: String
        /// The value of the dimension.
        public let value: String

        public init(dimensionValueType: DimensionValueType? = nil, name: String, value: String) {
            self.dimensionValueType = dimensionValueType
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueType = "DimensionValueType"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// An endpoint address.
        public let address: String
        /// The TTL for the endpoint, in minutes.
        public let cachePeriodInMinutes: Int64

        public init(address: String, cachePeriodInMinutes: Int64) {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case cachePeriodInMinutes = "CachePeriodInMinutes"
        }
    }

    public struct ListDatabasesRequest: AWSEncodableShape {
        /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatabasesResponse: AWSDecodableShape {
        /// A list of database names.
        public let databases: [Database]?
        /// The pagination token. This parameter is returned when the response is truncated.
        public let nextToken: String?

        public init(databases: [Database]? = nil, nextToken: String? = nil) {
            self.databases = databases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case databases = "Databases"
            case nextToken = "NextToken"
        }
    }

    public struct ListTablesRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String?
        /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        public init(databaseName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTablesResponse: AWSDecodableShape {
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// A list of tables.
        public let tables: [Table]?

        public init(nextToken: String? = nil, tables: [Table]? = nil) {
            self.nextToken = nextToken
            self.tables = tables
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tables = "Tables"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags currently associated with the Timestream resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MagneticStoreRejectedDataLocation: AWSEncodableShape & AWSDecodableShape {
        /// Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        public let s3Configuration: S3Configuration?

        public init(s3Configuration: S3Configuration? = nil) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }

    public struct MagneticStoreWriteProperties: AWSEncodableShape & AWSDecodableShape {
        /// A flag to enable magnetic store writes.
        public let enableMagneticStoreWrites: Bool
        /// The location to write error reports for records rejected asynchronously during magnetic store writes.
        public let magneticStoreRejectedDataLocation: MagneticStoreRejectedDataLocation?

        public init(enableMagneticStoreWrites: Bool, magneticStoreRejectedDataLocation: MagneticStoreRejectedDataLocation? = nil) {
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticStoreRejectedDataLocation = magneticStoreRejectedDataLocation
        }

        public func validate(name: String) throws {
            try self.magneticStoreRejectedDataLocation?.validate(name: "\(name).magneticStoreRejectedDataLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case enableMagneticStoreWrites = "EnableMagneticStoreWrites"
            case magneticStoreRejectedDataLocation = "MagneticStoreRejectedDataLocation"
        }
    }

    public struct MeasureValue: AWSEncodableShape {
        ///  Name of the MeasureValue.   For constraints on MeasureValue names, refer to  Naming Constraints in the Timestream developer guide.
        public let name: String
        /// Contains the data type of the MeasureValue for the time series data point.
        public let type: MeasureValueType
        ///  Value for the MeasureValue.
        public let value: String

        public init(name: String, type: MeasureValueType, value: String) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 2048)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct Record: AWSEncodableShape {
        /// Contains the list of dimensions for time series data points.
        public let dimensions: [Dimension]?
        /// Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures.
        public let measureName: String?
        /// Contains the measure value for the time series data point.
        public let measureValue: String?
        ///  Contains the list of MeasureValue for time series data points.  This is only allowed for type MULTI. For scalar values, use MeasureValue attribute of the Record directly.
        public let measureValues: [MeasureValue]?
        /// Contains the data type of the measure value for the time series data point. Default type is DOUBLE.
        public let measureValueType: MeasureValueType?
        /// Contains the time at which the measure value for the data point was collected.
        /// The time value plus the unit provides the time elapsed since the epoch.
        /// For example, if the time value is 12345 and the unit is ms, then 12345 ms have elapsed since the epoch.
        public let time: String?
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds or other supported values.
        /// Default is MILLISECONDS.
        public let timeUnit: TimeUnit?
        /// 64-bit attribute used for record updates.  Write requests for duplicate data with a higher version number will update the existing measure value and version.  In cases where the measure value is the same, Version will still be updated . Default value is 1.    Version must be 1 or greater, or you will receive a ValidationException error.
        public let version: Int64?

        public init(dimensions: [Dimension]? = nil, measureName: String? = nil, measureValue: String? = nil, measureValues: [MeasureValue]? = nil, measureValueType: MeasureValueType? = nil, time: String? = nil, timeUnit: TimeUnit? = nil, version: Int64? = nil) {
            self.dimensions = dimensions
            self.measureName = measureName
            self.measureValue = measureValue
            self.measureValues = measureValues
            self.measureValueType = measureValueType
            self.time = time
            self.timeUnit = timeUnit
            self.version = version
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 128)
            try self.validate(self.measureName, name: "measureName", parent: name, min: 1)
            try self.validate(self.measureValue, name: "measureValue", parent: name, max: 2048)
            try self.validate(self.measureValue, name: "measureValue", parent: name, min: 1)
            try self.measureValues?.forEach {
                try $0.validate(name: "\(name).measureValues[]")
            }
            try self.validate(self.time, name: "time", parent: name, max: 256)
            try self.validate(self.time, name: "time", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case measureName = "MeasureName"
            case measureValue = "MeasureValue"
            case measureValues = "MeasureValues"
            case measureValueType = "MeasureValueType"
            case time = "Time"
            case timeUnit = "TimeUnit"
            case version = "Version"
        }
    }

    public struct RecordsIngested: AWSDecodableShape {
        /// Count of records ingested into the magnetic store.
        public let magneticStore: Int?
        /// Count of records ingested into the memory store.
        public let memoryStore: Int?
        /// Total count of successfully ingested records.
        public let total: Int?

        public init(magneticStore: Int? = nil, memoryStore: Int? = nil, total: Int? = nil) {
            self.magneticStore = magneticStore
            self.memoryStore = memoryStore
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case magneticStore = "MagneticStore"
            case memoryStore = "MemoryStore"
            case total = "Total"
        }
    }

    public struct RetentionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The duration for which data must be stored in the magnetic store.
        public let magneticStoreRetentionPeriodInDays: Int64
        /// The duration for which data must be stored in the memory store.
        public let memoryStoreRetentionPeriodInHours: Int64

        public init(magneticStoreRetentionPeriodInDays: Int64, memoryStoreRetentionPeriodInHours: Int64) {
            self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
            self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
        }

        public func validate(name: String) throws {
            try self.validate(self.magneticStoreRetentionPeriodInDays, name: "magneticStoreRetentionPeriodInDays", parent: name, max: 73000)
            try self.validate(self.magneticStoreRetentionPeriodInDays, name: "magneticStoreRetentionPeriodInDays", parent: name, min: 1)
            try self.validate(self.memoryStoreRetentionPeriodInHours, name: "memoryStoreRetentionPeriodInHours", parent: name, max: 8766)
            try self.validate(self.memoryStoreRetentionPeriodInHours, name: "memoryStoreRetentionPeriodInHours", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case magneticStoreRetentionPeriodInDays = "MagneticStoreRetentionPeriodInDays"
            case memoryStoreRetentionPeriodInHours = "MemoryStoreRetentionPeriodInHours"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// >Bucket name of the customer S3 bucket.
        public let bucketName: String?
        /// Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key.
        public let encryptionOption: S3EncryptionOption?
        /// KMS key id for the customer s3 location when encrypting with a KMS managed key.
        public let kmsKeyId: String?
        /// Object key preview for the customer S3 location.
        public let objectKeyPrefix: String?

        public init(bucketName: String? = nil, encryptionOption: S3EncryptionOption? = nil, kmsKeyId: String? = nil, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 928)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case encryptionOption = "EncryptionOption"
            case kmsKeyId = "KmsKeyId"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct Table: AWSDecodableShape {
        /// The Amazon Resource Name that uniquely identifies this table.
        public let arn: String?
        /// The time when the Timestream table was created.
        public let creationTime: Date?
        /// The name of the Timestream database that contains this table.
        public let databaseName: String?
        /// The time when the Timestream table was last updated.
        public let lastUpdatedTime: Date?
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The retention duration for the memory store and magnetic store.
        public let retentionProperties: RetentionProperties?
        /// The name of the Timestream table.
        public let tableName: String?
        /// The current state of the table:     DELETING - The table is being deleted.     ACTIVE - The table is ready for use.
        public let tableStatus: TableStatus?

        public init(arn: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, lastUpdatedTime: Date? = nil, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, tableName: String? = nil, tableStatus: TableStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.tableName = tableName
            self.tableStatus = tableStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastUpdatedTime = "LastUpdatedTime"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case tableName = "TableName"
            case tableStatus = "TableStatus"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag. Tag keys are case sensitive.
        public let key: String
        /// The value of the tag. Tag values are case-sensitive and can be null.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        /// The tags to be assigned to the Timestream resource.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        ///  A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatabaseRequest: AWSEncodableShape {
        ///  The name of the database.
        public let databaseName: String
        ///  The identifier of the new KMS key (KmsKeyId) to be used to encrypt the data stored in the database. If the KmsKeyId currently registered with the database is the same as the KmsKeyId in the  request, there will not be any update.   You can specify the KmsKeyId using any of the following:   Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias ARN: arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias
        public let kmsKeyId: String

        public init(databaseName: String, kmsKeyId: String) {
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct UpdateDatabaseResponse: AWSDecodableShape {
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct UpdateTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The retention duration of the memory store and the magnetic store.
        public let retentionProperties: RetentionProperties?
        /// The name of the Timestream table.
        public let tableName: String

        public init(databaseName: String, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, tableName: String) {
            self.databaseName = databaseName
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.magneticStoreWriteProperties?.validate(name: "\(name).magneticStoreWriteProperties")
            try self.retentionProperties?.validate(name: "\(name).retentionProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case tableName = "TableName"
        }
    }

    public struct UpdateTableResponse: AWSDecodableShape {
        /// The updated Timestream table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct WriteRecordsRequest: AWSEncodableShape {
        /// A record containing the common measure, dimension, time,  and version attributes   shared across all the records in the request. The measure and dimension  attributes specified will be merged with the measure and dimension attributes in the records object when the data is written into Timestream. Dimensions may not overlap, or a ValidationException will be thrown. In other words, a record must contain dimensions with unique names.
        public let commonAttributes: Record?
        /// The name of the Timestream database.
        public let databaseName: String
        /// An array of records containing the unique measure, dimension, time, and version   attributes for each time series data point.
        public let records: [Record]
        /// The name of the Timestream table.
        public let tableName: String

        public init(commonAttributes: Record? = nil, databaseName: String, records: [Record], tableName: String) {
            self.commonAttributes = commonAttributes
            self.databaseName = databaseName
            self.records = records
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.commonAttributes?.validate(name: "\(name).commonAttributes")
            try self.records.forEach {
                try $0.validate(name: "\(name).records[]")
            }
            try self.validate(self.records, name: "records", parent: name, max: 100)
            try self.validate(self.records, name: "records", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case commonAttributes = "CommonAttributes"
            case databaseName = "DatabaseName"
            case records = "Records"
            case tableName = "TableName"
        }
    }

    public struct WriteRecordsResponse: AWSDecodableShape {
        /// Information on the records ingested by this request.
        public let recordsIngested: RecordsIngested?

        public init(recordsIngested: RecordsIngested? = nil) {
            self.recordsIngested = recordsIngested
        }

        private enum CodingKeys: String, CodingKey {
            case recordsIngested = "RecordsIngested"
        }
    }
}

// MARK: - Errors

/// Error enum for TimestreamWrite
public struct TimestreamWriteErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidEndpointException = "InvalidEndpointException"
        case rejectedRecordsException = "RejectedRecordsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize TimestreamWrite
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Timestream was unable to process this request because it contains resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    ///  Timestream was unable to fully process this request because of an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested endpoint was invalid.
    public static var invalidEndpointException: Self { .init(.invalidEndpointException) }
    ///  WriteRecords would throw this exception in the following cases:    Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:    Measure values are different   Version is not present in the request or the value of version in the new record is equal to or lower than the existing value    In this case, if Timestream rejects data, the ExistingVersion field in the RejectedRecords  response will indicate the current recordâ€™s version.  To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.    Records with timestamps that lie outside the retention duration of the memory store     Records with dimensions or measures that exceed the Timestream defined limits.     For more information, see Quotas in the Timestream Developer Guide.
    public static var rejectedRecordsException: Self { .init(.rejectedRecordsException) }
    /// The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  Instance quota of resource exceeded for this account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  Too many requests were made by a user exceeding service quotas. The request was throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  Invalid or malformed request.
    public static var validationException: Self { .init(.validationException) }
}

extension TimestreamWriteErrorType: Equatable {
    public static func == (lhs: TimestreamWriteErrorType, rhs: TimestreamWriteErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TimestreamWriteErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
