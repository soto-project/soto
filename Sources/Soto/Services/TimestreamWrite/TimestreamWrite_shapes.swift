//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension TimestreamWrite {
    // MARK: Enums

    public enum BatchLoadDataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        public var description: String { return self.rawValue }
    }

    public enum BatchLoadStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pendingResume = "PENDING_RESUME"
        case progressStopped = "PROGRESS_STOPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DimensionValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum MeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case multi = "MULTI"
        case timestamp = "TIMESTAMP"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum PartitionKeyEnforcementLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optional = "OPTIONAL"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum PartitionKeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dimension = "DIMENSION"
        case measure = "MEASURE"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sseKms = "SSE_KMS"
        case sseS3 = "SSE_S3"
        public var description: String { return self.rawValue }
    }

    public enum ScalarMeasureValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case timestamp = "TIMESTAMP"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum TableStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case restoring = "RESTORING"
        public var description: String { return self.rawValue }
    }

    public enum TimeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case microseconds = "MICROSECONDS"
        case milliseconds = "MILLISECONDS"
        case nanoseconds = "NANOSECONDS"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchLoadProgressReport: AWSDecodableShape {
        public let bytesMetered: Int64?
        public let fileFailures: Int64?
        public let parseFailures: Int64?
        public let recordIngestionFailures: Int64?
        public let recordsIngested: Int64?
        public let recordsProcessed: Int64?

        @inlinable
        public init(bytesMetered: Int64? = nil, fileFailures: Int64? = nil, parseFailures: Int64? = nil, recordIngestionFailures: Int64? = nil, recordsIngested: Int64? = nil, recordsProcessed: Int64? = nil) {
            self.bytesMetered = bytesMetered
            self.fileFailures = fileFailures
            self.parseFailures = parseFailures
            self.recordIngestionFailures = recordIngestionFailures
            self.recordsIngested = recordsIngested
            self.recordsProcessed = recordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case bytesMetered = "BytesMetered"
            case fileFailures = "FileFailures"
            case parseFailures = "ParseFailures"
            case recordIngestionFailures = "RecordIngestionFailures"
            case recordsIngested = "RecordsIngested"
            case recordsProcessed = "RecordsProcessed"
        }
    }

    public struct BatchLoadTask: AWSDecodableShape {
        /// The time when the Timestream batch load task was created.
        public let creationTime: Date?
        /// Database name for the database into which a batch load task loads data.
        public let databaseName: String?
        /// The time when the Timestream batch load task was last updated.
        public let lastUpdatedTime: Date?
        ///
        public let resumableUntil: Date?
        /// Table name for the table into which a batch load task loads data.
        public let tableName: String?
        /// The ID of the batch load task.
        public let taskId: String?
        /// Status of the batch load task.
        public let taskStatus: BatchLoadStatus?

        @inlinable
        public init(creationTime: Date? = nil, databaseName: String? = nil, lastUpdatedTime: Date? = nil, resumableUntil: Date? = nil, tableName: String? = nil, taskId: String? = nil, taskStatus: BatchLoadStatus? = nil) {
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.resumableUntil = resumableUntil
            self.tableName = tableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastUpdatedTime = "LastUpdatedTime"
            case resumableUntil = "ResumableUntil"
            case tableName = "TableName"
            case taskId = "TaskId"
            case taskStatus = "TaskStatus"
        }
    }

    public struct BatchLoadTaskDescription: AWSDecodableShape {
        /// The time when the Timestream batch load task was created.
        public let creationTime: Date?
        /// Data model configuration for a batch load task. This contains details about where a data model for a batch load task is stored.
        public let dataModelConfiguration: DataModelConfiguration?
        /// Configuration details about the data source for a batch load task.
        public let dataSourceConfiguration: DataSourceConfiguration?
        public let errorMessage: String?
        /// The time when the Timestream batch load task was last updated.
        public let lastUpdatedTime: Date?
        public let progressReport: BatchLoadProgressReport?
        public let recordVersion: Int64?
        /// Report configuration for a batch load task. This contains details about where error reports are stored.
        public let reportConfiguration: ReportConfiguration?
        ///
        public let resumableUntil: Date?
        public let targetDatabaseName: String?
        public let targetTableName: String?
        /// The ID of the batch load task.
        public let taskId: String?
        /// Status of the batch load task.
        public let taskStatus: BatchLoadStatus?

        @inlinable
        public init(creationTime: Date? = nil, dataModelConfiguration: DataModelConfiguration? = nil, dataSourceConfiguration: DataSourceConfiguration? = nil, errorMessage: String? = nil, lastUpdatedTime: Date? = nil, progressReport: BatchLoadProgressReport? = nil, recordVersion: Int64? = nil, reportConfiguration: ReportConfiguration? = nil, resumableUntil: Date? = nil, targetDatabaseName: String? = nil, targetTableName: String? = nil, taskId: String? = nil, taskStatus: BatchLoadStatus? = nil) {
            self.creationTime = creationTime
            self.dataModelConfiguration = dataModelConfiguration
            self.dataSourceConfiguration = dataSourceConfiguration
            self.errorMessage = errorMessage
            self.lastUpdatedTime = lastUpdatedTime
            self.progressReport = progressReport
            self.recordVersion = recordVersion
            self.reportConfiguration = reportConfiguration
            self.resumableUntil = resumableUntil
            self.targetDatabaseName = targetDatabaseName
            self.targetTableName = targetTableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataModelConfiguration = "DataModelConfiguration"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case errorMessage = "ErrorMessage"
            case lastUpdatedTime = "LastUpdatedTime"
            case progressReport = "ProgressReport"
            case recordVersion = "RecordVersion"
            case reportConfiguration = "ReportConfiguration"
            case resumableUntil = "ResumableUntil"
            case targetDatabaseName = "TargetDatabaseName"
            case targetTableName = "TargetTableName"
            case taskId = "TaskId"
            case taskStatus = "TaskStatus"
        }
    }

    public struct CreateBatchLoadTaskRequest: AWSEncodableShape {
        public let clientToken: String?
        public let dataModelConfiguration: DataModelConfiguration?
        /// Defines configuration details about the data source for a batch load task.
        public let dataSourceConfiguration: DataSourceConfiguration
        public let recordVersion: Int64?
        public let reportConfiguration: ReportConfiguration
        /// Target Timestream database for a batch load task.
        public let targetDatabaseName: String
        /// Target Timestream table for a batch load task.
        public let targetTableName: String

        @inlinable
        public init(clientToken: String? = CreateBatchLoadTaskRequest.idempotencyToken(), dataModelConfiguration: DataModelConfiguration? = nil, dataSourceConfiguration: DataSourceConfiguration, recordVersion: Int64? = nil, reportConfiguration: ReportConfiguration, targetDatabaseName: String, targetTableName: String) {
            self.clientToken = clientToken
            self.dataModelConfiguration = dataModelConfiguration
            self.dataSourceConfiguration = dataSourceConfiguration
            self.recordVersion = recordVersion
            self.reportConfiguration = reportConfiguration
            self.targetDatabaseName = targetDatabaseName
            self.targetTableName = targetTableName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.dataModelConfiguration?.validate(name: "\(name).dataModelConfiguration")
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.reportConfiguration.validate(name: "\(name).reportConfiguration")
            try self.validate(self.targetDatabaseName, name: "targetDatabaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.targetTableName, name: "targetTableName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataModelConfiguration = "DataModelConfiguration"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case recordVersion = "RecordVersion"
            case reportConfiguration = "ReportConfiguration"
            case targetDatabaseName = "TargetDatabaseName"
            case targetTableName = "TargetTableName"
        }
    }

    public struct CreateBatchLoadTaskResponse: AWSDecodableShape {
        /// The ID of the batch load task.
        public let taskId: String

        @inlinable
        public init(taskId: String) {
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "TaskId"
        }
    }

    public struct CreateDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// The KMS key for the database. If the KMS key is not specified, the database will be encrypted with a Timestream managed KMS key located in your account. For more information, see Amazon Web Services managed keys.
        public let kmsKeyId: String?
        ///  A list of key-value pairs to label the table.
        public let tags: [Tag]?

        @inlinable
        public init(databaseName: String, kmsKeyId: String? = nil, tags: [Tag]? = nil) {
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
            case tags = "Tags"
        }
    }

    public struct CreateDatabaseResponse: AWSDecodableShape {
        /// The newly created Timestream database.
        public let database: Database?

        @inlinable
        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct CreateTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The duration for which your time-series data must be stored in the memory store and the magnetic store.
        public let retentionProperties: RetentionProperties?
        ///  The schema of the table.
        public let schema: Schema?
        /// The name of the Timestream table.
        public let tableName: String
        ///  A list of key-value pairs to label the table.
        public let tags: [Tag]?

        @inlinable
        public init(databaseName: String, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, schema: Schema? = nil, tableName: String, tags: [Tag]? = nil) {
            self.databaseName = databaseName
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.schema = schema
            self.tableName = tableName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.magneticStoreWriteProperties?.validate(name: "\(name).magneticStoreWriteProperties")
            try self.retentionProperties?.validate(name: "\(name).retentionProperties")
            try self.schema?.validate(name: "\(name).schema")
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case schema = "Schema"
            case tableName = "TableName"
            case tags = "Tags"
        }
    }

    public struct CreateTableResponse: AWSDecodableShape {
        /// The newly created Timestream table.
        public let table: Table?

        @inlinable
        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct CsvConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Column separator can be one of comma (','), pipe ('|), semicolon (';'), tab('/t'), or blank space (' ').
        public let columnSeparator: String?
        /// Escape character can be one of
        public let escapeChar: String?
        /// Can be blank space (' ').
        public let nullValue: String?
        /// Can be single quote (') or double quote (").
        public let quoteChar: String?
        /// Specifies to trim leading and trailing white space.
        public let trimWhiteSpace: Bool?

        @inlinable
        public init(columnSeparator: String? = nil, escapeChar: String? = nil, nullValue: String? = nil, quoteChar: String? = nil, trimWhiteSpace: Bool? = nil) {
            self.columnSeparator = columnSeparator
            self.escapeChar = escapeChar
            self.nullValue = nullValue
            self.quoteChar = quoteChar
            self.trimWhiteSpace = trimWhiteSpace
        }

        public func validate(name: String) throws {
            try self.validate(self.columnSeparator, name: "columnSeparator", parent: name, max: 1)
            try self.validate(self.columnSeparator, name: "columnSeparator", parent: name, min: 1)
            try self.validate(self.escapeChar, name: "escapeChar", parent: name, max: 1)
            try self.validate(self.escapeChar, name: "escapeChar", parent: name, min: 1)
            try self.validate(self.nullValue, name: "nullValue", parent: name, max: 256)
            try self.validate(self.nullValue, name: "nullValue", parent: name, min: 1)
            try self.validate(self.quoteChar, name: "quoteChar", parent: name, max: 1)
            try self.validate(self.quoteChar, name: "quoteChar", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnSeparator = "ColumnSeparator"
            case escapeChar = "EscapeChar"
            case nullValue = "NullValue"
            case quoteChar = "QuoteChar"
            case trimWhiteSpace = "TrimWhiteSpace"
        }
    }

    public struct DataModel: AWSEncodableShape & AWSDecodableShape {
        /// Source to target mappings for dimensions.
        public let dimensionMappings: [DimensionMapping]
        public let measureNameColumn: String?
        /// Source to target mappings for measures.
        public let mixedMeasureMappings: [MixedMeasureMapping]?
        /// Source to target mappings for multi-measure records.
        public let multiMeasureMappings: MultiMeasureMappings?
        /// Source column to be mapped to time.
        public let timeColumn: String?
        ///  The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public let timeUnit: TimeUnit?

        @inlinable
        public init(dimensionMappings: [DimensionMapping], measureNameColumn: String? = nil, mixedMeasureMappings: [MixedMeasureMapping]? = nil, multiMeasureMappings: MultiMeasureMappings? = nil, timeColumn: String? = nil, timeUnit: TimeUnit? = nil) {
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.timeColumn = timeColumn
            self.timeUnit = timeUnit
        }

        public func validate(name: String) throws {
            try self.dimensionMappings.forEach {
                try $0.validate(name: "\(name).dimensionMappings[]")
            }
            try self.validate(self.dimensionMappings, name: "dimensionMappings", parent: name, min: 1)
            try self.validate(self.measureNameColumn, name: "measureNameColumn", parent: name, max: 256)
            try self.validate(self.measureNameColumn, name: "measureNameColumn", parent: name, min: 1)
            try self.mixedMeasureMappings?.forEach {
                try $0.validate(name: "\(name).mixedMeasureMappings[]")
            }
            try self.validate(self.mixedMeasureMappings, name: "mixedMeasureMappings", parent: name, min: 1)
            try self.multiMeasureMappings?.validate(name: "\(name).multiMeasureMappings")
            try self.validate(self.timeColumn, name: "timeColumn", parent: name, max: 256)
            try self.validate(self.timeColumn, name: "timeColumn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionMappings = "DimensionMappings"
            case measureNameColumn = "MeasureNameColumn"
            case mixedMeasureMappings = "MixedMeasureMappings"
            case multiMeasureMappings = "MultiMeasureMappings"
            case timeColumn = "TimeColumn"
            case timeUnit = "TimeUnit"
        }
    }

    public struct DataModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let dataModel: DataModel?
        public let dataModelS3Configuration: DataModelS3Configuration?

        @inlinable
        public init(dataModel: DataModel? = nil, dataModelS3Configuration: DataModelS3Configuration? = nil) {
            self.dataModel = dataModel
            self.dataModelS3Configuration = dataModelS3Configuration
        }

        public func validate(name: String) throws {
            try self.dataModel?.validate(name: "\(name).dataModel")
            try self.dataModelS3Configuration?.validate(name: "\(name).dataModelS3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataModel = "DataModel"
            case dataModelS3Configuration = "DataModelS3Configuration"
        }
    }

    public struct DataModelS3Configuration: AWSEncodableShape & AWSDecodableShape {
        public let bucketName: String?
        public let objectKey: String?

        @inlinable
        public init(bucketName: String? = nil, objectKey: String? = nil) {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.objectKey, name: "objectKey", parent: name, max: 1024)
            try self.validate(self.objectKey, name: "objectKey", parent: name, min: 1)
            try self.validate(self.objectKey, name: "objectKey", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKey = "ObjectKey"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let csvConfiguration: CsvConfiguration?
        /// This is currently CSV.
        public let dataFormat: BatchLoadDataFormat
        /// Configuration of an S3 location for a file which contains data to load.
        public let dataSourceS3Configuration: DataSourceS3Configuration

        @inlinable
        public init(csvConfiguration: CsvConfiguration? = nil, dataFormat: BatchLoadDataFormat, dataSourceS3Configuration: DataSourceS3Configuration) {
            self.csvConfiguration = csvConfiguration
            self.dataFormat = dataFormat
            self.dataSourceS3Configuration = dataSourceS3Configuration
        }

        public func validate(name: String) throws {
            try self.csvConfiguration?.validate(name: "\(name).csvConfiguration")
            try self.dataSourceS3Configuration.validate(name: "\(name).dataSourceS3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case csvConfiguration = "CsvConfiguration"
            case dataFormat = "DataFormat"
            case dataSourceS3Configuration = "DataSourceS3Configuration"
        }
    }

    public struct DataSourceS3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The bucket name of the customer S3 bucket.
        public let bucketName: String
        ///
        public let objectKeyPrefix: String?

        @inlinable
        public init(bucketName: String, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 1024)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct Database: AWSDecodableShape {
        /// The Amazon Resource Name that uniquely identifies this database.
        public let arn: String?
        /// The time when the database was created, calculated from the Unix epoch time.
        public let creationTime: Date?
        /// The name of the Timestream database.
        public let databaseName: String?
        /// The identifier of the KMS key used to encrypt the data stored in the database.
        public let kmsKeyId: String?
        ///  The last time that this database was updated.
        public let lastUpdatedTime: Date?
        /// The total number of tables found within a Timestream database.
        public let tableCount: Int64?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, kmsKeyId: String? = nil, lastUpdatedTime: Date? = nil, tableCount: Int64? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.lastUpdatedTime = lastUpdatedTime
            self.tableCount = tableCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
            case lastUpdatedTime = "LastUpdatedTime"
            case tableCount = "TableCount"
        }
    }

    public struct DeleteDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database to be deleted.
        public let databaseName: String

        @inlinable
        public init(databaseName: String) {
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
        }
    }

    public struct DeleteTableRequest: AWSEncodableShape {
        /// The name of the database where the Timestream database is to be deleted.
        public let databaseName: String
        /// The name of the Timestream table to be deleted.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DescribeBatchLoadTaskRequest: AWSEncodableShape {
        /// The ID of the batch load task.
        public let taskId: String

        @inlinable
        public init(taskId: String) {
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskId, name: "taskId", parent: name, max: 32)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 3)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[A-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "TaskId"
        }
    }

    public struct DescribeBatchLoadTaskResponse: AWSDecodableShape {
        /// Description of the batch load task.
        public let batchLoadTaskDescription: BatchLoadTaskDescription

        @inlinable
        public init(batchLoadTaskDescription: BatchLoadTaskDescription) {
            self.batchLoadTaskDescription = batchLoadTaskDescription
        }

        private enum CodingKeys: String, CodingKey {
            case batchLoadTaskDescription = "BatchLoadTaskDescription"
        }
    }

    public struct DescribeDatabaseRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String

        @inlinable
        public init(databaseName: String) {
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
        }
    }

    public struct DescribeDatabaseResponse: AWSDecodableShape {
        /// The name of the Timestream table.
        public let database: Database?

        @inlinable
        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct DescribeEndpointsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// An Endpoints object is returned when a DescribeEndpoints request is made.
        public let endpoints: [Endpoint]

        @inlinable
        public init(endpoints: [Endpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct DescribeTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// The name of the Timestream table.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DescribeTableResponse: AWSDecodableShape {
        /// The Timestream table.
        public let table: Table?

        @inlinable
        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct Dimension: AWSEncodableShape {
        /// The data type of the dimension for the time-series data point.
        public let dimensionValueType: DimensionValueType?
        ///  Dimension represents the metadata attributes of the time series. For example, the name and Availability Zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions.  For constraints on dimension names, see Naming Constraints.
        public let name: String
        /// The value of the dimension.
        public let value: String

        @inlinable
        public init(dimensionValueType: DimensionValueType? = nil, name: String, value: String) {
            self.dimensionValueType = dimensionValueType
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueType = "DimensionValueType"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DimensionMapping: AWSEncodableShape & AWSDecodableShape {
        ///
        public let destinationColumn: String?
        public let sourceColumn: String?

        @inlinable
        public init(destinationColumn: String? = nil, sourceColumn: String? = nil) {
            self.destinationColumn = destinationColumn
            self.sourceColumn = sourceColumn
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationColumn, name: "destinationColumn", parent: name, min: 1)
            try self.validate(self.sourceColumn, name: "sourceColumn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationColumn = "DestinationColumn"
            case sourceColumn = "SourceColumn"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// An endpoint address.
        public let address: String
        /// The TTL for the endpoint, in minutes.
        public let cachePeriodInMinutes: Int64

        @inlinable
        public init(address: String, cachePeriodInMinutes: Int64) {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case cachePeriodInMinutes = "CachePeriodInMinutes"
        }
    }

    public struct ListBatchLoadTasksRequest: AWSEncodableShape {
        /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// Status of the batch load task.
        public let taskStatus: BatchLoadStatus?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, taskStatus: BatchLoadStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.taskStatus = taskStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case taskStatus = "TaskStatus"
        }
    }

    public struct ListBatchLoadTasksResponse: AWSDecodableShape {
        /// A list of batch load task details.
        public let batchLoadTasks: [BatchLoadTask]?
        /// A token to specify where to start paginating. Provide the next ListBatchLoadTasksRequest.
        public let nextToken: String?

        @inlinable
        public init(batchLoadTasks: [BatchLoadTask]? = nil, nextToken: String? = nil) {
            self.batchLoadTasks = batchLoadTasks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchLoadTasks = "BatchLoadTasks"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatabasesRequest: AWSEncodableShape {
        /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatabasesResponse: AWSDecodableShape {
        /// A list of database names.
        public let databases: [Database]?
        /// The pagination token. This parameter is returned when the response is truncated.
        public let nextToken: String?

        @inlinable
        public init(databases: [Database]? = nil, nextToken: String? = nil) {
            self.databases = databases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case databases = "Databases"
            case nextToken = "NextToken"
        }
    }

    public struct ListTablesRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String?
        /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        @inlinable
        public init(databaseName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTablesResponse: AWSDecodableShape {
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// A list of tables.
        public let tables: [Table]?

        @inlinable
        public init(nextToken: String? = nil, tables: [Table]? = nil) {
            self.nextToken = nextToken
            self.tables = tables
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tables = "Tables"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The tags currently associated with the Timestream resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MagneticStoreRejectedDataLocation: AWSEncodableShape & AWSDecodableShape {
        /// Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        public let s3Configuration: S3Configuration?

        @inlinable
        public init(s3Configuration: S3Configuration? = nil) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }

    public struct MagneticStoreWriteProperties: AWSEncodableShape & AWSDecodableShape {
        /// A flag to enable magnetic store writes.
        public let enableMagneticStoreWrites: Bool
        /// The location to write error reports for records rejected asynchronously during magnetic store writes.
        public let magneticStoreRejectedDataLocation: MagneticStoreRejectedDataLocation?

        @inlinable
        public init(enableMagneticStoreWrites: Bool, magneticStoreRejectedDataLocation: MagneticStoreRejectedDataLocation? = nil) {
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticStoreRejectedDataLocation = magneticStoreRejectedDataLocation
        }

        public func validate(name: String) throws {
            try self.magneticStoreRejectedDataLocation?.validate(name: "\(name).magneticStoreRejectedDataLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case enableMagneticStoreWrites = "EnableMagneticStoreWrites"
            case magneticStoreRejectedDataLocation = "MagneticStoreRejectedDataLocation"
        }
    }

    public struct MeasureValue: AWSEncodableShape {
        ///  The name of the MeasureValue.  For constraints on MeasureValue names, see  Naming Constraints in the Amazon Timestream Developer Guide.
        public let name: String
        /// Contains the data type of the MeasureValue for the time-series data point.
        public let type: MeasureValueType
        ///  The value for the MeasureValue. For information, see Data types.
        public let value: String

        @inlinable
        public init(name: String, type: MeasureValueType, value: String) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 2048)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct MixedMeasureMapping: AWSEncodableShape & AWSDecodableShape {
        public let measureName: String?
        public let measureValueType: MeasureValueType
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]?
        public let sourceColumn: String?
        public let targetMeasureName: String?

        @inlinable
        public init(measureName: String? = nil, measureValueType: MeasureValueType, multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]? = nil, sourceColumn: String? = nil, targetMeasureName: String? = nil) {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }

        public func validate(name: String) throws {
            try self.validate(self.measureName, name: "measureName", parent: name, min: 1)
            try self.multiMeasureAttributeMappings?.forEach {
                try $0.validate(name: "\(name).multiMeasureAttributeMappings[]")
            }
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
            try self.validate(self.sourceColumn, name: "sourceColumn", parent: name, min: 1)
            try self.validate(self.targetMeasureName, name: "targetMeasureName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case measureName = "MeasureName"
            case measureValueType = "MeasureValueType"
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case sourceColumn = "SourceColumn"
            case targetMeasureName = "TargetMeasureName"
        }
    }

    public struct MultiMeasureAttributeMapping: AWSEncodableShape & AWSDecodableShape {
        public let measureValueType: ScalarMeasureValueType?
        public let sourceColumn: String
        public let targetMultiMeasureAttributeName: String?

        @inlinable
        public init(measureValueType: ScalarMeasureValueType? = nil, sourceColumn: String, targetMultiMeasureAttributeName: String? = nil) {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceColumn, name: "sourceColumn", parent: name, min: 1)
            try self.validate(self.targetMultiMeasureAttributeName, name: "targetMultiMeasureAttributeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case measureValueType = "MeasureValueType"
            case sourceColumn = "SourceColumn"
            case targetMultiMeasureAttributeName = "TargetMultiMeasureAttributeName"
        }
    }

    public struct MultiMeasureMappings: AWSEncodableShape & AWSDecodableShape {
        public let multiMeasureAttributeMappings: [MultiMeasureAttributeMapping]
        public let targetMultiMeasureName: String?

        @inlinable
        public init(multiMeasureAttributeMappings: [MultiMeasureAttributeMapping], targetMultiMeasureName: String? = nil) {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }

        public func validate(name: String) throws {
            try self.multiMeasureAttributeMappings.forEach {
                try $0.validate(name: "\(name).multiMeasureAttributeMappings[]")
            }
            try self.validate(self.multiMeasureAttributeMappings, name: "multiMeasureAttributeMappings", parent: name, min: 1)
            try self.validate(self.targetMultiMeasureName, name: "targetMultiMeasureName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
            case targetMultiMeasureName = "TargetMultiMeasureName"
        }
    }

    public struct PartitionKey: AWSEncodableShape & AWSDecodableShape {
        ///  The level of enforcement for the specification of a dimension key in ingested records. Options are REQUIRED (dimension key must be specified) and OPTIONAL (dimension key does not have to be specified).
        public let enforcementInRecord: PartitionKeyEnforcementLevel?
        ///  The name of the attribute used for a dimension key.
        public let name: String?
        ///  The type of the partition key. Options are DIMENSION (dimension key) and MEASURE (measure key).
        public let type: PartitionKeyType

        @inlinable
        public init(enforcementInRecord: PartitionKeyEnforcementLevel? = nil, name: String? = nil, type: PartitionKeyType) {
            self.enforcementInRecord = enforcementInRecord
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enforcementInRecord = "EnforcementInRecord"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct Record: AWSEncodableShape {
        /// Contains the list of dimensions for time-series data points.
        public let dimensions: [Dimension]?
        /// Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures.
        public let measureName: String?
        ///  Contains the measure value for the time-series data point.
        public let measureValue: String?
        ///  Contains the list of MeasureValue for time-series data points.  This is only allowed for type MULTI. For scalar values, use MeasureValue attribute of the record directly.
        public let measureValues: [MeasureValue]?
        ///  Contains the data type of the measure value for the time-series data point. Default type is DOUBLE. For more information, see Data types.
        public let measureValueType: MeasureValueType?
        ///  Contains the time at which the measure value for the data point was collected. The time value plus the unit provides the time elapsed since the epoch. For example, if the time value is 12345 and the unit is ms, then 12345 ms have elapsed since the epoch.
        public let time: String?
        ///  The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public let timeUnit: TimeUnit?
        /// 64-bit attribute used for record updates. Write requests for duplicate data with a higher version number will update the existing measure value and version. In cases where the measure value is the same, Version will still be updated. Default value is 1.   Version must be 1 or greater, or you will receive a ValidationException error.
        public let version: Int64?

        @inlinable
        public init(dimensions: [Dimension]? = nil, measureName: String? = nil, measureValue: String? = nil, measureValues: [MeasureValue]? = nil, measureValueType: MeasureValueType? = nil, time: String? = nil, timeUnit: TimeUnit? = nil, version: Int64? = nil) {
            self.dimensions = dimensions
            self.measureName = measureName
            self.measureValue = measureValue
            self.measureValues = measureValues
            self.measureValueType = measureValueType
            self.time = time
            self.timeUnit = timeUnit
            self.version = version
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 128)
            try self.validate(self.measureName, name: "measureName", parent: name, min: 1)
            try self.validate(self.measureValue, name: "measureValue", parent: name, max: 2048)
            try self.validate(self.measureValue, name: "measureValue", parent: name, min: 1)
            try self.measureValues?.forEach {
                try $0.validate(name: "\(name).measureValues[]")
            }
            try self.validate(self.time, name: "time", parent: name, max: 256)
            try self.validate(self.time, name: "time", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case measureName = "MeasureName"
            case measureValue = "MeasureValue"
            case measureValues = "MeasureValues"
            case measureValueType = "MeasureValueType"
            case time = "Time"
            case timeUnit = "TimeUnit"
            case version = "Version"
        }
    }

    public struct RecordsIngested: AWSDecodableShape {
        /// Count of records ingested into the magnetic store.
        public let magneticStore: Int?
        /// Count of records ingested into the memory store.
        public let memoryStore: Int?
        /// Total count of successfully ingested records.
        public let total: Int?

        @inlinable
        public init(magneticStore: Int? = nil, memoryStore: Int? = nil, total: Int? = nil) {
            self.magneticStore = magneticStore
            self.memoryStore = memoryStore
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case magneticStore = "MagneticStore"
            case memoryStore = "MemoryStore"
            case total = "Total"
        }
    }

    public struct RejectedRecord: AWSDecodableShape {
        /// The existing version of the record. This value is populated in scenarios where an identical record exists with a higher version than the version in the write request.
        public let existingVersion: Int64?
        ///  The reason why a record was not successfully inserted into Timestream. Possible causes of failure include:    Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:    Measure values are different   Version is not present in the request, or the value of version in the new record is equal to or lower than the existing value   If Timestream rejects data for this case, the ExistingVersion field in the RejectedRecords response will indicate the current records version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.   Records with timestamps that lie outside the retention duration of the memory store.   When the retention window is updated, you will receive a RejectedRecords exception if you immediately try to ingest data within the new window. To avoid a RejectedRecords exception, wait until the duration of the new window to ingest new data. For further information, see  Best Practices for Configuring Timestream and the explanation of how storage works in Timestream.    Records with dimensions or measures that exceed the Timestream defined limits.    For more information, see Access Management in the Timestream Developer Guide.
        public let reason: String?
        ///  The index of the record in the input request for WriteRecords. Indexes begin with 0.
        public let recordIndex: Int?

        @inlinable
        public init(existingVersion: Int64? = nil, reason: String? = nil, recordIndex: Int? = nil) {
            self.existingVersion = existingVersion
            self.reason = reason
            self.recordIndex = recordIndex
        }

        private enum CodingKeys: String, CodingKey {
            case existingVersion = "ExistingVersion"
            case reason = "Reason"
            case recordIndex = "RecordIndex"
        }
    }

    public struct RejectedRecordsException: AWSErrorShape {
        public let message: String?
        ///
        public let rejectedRecords: [RejectedRecord]?

        @inlinable
        public init(message: String? = nil, rejectedRecords: [RejectedRecord]? = nil) {
            self.message = message
            self.rejectedRecords = rejectedRecords
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case rejectedRecords = "RejectedRecords"
        }
    }

    public struct ReportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration of an S3 location to write error reports and events for a batch load.
        public let reportS3Configuration: ReportS3Configuration?

        @inlinable
        public init(reportS3Configuration: ReportS3Configuration? = nil) {
            self.reportS3Configuration = reportS3Configuration
        }

        public func validate(name: String) throws {
            try self.reportS3Configuration?.validate(name: "\(name).reportS3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case reportS3Configuration = "ReportS3Configuration"
        }
    }

    public struct ReportS3Configuration: AWSEncodableShape & AWSDecodableShape {
        public let bucketName: String
        public let encryptionOption: S3EncryptionOption?
        public let kmsKeyId: String?
        public let objectKeyPrefix: String?

        @inlinable
        public init(bucketName: String, encryptionOption: S3EncryptionOption? = nil, kmsKeyId: String? = nil, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 928)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case encryptionOption = "EncryptionOption"
            case kmsKeyId = "KmsKeyId"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct ResumeBatchLoadTaskRequest: AWSEncodableShape {
        /// The ID of the batch load task to resume.
        public let taskId: String

        @inlinable
        public init(taskId: String) {
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskId, name: "taskId", parent: name, max: 32)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 3)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[A-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "TaskId"
        }
    }

    public struct ResumeBatchLoadTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RetentionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The duration for which data must be stored in the magnetic store.
        public let magneticStoreRetentionPeriodInDays: Int64
        /// The duration for which data must be stored in the memory store.
        public let memoryStoreRetentionPeriodInHours: Int64

        @inlinable
        public init(magneticStoreRetentionPeriodInDays: Int64, memoryStoreRetentionPeriodInHours: Int64) {
            self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
            self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
        }

        public func validate(name: String) throws {
            try self.validate(self.magneticStoreRetentionPeriodInDays, name: "magneticStoreRetentionPeriodInDays", parent: name, max: 73000)
            try self.validate(self.magneticStoreRetentionPeriodInDays, name: "magneticStoreRetentionPeriodInDays", parent: name, min: 1)
            try self.validate(self.memoryStoreRetentionPeriodInHours, name: "memoryStoreRetentionPeriodInHours", parent: name, max: 8766)
            try self.validate(self.memoryStoreRetentionPeriodInHours, name: "memoryStoreRetentionPeriodInHours", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case magneticStoreRetentionPeriodInDays = "MagneticStoreRetentionPeriodInDays"
            case memoryStoreRetentionPeriodInHours = "MemoryStoreRetentionPeriodInHours"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The bucket name of the customer S3 bucket.
        public let bucketName: String?
        /// The encryption option for the customer S3 location. Options are S3 server-side encryption with an S3 managed key or Amazon Web Services managed key.
        public let encryptionOption: S3EncryptionOption?
        /// The KMS key ID for the customer S3 location when encrypting with an Amazon Web Services managed key.
        public let kmsKeyId: String?
        /// The object key preview for the customer S3 location.
        public let objectKeyPrefix: String?

        @inlinable
        public init(bucketName: String? = nil, encryptionOption: S3EncryptionOption? = nil, kmsKeyId: String? = nil, objectKeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, max: 928)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, min: 1)
            try self.validate(self.objectKeyPrefix, name: "objectKeyPrefix", parent: name, pattern: "^[a-zA-Z0-9|!\\-_*'\\(\\)]([a-zA-Z0-9]|[!\\-_*'\\(\\)\\/.])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case encryptionOption = "EncryptionOption"
            case kmsKeyId = "KmsKeyId"
            case objectKeyPrefix = "ObjectKeyPrefix"
        }
    }

    public struct Schema: AWSEncodableShape & AWSDecodableShape {
        /// A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed.
        public let compositePartitionKey: [PartitionKey]?

        @inlinable
        public init(compositePartitionKey: [PartitionKey]? = nil) {
            self.compositePartitionKey = compositePartitionKey
        }

        public func validate(name: String) throws {
            try self.compositePartitionKey?.forEach {
                try $0.validate(name: "\(name).compositePartitionKey[]")
            }
            try self.validate(self.compositePartitionKey, name: "compositePartitionKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case compositePartitionKey = "CompositePartitionKey"
        }
    }

    public struct Table: AWSDecodableShape {
        /// The Amazon Resource Name that uniquely identifies this table.
        public let arn: String?
        /// The time when the Timestream table was created.
        public let creationTime: Date?
        /// The name of the Timestream database that contains this table.
        public let databaseName: String?
        /// The time when the Timestream table was last updated.
        public let lastUpdatedTime: Date?
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The retention duration for the memory store and magnetic store.
        public let retentionProperties: RetentionProperties?
        ///  The schema of the table.
        public let schema: Schema?
        /// The name of the Timestream table.
        public let tableName: String?
        /// The current state of the table:    DELETING - The table is being deleted.    ACTIVE - The table is ready for use.
        public let tableStatus: TableStatus?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, lastUpdatedTime: Date? = nil, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, schema: Schema? = nil, tableName: String? = nil, tableStatus: TableStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.schema = schema
            self.tableName = tableName
            self.tableStatus = tableStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastUpdatedTime = "LastUpdatedTime"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case schema = "Schema"
            case tableName = "TableName"
            case tableStatus = "TableStatus"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        ///  The key of the tag. Tag keys are case sensitive.
        public let key: String
        ///  The value of the tag. Tag values are case-sensitive and can be null.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        ///  The tags to be assigned to the Timestream resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
        public let resourceARN: String
        ///  A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatabaseRequest: AWSEncodableShape {
        ///  The name of the database.
        public let databaseName: String
        ///  The identifier of the new KMS key (KmsKeyId) to be used to encrypt the data stored in the database. If the KmsKeyId currently registered with the database is the same as the KmsKeyId in the request, there will not be any update.  You can specify the KmsKeyId using any of the following:   Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab    Key ARN: arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab    Alias name: alias/ExampleAlias    Alias ARN: arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias
        public let kmsKeyId: String

        @inlinable
        public init(databaseName: String, kmsKeyId: String) {
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct UpdateDatabaseResponse: AWSDecodableShape {
        public let database: Database?

        @inlinable
        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct UpdateTableRequest: AWSEncodableShape {
        /// The name of the Timestream database.
        public let databaseName: String
        /// Contains properties to set on the table when enabling magnetic store writes.
        public let magneticStoreWriteProperties: MagneticStoreWriteProperties?
        /// The retention duration of the memory store and the magnetic store.
        public let retentionProperties: RetentionProperties?
        ///  The schema of the table.
        public let schema: Schema?
        /// The name of the Timestream table.
        public let tableName: String

        @inlinable
        public init(databaseName: String, magneticStoreWriteProperties: MagneticStoreWriteProperties? = nil, retentionProperties: RetentionProperties? = nil, schema: Schema? = nil, tableName: String) {
            self.databaseName = databaseName
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.schema = schema
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.magneticStoreWriteProperties?.validate(name: "\(name).magneticStoreWriteProperties")
            try self.retentionProperties?.validate(name: "\(name).retentionProperties")
            try self.schema?.validate(name: "\(name).schema")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
            case retentionProperties = "RetentionProperties"
            case schema = "Schema"
            case tableName = "TableName"
        }
    }

    public struct UpdateTableResponse: AWSDecodableShape {
        /// The updated Timestream table.
        public let table: Table?

        @inlinable
        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct WriteRecordsRequest: AWSEncodableShape {
        /// A record that contains the common measure, dimension, time, and version attributes shared across all the records in the request. The measure and dimension attributes specified will be merged with the measure and dimension attributes in the records object when the data is written into Timestream. Dimensions may not overlap, or a ValidationException will be thrown. In other words, a record must contain dimensions with unique names.
        public let commonAttributes: Record?
        /// The name of the Timestream database.
        public let databaseName: String
        /// An array of records that contain the unique measure, dimension, time, and version attributes for each time-series data point.
        public let records: [Record]
        /// The name of the Timestream table.
        public let tableName: String

        @inlinable
        public init(commonAttributes: Record? = nil, databaseName: String, records: [Record], tableName: String) {
            self.commonAttributes = commonAttributes
            self.databaseName = databaseName
            self.records = records
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.commonAttributes?.validate(name: "\(name).commonAttributes")
            try self.records.forEach {
                try $0.validate(name: "\(name).records[]")
            }
            try self.validate(self.records, name: "records", parent: name, max: 100)
            try self.validate(self.records, name: "records", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case commonAttributes = "CommonAttributes"
            case databaseName = "DatabaseName"
            case records = "Records"
            case tableName = "TableName"
        }
    }

    public struct WriteRecordsResponse: AWSDecodableShape {
        /// Information on the records ingested by this request.
        public let recordsIngested: RecordsIngested?

        @inlinable
        public init(recordsIngested: RecordsIngested? = nil) {
            self.recordsIngested = recordsIngested
        }

        private enum CodingKeys: String, CodingKey {
            case recordsIngested = "RecordsIngested"
        }
    }
}

// MARK: - Errors

/// Error enum for TimestreamWrite
public struct TimestreamWriteErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidEndpointException = "InvalidEndpointException"
        case rejectedRecordsException = "RejectedRecordsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize TimestreamWrite
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Timestream was unable to process this request because it contains resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    ///  Timestream was unable to fully process this request because of an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested endpoint was not valid.
    public static var invalidEndpointException: Self { .init(.invalidEndpointException) }
    ///  WriteRecords would throw this exception in the following cases:    Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:    Measure values are different   Version is not present in the request or the value of version in the new record is equal to or lower than the existing value   In this case, if Timestream rejects data, the ExistingVersion field in the RejectedRecords response will indicate the current records version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.   Records with timestamps that lie outside the retention duration of the memory store.    Records with dimensions or measures that exceed the Timestream defined limits.    For more information, see Quotas in the Amazon Timestream Developer Guide.
    public static var rejectedRecordsException: Self { .init(.rejectedRecordsException) }
    /// The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The instance quota of resource exceeded for this account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  Too many requests were made by a user and they exceeded the service quotas. The request was throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  An invalid or malformed request.
    public static var validationException: Self { .init(.validationException) }
}

extension TimestreamWriteErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "RejectedRecordsException": TimestreamWrite.RejectedRecordsException.self
    ]
}

extension TimestreamWriteErrorType: Equatable {
    public static func == (lhs: TimestreamWriteErrorType, rhs: TimestreamWriteErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TimestreamWriteErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
