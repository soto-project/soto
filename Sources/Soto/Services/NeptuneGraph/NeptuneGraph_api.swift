//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS NeptuneGraph service.
///
/// Neptune Analytics is a new analytics database engine for Amazon Neptune that helps customers get to  insights faster by quickly processing large amounts of graph data, invoking popular graph analytic  algorithms in low-latency queries, and getting analytics results in seconds.
public struct NeptuneGraph: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the NeptuneGraph client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "NeptuneGraph",
            serviceIdentifier: "neptune-graph",
            serviceProtocol: .restjson,
            apiVersion: "2023-11-29",
            endpoint: endpoint,
            errorType: NeptuneGraphErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Deletes the specified import task.
    @Sendable
    @inlinable
    public func cancelImportTask(_ input: CancelImportTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelImportTaskOutput {
        try await self.client.execute(
            operation: "CancelImportTask", 
            path: "/importtasks/{taskIdentifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified import task.
    ///
    /// Parameters:
    ///   - taskIdentifier: The unique identifier of the import task.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelImportTask(
        taskIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelImportTaskOutput {
        let input = CancelImportTaskInput(
            taskIdentifier: taskIdentifier
        )
        return try await self.cancelImportTask(input, logger: logger)
    }

    /// Cancels a specified query.
    @Sendable
    @inlinable
    public func cancelQuery(_ input: CancelQueryInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CancelQuery", 
            path: "/queries/{queryId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "{graphIdentifier}.", 
            logger: logger
        )
    }
    /// Cancels a specified query.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - queryId: The unique identifier of the query to cancel.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelQuery(
        graphIdentifier: String,
        queryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CancelQueryInput(
            graphIdentifier: graphIdentifier, 
            queryId: queryId
        )
        return try await self.cancelQuery(input, logger: logger)
    }

    /// Creates a new Neptune Analytics graph.
    @Sendable
    @inlinable
    public func createGraph(_ input: CreateGraphInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGraphOutput {
        try await self.client.execute(
            operation: "CreateGraph", 
            path: "/graphs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Neptune Analytics graph.
    ///
    /// Parameters:
    ///   - deletionProtection: Indicates whether or not to enable deletion protection on the graph. The graph canâ€™t be deleted when deletion protection is enabled. (true or false).
    ///   - graphName: A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    ///   - kmsKeyIdentifier: Specifies a KMS key to use to encrypt data in the new graph.
    ///   - provisionedMemory: The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    ///   - publicConnectivity: Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    ///   - replicaCount: The number of replicas in other AZs. Min =0, Max = 2, Default = 1.   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    ///   - tags: Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    ///   - vectorSearchConfiguration: Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    ///   - logger: Logger use during operation
    @inlinable
    public func createGraph(
        deletionProtection: Bool? = nil,
        graphName: String,
        kmsKeyIdentifier: String? = nil,
        provisionedMemory: Int,
        publicConnectivity: Bool? = nil,
        replicaCount: Int? = nil,
        tags: [String: String]? = nil,
        vectorSearchConfiguration: VectorSearchConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGraphOutput {
        let input = CreateGraphInput(
            deletionProtection: deletionProtection, 
            graphName: graphName, 
            kmsKeyIdentifier: kmsKeyIdentifier, 
            provisionedMemory: provisionedMemory, 
            publicConnectivity: publicConnectivity, 
            replicaCount: replicaCount, 
            tags: tags, 
            vectorSearchConfiguration: vectorSearchConfiguration
        )
        return try await self.createGraph(input, logger: logger)
    }

    /// Creates a snapshot of the specific graph.
    @Sendable
    @inlinable
    public func createGraphSnapshot(_ input: CreateGraphSnapshotInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGraphSnapshotOutput {
        try await self.client.execute(
            operation: "CreateGraphSnapshot", 
            path: "/snapshots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a snapshot of the specific graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - snapshotName: The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    ///   - tags: Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGraphSnapshot(
        graphIdentifier: String,
        snapshotName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGraphSnapshotOutput {
        let input = CreateGraphSnapshotInput(
            graphIdentifier: graphIdentifier, 
            snapshotName: snapshotName, 
            tags: tags
        )
        return try await self.createGraphSnapshot(input, logger: logger)
    }

    /// Creates a new Neptune Analytics graph and imports data into it, either from Amazon Simple Storage Service (S3) or from a Neptune database or a Neptune database snapshot. The data can be loaded from files in S3 that in either the Gremlin CSV format or the openCypher load format.
    @Sendable
    @inlinable
    public func createGraphUsingImportTask(_ input: CreateGraphUsingImportTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGraphUsingImportTaskOutput {
        try await self.client.execute(
            operation: "CreateGraphUsingImportTask", 
            path: "/importtasks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Neptune Analytics graph and imports data into it, either from Amazon Simple Storage Service (S3) or from a Neptune database or a Neptune database snapshot. The data can be loaded from files in S3 that in either the Gremlin CSV format or the openCypher load format.
    ///
    /// Parameters:
    ///   - blankNodeHandling: The method to handle blank nodes in the dataset. Currently, only convertToIri is supported,  meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples.  For more information, see Handling RDF values.
    ///   - deletionProtection: Indicates whether or not to enable deletion protection on the graph. The graph canâ€™t be deleted when deletion protection is enabled. (true or false).
    ///   - failOnError: If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    ///   - format: Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
    ///   - graphName: A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    ///   - importOptions: Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    ///   - kmsKeyIdentifier: Specifies a KMS key to use to encrypt data imported into the new graph.
    ///   - maxProvisionedMemory: The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the max of the min-provisioned-memory and max-provisioned memory is used to create the graph. If neither value is specified 128 m-NCUs are used.
    ///   - minProvisionedMemory: The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 128
    ///   - publicConnectivity: Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    ///   - replicaCount: The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2.   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    ///   - roleArn: The ARN of the IAM role that will allow access to the data that is to be imported.
    ///   - source: A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    ///   - tags: Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    ///   - vectorSearchConfiguration: Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    ///   - logger: Logger use during operation
    @inlinable
    public func createGraphUsingImportTask(
        blankNodeHandling: BlankNodeHandling? = nil,
        deletionProtection: Bool? = nil,
        failOnError: Bool? = nil,
        format: Format? = nil,
        graphName: String,
        importOptions: ImportOptions? = nil,
        kmsKeyIdentifier: String? = nil,
        maxProvisionedMemory: Int? = nil,
        minProvisionedMemory: Int? = nil,
        publicConnectivity: Bool? = nil,
        replicaCount: Int? = nil,
        roleArn: String,
        source: String,
        tags: [String: String]? = nil,
        vectorSearchConfiguration: VectorSearchConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGraphUsingImportTaskOutput {
        let input = CreateGraphUsingImportTaskInput(
            blankNodeHandling: blankNodeHandling, 
            deletionProtection: deletionProtection, 
            failOnError: failOnError, 
            format: format, 
            graphName: graphName, 
            importOptions: importOptions, 
            kmsKeyIdentifier: kmsKeyIdentifier, 
            maxProvisionedMemory: maxProvisionedMemory, 
            minProvisionedMemory: minProvisionedMemory, 
            publicConnectivity: publicConnectivity, 
            replicaCount: replicaCount, 
            roleArn: roleArn, 
            source: source, 
            tags: tags, 
            vectorSearchConfiguration: vectorSearchConfiguration
        )
        return try await self.createGraphUsingImportTask(input, logger: logger)
    }

    /// Create a private graph endpoint to allow private access from to the graph from within a VPC. You can attach security groups to the private graph endpoint.  VPC endpoint charges apply.
    @Sendable
    @inlinable
    public func createPrivateGraphEndpoint(_ input: CreatePrivateGraphEndpointInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePrivateGraphEndpointOutput {
        try await self.client.execute(
            operation: "CreatePrivateGraphEndpoint", 
            path: "/graphs/{graphIdentifier}/endpoints/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a private graph endpoint to allow private access from to the graph from within a VPC. You can attach security groups to the private graph endpoint.  VPC endpoint charges apply.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - subnetIds: Subnets in which private graph endpoint ENIs are created.
    ///   - vpcId:  The VPC in which the private graph endpoint needs to be created.
    ///   - vpcSecurityGroupIds: Security groups to be attached to the private graph endpoint..
    ///   - logger: Logger use during operation
    @inlinable
    public func createPrivateGraphEndpoint(
        graphIdentifier: String,
        subnetIds: [String]? = nil,
        vpcId: String? = nil,
        vpcSecurityGroupIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePrivateGraphEndpointOutput {
        let input = CreatePrivateGraphEndpointInput(
            graphIdentifier: graphIdentifier, 
            subnetIds: subnetIds, 
            vpcId: vpcId, 
            vpcSecurityGroupIds: vpcSecurityGroupIds
        )
        return try await self.createPrivateGraphEndpoint(input, logger: logger)
    }

    /// Deletes the specified graph. Graphs cannot be deleted if delete-protection is enabled.
    @Sendable
    @inlinable
    public func deleteGraph(_ input: DeleteGraphInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGraphOutput {
        try await self.client.execute(
            operation: "DeleteGraph", 
            path: "/graphs/{graphIdentifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified graph. Graphs cannot be deleted if delete-protection is enabled.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - skipSnapshot: Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGraph(
        graphIdentifier: String,
        skipSnapshot: Bool,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGraphOutput {
        let input = DeleteGraphInput(
            graphIdentifier: graphIdentifier, 
            skipSnapshot: skipSnapshot
        )
        return try await self.deleteGraph(input, logger: logger)
    }

    /// Deletes the specifed graph snapshot.
    @Sendable
    @inlinable
    public func deleteGraphSnapshot(_ input: DeleteGraphSnapshotInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGraphSnapshotOutput {
        try await self.client.execute(
            operation: "DeleteGraphSnapshot", 
            path: "/snapshots/{snapshotIdentifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specifed graph snapshot.
    ///
    /// Parameters:
    ///   - snapshotIdentifier: ID of the graph snapshot to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGraphSnapshot(
        snapshotIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGraphSnapshotOutput {
        let input = DeleteGraphSnapshotInput(
            snapshotIdentifier: snapshotIdentifier
        )
        return try await self.deleteGraphSnapshot(input, logger: logger)
    }

    /// Deletes a private graph endpoint.
    @Sendable
    @inlinable
    public func deletePrivateGraphEndpoint(_ input: DeletePrivateGraphEndpointInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePrivateGraphEndpointOutput {
        try await self.client.execute(
            operation: "DeletePrivateGraphEndpoint", 
            path: "/graphs/{graphIdentifier}/endpoints/{vpcId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a private graph endpoint.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - vpcId: The ID of the VPC where the private endpoint is located.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePrivateGraphEndpoint(
        graphIdentifier: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePrivateGraphEndpointOutput {
        let input = DeletePrivateGraphEndpointInput(
            graphIdentifier: graphIdentifier, 
            vpcId: vpcId
        )
        return try await self.deletePrivateGraphEndpoint(input, logger: logger)
    }

    /// Execute an openCypher query.  When invoking this operation in a Neptune Analytics cluster, the IAM user or role making the request must have a policy attached  that allows one of the following IAM actions in that cluster, depending on the query:    neptune-graph:ReadDataViaQuery   neptune-graph:WriteDataViaQuery   neptune-graph:DeleteDataViaQuery
    @Sendable
    @inlinable
    public func executeQuery(_ input: ExecuteQueryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ExecuteQueryOutput {
        try await self.client.execute(
            operation: "ExecuteQuery", 
            path: "/queries", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "{graphIdentifier}.", 
            logger: logger
        )
    }
    /// Execute an openCypher query.  When invoking this operation in a Neptune Analytics cluster, the IAM user or role making the request must have a policy attached  that allows one of the following IAM actions in that cluster, depending on the query:    neptune-graph:ReadDataViaQuery   neptune-graph:WriteDataViaQuery   neptune-graph:DeleteDataViaQuery
    ///
    /// Parameters:
    ///   - explainMode: The explain mode parameter returns a query explain instead of the actual query results. A query explain can  be used to gather insights about the query execution such as planning decisions, time spent on each operator, solutions  flowing etc.
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - language: The query language the query is written in. Currently only openCypher is supported.
    ///   - parameters: The data parameters the query can use in JSON format. For example: {"name": "john", "age": 20}. (optional)
    ///   - planCache: Query plan cache is a feature that saves the query plan and reuses it on successive executions of the same query.  This reduces query latency, and works for both READ and UPDATE queries. The plan cache is an  LRU cache with a 5 minute TTL and a capacity of 1000.
    ///   - queryString: The query string to be executed.
    ///   - queryTimeoutMilliseconds: Specifies the query timeout duration, in milliseconds. (optional)
    ///   - logger: Logger use during operation
    @inlinable
    public func executeQuery(
        explainMode: ExplainMode? = nil,
        graphIdentifier: String,
        language: QueryLanguage,
        parameters: [String: String]? = nil,
        planCache: PlanCacheType? = nil,
        queryString: String,
        queryTimeoutMilliseconds: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ExecuteQueryOutput {
        let input = ExecuteQueryInput(
            explainMode: explainMode, 
            graphIdentifier: graphIdentifier, 
            language: language, 
            parameters: parameters, 
            planCache: planCache, 
            queryString: queryString, 
            queryTimeoutMilliseconds: queryTimeoutMilliseconds
        )
        return try await self.executeQuery(input, logger: logger)
    }

    /// Gets information about a specified graph.
    @Sendable
    @inlinable
    public func getGraph(_ input: GetGraphInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGraphOutput {
        try await self.client.execute(
            operation: "GetGraph", 
            path: "/graphs/{graphIdentifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGraph(
        graphIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGraphOutput {
        let input = GetGraphInput(
            graphIdentifier: graphIdentifier
        )
        return try await self.getGraph(input, logger: logger)
    }

    /// Retrieves a specified graph snapshot.
    @Sendable
    @inlinable
    public func getGraphSnapshot(_ input: GetGraphSnapshotInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGraphSnapshotOutput {
        try await self.client.execute(
            operation: "GetGraphSnapshot", 
            path: "/snapshots/{snapshotIdentifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified graph snapshot.
    ///
    /// Parameters:
    ///   - snapshotIdentifier: The ID of the snapshot to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGraphSnapshot(
        snapshotIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGraphSnapshotOutput {
        let input = GetGraphSnapshotInput(
            snapshotIdentifier: snapshotIdentifier
        )
        return try await self.getGraphSnapshot(input, logger: logger)
    }

    /// Gets a graph summary for a property graph.
    @Sendable
    @inlinable
    public func getGraphSummary(_ input: GetGraphSummaryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGraphSummaryOutput {
        try await self.client.execute(
            operation: "GetGraphSummary", 
            path: "/summary", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "{graphIdentifier}.", 
            logger: logger
        )
    }
    /// Gets a graph summary for a property graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - mode: The summary mode can take one of two values: basic (the default), and detailed.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGraphSummary(
        graphIdentifier: String,
        mode: GraphSummaryMode? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGraphSummaryOutput {
        let input = GetGraphSummaryInput(
            graphIdentifier: graphIdentifier, 
            mode: mode
        )
        return try await self.getGraphSummary(input, logger: logger)
    }

    /// Retrieves a specified import task.
    @Sendable
    @inlinable
    public func getImportTask(_ input: GetImportTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImportTaskOutput {
        try await self.client.execute(
            operation: "GetImportTask", 
            path: "/importtasks/{taskIdentifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified import task.
    ///
    /// Parameters:
    ///   - taskIdentifier: The unique identifier of the import task.
    ///   - logger: Logger use during operation
    @inlinable
    public func getImportTask(
        taskIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImportTaskOutput {
        let input = GetImportTaskInput(
            taskIdentifier: taskIdentifier
        )
        return try await self.getImportTask(input, logger: logger)
    }

    /// Retrieves information about a specified private endpoint.
    @Sendable
    @inlinable
    public func getPrivateGraphEndpoint(_ input: GetPrivateGraphEndpointInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPrivateGraphEndpointOutput {
        try await self.client.execute(
            operation: "GetPrivateGraphEndpoint", 
            path: "/graphs/{graphIdentifier}/endpoints/{vpcId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specified private endpoint.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - vpcId: The ID of the VPC where the private endpoint is located.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPrivateGraphEndpoint(
        graphIdentifier: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPrivateGraphEndpointOutput {
        let input = GetPrivateGraphEndpointInput(
            graphIdentifier: graphIdentifier, 
            vpcId: vpcId
        )
        return try await self.getPrivateGraphEndpoint(input, logger: logger)
    }

    /// Retrieves the status of a specified query.   When invoking this operation in a Neptune Analytics cluster, the IAM user or role making the request must have the  neptune-graph:GetQueryStatus IAM action attached.
    @Sendable
    @inlinable
    public func getQuery(_ input: GetQueryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetQueryOutput {
        try await self.client.execute(
            operation: "GetQuery", 
            path: "/queries/{queryId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "{graphIdentifier}.", 
            logger: logger
        )
    }
    /// Retrieves the status of a specified query.   When invoking this operation in a Neptune Analytics cluster, the IAM user or role making the request must have the  neptune-graph:GetQueryStatus IAM action attached.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - queryId: The ID of the query in question.
    ///   - logger: Logger use during operation
    @inlinable
    public func getQuery(
        graphIdentifier: String,
        queryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetQueryOutput {
        let input = GetQueryInput(
            graphIdentifier: graphIdentifier, 
            queryId: queryId
        )
        return try await self.getQuery(input, logger: logger)
    }

    /// Lists available snapshots of a specified Neptune Analytics graph.
    @Sendable
    @inlinable
    public func listGraphSnapshots(_ input: ListGraphSnapshotsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGraphSnapshotsOutput {
        try await self.client.execute(
            operation: "ListGraphSnapshots", 
            path: "/snapshots", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists available snapshots of a specified Neptune Analytics graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - nextToken: Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGraphSnapshots(
        graphIdentifier: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGraphSnapshotsOutput {
        let input = ListGraphSnapshotsInput(
            graphIdentifier: graphIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGraphSnapshots(input, logger: logger)
    }

    /// Lists available Neptune Analytics graphs.
    @Sendable
    @inlinable
    public func listGraphs(_ input: ListGraphsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGraphsOutput {
        try await self.client.execute(
            operation: "ListGraphs", 
            path: "/graphs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists available Neptune Analytics graphs.
    ///
    /// Parameters:
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - nextToken: Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGraphs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGraphsOutput {
        let input = ListGraphsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGraphs(input, logger: logger)
    }

    /// Lists import tasks.
    @Sendable
    @inlinable
    public func listImportTasks(_ input: ListImportTasksInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImportTasksOutput {
        try await self.client.execute(
            operation: "ListImportTasks", 
            path: "/importtasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists import tasks.
    ///
    /// Parameters:
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - nextToken: Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listImportTasks(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImportTasksOutput {
        let input = ListImportTasksInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImportTasks(input, logger: logger)
    }

    /// Lists private endpoints for a specified Neptune Analytics graph.
    @Sendable
    @inlinable
    public func listPrivateGraphEndpoints(_ input: ListPrivateGraphEndpointsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPrivateGraphEndpointsOutput {
        try await self.client.execute(
            operation: "ListPrivateGraphEndpoints", 
            path: "/graphs/{graphIdentifier}/endpoints/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists private endpoints for a specified Neptune Analytics graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - nextToken: Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrivateGraphEndpoints(
        graphIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPrivateGraphEndpointsOutput {
        let input = ListPrivateGraphEndpointsInput(
            graphIdentifier: graphIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPrivateGraphEndpoints(input, logger: logger)
    }

    /// Lists active openCypher queries.
    @Sendable
    @inlinable
    public func listQueries(_ input: ListQueriesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueriesOutput {
        try await self.client.execute(
            operation: "ListQueries", 
            path: "/queries", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "{graphIdentifier}.", 
            logger: logger
        )
    }
    /// Lists active openCypher queries.
    ///
    /// Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - maxResults: The maximum number of results to be fetched by the API.
    ///   - state: Filtered list of queries based on state.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueries(
        graphIdentifier: String,
        maxResults: Int,
        state: QueryStateInput? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueriesOutput {
        let input = ListQueriesInput(
            graphIdentifier: graphIdentifier, 
            maxResults: maxResults, 
            state: state
        )
        return try await self.listQueries(input, logger: logger)
    }

    /// Lists tags associated with a specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists tags associated with a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Empties the data from a specified Neptune Analytics graph.
    @Sendable
    @inlinable
    public func resetGraph(_ input: ResetGraphInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ResetGraphOutput {
        try await self.client.execute(
            operation: "ResetGraph", 
            path: "/graphs/{graphIdentifier}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Empties the data from a specified Neptune Analytics graph.
    ///
    /// Parameters:
    ///   - graphIdentifier: ID of the graph to reset.
    ///   - skipSnapshot: Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func resetGraph(
        graphIdentifier: String,
        skipSnapshot: Bool,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ResetGraphOutput {
        let input = ResetGraphInput(
            graphIdentifier: graphIdentifier, 
            skipSnapshot: skipSnapshot
        )
        return try await self.resetGraph(input, logger: logger)
    }

    /// Restores a graph from a snapshot.
    @Sendable
    @inlinable
    public func restoreGraphFromSnapshot(_ input: RestoreGraphFromSnapshotInput, logger: Logger = AWSClient.loggingDisabled) async throws -> RestoreGraphFromSnapshotOutput {
        try await self.client.execute(
            operation: "RestoreGraphFromSnapshot", 
            path: "/snapshots/{snapshotIdentifier}/restore", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Restores a graph from a snapshot.
    ///
    /// Parameters:
    ///   - deletionProtection: A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    ///   - graphName: A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    ///   - provisionedMemory: The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    ///   - publicConnectivity: Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    ///   - replicaCount: The number of replicas in other AZs. Min =0, Max = 2, Default =1   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    ///   - snapshotIdentifier: The ID of the snapshot in question.
    ///   - tags: Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func restoreGraphFromSnapshot(
        deletionProtection: Bool? = nil,
        graphName: String,
        provisionedMemory: Int? = nil,
        publicConnectivity: Bool? = nil,
        replicaCount: Int? = nil,
        snapshotIdentifier: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RestoreGraphFromSnapshotOutput {
        let input = RestoreGraphFromSnapshotInput(
            deletionProtection: deletionProtection, 
            graphName: graphName, 
            provisionedMemory: provisionedMemory, 
            publicConnectivity: publicConnectivity, 
            replicaCount: replicaCount, 
            snapshotIdentifier: snapshotIdentifier, 
            tags: tags
        )
        return try await self.restoreGraphFromSnapshot(input, logger: logger)
    }

    /// Import data into existing Neptune Analytics graph from Amazon Simple Storage Service (S3). The graph needs to be empty and in the AVAILABLE state.
    @Sendable
    @inlinable
    public func startImportTask(_ input: StartImportTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImportTaskOutput {
        try await self.client.execute(
            operation: "StartImportTask", 
            path: "/graphs/{graphIdentifier}/importtasks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Import data into existing Neptune Analytics graph from Amazon Simple Storage Service (S3). The graph needs to be empty and in the AVAILABLE state.
    ///
    /// Parameters:
    ///   - blankNodeHandling: The method to handle blank nodes in the dataset. Currently, only convertToIri is supported,  meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples.  For more information, see Handling RDF values.
    ///   - failOnError: If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that  caused the error and continues if possible.
    ///   - format: Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or  OPENCYPHER, which identies the openCypher load format.
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - importOptions: 
    ///   - roleArn: The ARN of the IAM role that will allow access to the data that is to be imported.
    ///   - source: A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a  Neptune database endpoint or snapshot.
    ///   - logger: Logger use during operation
    @inlinable
    public func startImportTask(
        blankNodeHandling: BlankNodeHandling? = nil,
        failOnError: Bool? = nil,
        format: Format? = nil,
        graphIdentifier: String,
        importOptions: ImportOptions? = nil,
        roleArn: String,
        source: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartImportTaskOutput {
        let input = StartImportTaskInput(
            blankNodeHandling: blankNodeHandling, 
            failOnError: failOnError, 
            format: format, 
            graphIdentifier: graphIdentifier, 
            importOptions: importOptions, 
            roleArn: roleArn, 
            source: source
        )
        return try await self.startImportTask(input, logger: logger)
    }

    /// Adds tags to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds tags to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: ARN of the resource for which tags need to be added.
    ///   - tags: The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs:  Key (string) Â  â€“ Â  A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").  Value (string) Â  â€“ Â  A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the specified tags from the specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified tags from the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: ARN of the resource whose tag needs to be removed.
    ///   - tagKeys: Tag keys for the tags to be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of a specified Neptune Analytics graph
    @Sendable
    @inlinable
    public func updateGraph(_ input: UpdateGraphInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGraphOutput {
        try await self.client.execute(
            operation: "UpdateGraph", 
            path: "/graphs/{graphIdentifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a specified Neptune Analytics graph
    ///
    /// Parameters:
    ///   - deletionProtection: A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - provisionedMemory: The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    ///   - publicConnectivity: Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGraph(
        deletionProtection: Bool? = nil,
        graphIdentifier: String,
        provisionedMemory: Int? = nil,
        publicConnectivity: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGraphOutput {
        let input = UpdateGraphInput(
            deletionProtection: deletionProtection, 
            graphIdentifier: graphIdentifier, 
            provisionedMemory: provisionedMemory, 
            publicConnectivity: publicConnectivity
        )
        return try await self.updateGraph(input, logger: logger)
    }
}

extension NeptuneGraph {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: NeptuneGraph, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NeptuneGraph {
    /// Return PaginatorSequence for operation ``listGraphSnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGraphSnapshotsPaginator(
        _ input: ListGraphSnapshotsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGraphSnapshotsInput, ListGraphSnapshotsOutput> {
        return .init(
            input: input,
            command: self.listGraphSnapshots,
            inputKey: \ListGraphSnapshotsInput.nextToken,
            outputKey: \ListGraphSnapshotsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGraphSnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGraphSnapshotsPaginator(
        graphIdentifier: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGraphSnapshotsInput, ListGraphSnapshotsOutput> {
        let input = ListGraphSnapshotsInput(
            graphIdentifier: graphIdentifier, 
            maxResults: maxResults
        )
        return self.listGraphSnapshotsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGraphs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGraphsPaginator(
        _ input: ListGraphsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGraphsInput, ListGraphsOutput> {
        return .init(
            input: input,
            command: self.listGraphs,
            inputKey: \ListGraphsInput.nextToken,
            outputKey: \ListGraphsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGraphs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGraphsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGraphsInput, ListGraphsOutput> {
        let input = ListGraphsInput(
            maxResults: maxResults
        )
        return self.listGraphsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImportTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportTasksPaginator(
        _ input: ListImportTasksInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImportTasksInput, ListImportTasksOutput> {
        return .init(
            input: input,
            command: self.listImportTasks,
            inputKey: \ListImportTasksInput.nextToken,
            outputKey: \ListImportTasksOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImportTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportTasksPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImportTasksInput, ListImportTasksOutput> {
        let input = ListImportTasksInput(
            maxResults: maxResults
        )
        return self.listImportTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrivateGraphEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrivateGraphEndpointsPaginator(
        _ input: ListPrivateGraphEndpointsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPrivateGraphEndpointsInput, ListPrivateGraphEndpointsOutput> {
        return .init(
            input: input,
            command: self.listPrivateGraphEndpoints,
            inputKey: \ListPrivateGraphEndpointsInput.nextToken,
            outputKey: \ListPrivateGraphEndpointsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrivateGraphEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - maxResults: The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrivateGraphEndpointsPaginator(
        graphIdentifier: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPrivateGraphEndpointsInput, ListPrivateGraphEndpointsOutput> {
        let input = ListPrivateGraphEndpointsInput(
            graphIdentifier: graphIdentifier, 
            maxResults: maxResults
        )
        return self.listPrivateGraphEndpointsPaginator(input, logger: logger)
    }
}

extension NeptuneGraph.ListGraphSnapshotsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> NeptuneGraph.ListGraphSnapshotsInput {
        return .init(
            graphIdentifier: self.graphIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension NeptuneGraph.ListGraphsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> NeptuneGraph.ListGraphsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension NeptuneGraph.ListImportTasksInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> NeptuneGraph.ListImportTasksInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension NeptuneGraph.ListPrivateGraphEndpointsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> NeptuneGraph.ListPrivateGraphEndpointsInput {
        return .init(
            graphIdentifier: self.graphIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NeptuneGraph {
    /// Waiter for operation ``getGraph(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphAvailable(
        _ input: GetGraphInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetGraphInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "AVAILABLE")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(28800),
            command: self.getGraph
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getGraph(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphAvailable(
        graphIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetGraphInput(
            graphIdentifier: graphIdentifier
        )
        try await self.waitUntilGraphAvailable(input, logger: logger)
    }

    /// Waiter for operation ``getGraph(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphDeleted(
        _ input: GetGraphInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetGraphInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status != 'deletinG'", expected: "true")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(3600),
            command: self.getGraph
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getGraph(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphDeleted(
        graphIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetGraphInput(
            graphIdentifier: graphIdentifier
        )
        try await self.waitUntilGraphDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getGraphSnapshot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphSnapshotAvailable(
        _ input: GetGraphSnapshotInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetGraphSnapshotInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "AVAILABLE")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(7200),
            command: self.getGraphSnapshot
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getGraphSnapshot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - snapshotIdentifier: The ID of the snapshot to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphSnapshotAvailable(
        snapshotIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetGraphSnapshotInput(
            snapshotIdentifier: snapshotIdentifier
        )
        try await self.waitUntilGraphSnapshotAvailable(input, logger: logger)
    }

    /// Waiter for operation ``getGraphSnapshot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphSnapshotDeleted(
        _ input: GetGraphSnapshotInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetGraphSnapshotInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status != 'deletinG'", expected: "true")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(3600),
            command: self.getGraphSnapshot
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getGraphSnapshot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - snapshotIdentifier: The ID of the snapshot to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilGraphSnapshotDeleted(
        snapshotIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetGraphSnapshotInput(
            snapshotIdentifier: snapshotIdentifier
        )
        try await self.waitUntilGraphSnapshotDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getImportTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilImportTaskCancelled(
        _ input: GetImportTaskInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetImportTaskInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status != 'cancellinG' && status != 'cancelleD'", expected: "true")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(3600),
            command: self.getImportTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getImportTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - taskIdentifier: The unique identifier of the import task.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilImportTaskCancelled(
        taskIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetImportTaskInput(
            taskIdentifier: taskIdentifier
        )
        try await self.waitUntilImportTaskCancelled(input, logger: logger)
    }

    /// Waiter for operation ``getImportTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilImportTaskSuccessful(
        _ input: GetImportTaskInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetImportTaskInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CANCELLED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "ROLLING_BACK")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "SUCCEEDED")),
            ],
            minDelayTime: .seconds(60),
            maxDelayTime: .seconds(28800),
            command: self.getImportTask
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getImportTask(_:logger:)``.
    ///
    /// - Parameters:
    ///   - taskIdentifier: The unique identifier of the import task.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilImportTaskSuccessful(
        taskIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetImportTaskInput(
            taskIdentifier: taskIdentifier
        )
        try await self.waitUntilImportTaskSuccessful(input, logger: logger)
    }

    /// Waiter for operation ``getPrivateGraphEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPrivateGraphEndpointAvailable(
        _ input: GetPrivateGraphEndpointInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPrivateGraphEndpointInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "AVAILABLE")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(1800),
            command: self.getPrivateGraphEndpoint
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPrivateGraphEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - vpcId: The ID of the VPC where the private endpoint is located.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPrivateGraphEndpointAvailable(
        graphIdentifier: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPrivateGraphEndpointInput(
            graphIdentifier: graphIdentifier, 
            vpcId: vpcId
        )
        try await self.waitUntilPrivateGraphEndpointAvailable(input, logger: logger)
    }

    /// Waiter for operation ``getPrivateGraphEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPrivateGraphEndpointDeleted(
        _ input: GetPrivateGraphEndpointInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPrivateGraphEndpointInput, _>(
            acceptors: [
                .init(state: .failure, matcher: try! JMESPathMatcher("status != 'deletinG'", expected: "true")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(1800),
            command: self.getPrivateGraphEndpoint
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPrivateGraphEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - graphIdentifier: The unique identifier of the Neptune Analytics graph.
    ///   - vpcId: The ID of the VPC where the private endpoint is located.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPrivateGraphEndpointDeleted(
        graphIdentifier: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPrivateGraphEndpointInput(
            graphIdentifier: graphIdentifier, 
            vpcId: vpcId
        )
        try await self.waitUntilPrivateGraphEndpointDeleted(input, logger: logger)
    }
}
