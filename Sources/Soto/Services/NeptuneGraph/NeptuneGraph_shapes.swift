//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension NeptuneGraph {
    // MARK: Enums

    public enum ExplainMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case details = "DETAILS"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case openCypher = "OPEN_CYPHER"
        public var description: String { return self.rawValue }
    }

    public enum GraphStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case importing = "IMPORTING"
        case resetting = "RESETTING"
        case snapshotting = "SNAPSHOTTING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum GraphSummaryMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case detailed = "DETAILED"
        public var description: String { return self.rawValue }
    }

    public enum ImportTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analyzingData = "ANALYZING_DATA"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case exporting = "EXPORTING"
        case failed = "FAILED"
        case importing = "IMPORTING"
        case initializing = "INITIALIZING"
        case reprovisioning = "REPROVISIONING"
        case rollingBack = "ROLLING_BACK"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum PlanCacheType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PrivateGraphEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum QueryLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case openCypher = "OPEN_CYPHER"
        public var description: String { return self.rawValue }
    }

    public enum QueryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelling = "CANCELLING"
        case running = "RUNNING"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum QueryStateInput: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case cancelling = "CANCELLING"
        case running = "RUNNING"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CancelImportTaskInput: AWSEncodableShape {
        /// The unique identifier of the import task.
        public let taskIdentifier: String

        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// Current status of the task. Status is CANCELLING when the import task is cancelled.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        public init(format: Format? = nil, graphId: String? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct CancelQueryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The unique identifier of the query to cancel.
        public let queryId: String

        public init(graphIdentifier: String, queryId: String) {
            self.graphIdentifier = graphIdentifier
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateGraphInput: AWSEncodableShape {
        /// Indicates whether or not to enable deletion protection on the graph. The graph canâ€™t be deleted when deletion protection is enabled. (true or false).
        public let deletionProtection: Bool?
        /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let graphName: String
        /// Specifies a KMS key to use to encrypt data in the new graph.
        public let kmsKeyIdentifier: String?
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
        public let provisionedMemory: Int
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Min =0, Max = 2, Default = 1.
        public let replicaCount: Int?
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?
        /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(deletionProtection: Bool? = nil, graphName: String, kmsKeyIdentifier: String? = nil, provisionedMemory: Int, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, tags: [String: String]? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.deletionProtection = deletionProtection
            self.graphName = graphName
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.tags = tags
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 128)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vectorSearchConfiguration?.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case graphName = "graphName"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case tags = "tags"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphOutput: AWSDecodableShape {
        /// The ARN of the graph.
        public let arn: String
        /// The build number of the graph software.
        public let buildNumber: String?
        /// The time when the graph was created.
        public let createTime: Date?
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The ID of the graph.
        public let id: String
        /// Specifies the KMS key used to encrypt data in the new graph.
        public let kmsKeyIdentifier: String?
        /// The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let name: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated.  If enabling public connectivity for the first time, there will be a delay while it is enabled.
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Default: If not specified, the default value is 1.
        public let replicaCount: Int?
        /// The ID of the source graph.
        public let sourceSnapshotId: String?
        /// The current status of the graph.
        public let status: GraphStatus?
        /// The reason the status was given.
        public let statusReason: String?
        /// The vector-search configuration for the graph, which specifies the vector dimension to use in the vector index, if any.
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphSnapshotInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let snapshotName: String
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?

        public init(graphIdentifier: String, snapshotName: String, tags: [String: String]? = nil) {
            self.graphIdentifier = graphIdentifier
            self.snapshotName = snapshotName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 63)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^(?!gs-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case graphIdentifier = "graphIdentifier"
            case snapshotName = "snapshotName"
            case tags = "tags"
        }
    }

    public struct CreateGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the snapshot created.
        public let arn: String
        /// The ID of the snapshot created.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the snapshot created.
        public let name: String
        /// The snapshot creation time
        public let snapshotCreateTime: Date?
        /// The Id of the Neptune Analytics graph from which the snapshot is created.
        public let sourceGraphId: String?
        /// The current state of the snapshot.
        public let status: SnapshotStatus?

        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct CreateGraphUsingImportTaskInput: AWSEncodableShape {
        /// Indicates whether or not to enable deletion protection on the graph. The graph canâ€™t be deleted when deletion protection is enabled. (true or false).
        public let deletionProtection: Bool?
        /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
        public let failOnError: Bool?
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let graphName: String
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// Specifies a KMS key to use to encrypt data imported into the new graph.
        public let kmsKeyIdentifier: String?
        /// The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the max of the min-provisioned-memory and max-provisioned memory is used to create the graph. If neither value is specified 128 m-NCUs are used.
        public let maxProvisionedMemory: Int?
        /// The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 128
        public let minProvisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2.
        public let replicaCount: Int?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?
        /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(deletionProtection: Bool? = nil, failOnError: Bool? = nil, format: Format? = nil, graphName: String, importOptions: ImportOptions? = nil, kmsKeyIdentifier: String? = nil, maxProvisionedMemory: Int? = nil, minProvisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, roleArn: String, source: String, tags: [String: String]? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.deletionProtection = deletionProtection
            self.failOnError = failOnError
            self.format = format
            self.graphName = graphName
            self.importOptions = importOptions
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.maxProvisionedMemory = maxProvisionedMemory
            self.minProvisionedMemory = minProvisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.roleArn = roleArn
            self.source = source
            self.tags = tags
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.maxProvisionedMemory, name: "maxProvisionedMemory", parent: name, max: 24576)
            try self.validate(self.maxProvisionedMemory, name: "maxProvisionedMemory", parent: name, min: 128)
            try self.validate(self.minProvisionedMemory, name: "minProvisionedMemory", parent: name, max: 24576)
            try self.validate(self.minProvisionedMemory, name: "minProvisionedMemory", parent: name, min: 128)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vectorSearchConfiguration?.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case failOnError = "failOnError"
            case format = "format"
            case graphName = "graphName"
            case importOptions = "importOptions"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case maxProvisionedMemory = "maxProvisionedMemory"
            case minProvisionedMemory = "minProvisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case roleArn = "roleArn"
            case source = "source"
            case tags = "tags"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphUsingImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// The status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        public init(format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct CreatePrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// Subnets in which private graph endpoint ENIs are created.
        public let subnetIds: [String]?
        ///  The VPC in which the private graph endpoint needs to be created.
        public let vpcId: String?
        /// Security groups to be attached to the private graph endpoint..
        public let vpcSecurityGroupIds: [String]?

        public init(graphIdentifier: String, subnetIds: [String]? = nil, vpcId: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.graphIdentifier = graphIdentifier
            self.subnetIds = subnetIds
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.vpcId, forKey: .vpcId)
            try container.encodeIfPresent(self.vpcSecurityGroupIds, forKey: .vpcSecurityGroupIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[a-z0-9]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 6)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
            try self.vpcSecurityGroupIds?.forEach {
                try validate($0, name: "vpcSecurityGroupIds[]", parent: name, pattern: "^sg-[a-z0-9]+$")
            }
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, max: 10)
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
        }
    }

    public struct CreatePrivateGraphEndpointOutput: AWSDecodableShape {
        /// Status of the private graph endpoint.
        public let status: PrivateGraphEndpointStatus
        /// Subnets in which the private graph endpoint ENIs are created.
        public let subnetIds: [String]
        /// Endpoint ID of the prviate grpah endpoint.
        public let vpcEndpointId: String?
        /// VPC in which the private graph endpoint is created.
        public let vpcId: String

        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct DeleteGraphInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
        public let skipSnapshot: Bool

        public init(graphIdentifier: String, skipSnapshot: Bool) {
            self.graphIdentifier = graphIdentifier
            self.skipSnapshot = skipSnapshot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.skipSnapshot, key: "skipSnapshot")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number associated with the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection was enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if the graph was recovered from a snapshot.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason for the status of the graph.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct DeleteGraphSnapshotInput: AWSEncodableShape {
        /// ID of the graph snapshot to be deleted.
        public let snapshotIdentifier: String

        public init(snapshotIdentifier: String) {
            self.snapshotIdentifier = snapshotIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph from which the snapshot was created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct DeletePrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        public init(graphIdentifier: String, vpcId: String) {
            self.graphIdentifier = graphIdentifier
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.vpcId, key: "vpcId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePrivateGraphEndpointOutput: AWSDecodableShape {
        /// The status of the delete operation.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs involved.
        public let subnetIds: [String]
        /// The ID of the VPC endpoint that was deleted.
        public let vpcEndpointId: String?
        /// The ID of the VPC where the private endpoint was deleted.
        public let vpcId: String

        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct EdgeStructure: AWSDecodableShape {
        /// The number of instances of the edge in the graph.
        public let count: Int64?
        /// A list of the properties associated with the edge.
        public let edgeProperties: [String]?

        public init(count: Int64? = nil, edgeProperties: [String]? = nil) {
            self.count = count
            self.edgeProperties = edgeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case edgeProperties = "edgeProperties"
        }
    }

    public struct ExecuteQueryInput: AWSEncodableShape {
        /// The explain mode parameter returns a query explain instead of the actual query results. A query explain can  be used to gather insights about the query execution such as planning decisions, time spent on each operator, solutions  flowing etc.
        public let explainMode: ExplainMode?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The query language the query is written in. Currently only openCypher is supported.
        public let language: QueryLanguage
        /// The data parameters the query can use in JSON format. For example: {"name": "john", "age": 20}. (optional)
        public let parameters: [String: String]?
        /// Query plan cache is a feature that saves the query plan and reuses it on successive executions of the same query.  This reduces query latency, and works for both READ and UPDATE queries. The plan cache is an  LRU cache with a 5 minute TTL and a capacity of 1000.
        public let planCache: PlanCacheType?
        /// The query string to be executed.
        public let queryString: String
        /// Specifies the query timeout duration, in milliseconds. (optional)
        public let queryTimeoutMilliseconds: Int?

        public init(explainMode: ExplainMode? = nil, graphIdentifier: String, language: QueryLanguage, parameters: [String: String]? = nil, planCache: PlanCacheType? = nil, queryString: String, queryTimeoutMilliseconds: Int? = nil) {
            self.explainMode = explainMode
            self.graphIdentifier = graphIdentifier
            self.language = language
            self.parameters = parameters
            self.planCache = planCache
            self.queryString = queryString
            self.queryTimeoutMilliseconds = queryTimeoutMilliseconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.explainMode, forKey: .explainMode)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            try container.encode(self.language, forKey: .language)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.planCache, forKey: .planCache)
            try container.encode(self.queryString, forKey: .queryString)
            try container.encodeIfPresent(self.queryTimeoutMilliseconds, forKey: .queryTimeoutMilliseconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainMode = "explain"
            case language = "language"
            case parameters = "parameters"
            case planCache = "planCache"
            case queryString = "query"
            case queryTimeoutMilliseconds = "queryTimeoutMilliseconds"
        }
    }

    public struct ExecuteQueryOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The query results.
        public let payload: AWSHTTPBody

        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String

        public init(graphIdentifier: String) {
            self.graphIdentifier = graphIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if it was created from a snapshot.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct GetGraphSnapshotInput: AWSEncodableShape {
        /// The ID of the snapshot to retrieve.
        public let snapshotIdentifier: String

        public init(snapshotIdentifier: String) {
            self.snapshotIdentifier = snapshotIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct GetGraphSummaryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The summary mode can take one of two values: basic (the default), and detailed.
        public let mode: GraphSummaryMode?

        public init(graphIdentifier: String, mode: GraphSummaryMode? = nil) {
            self.graphIdentifier = graphIdentifier
            self.mode = mode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.mode, key: "mode")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphSummaryOutput: AWSDecodableShape {
        /// The graph summary.
        public let graphSummary: GraphDataSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune Analytics last computed statistics.
        public let lastStatisticsComputationTime: Date?
        /// Display the version of this tool.
        public let version: String?

        public init(graphSummary: GraphDataSummary? = nil, lastStatisticsComputationTime: Date? = nil, version: String? = nil) {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case graphSummary = "graphSummary"
            case lastStatisticsComputationTime = "lastStatisticsComputationTime"
            case version = "version"
        }
    }

    public struct GetImportTaskInput: AWSEncodableShape {
        /// The unique identifier of the import task.
        public let taskIdentifier: String

        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportTaskOutput: AWSDecodableShape {
        /// The number of the current attempt to execute the import task.
        public let attemptNumber: Int?
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// Contains details about the specified import task.
        public let importTaskDetails: ImportTaskDetails?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        public let source: String
        /// The status of the import task:    INITIALIZING Â  â€“ Â  The necessary resources needed to create the graph are being prepared.    ANALYZING_DATA Â  â€“ Â  The data is being analyzed to determine the optimal infrastructure configuration for the new graph.    RE_PROVISIONING Â  â€“ Â  The data did not fit into the provisioned graph, so it is being re-provisioned with more capacity.    IMPORTING Â  â€“ Â  The data is being loaded.    ERROR_ENCOUNTERED Â  â€“ Â  An error has been encountered while trying to create the graph and import the data.    ERROR_ENCOUNTERED_ROLLING_BACK Â  â€“ Â  Because of the error that was encountered, the graph is being rolled back and all its resources released.    SUCCEEDED Â  â€“ Â  Graph creation and data loading succeeded.    FAILED Â  â€“ Â  Graph creation or data loading failed. When the status is FAILED, you can use get-graphs to get more information about the state of the graph.    CANCELLING Â  â€“ Â  Because you cancelled the import task, cancellation is in progress.    CANCELLED Â  â€“ Â  You have successfully cancelled the import task.
        public let status: ImportTaskStatus
        /// The reason that the import task has this status value.
        public let statusReason: String?
        /// The unique identifier of the import task.
        public let taskId: String

        public init(attemptNumber: Int? = nil, format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, importTaskDetails: ImportTaskDetails? = nil, roleArn: String, source: String, status: ImportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.attemptNumber = attemptNumber
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.importTaskDetails = importTaskDetails
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case attemptNumber = "attemptNumber"
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case importTaskDetails = "importTaskDetails"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct GetPrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        public init(graphIdentifier: String, vpcId: String) {
            self.graphIdentifier = graphIdentifier
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.vpcId, key: "vpcId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPrivateGraphEndpointOutput: AWSDecodableShape {
        /// The current status of the private endpoint.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs involved.
        public let subnetIds: [String]
        /// The ID of the private endpoint.
        public let vpcEndpointId: String?
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct GetQueryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the query in question.
        public let queryId: String

        public init(graphIdentifier: String, queryId: String) {
            self.graphIdentifier = graphIdentifier
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryOutput: AWSDecodableShape {
        /// The number of milliseconds the query has been running.
        public let elapsed: Int?
        /// The ID of the query in question.
        public let id: String?
        /// The query in question.
        public let queryString: String?
        /// State of the query.
        public let state: QueryState?
        /// Indicates how long the query waited, in milliseconds.
        public let waited: Int?

        public init(elapsed: Int? = nil, id: String? = nil, queryString: String? = nil, state: QueryState? = nil, waited: Int? = nil) {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }

        private enum CodingKeys: String, CodingKey {
            case elapsed = "elapsed"
            case id = "id"
            case queryString = "queryString"
            case state = "state"
            case waited = "waited"
        }
    }

    public struct GraphDataSummary: AWSDecodableShape {
        /// A list of the edge labels in the graph.
        public let edgeLabels: [String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public let edgeProperties: [[String: Int64]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public let edgeStructures: [EdgeStructure]?
        /// A list of distinct node labels in the graph.
        public let nodeLabels: [String]?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public let nodeProperties: [[String: Int64]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public let nodeStructures: [NodeStructure]?
        /// The number of unique edge labels in the graph.
        public let numEdgeLabels: Int64?
        /// The number of edge properties in the graph.
        public let numEdgeProperties: Int64?
        /// The number of edges in the graph.
        public let numEdges: Int64?
        /// The number of distinct node labels in the graph.
        public let numNodeLabels: Int64?
        /// The number of distinct node properties in the graph.
        public let numNodeProperties: Int64?
        /// The number of nodes in the graph.
        public let numNodes: Int64?
        /// The total number of usages of all edge properties.
        public let totalEdgePropertyValues: Int64?
        /// The total number of usages of all node properties.
        public let totalNodePropertyValues: Int64?

        public init(edgeLabels: [String]? = nil, edgeProperties: [[String: Int64]]? = nil, edgeStructures: [EdgeStructure]? = nil, nodeLabels: [String]? = nil, nodeProperties: [[String: Int64]]? = nil, nodeStructures: [NodeStructure]? = nil, numEdgeLabels: Int64? = nil, numEdgeProperties: Int64? = nil, numEdges: Int64? = nil, numNodeLabels: Int64? = nil, numNodeProperties: Int64? = nil, numNodes: Int64? = nil, totalEdgePropertyValues: Int64? = nil, totalNodePropertyValues: Int64? = nil) {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLabels = "edgeLabels"
            case edgeProperties = "edgeProperties"
            case edgeStructures = "edgeStructures"
            case nodeLabels = "nodeLabels"
            case nodeProperties = "nodeProperties"
            case nodeStructures = "nodeStructures"
            case numEdgeLabels = "numEdgeLabels"
            case numEdgeProperties = "numEdgeProperties"
            case numEdges = "numEdges"
            case numNodeLabels = "numNodeLabels"
            case numNodeProperties = "numNodeProperties"
            case numNodes = "numNodes"
            case totalEdgePropertyValues = "totalEdgePropertyValues"
            case totalNodePropertyValues = "totalNodePropertyValues"
        }
    }

    public struct GraphSnapshotSummary: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct GraphSummary: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The status of the graph.
        public let status: GraphStatus?

        public init(arn: String, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, status: GraphStatus? = nil) {
            self.arn = arn
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case status = "status"
        }
    }

    public struct ImportTaskDetails: AWSDecodableShape {
        /// The number of dictionary entries in the import task.
        public let dictionaryEntryCount: Int64
        /// The number of errors encountered so far.
        public let errorCount: Int
        /// Details about the errors that have been encountered.
        public let errorDetails: String?
        /// The percentage progress so far.
        public let progressPercentage: Int
        /// Time at which the import task started.
        public let startTime: Date
        /// The number of statements in the import task.
        public let statementCount: Int64
        /// Status of the import task.
        public let status: String
        /// Seconds elapsed since the import task started.
        public let timeElapsedSeconds: Int64

        public init(dictionaryEntryCount: Int64, errorCount: Int, errorDetails: String? = nil, progressPercentage: Int, startTime: Date, statementCount: Int64, status: String, timeElapsedSeconds: Int64) {
            self.dictionaryEntryCount = dictionaryEntryCount
            self.errorCount = errorCount
            self.errorDetails = errorDetails
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.statementCount = statementCount
            self.status = status
            self.timeElapsedSeconds = timeElapsedSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case dictionaryEntryCount = "dictionaryEntryCount"
            case errorCount = "errorCount"
            case errorDetails = "errorDetails"
            case progressPercentage = "progressPercentage"
            case startTime = "startTime"
            case statementCount = "statementCount"
            case status = "status"
            case timeElapsedSeconds = "timeElapsedSeconds"
        }
    }

    public struct ImportTaskSummary: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        public let source: String
        /// Status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        public init(format: Format? = nil, graphId: String? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct ListGraphSnapshotsInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String?
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(graphIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphSnapshotsOutput: AWSDecodableShape {
        /// The requested list of snapshots.
        public let graphSnapshots: [GraphSnapshotSummary]
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(graphSnapshots: [GraphSnapshotSummary], nextToken: String? = nil) {
            self.graphSnapshots = graphSnapshots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphSnapshots = "graphSnapshots"
            case nextToken = "nextToken"
        }
    }

    public struct ListGraphsInput: AWSEncodableShape {
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphsOutput: AWSDecodableShape {
        /// A list of the graphs.
        public let graphs: [GraphSummary]
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(graphs: [GraphSummary], nextToken: String? = nil) {
            self.graphs = graphs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphs = "graphs"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportTasksInput: AWSEncodableShape {
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportTasksOutput: AWSDecodableShape {
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?
        /// The requested list of import tasks.
        public let tasks: [ImportTaskSummary]

        public init(nextToken: String? = nil, tasks: [ImportTaskSummary]) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct ListPrivateGraphEndpointsInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        public init(graphIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivateGraphEndpointsOutput: AWSDecodableShape {
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?
        /// A list of private endpoints for the specified Neptune Analytics graph.
        public let privateGraphEndpoints: [PrivateGraphEndpointSummary]

        public init(nextToken: String? = nil, privateGraphEndpoints: [PrivateGraphEndpointSummary]) {
            self.nextToken = nextToken
            self.privateGraphEndpoints = privateGraphEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privateGraphEndpoints = "privateGraphEndpoints"
        }
    }

    public struct ListQueriesInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The maximum number of results to be fetched by the API.
        public let maxResults: Int
        /// Filtered list of queries based on state.
        public let state: QueryStateInput?

        public init(graphIdentifier: String, maxResults: Int, state: QueryStateInput? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueriesOutput: AWSDecodableShape {
        /// A list of current openCypher queries.
        public let queries: [QuerySummary]

        public init(queries: [QuerySummary]) {
            self.queries = queries
        }

        private enum CodingKeys: String, CodingKey {
            case queries = "queries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The list of metadata tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NeptuneImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// Neptune Analytics supports label-less vertices and no labels are assigned unless one is explicitly provided. Neptune assigns default labels when none is explicitly provided. When importing the data into Neptune Analytics, the default vertex labels can be omitted by setting preserveDefaultVertexLabels to false. Note that if the vertex only has default labels, and has no other properties or edges, then the vertex will effectively not get imported into Neptune Analytics when preserveDefaultVertexLabels is set to false.
        public let preserveDefaultVertexLabels: Bool?
        /// Neptune Analytics currently does not support user defined edge ids. The edge ids are not imported by default. They are imported if preserveEdgeIds is set to true, and ids are stored as properties on the relationships with the property name neptuneEdgeId.
        public let preserveEdgeIds: Bool?
        /// The KMS key to use to encrypt data in the S3 bucket where the graph data is exported
        public let s3ExportKmsKeyId: String
        /// The path to an S3 bucket from which to import data.
        public let s3ExportPath: String

        public init(preserveDefaultVertexLabels: Bool? = nil, preserveEdgeIds: Bool? = nil, s3ExportKmsKeyId: String, s3ExportPath: String) {
            self.preserveDefaultVertexLabels = preserveDefaultVertexLabels
            self.preserveEdgeIds = preserveEdgeIds
            self.s3ExportKmsKeyId = s3ExportKmsKeyId
            self.s3ExportPath = s3ExportPath
        }

        private enum CodingKeys: String, CodingKey {
            case preserveDefaultVertexLabels = "preserveDefaultVertexLabels"
            case preserveEdgeIds = "preserveEdgeIds"
            case s3ExportKmsKeyId = "s3ExportKmsKeyId"
            case s3ExportPath = "s3ExportPath"
        }
    }

    public struct NodeStructure: AWSDecodableShape {
        /// The number of instances of this node.
        public let count: Int64?
        /// The outgoing edge labels associated with this node.
        public let distinctOutgoingEdgeLabels: [String]?
        /// Properties associated with this node.
        public let nodeProperties: [String]?

        public init(count: Int64? = nil, distinctOutgoingEdgeLabels: [String]? = nil, nodeProperties: [String]? = nil) {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case distinctOutgoingEdgeLabels = "distinctOutgoingEdgeLabels"
            case nodeProperties = "nodeProperties"
        }
    }

    public struct PrivateGraphEndpointSummary: AWSDecodableShape {
        /// The status of the private graph endpoint.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs associated with the private graph endpoint.
        public let subnetIds: [String]
        /// The ID of the VPC endpoint.
        public let vpcEndpointId: String?
        /// The ID of the VPC in which the private graph endpoint is located.
        public let vpcId: String

        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct QuerySummary: AWSDecodableShape {
        /// The running time of the query, in milliseconds.
        public let elapsed: Int?
        /// A string representation of the id of the query.
        public let id: String?
        /// The actual query text. The queryString may be truncated if the actual query string is too long.
        public let queryString: String?
        /// State of the query.
        public let state: QueryState?
        /// The amount of time, in milliseconds, the query has waited in the queue before being picked up by a worker thread.
        public let waited: Int?

        public init(elapsed: Int? = nil, id: String? = nil, queryString: String? = nil, state: QueryState? = nil, waited: Int? = nil) {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }

        private enum CodingKeys: String, CodingKey {
            case elapsed = "elapsed"
            case id = "id"
            case queryString = "queryString"
            case state = "state"
            case waited = "waited"
        }
    }

    public struct ResetGraphInput: AWSEncodableShape {
        /// ID of the graph to reset.
        public let graphIdentifier: String
        /// Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
        public let skipSnapshot: Bool

        public init(graphIdentifier: String, skipSnapshot: Bool) {
            self.graphIdentifier = graphIdentifier
            self.skipSnapshot = skipSnapshot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encode(self.skipSnapshot, forKey: .skipSnapshot)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case skipSnapshot = "skipSnapshot"
        }
    }

    public struct ResetGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct RestoreGraphFromSnapshotInput: AWSEncodableShape {
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        public let graphName: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Min =0, Max = 2, Default =1
        public let replicaCount: Int?
        /// The ID of the snapshot in question.
        public let snapshotIdentifier: String
        /// Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?

        public init(deletionProtection: Bool? = nil, graphName: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, snapshotIdentifier: String, tags: [String: String]? = nil) {
            self.deletionProtection = deletionProtection
            self.graphName = graphName
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.snapshotIdentifier = snapshotIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deletionProtection, forKey: .deletionProtection)
            try container.encode(self.graphName, forKey: .graphName)
            try container.encodeIfPresent(self.provisionedMemory, forKey: .provisionedMemory)
            try container.encodeIfPresent(self.publicConnectivity, forKey: .publicConnectivity)
            try container.encodeIfPresent(self.replicaCount, forKey: .replicaCount)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 128)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case graphName = "graphName"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case tags = "tags"
        }
    }

    public struct RestoreGraphFromSnapshotOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct StartImportTaskInput: AWSEncodableShape {
        /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that  caused the error and continues if possible.
        public let failOnError: Bool?
        /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or  OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        public let importOptions: ImportOptions?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a  Neptune database endpoint or snapshot.
        public let source: String

        public init(failOnError: Bool? = nil, format: Format? = nil, graphIdentifier: String, importOptions: ImportOptions? = nil, roleArn: String, source: String) {
            self.failOnError = failOnError
            self.format = format
            self.graphIdentifier = graphIdentifier
            self.importOptions = importOptions
            self.roleArn = roleArn
            self.source = source
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.failOnError, forKey: .failOnError)
            try container.encodeIfPresent(self.format, forKey: .format)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.importOptions, forKey: .importOptions)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.source, forKey: .source)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case failOnError = "failOnError"
            case format = "format"
            case importOptions = "importOptions"
            case roleArn = "roleArn"
            case source = "source"
        }
    }

    public struct StartImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or  OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        public let importOptions: ImportOptions?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a  Neptune database endpoint or snapshot.
        public let source: String
        /// The status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        public init(format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// ARN of the resource for which tags need to be added.
        public let resourceArn: String
        /// The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs:  Key (string) Â  â€“ Â  A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").  Value (string) Â  â€“ Â  A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// ARN of the resource whose tag needs to be removed.
        public let resourceArn: String
        /// Tag keys for the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGraphInput: AWSEncodableShape {
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
        public let publicConnectivity: Bool?

        public init(deletionProtection: Bool? = nil, graphIdentifier: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil) {
            self.deletionProtection = deletionProtection
            self.graphIdentifier = graphIdentifier
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deletionProtection, forKey: .deletionProtection)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.provisionedMemory, forKey: .provisionedMemory)
            try container.encodeIfPresent(self.publicConnectivity, forKey: .publicConnectivity)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
        }
    }

    public struct UpdateGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct VectorSearchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of dimensions.
        public let dimension: Int

        public init(dimension: Int) {
            self.dimension = dimension
        }

        public func validate(name: String) throws {
            try self.validate(self.dimension, name: "dimension", parent: name, max: 65536)
            try self.validate(self.dimension, name: "dimension", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimension = "dimension"
        }
    }

    public struct ImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// Options for importing data from a Neptune database.
        public let neptune: NeptuneImportOptions?

        public init(neptune: NeptuneImportOptions? = nil) {
            self.neptune = neptune
        }

        private enum CodingKeys: String, CodingKey {
            case neptune = "neptune"
        }
    }
}

// MARK: - Errors

/// Error enum for NeptuneGraph
public struct NeptuneGraphErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unprocessableException = "UnprocessableException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize NeptuneGraph
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Raised in case of an authentication or authorization failure.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Raised when a conflict is encountered.
    public static var conflictException: Self { .init(.conflictException) }
    /// A failure occurred on the server.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A specified resource could not be located.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service quota was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The exception was interrupted by throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Request cannot be processed due to known reasons. Eg. partition full.
    public static var unprocessableException: Self { .init(.unprocessableException) }
    /// A resource could not be validated.
    public static var validationException: Self { .init(.validationException) }
}

extension NeptuneGraphErrorType: Equatable {
    public static func == (lhs: NeptuneGraphErrorType, rhs: NeptuneGraphErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NeptuneGraphErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
