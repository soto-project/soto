//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension NeptuneGraph {
    // MARK: Enums

    public enum BlankNodeHandling: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case convertToIri = "convertToIri"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concurrentModification = "CONCURRENT_MODIFICATION"
        public var description: String { return self.rawValue }
    }

    public enum ExplainMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case details = "DETAILS"
        public var description: String { return self.rawValue }
    }

    public enum ExportFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum ExportTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case deleted = "DELETED"
        case exporting = "EXPORTING"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case ntriples = "NTRIPLES"
        case openCypher = "OPEN_CYPHER"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum GraphStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case importing = "IMPORTING"
        case resetting = "RESETTING"
        case snapshotting = "SNAPSHOTTING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum GraphSummaryMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case detailed = "DETAILED"
        public var description: String { return self.rawValue }
    }

    public enum ImportTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analyzingData = "ANALYZING_DATA"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case deleted = "DELETED"
        case exporting = "EXPORTING"
        case failed = "FAILED"
        case importing = "IMPORTING"
        case initializing = "INITIALIZING"
        case reprovisioning = "REPROVISIONING"
        case rollingBack = "ROLLING_BACK"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum MultiValueHandlingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pickFirst = "PICK_FIRST"
        case toList = "TO_LIST"
        public var description: String { return self.rawValue }
    }

    public enum ParquetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case columnar = "COLUMNAR"
        public var description: String { return self.rawValue }
    }

    public enum PlanCacheType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PrivateGraphEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum QueryLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case openCypher = "OPEN_CYPHER"
        public var description: String { return self.rawValue }
    }

    public enum QueryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelling = "CANCELLING"
        case running = "RUNNING"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum QueryStateInput: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case cancelling = "CANCELLING"
        case running = "RUNNING"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum UnprocessableExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalLimitExceeded = "INTERNAL_LIMIT_EXCEEDED"
        case memoryLimitExceeded = "MEMORY_LIMIT_EXCEEDED"
        case partitionFull = "PARTITION_FULL"
        case queryTimeout = "QUERY_TIMEOUT"
        case storageLimitExceeded = "STORAGE_LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case constraintViolation = "CONSTRAINT_VIOLATION"
        case illegalArgument = "ILLEGAL_ARGUMENT"
        case malformedQuery = "MALFORMED_QUERY"
        case queryCancelled = "QUERY_CANCELLED"
        case queryTooLarge = "QUERY_TOO_LARGE"
        case unsupportedOperation = "UNSUPPORTED_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CancelExportTaskInput: AWSEncodableShape {
        /// The unique identifier of the export task.
        public let taskIdentifier: String

        @inlinable
        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelExportTaskOutput: AWSDecodableShape {
        /// The Amazon S3 URI of the cancelled export task where data will be exported to.
        public let destination: String
        /// The format of the cancelled export task.
        public let format: ExportFormat
        /// The source graph identifier of the cancelled export task.
        public let graphId: String
        /// The KMS key identifier of the cancelled export task.
        public let kmsKeyIdentifier: String
        /// The parquet type of the cancelled export task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow the exporting of data to the destination.
        public let roleArn: String
        /// The current status of the export task. The status is CANCELLING when the  export task is cancelled.
        public let status: ExportTaskStatus
        /// The reason that the export task has this status value.
        public let statusReason: String?
        /// The unique identifier of the export task.
        public let taskId: String

        @inlinable
        public init(destination: String, format: ExportFormat, graphId: String, kmsKeyIdentifier: String, parquetType: ParquetType? = nil, roleArn: String, status: ExportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.destination = destination
            self.format = format
            self.graphId = graphId
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case format = "format"
            case graphId = "graphId"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct CancelImportTaskInput: AWSEncodableShape {
        /// The unique identifier of the import task.
        public let taskIdentifier: String

        @inlinable
        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// The parquet type of the cancelled import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// Current status of the task. Status is CANCELLING when the import task is cancelled.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        @inlinable
        public init(format: Format? = nil, graphId: String? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct CancelQueryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The unique identifier of the query to cancel.
        public let queryId: String

        @inlinable
        public init(graphIdentifier: String, queryId: String) {
            self.graphIdentifier = graphIdentifier
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConflictException: AWSErrorShape {
        /// A message describing the problem.
        public let message: String
        /// The reason for the conflict exception.
        public let reason: ConflictExceptionReason?

        @inlinable
        public init(message: String, reason: ConflictExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct CreateGraphInput: AWSEncodableShape {
        /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
        public let deletionProtection: Bool?
        /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let graphName: String
        /// Specifies a KMS key to use to encrypt data in the new graph.
        public let kmsKeyIdentifier: String?
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 16
        public let provisionedMemory: Int
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Min =0, Max = 2, Default = 1.   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
        public let replicaCount: Int?
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?
        /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(deletionProtection: Bool? = nil, graphName: String, kmsKeyIdentifier: String? = nil, provisionedMemory: Int, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, tags: [String: String]? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.deletionProtection = deletionProtection
            self.graphName = graphName
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.tags = tags
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 16)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vectorSearchConfiguration?.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case graphName = "graphName"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case tags = "tags"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphOutput: AWSDecodableShape {
        /// The ARN of the graph.
        public let arn: String
        /// The build number of the graph software.
        public let buildNumber: String?
        /// The time when the graph was created.
        public let createTime: Date?
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The ID of the graph.
        public let id: String
        /// Specifies the KMS key used to encrypt data in the new graph.
        public let kmsKeyIdentifier: String?
        /// The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let name: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 16
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated.  If enabling public connectivity for the first time, there will be a delay while it is enabled.
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Default: If not specified, the default value is 1.
        public let replicaCount: Int?
        /// The ID of the source graph.
        public let sourceSnapshotId: String?
        /// The current status of the graph.
        public let status: GraphStatus?
        /// The reason the status was given.
        public let statusReason: String?
        /// The vector-search configuration for the graph, which specifies the vector dimension to use in the vector index, if any.
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphSnapshotInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let snapshotName: String
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?

        @inlinable
        public init(graphIdentifier: String, snapshotName: String, tags: [String: String]? = nil) {
            self.graphIdentifier = graphIdentifier
            self.snapshotName = snapshotName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 63)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^(?!gs-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case graphIdentifier = "graphIdentifier"
            case snapshotName = "snapshotName"
            case tags = "tags"
        }
    }

    public struct CreateGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the snapshot created.
        public let arn: String
        /// The ID of the snapshot created.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the snapshot created.
        public let name: String
        /// The snapshot creation time
        public let snapshotCreateTime: Date?
        /// The Id of the Neptune Analytics graph from which the snapshot is created.
        public let sourceGraphId: String?
        /// The current state of the snapshot.
        public let status: SnapshotStatus?

        @inlinable
        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct CreateGraphUsingImportTaskInput: AWSEncodableShape {
        /// The method to handle blank nodes in the dataset. Currently, only convertToIri is supported,  meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples.  For more information, see Handling RDF values.
        public let blankNodeHandling: BlankNodeHandling?
        /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
        public let deletionProtection: Bool?
        /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
        public let failOnError: Bool?
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format, OPEN_CYPHER, which identifies the openCypher load format, or ntriples, which identifies the RDF n-triples format.
        public let format: Format?
        /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let graphName: String
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// Specifies a KMS key to use to encrypt data imported into the new graph.
        public let kmsKeyIdentifier: String?
        /// The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the final provisioned-memory will be chosen per the actual size of your imported data. If neither value is specified,  128 m-NCUs are used.
        public let maxProvisionedMemory: Int?
        /// The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 16
        public let minProvisionedMemory: Int?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2.   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
        public let replicaCount: Int?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?
        /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(blankNodeHandling: BlankNodeHandling? = nil, deletionProtection: Bool? = nil, failOnError: Bool? = nil, format: Format? = nil, graphName: String, importOptions: ImportOptions? = nil, kmsKeyIdentifier: String? = nil, maxProvisionedMemory: Int? = nil, minProvisionedMemory: Int? = nil, parquetType: ParquetType? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, roleArn: String, source: String, tags: [String: String]? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.blankNodeHandling = blankNodeHandling
            self.deletionProtection = deletionProtection
            self.failOnError = failOnError
            self.format = format
            self.graphName = graphName
            self.importOptions = importOptions
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.maxProvisionedMemory = maxProvisionedMemory
            self.minProvisionedMemory = minProvisionedMemory
            self.parquetType = parquetType
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.roleArn = roleArn
            self.source = source
            self.tags = tags
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.maxProvisionedMemory, name: "maxProvisionedMemory", parent: name, max: 24576)
            try self.validate(self.maxProvisionedMemory, name: "maxProvisionedMemory", parent: name, min: 16)
            try self.validate(self.minProvisionedMemory, name: "minProvisionedMemory", parent: name, max: 24576)
            try self.validate(self.minProvisionedMemory, name: "minProvisionedMemory", parent: name, min: 16)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)(/[\\w+=,.@-]+)+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vectorSearchConfiguration?.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case blankNodeHandling = "blankNodeHandling"
            case deletionProtection = "deletionProtection"
            case failOnError = "failOnError"
            case format = "format"
            case graphName = "graphName"
            case importOptions = "importOptions"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case maxProvisionedMemory = "maxProvisionedMemory"
            case minProvisionedMemory = "minProvisionedMemory"
            case parquetType = "parquetType"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case roleArn = "roleArn"
            case source = "source"
            case tags = "tags"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct CreateGraphUsingImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format, OPENCYPHER, which identifies the openCypher load format, or ntriples, which identifies the RDF n-triples format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
        public let source: String
        /// The status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        @inlinable
        public init(format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct CreatePrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// Subnets in which private graph endpoint ENIs are created.
        public let subnetIds: [String]?
        ///  The VPC in which the private graph endpoint needs to be created.
        public let vpcId: String?
        /// Security groups to be attached to the private graph endpoint..
        public let vpcSecurityGroupIds: [String]?

        @inlinable
        public init(graphIdentifier: String, subnetIds: [String]? = nil, vpcId: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.graphIdentifier = graphIdentifier
            self.subnetIds = subnetIds
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.vpcId, forKey: .vpcId)
            try container.encodeIfPresent(self.vpcSecurityGroupIds, forKey: .vpcSecurityGroupIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[a-z0-9]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 6)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
            try self.vpcSecurityGroupIds?.forEach {
                try validate($0, name: "vpcSecurityGroupIds[]", parent: name, pattern: "^sg-[a-z0-9]+$")
            }
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, max: 10)
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
        }
    }

    public struct CreatePrivateGraphEndpointOutput: AWSDecodableShape {
        /// Status of the private graph endpoint.
        public let status: PrivateGraphEndpointStatus
        /// Subnets in which the private graph endpoint ENIs are created.
        public let subnetIds: [String]
        /// Endpoint ID of the prviate grpah endpoint.
        public let vpcEndpointId: String?
        /// VPC in which the private graph endpoint is created.
        public let vpcId: String

        @inlinable
        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct DeleteGraphInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
        public let skipSnapshot: Bool

        @inlinable
        public init(graphIdentifier: String, skipSnapshot: Bool) {
            self.graphIdentifier = graphIdentifier
            self.skipSnapshot = skipSnapshot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.skipSnapshot, key: "skipSnapshot")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number associated with the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection was enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if the graph was recovered from a snapshot.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason for the status of the graph.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct DeleteGraphSnapshotInput: AWSEncodableShape {
        /// ID of the graph snapshot to be deleted.
        public let snapshotIdentifier: String

        @inlinable
        public init(snapshotIdentifier: String) {
            self.snapshotIdentifier = snapshotIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph from which the snapshot was created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        @inlinable
        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct DeletePrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        @inlinable
        public init(graphIdentifier: String, vpcId: String) {
            self.graphIdentifier = graphIdentifier
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.vpcId, key: "vpcId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePrivateGraphEndpointOutput: AWSDecodableShape {
        /// The status of the delete operation.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs involved.
        public let subnetIds: [String]
        /// The ID of the VPC endpoint that was deleted.
        public let vpcEndpointId: String?
        /// The ID of the VPC where the private endpoint was deleted.
        public let vpcId: String

        @inlinable
        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct EdgeStructure: AWSDecodableShape {
        /// The number of instances of the edge in the graph.
        public let count: Int64?
        /// A list of the properties associated with the edge.
        public let edgeProperties: [String]?

        @inlinable
        public init(count: Int64? = nil, edgeProperties: [String]? = nil) {
            self.count = count
            self.edgeProperties = edgeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case edgeProperties = "edgeProperties"
        }
    }

    public struct ExecuteQueryInput: AWSEncodableShape {
        /// The explain mode parameter returns a query explain instead of the actual query results. A query explain can  be used to gather insights about the query execution such as planning decisions, time spent on each operator, solutions  flowing etc.
        public let explainMode: ExplainMode?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The query language the query is written in. Currently only openCypher is supported.
        public let language: QueryLanguage
        /// The data parameters the query can use in JSON format. For example: {"name": "john", "age": 20}. (optional)
        public let parameters: [String: AWSDocument]?
        /// Query plan cache is a feature that saves the query plan and reuses it on successive executions of the same query.  This reduces query latency, and works for both READ and UPDATE queries. The plan cache is an  LRU cache with a 5 minute TTL and a capacity of 1000.
        public let planCache: PlanCacheType?
        /// The query string to be executed.
        public let queryString: String
        /// Specifies the query timeout duration, in milliseconds. (optional)
        public let queryTimeoutMilliseconds: Int?

        @inlinable
        public init(explainMode: ExplainMode? = nil, graphIdentifier: String, language: QueryLanguage, parameters: [String: AWSDocument]? = nil, planCache: PlanCacheType? = nil, queryString: String, queryTimeoutMilliseconds: Int? = nil) {
            self.explainMode = explainMode
            self.graphIdentifier = graphIdentifier
            self.language = language
            self.parameters = parameters
            self.planCache = planCache
            self.queryString = queryString
            self.queryTimeoutMilliseconds = queryTimeoutMilliseconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.explainMode, forKey: .explainMode)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            try container.encode(self.language, forKey: .language)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.planCache, forKey: .planCache)
            try container.encode(self.queryString, forKey: .queryString)
            try container.encodeIfPresent(self.queryTimeoutMilliseconds, forKey: .queryTimeoutMilliseconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainMode = "explain"
            case language = "language"
            case parameters = "parameters"
            case planCache = "planCache"
            case queryString = "query"
            case queryTimeoutMilliseconds = "queryTimeoutMilliseconds"
        }
    }

    public struct ExecuteQueryOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The query results.
        public let payload: AWSHTTPBody

        @inlinable
        public init(payload: AWSHTTPBody) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportFilter: AWSEncodableShape & AWSDecodableShape {
        /// Used to specify filters on a per-label basis for edges. This allows you to control which edge labels  and properties are included in the export.
        public let edgeFilter: [String: ExportFilterElement]?
        /// Used to specify filters on a per-label basis for vertices. This allows you to control which vertex labels  and properties are included in the export.
        public let vertexFilter: [String: ExportFilterElement]?

        @inlinable
        public init(edgeFilter: [String: ExportFilterElement]? = nil, vertexFilter: [String: ExportFilterElement]? = nil) {
            self.edgeFilter = edgeFilter
            self.vertexFilter = vertexFilter
        }

        public func validate(name: String) throws {
            try self.edgeFilter?.forEach {
                try validate($0.key, name: "edgeFilter.key", parent: name, max: 128)
                try validate($0.key, name: "edgeFilter.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).edgeFilter[\"\($0.key)\"]")
            }
            try self.vertexFilter?.forEach {
                try validate($0.key, name: "vertexFilter.key", parent: name, max: 128)
                try validate($0.key, name: "vertexFilter.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).vertexFilter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case edgeFilter = "edgeFilter"
            case vertexFilter = "vertexFilter"
        }
    }

    public struct ExportFilterElement: AWSEncodableShape & AWSDecodableShape {
        /// Each property is defined by a key-value pair, where the key is the desired output property name (e.g. "name"),  and the value is an object.
        public let properties: [String: ExportFilterPropertyAttributes]?

        @inlinable
        public init(properties: [String: ExportFilterPropertyAttributes]? = nil) {
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 128)
                try validate($0.key, name: "properties.key", parent: name, min: 1)
                try validate($0.key, name: "properties.key", parent: name, pattern: "^[a-zA-Z0-9_]+$")
                try $0.value.validate(name: "\(name).properties[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case properties = "properties"
        }
    }

    public struct ExportFilterPropertyAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how to handle properties that have multiple values. Can be either TO_LIST to export all  values as a list, or PICK_FIRST to export the first value encountered. If not specified, the default  value is PICK_FIRST.
        public let multiValueHandling: MultiValueHandlingType?
        /// Specifies the data type to use for the property in the exported data (e.g. "String", "Int", "Float").  If a type is not provided, the export process will determine the type. If a given property is present as multiple  types (e.g. one vertex has "height" stored as a double, and another edge has it stored as a string), the type  will be of Any type, otherwise, it will be the type of the property as present in vertices.
        public let outputType: String?
        /// The name of the property as it exists in the original graph data. If not provided, it is assumed that the key  matches the desired sourcePropertyName.
        public let sourcePropertyName: String?

        @inlinable
        public init(multiValueHandling: MultiValueHandlingType? = nil, outputType: String? = nil, sourcePropertyName: String? = nil) {
            self.multiValueHandling = multiValueHandling
            self.outputType = outputType
            self.sourcePropertyName = sourcePropertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.outputType, name: "outputType", parent: name, pattern: "^(Any|Byte|Short|Int|Long|Float|Double|String|Bool|Boolean|Float\\[\\]|Double\\[\\])$")
            try self.validate(self.sourcePropertyName, name: "sourcePropertyName", parent: name, max: 128)
            try self.validate(self.sourcePropertyName, name: "sourcePropertyName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case multiValueHandling = "multiValueHandling"
            case outputType = "outputType"
            case sourcePropertyName = "sourcePropertyName"
        }
    }

    public struct ExportTaskDetails: AWSDecodableShape {
        /// The number of exported edges.
        public let numEdgesWritten: Int64?
        /// The number of exported vertices.
        public let numVerticesWritten: Int64?
        /// The number of progress percentage of the export task.
        public let progressPercentage: Int
        /// The start time of the export task.
        public let startTime: Date
        /// The time elapsed, in seconds, since the start time of the export task.
        public let timeElapsedSeconds: Int64

        @inlinable
        public init(numEdgesWritten: Int64? = nil, numVerticesWritten: Int64? = nil, progressPercentage: Int, startTime: Date, timeElapsedSeconds: Int64) {
            self.numEdgesWritten = numEdgesWritten
            self.numVerticesWritten = numVerticesWritten
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.timeElapsedSeconds = timeElapsedSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case numEdgesWritten = "numEdgesWritten"
            case numVerticesWritten = "numVerticesWritten"
            case progressPercentage = "progressPercentage"
            case startTime = "startTime"
            case timeElapsedSeconds = "timeElapsedSeconds"
        }
    }

    public struct ExportTaskSummary: AWSDecodableShape {
        /// The Amazon S3 URI of the export task where data will be exported to.
        public let destination: String
        /// The format of the export task.
        public let format: ExportFormat
        /// The source graph identifier of the export task.
        public let graphId: String
        /// The KMS key identifier of the export task.
        public let kmsKeyIdentifier: String
        /// The parquet type of the export task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow the data to be exported to the destination.
        public let roleArn: String
        /// The current status of the export task.
        public let status: ExportTaskStatus
        /// The reason that the export task has this status value.
        public let statusReason: String?
        /// The unique identifier of the export task.
        public let taskId: String

        @inlinable
        public init(destination: String, format: ExportFormat, graphId: String, kmsKeyIdentifier: String, parquetType: ParquetType? = nil, roleArn: String, status: ExportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.destination = destination
            self.format = format
            self.graphId = graphId
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case format = "format"
            case graphId = "graphId"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct GetExportTaskInput: AWSEncodableShape {
        /// The unique identifier of the export task.
        public let taskIdentifier: String

        @inlinable
        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExportTaskOutput: AWSDecodableShape {
        /// The Amazon S3 URI of the export task where data will be exported.
        public let destination: String
        /// The export filter of the export task.
        public let exportFilter: ExportFilter?
        /// The details of the export task.
        public let exportTaskDetails: ExportTaskDetails?
        /// The format of the export task.
        public let format: ExportFormat
        /// The source graph identifier of the export task.
        public let graphId: String
        /// The KMS key identifier of the export task.
        public let kmsKeyIdentifier: String
        /// The parquet type of the export task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow data to be exported to the destination.
        public let roleArn: String
        /// The current status of the export task.
        public let status: ExportTaskStatus
        /// The reason that the export task has this status value.
        public let statusReason: String?
        /// The unique identifier of the export task.
        public let taskId: String

        @inlinable
        public init(destination: String, exportFilter: ExportFilter? = nil, exportTaskDetails: ExportTaskDetails? = nil, format: ExportFormat, graphId: String, kmsKeyIdentifier: String, parquetType: ParquetType? = nil, roleArn: String, status: ExportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.destination = destination
            self.exportFilter = exportFilter
            self.exportTaskDetails = exportTaskDetails
            self.format = format
            self.graphId = graphId
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case exportFilter = "exportFilter"
            case exportTaskDetails = "exportTaskDetails"
            case format = "format"
            case graphId = "graphId"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct GetGraphInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String

        @inlinable
        public init(graphIdentifier: String) {
            self.graphIdentifier = graphIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if it was created from a snapshot.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct GetGraphSnapshotInput: AWSEncodableShape {
        /// The ID of the snapshot to retrieve.
        public let snapshotIdentifier: String

        @inlinable
        public init(snapshotIdentifier: String) {
            self.snapshotIdentifier = snapshotIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphSnapshotOutput: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        @inlinable
        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct GetGraphSummaryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The summary mode can take one of two values: basic (the default), and detailed.
        public let mode: GraphSummaryMode?

        @inlinable
        public init(graphIdentifier: String, mode: GraphSummaryMode? = nil) {
            self.graphIdentifier = graphIdentifier
            self.mode = mode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.mode, key: "mode")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphSummaryOutput: AWSDecodableShape {
        /// The graph summary.
        public let graphSummary: GraphDataSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune Analytics last computed statistics.
        public let lastStatisticsComputationTime: Date?
        /// Display the version of this tool.
        public let version: String?

        @inlinable
        public init(graphSummary: GraphDataSummary? = nil, lastStatisticsComputationTime: Date? = nil, version: String? = nil) {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case graphSummary = "graphSummary"
            case lastStatisticsComputationTime = "lastStatisticsComputationTime"
            case version = "version"
        }
    }

    public struct GetImportTaskInput: AWSEncodableShape {
        /// The unique identifier of the import task.
        public let taskIdentifier: String

        @inlinable
        public init(taskIdentifier: String) {
            self.taskIdentifier = taskIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskIdentifier, key: "taskIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskIdentifier, name: "taskIdentifier", parent: name, pattern: "^t-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportTaskOutput: AWSDecodableShape {
        /// The number of the current attempts to execute the import task.
        public let attemptNumber: Int?
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
        public let importOptions: ImportOptions?
        /// Contains details about the specified import task.
        public let importTaskDetails: ImportTaskDetails?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        public let source: String
        /// The status of the import task:    INITIALIZING   –   The necessary resources needed to create the graph are being prepared.    ANALYZING_DATA   –   The data is being analyzed to determine the optimal infrastructure configuration for the new graph.    RE_PROVISIONING   –   The data did not fit into the provisioned graph, so it is being re-provisioned with more capacity.    IMPORTING   –   The data is being loaded.    ERROR_ENCOUNTERED   –   An error has been encountered while trying to create the graph and import the data.    ERROR_ENCOUNTERED_ROLLING_BACK   –   Because of the error that was encountered, the graph is being rolled back and all its resources released.    SUCCEEDED   –   Graph creation and data loading succeeded.    FAILED   –   Graph creation or data loading failed. When the status is FAILED, you can use get-graphs to get more information about the state of the graph.    CANCELLING   –   Because you cancelled the import task, cancellation is in progress.    CANCELLED   –   You have successfully cancelled the import task.
        public let status: ImportTaskStatus
        /// The reason that the import task has this status value.
        public let statusReason: String?
        /// The unique identifier of the import task.
        public let taskId: String

        @inlinable
        public init(attemptNumber: Int? = nil, format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, importTaskDetails: ImportTaskDetails? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String, status: ImportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.attemptNumber = attemptNumber
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.importTaskDetails = importTaskDetails
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case attemptNumber = "attemptNumber"
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case importTaskDetails = "importTaskDetails"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct GetPrivateGraphEndpointInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        @inlinable
        public init(graphIdentifier: String, vpcId: String) {
            self.graphIdentifier = graphIdentifier
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.vpcId, key: "vpcId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPrivateGraphEndpointOutput: AWSDecodableShape {
        /// The current status of the private endpoint.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs involved.
        public let subnetIds: [String]
        /// The ID of the private endpoint.
        public let vpcEndpointId: String?
        /// The ID of the VPC where the private endpoint is located.
        public let vpcId: String

        @inlinable
        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct GetQueryInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The ID of the query in question.
        public let queryId: String

        @inlinable
        public init(graphIdentifier: String, queryId: String) {
            self.graphIdentifier = graphIdentifier
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryOutput: AWSDecodableShape {
        /// The number of milliseconds the query has been running.
        public let elapsed: Int?
        /// The ID of the query in question.
        public let id: String?
        /// The query in question.
        public let queryString: String?
        /// State of the query.
        public let state: QueryState?
        /// Indicates how long the query waited, in milliseconds.
        public let waited: Int?

        @inlinable
        public init(elapsed: Int? = nil, id: String? = nil, queryString: String? = nil, state: QueryState? = nil, waited: Int? = nil) {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }

        private enum CodingKeys: String, CodingKey {
            case elapsed = "elapsed"
            case id = "id"
            case queryString = "queryString"
            case state = "state"
            case waited = "waited"
        }
    }

    public struct GraphDataSummary: AWSDecodableShape {
        /// A list of the edge labels in the graph.
        public let edgeLabels: [String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public let edgeProperties: [[String: Int64]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public let edgeStructures: [EdgeStructure]?
        /// A list of distinct node labels in the graph.
        public let nodeLabels: [String]?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public let nodeProperties: [[String: Int64]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public let nodeStructures: [NodeStructure]?
        /// The number of unique edge labels in the graph.
        public let numEdgeLabels: Int64?
        /// The number of edge properties in the graph.
        public let numEdgeProperties: Int64?
        /// The number of edges in the graph.
        public let numEdges: Int64?
        /// The number of distinct node labels in the graph.
        public let numNodeLabels: Int64?
        /// The number of distinct node properties in the graph.
        public let numNodeProperties: Int64?
        /// The number of nodes in the graph.
        public let numNodes: Int64?
        /// The total number of usages of all edge properties.
        public let totalEdgePropertyValues: Int64?
        /// The total number of usages of all node properties.
        public let totalNodePropertyValues: Int64?

        @inlinable
        public init(edgeLabels: [String]? = nil, edgeProperties: [[String: Int64]]? = nil, edgeStructures: [EdgeStructure]? = nil, nodeLabels: [String]? = nil, nodeProperties: [[String: Int64]]? = nil, nodeStructures: [NodeStructure]? = nil, numEdgeLabels: Int64? = nil, numEdgeProperties: Int64? = nil, numEdges: Int64? = nil, numNodeLabels: Int64? = nil, numNodeProperties: Int64? = nil, numNodes: Int64? = nil, totalEdgePropertyValues: Int64? = nil, totalNodePropertyValues: Int64? = nil) {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLabels = "edgeLabels"
            case edgeProperties = "edgeProperties"
            case edgeStructures = "edgeStructures"
            case nodeLabels = "nodeLabels"
            case nodeProperties = "nodeProperties"
            case nodeStructures = "nodeStructures"
            case numEdgeLabels = "numEdgeLabels"
            case numEdgeProperties = "numEdgeProperties"
            case numEdges = "numEdges"
            case numNodeLabels = "numNodeLabels"
            case numNodeProperties = "numNodeProperties"
            case numNodes = "numNodes"
            case totalEdgePropertyValues = "totalEdgePropertyValues"
            case totalNodePropertyValues = "totalNodePropertyValues"
        }
    }

    public struct GraphSnapshotSummary: AWSDecodableShape {
        /// The ARN of the graph snapshot.
        public let arn: String
        /// The unique identifier of the graph snapshot.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public let kmsKeyIdentifier: String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let name: String
        /// The time when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public let sourceGraphId: String?
        /// The status of the graph snapshot.
        public let status: SnapshotStatus?

        @inlinable
        public init(arn: String, id: String, kmsKeyIdentifier: String? = nil, name: String, snapshotCreateTime: Date? = nil, sourceGraphId: String? = nil, status: SnapshotStatus? = nil) {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case snapshotCreateTime = "snapshotCreateTime"
            case sourceGraphId = "sourceGraphId"
            case status = "status"
        }
    }

    public struct GraphSummary: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The status of the graph.
        public let status: GraphStatus?

        @inlinable
        public init(arn: String, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, status: GraphStatus? = nil) {
            self.arn = arn
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case status = "status"
        }
    }

    public struct ImportTaskDetails: AWSDecodableShape {
        /// The number of dictionary entries in the import task.
        public let dictionaryEntryCount: Int64
        /// The number of errors encountered so far.
        public let errorCount: Int
        /// Details about the errors that have been encountered.
        public let errorDetails: String?
        /// The percentage progress so far.
        public let progressPercentage: Int
        /// Time at which the import task started.
        public let startTime: Date
        /// The number of statements in the import task.
        public let statementCount: Int64
        /// Status of the import task.
        public let status: String
        /// Seconds elapsed since the import task started.
        public let timeElapsedSeconds: Int64

        @inlinable
        public init(dictionaryEntryCount: Int64, errorCount: Int, errorDetails: String? = nil, progressPercentage: Int, startTime: Date, statementCount: Int64, status: String, timeElapsedSeconds: Int64) {
            self.dictionaryEntryCount = dictionaryEntryCount
            self.errorCount = errorCount
            self.errorDetails = errorDetails
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.statementCount = statementCount
            self.status = status
            self.timeElapsedSeconds = timeElapsedSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case dictionaryEntryCount = "dictionaryEntryCount"
            case errorCount = "errorCount"
            case errorDetails = "errorDetails"
            case progressPercentage = "progressPercentage"
            case startTime = "startTime"
            case statementCount = "statementCount"
            case status = "status"
            case timeElapsedSeconds = "timeElapsedSeconds"
        }
    }

    public struct ImportTaskSummary: AWSDecodableShape {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        public let source: String
        /// Status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        @inlinable
        public init(format: Format? = nil, graphId: String? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct ListExportTasksInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String?
        /// The maximum number of export tasks to return.
        public let maxResults: Int?
        /// Pagination token used to paginate input.
        public let nextToken: String?

        @inlinable
        public init(graphIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExportTasksOutput: AWSDecodableShape {
        /// Pagination token used to paginate output.
        public let nextToken: String?
        /// The requested list of export tasks.
        public let tasks: [ExportTaskSummary]

        @inlinable
        public init(nextToken: String? = nil, tasks: [ExportTaskSummary]) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct ListGraphSnapshotsInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String?
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(graphIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphSnapshotsOutput: AWSDecodableShape {
        /// The requested list of snapshots.
        public let graphSnapshots: [GraphSnapshotSummary]
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(graphSnapshots: [GraphSnapshotSummary], nextToken: String? = nil) {
            self.graphSnapshots = graphSnapshots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphSnapshots = "graphSnapshots"
            case nextToken = "nextToken"
        }
    }

    public struct ListGraphsInput: AWSEncodableShape {
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphsOutput: AWSDecodableShape {
        /// A list of the graphs.
        public let graphs: [GraphSummary]
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(graphs: [GraphSummary], nextToken: String? = nil) {
            self.graphs = graphs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphs = "graphs"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportTasksInput: AWSEncodableShape {
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportTasksOutput: AWSDecodableShape {
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?
        /// The requested list of import tasks.
        public let tasks: [ImportTaskSummary]

        @inlinable
        public init(nextToken: String? = nil, tasks: [ImportTaskSummary]) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct ListPrivateGraphEndpointsInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
        public let maxResults: Int?
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(graphIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivateGraphEndpointsOutput: AWSDecodableShape {
        /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
        public let nextToken: String?
        /// A list of private endpoints for the specified Neptune Analytics graph.
        public let privateGraphEndpoints: [PrivateGraphEndpointSummary]

        @inlinable
        public init(nextToken: String? = nil, privateGraphEndpoints: [PrivateGraphEndpointSummary]) {
            self.nextToken = nextToken
            self.privateGraphEndpoints = privateGraphEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privateGraphEndpoints = "privateGraphEndpoints"
        }
    }

    public struct ListQueriesInput: AWSEncodableShape {
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The maximum number of results to be fetched by the API.
        public let maxResults: Int
        /// Filtered list of queries based on state.
        public let state: QueryStateInput?

        @inlinable
        public init(graphIdentifier: String, maxResults: Int, state: QueryStateInput? = nil) {
            self.graphIdentifier = graphIdentifier
            self.maxResults = maxResults
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.graphIdentifier, key: "graphIdentifier")
            request.encodeHostPrefix(self.graphIdentifier, key: "graphIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueriesOutput: AWSDecodableShape {
        /// A list of current openCypher queries.
        public let queries: [QuerySummary]

        @inlinable
        public init(queries: [QuerySummary]) {
            self.queries = queries
        }

        private enum CodingKeys: String, CodingKey {
            case queries = "queries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The list of metadata tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NeptuneImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// Neptune Analytics supports label-less vertices and no labels are assigned unless one is explicitly provided. Neptune assigns default labels when none is explicitly provided. When importing the data into Neptune Analytics, the default vertex labels can be omitted by setting preserveDefaultVertexLabels to false. Note that if the vertex only has default labels, and has no other properties or edges, then the vertex will effectively not get imported into Neptune Analytics when preserveDefaultVertexLabels is set to false.
        public let preserveDefaultVertexLabels: Bool?
        /// Neptune Analytics currently does not support user defined edge ids. The edge ids are not imported by default. They are imported if preserveEdgeIds is set to true, and ids are stored as properties on the relationships with the property name neptuneEdgeId.
        public let preserveEdgeIds: Bool?
        /// The KMS key to use to encrypt data in the S3 bucket where the graph data is exported
        public let s3ExportKmsKeyId: String
        /// The path to an S3 bucket from which to import data.
        public let s3ExportPath: String

        @inlinable
        public init(preserveDefaultVertexLabels: Bool? = nil, preserveEdgeIds: Bool? = nil, s3ExportKmsKeyId: String, s3ExportPath: String) {
            self.preserveDefaultVertexLabels = preserveDefaultVertexLabels
            self.preserveEdgeIds = preserveEdgeIds
            self.s3ExportKmsKeyId = s3ExportKmsKeyId
            self.s3ExportPath = s3ExportPath
        }

        private enum CodingKeys: String, CodingKey {
            case preserveDefaultVertexLabels = "preserveDefaultVertexLabels"
            case preserveEdgeIds = "preserveEdgeIds"
            case s3ExportKmsKeyId = "s3ExportKmsKeyId"
            case s3ExportPath = "s3ExportPath"
        }
    }

    public struct NodeStructure: AWSDecodableShape {
        /// The number of instances of this node.
        public let count: Int64?
        /// The outgoing edge labels associated with this node.
        public let distinctOutgoingEdgeLabels: [String]?
        /// Properties associated with this node.
        public let nodeProperties: [String]?

        @inlinable
        public init(count: Int64? = nil, distinctOutgoingEdgeLabels: [String]? = nil, nodeProperties: [String]? = nil) {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case distinctOutgoingEdgeLabels = "distinctOutgoingEdgeLabels"
            case nodeProperties = "nodeProperties"
        }
    }

    public struct PrivateGraphEndpointSummary: AWSDecodableShape {
        /// The status of the private graph endpoint.
        public let status: PrivateGraphEndpointStatus
        /// The subnet IDs associated with the private graph endpoint.
        public let subnetIds: [String]
        /// The ID of the VPC endpoint.
        public let vpcEndpointId: String?
        /// The ID of the VPC in which the private graph endpoint is located.
        public let vpcId: String

        @inlinable
        public init(status: PrivateGraphEndpointStatus, subnetIds: [String], vpcEndpointId: String? = nil, vpcId: String) {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct QuerySummary: AWSDecodableShape {
        /// The running time of the query, in milliseconds.
        public let elapsed: Int?
        /// A string representation of the id of the query.
        public let id: String?
        /// The actual query text. The queryString may be truncated if the actual query string is too long.
        public let queryString: String?
        /// State of the query.
        public let state: QueryState?
        /// The amount of time, in milliseconds, the query has waited in the queue before being picked up by a worker thread.
        public let waited: Int?

        @inlinable
        public init(elapsed: Int? = nil, id: String? = nil, queryString: String? = nil, state: QueryState? = nil, waited: Int? = nil) {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }

        private enum CodingKeys: String, CodingKey {
            case elapsed = "elapsed"
            case id = "id"
            case queryString = "queryString"
            case state = "state"
            case waited = "waited"
        }
    }

    public struct ResetGraphInput: AWSEncodableShape {
        /// ID of the graph to reset.
        public let graphIdentifier: String
        /// Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
        public let skipSnapshot: Bool

        @inlinable
        public init(graphIdentifier: String, skipSnapshot: Bool) {
            self.graphIdentifier = graphIdentifier
            self.skipSnapshot = skipSnapshot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encode(self.skipSnapshot, forKey: .skipSnapshot)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case skipSnapshot = "skipSnapshot"
        }
    }

    public struct ResetGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct RestoreGraphFromSnapshotInput: AWSEncodableShape {
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. Only lowercase letters are allowed.
        public let graphName: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 16
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
        public let publicConnectivity: Bool?
        /// The number of replicas in other AZs. Min =0, Max = 2, Default =1   Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
        public let replicaCount: Int?
        /// The ID of the snapshot in question.
        public let snapshotIdentifier: String
        /// Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
        public let tags: [String: String]?

        @inlinable
        public init(deletionProtection: Bool? = nil, graphName: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, snapshotIdentifier: String, tags: [String: String]? = nil) {
            self.deletionProtection = deletionProtection
            self.graphName = graphName
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.snapshotIdentifier = snapshotIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deletionProtection, forKey: .deletionProtection)
            try container.encode(self.graphName, forKey: .graphName)
            try container.encodeIfPresent(self.provisionedMemory, forKey: .provisionedMemory)
            try container.encodeIfPresent(self.publicConnectivity, forKey: .publicConnectivity)
            try container.encodeIfPresent(self.replicaCount, forKey: .replicaCount)
            request.encodePath(self.snapshotIdentifier, key: "snapshotIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphName, name: "graphName", parent: name, max: 63)
            try self.validate(self.graphName, name: "graphName", parent: name, min: 1)
            try self.validate(self.graphName, name: "graphName", parent: name, pattern: "^(?!g-)[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 16)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, max: 2)
            try self.validate(self.replicaCount, name: "replicaCount", parent: name, min: 0)
            try self.validate(self.snapshotIdentifier, name: "snapshotIdentifier", parent: name, pattern: "^gs-[a-z0-9]{10}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case graphName = "graphName"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case tags = "tags"
        }
    }

    public struct RestoreGraphFromSnapshotOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// Service quota code of the resource for which quota was exceeded.
        public let quotaCode: String?
        /// The identifier of the resource that exceeded quota.
        public let resourceId: String?
        /// The type of the resource that exceeded quota. Ex: Graph, Snapshot
        public let resourceType: String?
        /// The service code that exceeded quota.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct StartExportTaskInput: AWSEncodableShape {
        /// The Amazon S3 URI where data will be exported to.
        public let destination: String
        /// The export filter of the export task.
        public let exportFilter: ExportFilter?
        /// The format of the export task.
        public let format: ExportFormat
        /// The source graph identifier of the export task.
        public let graphIdentifier: String
        /// The KMS key identifier of the export task.
        public let kmsKeyIdentifier: String
        /// The parquet type of the export task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow data to be exported to the destination.
        public let roleArn: String
        /// Tags to be applied to the export task.
        public let tags: [String: String]?

        @inlinable
        public init(destination: String, exportFilter: ExportFilter? = nil, format: ExportFormat, graphIdentifier: String, kmsKeyIdentifier: String, parquetType: ParquetType? = nil, roleArn: String, tags: [String: String]? = nil) {
            self.destination = destination
            self.exportFilter = exportFilter
            self.format = format
            self.graphIdentifier = graphIdentifier
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.exportFilter?.validate(name: "\(name).exportFilter")
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)(/[\\w+=,.@-]+)+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case exportFilter = "exportFilter"
            case format = "format"
            case graphIdentifier = "graphIdentifier"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct StartExportTaskOutput: AWSDecodableShape {
        /// The Amazon S3 URI of the export task where data will be exported to.
        public let destination: String
        /// The export filter of the export task.
        public let exportFilter: ExportFilter?
        /// The format of the export task.
        public let format: ExportFormat
        /// The source graph identifier of the export task.
        public let graphId: String
        /// The KMS key identifier of the export task.
        public let kmsKeyIdentifier: String
        /// The parquet type of the export task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow data to be exported to the destination.
        public let roleArn: String
        /// The current status of the export task.
        public let status: ExportTaskStatus
        /// The reason that the export task has this status value.
        public let statusReason: String?
        /// The unique identifier of the export task.
        public let taskId: String

        @inlinable
        public init(destination: String, exportFilter: ExportFilter? = nil, format: ExportFormat, graphId: String, kmsKeyIdentifier: String, parquetType: ParquetType? = nil, roleArn: String, status: ExportTaskStatus, statusReason: String? = nil, taskId: String) {
            self.destination = destination
            self.exportFilter = exportFilter
            self.format = format
            self.graphId = graphId
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.status = status
            self.statusReason = statusReason
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case exportFilter = "exportFilter"
            case format = "format"
            case graphId = "graphId"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReason = "statusReason"
            case taskId = "taskId"
        }
    }

    public struct StartImportTaskInput: AWSEncodableShape {
        /// The method to handle blank nodes in the dataset. Currently, only convertToIri is supported,  meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples.  For more information, see Handling RDF values.
        public let blankNodeHandling: BlankNodeHandling?
        /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that  caused the error and continues if possible.
        public let failOnError: Bool?
        /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or  OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        public let importOptions: ImportOptions?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a  Neptune database endpoint or snapshot.
        public let source: String

        @inlinable
        public init(blankNodeHandling: BlankNodeHandling? = nil, failOnError: Bool? = nil, format: Format? = nil, graphIdentifier: String, importOptions: ImportOptions? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String) {
            self.blankNodeHandling = blankNodeHandling
            self.failOnError = failOnError
            self.format = format
            self.graphIdentifier = graphIdentifier
            self.importOptions = importOptions
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.blankNodeHandling, forKey: .blankNodeHandling)
            try container.encodeIfPresent(self.failOnError, forKey: .failOnError)
            try container.encodeIfPresent(self.format, forKey: .format)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.importOptions, forKey: .importOptions)
            try container.encodeIfPresent(self.parquetType, forKey: .parquetType)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.source, forKey: .source)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)(/[\\w+=,.@-]+)+$")
        }

        private enum CodingKeys: String, CodingKey {
            case blankNodeHandling = "blankNodeHandling"
            case failOnError = "failOnError"
            case format = "format"
            case importOptions = "importOptions"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
        }
    }

    public struct StartImportTaskOutput: AWSDecodableShape {
        /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or  OPENCYPHER, which identies the openCypher load format.
        public let format: Format?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphId: String?
        public let importOptions: ImportOptions?
        /// The parquet type of the import task.
        public let parquetType: ParquetType?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        public let roleArn: String
        /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a  Neptune database endpoint or snapshot.
        public let source: String
        /// The status of the import task.
        public let status: ImportTaskStatus
        /// The unique identifier of the import task.
        public let taskId: String

        @inlinable
        public init(format: Format? = nil, graphId: String? = nil, importOptions: ImportOptions? = nil, parquetType: ParquetType? = nil, roleArn: String, source: String, status: ImportTaskStatus, taskId: String) {
            self.format = format
            self.graphId = graphId
            self.importOptions = importOptions
            self.parquetType = parquetType
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case graphId = "graphId"
            case importOptions = "importOptions"
            case parquetType = "parquetType"
            case roleArn = "roleArn"
            case source = "source"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// ARN of the resource for which tags need to be added.
        public let resourceArn: String
        /// The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs:  Key (string)   –   A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").  Value (string)   –   A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UnprocessableException: AWSErrorShape {
        public let message: String
        /// The reason for the unprocessable exception.
        public let reason: UnprocessableExceptionReason

        @inlinable
        public init(message: String, reason: UnprocessableExceptionReason) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// ARN of the resource whose tag needs to be removed.
        public let resourceArn: String
        /// Tag keys for the tags to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGraphInput: AWSEncodableShape {
        /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The unique identifier of the Neptune Analytics graph.
        public let graphIdentifier: String
        /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 16
        public let provisionedMemory: Int?
        /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
        public let publicConnectivity: Bool?

        @inlinable
        public init(deletionProtection: Bool? = nil, graphIdentifier: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil) {
            self.deletionProtection = deletionProtection
            self.graphIdentifier = graphIdentifier
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deletionProtection, forKey: .deletionProtection)
            request.encodePath(self.graphIdentifier, key: "graphIdentifier")
            try container.encodeIfPresent(self.provisionedMemory, forKey: .provisionedMemory)
            try container.encodeIfPresent(self.publicConnectivity, forKey: .publicConnectivity)
        }

        public func validate(name: String) throws {
            try self.validate(self.graphIdentifier, name: "graphIdentifier", parent: name, pattern: "^g-[a-z0-9]{10}$")
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, max: 24576)
            try self.validate(self.provisionedMemory, name: "provisionedMemory", parent: name, min: 16)
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtection = "deletionProtection"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
        }
    }

    public struct UpdateGraphOutput: AWSDecodableShape {
        /// The ARN associated with the graph.
        public let arn: String
        /// The build number of the graph.
        public let buildNumber: String?
        /// The time at which the graph was created.
        public let createTime: Date?
        /// If true, deletion protection is enabled for the graph.
        public let deletionProtection: Bool?
        /// The graph endpoint.
        public let endpoint: String?
        /// The unique identifier of the graph.
        public let id: String
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public let kmsKeyIdentifier: String?
        /// The name of the graph.
        public let name: String
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public let provisionedMemory: Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public let publicConnectivity: Bool?
        /// The number of replicas for the graph.
        public let replicaCount: Int?
        /// The ID of the snapshot from which the graph was created, if any.
        public let sourceSnapshotId: String?
        /// The status of the graph.
        public let status: GraphStatus?
        /// The reason that the graph has this status.
        public let statusReason: String?
        public let vectorSearchConfiguration: VectorSearchConfiguration?

        @inlinable
        public init(arn: String, buildNumber: String? = nil, createTime: Date? = nil, deletionProtection: Bool? = nil, endpoint: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String, provisionedMemory: Int? = nil, publicConnectivity: Bool? = nil, replicaCount: Int? = nil, sourceSnapshotId: String? = nil, status: GraphStatus? = nil, statusReason: String? = nil, vectorSearchConfiguration: VectorSearchConfiguration? = nil) {
            self.arn = arn
            self.buildNumber = buildNumber
            self.createTime = createTime
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.sourceSnapshotId = sourceSnapshotId
            self.status = status
            self.statusReason = statusReason
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildNumber = "buildNumber"
            case createTime = "createTime"
            case deletionProtection = "deletionProtection"
            case endpoint = "endpoint"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case provisionedMemory = "provisionedMemory"
            case publicConnectivity = "publicConnectivity"
            case replicaCount = "replicaCount"
            case sourceSnapshotId = "sourceSnapshotId"
            case status = "status"
            case statusReason = "statusReason"
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A message describing the problem.
        public let message: String
        /// The reason that the resource could not be validated.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(message: String, reason: ValidationExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct VectorSearchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of dimensions.
        public let dimension: Int

        @inlinable
        public init(dimension: Int) {
            self.dimension = dimension
        }

        public func validate(name: String) throws {
            try self.validate(self.dimension, name: "dimension", parent: name, max: 65536)
            try self.validate(self.dimension, name: "dimension", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimension = "dimension"
        }
    }

    public struct ImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// Options for importing data from a Neptune database.
        public let neptune: NeptuneImportOptions?

        @inlinable
        public init(neptune: NeptuneImportOptions? = nil) {
            self.neptune = neptune
        }

        private enum CodingKeys: String, CodingKey {
            case neptune = "neptune"
        }
    }
}

// MARK: - Errors

/// Error enum for NeptuneGraph
public struct NeptuneGraphErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unprocessableException = "UnprocessableException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize NeptuneGraph
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Raised in case of an authentication or authorization failure.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Raised when a conflict is encountered.
    public static var conflictException: Self { .init(.conflictException) }
    /// A failure occurred on the server.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A specified resource could not be located.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service quota was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The exception was interrupted by throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Request cannot be processed due to known reasons. Eg. partition full.
    public static var unprocessableException: Self { .init(.unprocessableException) }
    /// A resource could not be validated.
    public static var validationException: Self { .init(.validationException) }
}

extension NeptuneGraphErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": NeptuneGraph.ConflictException.self,
        "ServiceQuotaExceededException": NeptuneGraph.ServiceQuotaExceededException.self,
        "UnprocessableException": NeptuneGraph.UnprocessableException.self,
        "ValidationException": NeptuneGraph.ValidationException.self
    ]
}

extension NeptuneGraphErrorType: Equatable {
    public static func == (lhs: NeptuneGraphErrorType, rhs: NeptuneGraphErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NeptuneGraphErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
