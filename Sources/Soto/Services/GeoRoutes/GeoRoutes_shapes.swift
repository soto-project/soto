//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GeoRoutes {
    // MARK: Enums

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "Friday"
        case monday = "Monday"
        case saturday = "Saturday"
        case sunday = "Sunday"
        case thursday = "Thursday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        public var description: String { return self.rawValue }
    }

    public enum GeometryFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flexiblePolyline = "FlexiblePolyline"
        case simple = "Simple"
        public var description: String { return self.rawValue }
    }

    public enum IsolineEngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case electric = "Electric"
        case internalCombustion = "InternalCombustion"
        case pluginHybrid = "PluginHybrid"
        public var description: String { return self.rawValue }
    }

    public enum IsolineHazardousCargoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case combustible = "Combustible"
        case corrosive = "Corrosive"
        case explosive = "Explosive"
        case flammable = "Flammable"
        case gas = "Gas"
        case harmfulToWater = "HarmfulToWater"
        case organic = "Organic"
        case other = "Other"
        case poison = "Poison"
        case poisonousInhalation = "PoisonousInhalation"
        case radioactive = "Radioactive"
        public var description: String { return self.rawValue }
    }

    public enum IsolineOptimizationObjective: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accurateCalculation = "AccurateCalculation"
        case balancedCalculation = "BalancedCalculation"
        case fastCalculation = "FastCalculation"
        public var description: String { return self.rawValue }
    }

    public enum IsolineTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum IsolineTruckType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lightTruck = "LightTruck"
        case straightTruck = "StraightTruck"
        case tractor = "Tractor"
        public var description: String { return self.rawValue }
    }

    public enum IsolineZoneCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case congestionPricing = "CongestionPricing"
        case environmental = "Environmental"
        case vignette = "Vignette"
        public var description: String { return self.rawValue }
    }

    public enum MatchingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case matchAny = "MatchAny"
        case matchMostSignificantRoad = "MatchMostSignificantRoad"
        public var description: String { return self.rawValue }
    }

    public enum MeasurementSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case imperial = "Imperial"
        case metric = "Metric"
        public var description: String { return self.rawValue }
    }

    public enum RoadSnapHazardousCargoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case combustible = "Combustible"
        case corrosive = "Corrosive"
        case explosive = "Explosive"
        case flammable = "Flammable"
        case gas = "Gas"
        case harmfulToWater = "HarmfulToWater"
        case organic = "Organic"
        case other = "Other"
        case poison = "Poison"
        case poisonousInhalation = "PoisonousInhalation"
        case radioactive = "Radioactive"
        public var description: String { return self.rawValue }
    }

    public enum RoadSnapNoticeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tracePointsHeadingIgnored = "TracePointsHeadingIgnored"
        case tracePointsIgnored = "TracePointsIgnored"
        case tracePointsMovedByLargeDistance = "TracePointsMovedByLargeDistance"
        case tracePointsNotMatched = "TracePointsNotMatched"
        case tracePointsOutOfSequence = "TracePointsOutOfSequence"
        case tracePointsSpeedEstimated = "TracePointsSpeedEstimated"
        case tracePointsSpeedIgnored = "TracePointsSpeedIgnored"
        public var description: String { return self.rawValue }
    }

    public enum RoadSnapTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum RouteDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case east = "East"
        case north = "North"
        case south = "South"
        case west = "West"
        public var description: String { return self.rawValue }
    }

    public enum RouteEngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case electric = "Electric"
        case internalCombustion = "InternalCombustion"
        case pluginHybrid = "PluginHybrid"
        public var description: String { return self.rawValue }
    }

    public enum RouteFerryAfterTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deboard = "Deboard"
        public var description: String { return self.rawValue }
    }

    public enum RouteFerryBeforeTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case board = "Board"
        public var description: String { return self.rawValue }
    }

    public enum RouteFerryNoticeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accuratePolylineUnavailable = "AccuratePolylineUnavailable"
        case noSchedule = "NoSchedule"
        case other = "Other"
        case seasonalClosure = "SeasonalClosure"
        case violatedAvoidFerry = "ViolatedAvoidFerry"
        case violatedAvoidRailFerry = "ViolatedAvoidRailFerry"
        public var description: String { return self.rawValue }
    }

    public enum RouteFerryTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arrive = "Arrive"
        case `continue` = "Continue"
        case depart = "Depart"
        public var description: String { return self.rawValue }
    }

    public enum RouteHazardousCargoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case combustible = "Combustible"
        case corrosive = "Corrosive"
        case explosive = "Explosive"
        case flammable = "Flammable"
        case gas = "Gas"
        case harmfulToWater = "HarmfulToWater"
        case organic = "Organic"
        case other = "Other"
        case poison = "Poison"
        case poisonousInhalation = "PoisonousInhalation"
        case radioactive = "Radioactive"
        public var description: String { return self.rawValue }
    }

    public enum RouteLegAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case elevation = "Elevation"
        case incidents = "Incidents"
        case passThroughWaypoints = "PassThroughWaypoints"
        case summary = "Summary"
        case tolls = "Tolls"
        case travelStepInstructions = "TravelStepInstructions"
        case truckRoadTypes = "TruckRoadTypes"
        case typicalDuration = "TypicalDuration"
        case zones = "Zones"
        public var description: String { return self.rawValue }
    }

    public enum RouteLegTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case carShuttleTrain = "CarShuttleTrain"
        case ferry = "Ferry"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum RouteLegType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ferry = "Ferry"
        case pedestrian = "Pedestrian"
        case vehicle = "Vehicle"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noMatch = "NoMatch"
        case noMatchDestination = "NoMatchDestination"
        case noMatchOrigin = "NoMatchOrigin"
        case noRoute = "NoRoute"
        case other = "Other"
        case outOfBounds = "OutOfBounds"
        case outOfBoundsDestination = "OutOfBoundsDestination"
        case outOfBoundsOrigin = "OutOfBoundsOrigin"
        case violation = "Violation"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixHazardousCargoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case combustible = "Combustible"
        case corrosive = "Corrosive"
        case explosive = "Explosive"
        case flammable = "Flammable"
        case gas = "Gas"
        case harmfulToWater = "HarmfulToWater"
        case organic = "Organic"
        case other = "Other"
        case poison = "Poison"
        case poisonousInhalation = "PoisonousInhalation"
        case radioactive = "Radioactive"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixTruckType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lightTruck = "LightTruck"
        case straightTruck = "StraightTruck"
        case tractor = "Tractor"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixZoneCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case congestionPricing = "CongestionPricing"
        case environmental = "Environmental"
        case vignette = "Vignette"
        public var description: String { return self.rawValue }
    }

    public enum RouteNoticeImpact: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "High"
        case low = "Low"
        public var description: String { return self.rawValue }
    }

    public enum RoutePedestrianNoticeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accuratePolylineUnavailable = "AccuratePolylineUnavailable"
        case other = "Other"
        case violatedAvoidDirtRoad = "ViolatedAvoidDirtRoad"
        case violatedAvoidTunnel = "ViolatedAvoidTunnel"
        case violatedPedestrianOption = "ViolatedPedestrianOption"
        public var description: String { return self.rawValue }
    }

    public enum RoutePedestrianTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arrive = "Arrive"
        case `continue` = "Continue"
        case depart = "Depart"
        case exit = "Exit"
        case keep = "Keep"
        case ramp = "Ramp"
        case roundaboutEnter = "RoundaboutEnter"
        case roundaboutExit = "RoundaboutExit"
        case roundaboutPass = "RoundaboutPass"
        case turn = "Turn"
        case uTurn = "UTurn"
        public var description: String { return self.rawValue }
    }

    public enum RouteResponseNoticeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mainLanguageNotFound = "MainLanguageNotFound"
        case other = "Other"
        case travelTimeExceedsDriverWorkHours = "TravelTimeExceedsDriverWorkHours"
        public var description: String { return self.rawValue }
    }

    public enum RouteRoadType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case highway = "Highway"
        case rural = "Rural"
        case urban = "Urban"
        public var description: String { return self.rawValue }
    }

    public enum RouteSideOfStreet: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case left = "Left"
        case right = "Right"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bestCaseDuration = "BestCaseDuration"
        case carAccess = "CarAccess"
        case consumption = "Consumption"
        case country = "Country"
        case distance = "Distance"
        case duration = "Duration"
        case dynamicSpeed = "DynamicSpeed"
        case functionalClassification = "FunctionalClassification"
        case gates = "Gates"
        case incidents = "Incidents"
        case names = "Names"
        case notices = "Notices"
        case pedestrianAccess = "PedestrianAccess"
        case railwayCrossings = "RailwayCrossings"
        case region = "Region"
        case roadAttributes = "RoadAttributes"
        case routeNumbers = "RouteNumbers"
        case scooterAccess = "ScooterAccess"
        case speedLimit = "SpeedLimit"
        case tollSystems = "TollSystems"
        case truckAccess = "TruckAccess"
        case truckRoadTypes = "TruckRoadTypes"
        case typicalDuration = "TypicalDuration"
        case zones = "Zones"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanCarAccessAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "Allowed"
        case noThroughTraffic = "NoThroughTraffic"
        case tollRoad = "TollRoad"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanGateAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emergency = "Emergency"
        case keyAccess = "KeyAccess"
        case permissionRequired = "PermissionRequired"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanPedestrianAccessAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "Allowed"
        case indoors = "Indoors"
        case noThroughTraffic = "NoThroughTraffic"
        case park = "Park"
        case stairs = "Stairs"
        case tollRoad = "TollRoad"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanRailwayCrossingAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case protected = "Protected"
        case unprotected = "Unprotected"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanRoadAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bridge = "Bridge"
        case builtUpArea = "BuiltUpArea"
        case controlledAccessHighway = "ControlledAccessHighway"
        case dirtRoad = "DirtRoad"
        case dividedRoad = "DividedRoad"
        case motorway = "Motorway"
        case privateRoad = "PrivateRoad"
        case ramp = "Ramp"
        case rightHandTraffic = "RightHandTraffic"
        case roundabout = "Roundabout"
        case tunnel = "Tunnel"
        case underConstruction = "UnderConstruction"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanScooterAccessAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "Allowed"
        case noThroughTraffic = "NoThroughTraffic"
        case tollRoad = "TollRoad"
        public var description: String { return self.rawValue }
    }

    public enum RouteSpanTruckAccessAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "Allowed"
        case noThroughTraffic = "NoThroughTraffic"
        case tollRoad = "TollRoad"
        public var description: String { return self.rawValue }
    }

    public enum RouteSteeringDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case left = "Left"
        case right = "Right"
        case straight = "Straight"
        public var description: String { return self.rawValue }
    }

    public enum RouteTollPassValidityPeriodType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case annual = "Annual"
        case days = "Days"
        case extendedAnnual = "ExtendedAnnual"
        case minutes = "Minutes"
        case months = "Months"
        public var description: String { return self.rawValue }
    }

    public enum RouteTollPaymentMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bankCard = "BankCard"
        case cash = "Cash"
        case cashExact = "CashExact"
        case creditCard = "CreditCard"
        case passSubscription = "PassSubscription"
        case transponder = "Transponder"
        case travelCard = "TravelCard"
        case videoToll = "VideoToll"
        public var description: String { return self.rawValue }
    }

    public enum RouteTollVehicleCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case minibus = "Minibus"
        public var description: String { return self.rawValue }
    }

    public enum RouteTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum RouteTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "Default"
        case turnByTurn = "TurnByTurn"
        public var description: String { return self.rawValue }
    }

    public enum RouteTruckType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lightTruck = "LightTruck"
        case straightTruck = "StraightTruck"
        case tractor = "Tractor"
        public var description: String { return self.rawValue }
    }

    public enum RouteTurnIntensity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sharp = "Sharp"
        case slight = "Slight"
        case typical = "Typical"
        public var description: String { return self.rawValue }
    }

    public enum RouteVehicleIncidentSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "Critical"
        case high = "High"
        case low = "Low"
        case medium = "Medium"
        public var description: String { return self.rawValue }
    }

    public enum RouteVehicleIncidentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accident = "Accident"
        case congestion = "Congestion"
        case construction = "Construction"
        case disabledVehicle = "DisabledVehicle"
        case laneRestriction = "LaneRestriction"
        case massTransit = "MassTransit"
        case other = "Other"
        case plannedEvent = "PlannedEvent"
        case roadClosure = "RoadClosure"
        case roadHazard = "RoadHazard"
        case weather = "Weather"
        public var description: String { return self.rawValue }
    }

    public enum RouteVehicleNoticeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accuratePolylineUnavailable = "AccuratePolylineUnavailable"
        case other = "Other"
        case potentialViolatedAvoidTollRoadUsage = "PotentialViolatedAvoidTollRoadUsage"
        case potentialViolatedCarpoolUsage = "PotentialViolatedCarpoolUsage"
        case potentialViolatedTurnRestrictionUsage = "PotentialViolatedTurnRestrictionUsage"
        case potentialViolatedVehicleRestrictionUsage = "PotentialViolatedVehicleRestrictionUsage"
        case potentialViolatedZoneRestrictionUsage = "PotentialViolatedZoneRestrictionUsage"
        case seasonalClosure = "SeasonalClosure"
        case tollTransponder = "TollTransponder"
        case tollsDataTemporarilyUnavailable = "TollsDataTemporarilyUnavailable"
        case tollsDataUnavailable = "TollsDataUnavailable"
        case violatedAvoidControlledAccessHighway = "ViolatedAvoidControlledAccessHighway"
        case violatedAvoidDifficultTurns = "ViolatedAvoidDifficultTurns"
        case violatedAvoidDirtRoad = "ViolatedAvoidDirtRoad"
        case violatedAvoidSeasonalClosure = "ViolatedAvoidSeasonalClosure"
        case violatedAvoidTollRoad = "ViolatedAvoidTollRoad"
        case violatedAvoidTollTransponder = "ViolatedAvoidTollTransponder"
        case violatedAvoidTruckRoadType = "ViolatedAvoidTruckRoadType"
        case violatedAvoidTunnel = "ViolatedAvoidTunnel"
        case violatedAvoidUTurns = "ViolatedAvoidUTurns"
        case violatedBlockedRoad = "ViolatedBlockedRoad"
        case violatedCarpool = "ViolatedCarpool"
        case violatedEmergencyGate = "ViolatedEmergencyGate"
        case violatedStartDirection = "ViolatedStartDirection"
        case violatedTurnRestriction = "ViolatedTurnRestriction"
        case violatedVehicleRestriction = "ViolatedVehicleRestriction"
        case violatedZoneRestriction = "ViolatedZoneRestriction"
        public var description: String { return self.rawValue }
    }

    public enum RouteVehicleTravelStepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arrive = "Arrive"
        case `continue` = "Continue"
        case continueHighway = "ContinueHighway"
        case depart = "Depart"
        case enterHighway = "EnterHighway"
        case exit = "Exit"
        case keep = "Keep"
        case ramp = "Ramp"
        case roundaboutEnter = "RoundaboutEnter"
        case roundaboutExit = "RoundaboutExit"
        case roundaboutPass = "RoundaboutPass"
        case turn = "Turn"
        case uTurn = "UTurn"
        public var description: String { return self.rawValue }
    }

    public enum RouteWeightConstraintType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case current = "Current"
        case gross = "Gross"
        case unknown = "Unknown"
        public var description: String { return self.rawValue }
    }

    public enum RouteZoneCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case congestionPricing = "CongestionPricing"
        case environmental = "Environmental"
        case vignette = "Vignette"
        public var description: String { return self.rawValue }
    }

    public enum RoutingObjective: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fastestRoute = "FastestRoute"
        case shortestRoute = "ShortestRoute"
        public var description: String { return self.rawValue }
    }

    public enum SideOfStreetMatchingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anyStreet = "AnyStreet"
        case dividedStreetOnly = "DividedStreetOnly"
        public var description: String { return self.rawValue }
    }

    public enum TrafficUsage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ignoreTrafficData = "IgnoreTrafficData"
        case useTrafficData = "UseTrafficData"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse = "CannotParse"
        ///     The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed = "FieldValidationFailed"
        /// The required input is missing.
        case missing = "Missing"
        /// The input is invalid but no more specific reason is applicable.
        case other = "Other"
        /// No such field is supported.
        case unknownField = "UnknownField"
        /// No such operation is supported.
        case unknownOperation = "UnknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationClusteringAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case drivingDistance = "DrivingDistance"
        case topologySegment = "TopologySegment"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationConstraint: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessHours = "AccessHours"
        case appointmentTime = "AppointmentTime"
        case before = "Before"
        case heading = "Heading"
        case serviceDuration = "ServiceDuration"
        case sideOfStreet = "SideOfStreet"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationHazardousCargoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case combustible = "Combustible"
        case corrosive = "Corrosive"
        case explosive = "Explosive"
        case flammable = "Flammable"
        case gas = "Gas"
        case harmfulToWater = "HarmfulToWater"
        case organic = "Organic"
        case other = "Other"
        case poison = "Poison"
        case poisonousInhalation = "PoisonousInhalation"
        case radioactive = "Radioactive"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationSequencingObjective: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fastestRoute = "FastestRoute"
        case shortestRoute = "ShortestRoute"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationServiceTimeTreatment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rest = "Rest"
        case work = "Work"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationTravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case car = "Car"
        case pedestrian = "Pedestrian"
        case scooter = "Scooter"
        case truck = "Truck"
        public var description: String { return self.rawValue }
    }

    public enum WaypointOptimizationTruckType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case straightTruck = "StraightTruck"
        case tractor = "Tractor"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CalculateIsolinesRequest: AWSEncodableShape {
        /// Features that are allowed while calculating an isoline.
        public let allow: IsolineAllowOptions?
        /// Time of arrival at the destination. Time format: YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let arrivalTime: String?
        /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
        public let avoid: IsolineAvoidanceOptions?
        /// Uses the current time as the time of departure.
        public let departNow: Bool?
        /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String?
        /// The final position for the route. In the World Geodetic System (WGS 84) format: [longitude, latitude].
        public let destination: [Double]?
        /// Destination related options.
        public let destinationOptions: IsolineDestinationOptions?
        /// The format of the returned IsolineGeometry.  Default Value:FlexiblePolyline
        public let isolineGeometryFormat: GeometryFormat?
        /// Defines the granularity of the returned Isoline.
        public let isolineGranularity: IsolineGranularityOptions?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.  Default Value: BalancedCalculation
        public let optimizeIsolineFor: IsolineOptimizationObjective?
        /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
        public let optimizeRoutingFor: RoutingObjective?
        /// The start position for the route.
        public let origin: [Double]?
        /// Origin related options.
        public let originOptions: IsolineOriginOptions?
        /// Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested. You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See  Amazon Location's pricing page for more information.
        public let thresholds: IsolineThresholds
        /// Traffic related options.
        public let traffic: IsolineTrafficOptions?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.  The mode Scooter also applies to motorcycles, set to Scooter when wanted to calculate options for motorcycles.  Default Value: Car
        public let travelMode: IsolineTravelMode?
        /// Travel mode related options for the provided travel mode.
        public let travelModeOptions: IsolineTravelModeOptions?

        @inlinable
        public init(allow: IsolineAllowOptions? = nil, arrivalTime: String? = nil, avoid: IsolineAvoidanceOptions? = nil, departNow: Bool? = nil, departureTime: String? = nil, destination: [Double]? = nil, destinationOptions: IsolineDestinationOptions? = nil, isolineGeometryFormat: GeometryFormat? = nil, isolineGranularity: IsolineGranularityOptions? = nil, key: String? = nil, optimizeIsolineFor: IsolineOptimizationObjective? = nil, optimizeRoutingFor: RoutingObjective? = nil, origin: [Double]? = nil, originOptions: IsolineOriginOptions? = nil, thresholds: IsolineThresholds, traffic: IsolineTrafficOptions? = nil, travelMode: IsolineTravelMode? = nil, travelModeOptions: IsolineTravelModeOptions? = nil) {
            self.allow = allow
            self.arrivalTime = arrivalTime
            self.avoid = avoid
            self.departNow = departNow
            self.departureTime = departureTime
            self.destination = destination
            self.destinationOptions = destinationOptions
            self.isolineGeometryFormat = isolineGeometryFormat
            self.isolineGranularity = isolineGranularity
            self.key = key
            self.optimizeIsolineFor = optimizeIsolineFor
            self.optimizeRoutingFor = optimizeRoutingFor
            self.origin = origin
            self.originOptions = originOptions
            self.thresholds = thresholds
            self.traffic = traffic
            self.travelMode = travelMode
            self.travelModeOptions = travelModeOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allow, forKey: .allow)
            try container.encodeIfPresent(self.arrivalTime, forKey: .arrivalTime)
            try container.encodeIfPresent(self.avoid, forKey: .avoid)
            try container.encodeIfPresent(self.departNow, forKey: .departNow)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encodeIfPresent(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationOptions, forKey: .destinationOptions)
            try container.encodeIfPresent(self.isolineGeometryFormat, forKey: .isolineGeometryFormat)
            try container.encodeIfPresent(self.isolineGranularity, forKey: .isolineGranularity)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.optimizeIsolineFor, forKey: .optimizeIsolineFor)
            try container.encodeIfPresent(self.optimizeRoutingFor, forKey: .optimizeRoutingFor)
            try container.encodeIfPresent(self.origin, forKey: .origin)
            try container.encodeIfPresent(self.originOptions, forKey: .originOptions)
            try container.encode(self.thresholds, forKey: .thresholds)
            try container.encodeIfPresent(self.traffic, forKey: .traffic)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.travelModeOptions, forKey: .travelModeOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.arrivalTime, name: "arrivalTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.avoid?.validate(name: "\(name).avoid")
            try self.validate(self.departureTime, name: "departureTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.validate(self.destination, name: "destination", parent: name, max: 2)
            try self.validate(self.destination, name: "destination", parent: name, min: 2)
            try self.destinationOptions?.validate(name: "\(name).destinationOptions")
            try self.isolineGranularity?.validate(name: "\(name).isolineGranularity")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.origin, name: "origin", parent: name, max: 2)
            try self.validate(self.origin, name: "origin", parent: name, min: 2)
            try self.originOptions?.validate(name: "\(name).originOptions")
            try self.thresholds.validate(name: "\(name).thresholds")
            try self.traffic?.validate(name: "\(name).traffic")
            try self.travelModeOptions?.validate(name: "\(name).travelModeOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case arrivalTime = "ArrivalTime"
            case avoid = "Avoid"
            case departNow = "DepartNow"
            case departureTime = "DepartureTime"
            case destination = "Destination"
            case destinationOptions = "DestinationOptions"
            case isolineGeometryFormat = "IsolineGeometryFormat"
            case isolineGranularity = "IsolineGranularity"
            case optimizeIsolineFor = "OptimizeIsolineFor"
            case optimizeRoutingFor = "OptimizeRoutingFor"
            case origin = "Origin"
            case originOptions = "OriginOptions"
            case thresholds = "Thresholds"
            case traffic = "Traffic"
            case travelMode = "TravelMode"
            case travelModeOptions = "TravelModeOptions"
        }
    }

    public struct CalculateIsolinesResponse: AWSDecodableShape {
        /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request.  Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let arrivalTime: String?
        /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String?
        /// The format of the returned IsolineGeometry.  Default Value:FlexiblePolyline
        public let isolineGeometryFormat: GeometryFormat
        /// Calculated isolines and associated properties.
        public let isolines: [Isoline]
        /// The pricing bucket for which the query is charged at.
        public let pricingBucket: String
        /// Snapped destination that was used for the Isoline calculation.
        public let snappedDestination: [Double]?
        /// Snapped origin that was used for the Isoline calculation.
        public let snappedOrigin: [Double]?

        @inlinable
        public init(arrivalTime: String? = nil, departureTime: String? = nil, isolineGeometryFormat: GeometryFormat, isolines: [Isoline], pricingBucket: String, snappedDestination: [Double]? = nil, snappedOrigin: [Double]? = nil) {
            self.arrivalTime = arrivalTime
            self.departureTime = departureTime
            self.isolineGeometryFormat = isolineGeometryFormat
            self.isolines = isolines
            self.pricingBucket = pricingBucket
            self.snappedDestination = snappedDestination
            self.snappedOrigin = snappedOrigin
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arrivalTime = try container.decodeIfPresent(String.self, forKey: .arrivalTime)
            self.departureTime = try container.decodeIfPresent(String.self, forKey: .departureTime)
            self.isolineGeometryFormat = try container.decode(GeometryFormat.self, forKey: .isolineGeometryFormat)
            self.isolines = try container.decode([Isoline].self, forKey: .isolines)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.snappedDestination = try container.decodeIfPresent([Double].self, forKey: .snappedDestination)
            self.snappedOrigin = try container.decodeIfPresent([Double].self, forKey: .snappedOrigin)
        }

        private enum CodingKeys: String, CodingKey {
            case arrivalTime = "ArrivalTime"
            case departureTime = "DepartureTime"
            case isolineGeometryFormat = "IsolineGeometryFormat"
            case isolines = "Isolines"
            case snappedDestination = "SnappedDestination"
            case snappedOrigin = "SnappedOrigin"
        }
    }

    public struct CalculateRouteMatrixRequest: AWSEncodableShape {
        /// Features that are allowed while calculating a route.
        public let allow: RouteMatrixAllowOptions?
        /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
        public let avoid: RouteMatrixAvoidanceOptions?
        /// Uses the current time as the time of departure.
        public let departNow: Bool?
        /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String?
        /// List of destinations for the route.  Route calculations are billed for each origin and destination pair. If you use a large matrix of origins and destinations, your costs will increase accordingly. See  Amazon Location's pricing page for more information.
        public let destinations: [RouteMatrixDestination]
        /// Features to be strictly excluded while calculating the route.
        public let exclude: RouteMatrixExclusionOptions?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
        public let optimizeRoutingFor: RoutingObjective?
        /// The position in longitude and latitude for the origin.  Route calculations are billed for each origin and destination pair. Using a large amount of Origins in a request can lead you to incur unexpected charges. See  Amazon Location's pricing page for more information.
        public let origins: [RouteMatrixOrigin]
        /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.  When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
        public let routingBoundary: RouteMatrixBoundary
        /// Traffic related options.
        public let traffic: RouteMatrixTrafficOptions?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        public let travelMode: RouteMatrixTravelMode?
        /// Travel mode related options for the provided travel mode.
        public let travelModeOptions: RouteMatrixTravelModeOptions?

        @inlinable
        public init(allow: RouteMatrixAllowOptions? = nil, avoid: RouteMatrixAvoidanceOptions? = nil, departNow: Bool? = nil, departureTime: String? = nil, destinations: [RouteMatrixDestination], exclude: RouteMatrixExclusionOptions? = nil, key: String? = nil, optimizeRoutingFor: RoutingObjective? = nil, origins: [RouteMatrixOrigin], routingBoundary: RouteMatrixBoundary, traffic: RouteMatrixTrafficOptions? = nil, travelMode: RouteMatrixTravelMode? = nil, travelModeOptions: RouteMatrixTravelModeOptions? = nil) {
            self.allow = allow
            self.avoid = avoid
            self.departNow = departNow
            self.departureTime = departureTime
            self.destinations = destinations
            self.exclude = exclude
            self.key = key
            self.optimizeRoutingFor = optimizeRoutingFor
            self.origins = origins
            self.routingBoundary = routingBoundary
            self.traffic = traffic
            self.travelMode = travelMode
            self.travelModeOptions = travelModeOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allow, forKey: .allow)
            try container.encodeIfPresent(self.avoid, forKey: .avoid)
            try container.encodeIfPresent(self.departNow, forKey: .departNow)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encode(self.destinations, forKey: .destinations)
            try container.encodeIfPresent(self.exclude, forKey: .exclude)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.optimizeRoutingFor, forKey: .optimizeRoutingFor)
            try container.encode(self.origins, forKey: .origins)
            try container.encode(self.routingBoundary, forKey: .routingBoundary)
            try container.encodeIfPresent(self.traffic, forKey: .traffic)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.travelModeOptions, forKey: .travelModeOptions)
        }

        public func validate(name: String) throws {
            try self.avoid?.validate(name: "\(name).avoid")
            try self.validate(self.departureTime, name: "departureTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.exclude?.validate(name: "\(name).exclude")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.origins.forEach {
                try $0.validate(name: "\(name).origins[]")
            }
            try self.routingBoundary.validate(name: "\(name).routingBoundary")
            try self.traffic?.validate(name: "\(name).traffic")
            try self.travelModeOptions?.validate(name: "\(name).travelModeOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case avoid = "Avoid"
            case departNow = "DepartNow"
            case departureTime = "DepartureTime"
            case destinations = "Destinations"
            case exclude = "Exclude"
            case optimizeRoutingFor = "OptimizeRoutingFor"
            case origins = "Origins"
            case routingBoundary = "RoutingBoundary"
            case traffic = "Traffic"
            case travelMode = "TravelMode"
            case travelModeOptions = "TravelModeOptions"
        }
    }

    public struct CalculateRouteMatrixResponse: AWSDecodableShape {
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        public let errorCount: Int
        /// The pricing bucket for which the query is charged at.
        public let pricingBucket: String
        /// The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.
        public let routeMatrix: [[RouteMatrixEntry]]
        /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.  When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
        public let routingBoundary: RouteMatrixBoundary

        @inlinable
        public init(errorCount: Int, pricingBucket: String, routeMatrix: [[RouteMatrixEntry]], routingBoundary: RouteMatrixBoundary) {
            self.errorCount = errorCount
            self.pricingBucket = pricingBucket
            self.routeMatrix = routeMatrix
            self.routingBoundary = routingBoundary
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.errorCount = try container.decode(Int.self, forKey: .errorCount)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.routeMatrix = try container.decode([[RouteMatrixEntry]].self, forKey: .routeMatrix)
            self.routingBoundary = try container.decode(RouteMatrixBoundary.self, forKey: .routingBoundary)
        }

        private enum CodingKeys: String, CodingKey {
            case errorCount = "ErrorCount"
            case routeMatrix = "RouteMatrix"
            case routingBoundary = "RoutingBoundary"
        }
    }

    public struct CalculateRoutesRequest: AWSEncodableShape {
        /// Features that are allowed while calculating a route.
        public let allow: RouteAllowOptions?
        /// Time of arrival at the destination. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let arrivalTime: String?
        /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
        public let avoid: RouteAvoidanceOptions?
        /// Uses the current time as the time of departure.
        public let departNow: Bool?
        /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String?
        /// The final position for the route. In the World Geodetic System (WGS 84) format: [longitude, latitude].
        public let destination: [Double]
        /// Destination related options.
        public let destinationOptions: RouteDestinationOptions?
        /// Driver related options.
        public let driver: RouteDriverOptions?
        /// Features to be strictly excluded while calculating the route.
        public let exclude: RouteExclusionOptions?
        /// Measurement system to be used for instructions within steps in the response.
        public let instructionsMeasurementSystem: MeasurementSystem?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// List of languages for instructions within steps in the response.  Instructions in the requested language are returned only if they are available.
        public let languages: [String]?
        /// A list of optional additional parameters such as timezone that can be requested for each result.    Elevation: Retrieves the elevation information for each location.    Incidents: Provides information on traffic incidents along the route.    PassThroughWaypoints: Indicates waypoints that are passed through without stopping.    Summary: Returns a summary of the route, including distance and duration.    Tolls: Supplies toll cost information along the route.    TravelStepInstructions: Provides step-by-step instructions for travel along the route.    TruckRoadTypes: Returns information about road types suitable for trucks.    TypicalDuration: Gives typical travel duration based on historical data.    Zones: Specifies the time zone information for each waypoint.
        public let legAdditionalFeatures: [RouteLegAdditionalFeature]?
        /// Specifies the format of the geometry returned for each leg of the route. You can choose between two different geometry encoding formats.  FlexiblePolyline: A compact and precise encoding format for the leg geometry. For more information on the format, see the GitHub repository for  FlexiblePolyline .  Simple: A less compact encoding, which is easier to decode but may be less precise and result in larger payloads.
        public let legGeometryFormat: GeometryFormat?
        /// Maximum number of alternative routes to be provided in the response, if available.
        public let maxAlternatives: Int?
        /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
        public let optimizeRoutingFor: RoutingObjective?
        /// The start position for the route.
        public let origin: [Double]
        /// Origin related options.
        public let originOptions: RouteOriginOptions?
        /// A list of optional features such as SpeedLimit that can be requested for a Span. A span is a section of a Leg for which the requested features have the same values.
        public let spanAdditionalFeatures: [RouteSpanAdditionalFeature]?
        /// Toll related options.
        public let tolls: RouteTollOptions?
        /// Traffic related options.
        public let traffic: RouteTrafficOptions?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        public let travelMode: RouteTravelMode?
        /// Travel mode related options for the provided travel mode.
        public let travelModeOptions: RouteTravelModeOptions?
        /// Type of step returned by the response. Default provides basic steps intended for web based applications. TurnByTurn provides detailed instructions with more granularity intended for a turn based navigation system.
        public let travelStepType: RouteTravelStepType?
        /// List of waypoints between the Origin and Destination.
        public let waypoints: [RouteWaypoint]?

        @inlinable
        public init(allow: RouteAllowOptions? = nil, arrivalTime: String? = nil, avoid: RouteAvoidanceOptions? = nil, departNow: Bool? = nil, departureTime: String? = nil, destination: [Double], destinationOptions: RouteDestinationOptions? = nil, driver: RouteDriverOptions? = nil, exclude: RouteExclusionOptions? = nil, instructionsMeasurementSystem: MeasurementSystem? = nil, key: String? = nil, languages: [String]? = nil, legAdditionalFeatures: [RouteLegAdditionalFeature]? = nil, legGeometryFormat: GeometryFormat? = nil, maxAlternatives: Int? = nil, optimizeRoutingFor: RoutingObjective? = nil, origin: [Double], originOptions: RouteOriginOptions? = nil, spanAdditionalFeatures: [RouteSpanAdditionalFeature]? = nil, tolls: RouteTollOptions? = nil, traffic: RouteTrafficOptions? = nil, travelMode: RouteTravelMode? = nil, travelModeOptions: RouteTravelModeOptions? = nil, travelStepType: RouteTravelStepType? = nil, waypoints: [RouteWaypoint]? = nil) {
            self.allow = allow
            self.arrivalTime = arrivalTime
            self.avoid = avoid
            self.departNow = departNow
            self.departureTime = departureTime
            self.destination = destination
            self.destinationOptions = destinationOptions
            self.driver = driver
            self.exclude = exclude
            self.instructionsMeasurementSystem = instructionsMeasurementSystem
            self.key = key
            self.languages = languages
            self.legAdditionalFeatures = legAdditionalFeatures
            self.legGeometryFormat = legGeometryFormat
            self.maxAlternatives = maxAlternatives
            self.optimizeRoutingFor = optimizeRoutingFor
            self.origin = origin
            self.originOptions = originOptions
            self.spanAdditionalFeatures = spanAdditionalFeatures
            self.tolls = tolls
            self.traffic = traffic
            self.travelMode = travelMode
            self.travelModeOptions = travelModeOptions
            self.travelStepType = travelStepType
            self.waypoints = waypoints
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allow, forKey: .allow)
            try container.encodeIfPresent(self.arrivalTime, forKey: .arrivalTime)
            try container.encodeIfPresent(self.avoid, forKey: .avoid)
            try container.encodeIfPresent(self.departNow, forKey: .departNow)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encode(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationOptions, forKey: .destinationOptions)
            try container.encodeIfPresent(self.driver, forKey: .driver)
            try container.encodeIfPresent(self.exclude, forKey: .exclude)
            try container.encodeIfPresent(self.instructionsMeasurementSystem, forKey: .instructionsMeasurementSystem)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.languages, forKey: .languages)
            try container.encodeIfPresent(self.legAdditionalFeatures, forKey: .legAdditionalFeatures)
            try container.encodeIfPresent(self.legGeometryFormat, forKey: .legGeometryFormat)
            try container.encodeIfPresent(self.maxAlternatives, forKey: .maxAlternatives)
            try container.encodeIfPresent(self.optimizeRoutingFor, forKey: .optimizeRoutingFor)
            try container.encode(self.origin, forKey: .origin)
            try container.encodeIfPresent(self.originOptions, forKey: .originOptions)
            try container.encodeIfPresent(self.spanAdditionalFeatures, forKey: .spanAdditionalFeatures)
            try container.encodeIfPresent(self.tolls, forKey: .tolls)
            try container.encodeIfPresent(self.traffic, forKey: .traffic)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.travelModeOptions, forKey: .travelModeOptions)
            try container.encodeIfPresent(self.travelStepType, forKey: .travelStepType)
            try container.encodeIfPresent(self.waypoints, forKey: .waypoints)
        }

        public func validate(name: String) throws {
            try self.validate(self.arrivalTime, name: "arrivalTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.avoid?.validate(name: "\(name).avoid")
            try self.validate(self.departureTime, name: "departureTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.validate(self.destination, name: "destination", parent: name, max: 2)
            try self.validate(self.destination, name: "destination", parent: name, min: 2)
            try self.destinationOptions?.validate(name: "\(name).destinationOptions")
            try self.driver?.validate(name: "\(name).driver")
            try self.exclude?.validate(name: "\(name).exclude")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.languages?.forEach {
                try validate($0, name: "languages[]", parent: name, max: 35)
                try validate($0, name: "languages[]", parent: name, min: 2)
            }
            try self.validate(self.legAdditionalFeatures, name: "legAdditionalFeatures", parent: name, max: 9)
            try self.validate(self.origin, name: "origin", parent: name, max: 2)
            try self.validate(self.origin, name: "origin", parent: name, min: 2)
            try self.originOptions?.validate(name: "\(name).originOptions")
            try self.validate(self.spanAdditionalFeatures, name: "spanAdditionalFeatures", parent: name, max: 24)
            try self.tolls?.validate(name: "\(name).tolls")
            try self.traffic?.validate(name: "\(name).traffic")
            try self.travelModeOptions?.validate(name: "\(name).travelModeOptions")
            try self.waypoints?.forEach {
                try $0.validate(name: "\(name).waypoints[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case arrivalTime = "ArrivalTime"
            case avoid = "Avoid"
            case departNow = "DepartNow"
            case departureTime = "DepartureTime"
            case destination = "Destination"
            case destinationOptions = "DestinationOptions"
            case driver = "Driver"
            case exclude = "Exclude"
            case instructionsMeasurementSystem = "InstructionsMeasurementSystem"
            case languages = "Languages"
            case legAdditionalFeatures = "LegAdditionalFeatures"
            case legGeometryFormat = "LegGeometryFormat"
            case maxAlternatives = "MaxAlternatives"
            case optimizeRoutingFor = "OptimizeRoutingFor"
            case origin = "Origin"
            case originOptions = "OriginOptions"
            case spanAdditionalFeatures = "SpanAdditionalFeatures"
            case tolls = "Tolls"
            case traffic = "Traffic"
            case travelMode = "TravelMode"
            case travelModeOptions = "TravelModeOptions"
            case travelStepType = "TravelStepType"
            case waypoints = "Waypoints"
        }
    }

    public struct CalculateRoutesResponse: AWSDecodableShape {
        /// Specifies the format of the geometry returned for each leg of the route.
        public let legGeometryFormat: GeometryFormat
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [RouteResponseNotice]
        /// The pricing bucket for which the query is charged at.
        public let pricingBucket: String
        /// The path from the origin to the destination.
        public let routes: [Route]

        @inlinable
        public init(legGeometryFormat: GeometryFormat, notices: [RouteResponseNotice], pricingBucket: String, routes: [Route]) {
            self.legGeometryFormat = legGeometryFormat
            self.notices = notices
            self.pricingBucket = pricingBucket
            self.routes = routes
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.legGeometryFormat = try container.decode(GeometryFormat.self, forKey: .legGeometryFormat)
            self.notices = try container.decode([RouteResponseNotice].self, forKey: .notices)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.routes = try container.decode([Route].self, forKey: .routes)
        }

        private enum CodingKeys: String, CodingKey {
            case legGeometryFormat = "LegGeometryFormat"
            case notices = "Notices"
            case routes = "Routes"
        }
    }

    public struct Circle: AWSEncodableShape & AWSDecodableShape {
        /// Center of the Circle defined in longitude and latitude coordinates. Example: [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public let center: [Double]
        /// Radius of the Circle.  Unit: meters
        public let radius: Double

        @inlinable
        public init(center: [Double], radius: Double) {
            self.center = center
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.validate(self.center, name: "center", parent: name, max: 2)
            try self.validate(self.center, name: "center", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case center = "Center"
            case radius = "Radius"
        }
    }

    public struct Corridor: AWSEncodableShape {
        /// An ordered list of positions used to plot a route on a map.  LineString and Polyline are mutually exclusive properties.
        public let lineString: [[Double]]
        /// Radius that defines the width of the corridor.
        public let radius: Int

        @inlinable
        public init(lineString: [[Double]], radius: Int) {
            self.lineString = lineString
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.lineString.forEach {
                try validate($0, name: "lineString[]", parent: name, max: 2)
                try validate($0, name: "lineString[]", parent: name, min: 2)
            }
            try self.validate(self.lineString, name: "lineString", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
            case radius = "Radius"
        }
    }

    public struct Isoline: AWSDecodableShape {
        /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
        public let connections: [IsolineConnection]
        /// Distance threshold corresponding to the calculated Isoline.
        public let distanceThreshold: Int64?
        /// Geometries for the Calculated isolines.
        public let geometries: [IsolineShapeGeometry]
        /// Time threshold corresponding to the calculated isoline.
        public let timeThreshold: Int64?

        @inlinable
        public init(connections: [IsolineConnection], distanceThreshold: Int64? = nil, geometries: [IsolineShapeGeometry], timeThreshold: Int64? = nil) {
            self.connections = connections
            self.distanceThreshold = distanceThreshold
            self.geometries = geometries
            self.timeThreshold = timeThreshold
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case distanceThreshold = "DistanceThreshold"
            case geometries = "Geometries"
            case timeThreshold = "TimeThreshold"
        }
    }

    public struct IsolineAllowOptions: AWSEncodableShape {
        /// Allow Hot (High Occupancy Toll) lanes while calculating an isoline. Default value: false
        public let hot: Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating an isoline. Default value: false
        public let hov: Bool?

        @inlinable
        public init(hot: Bool? = nil, hov: Bool? = nil) {
            self.hot = hot
            self.hov = hov
        }

        private enum CodingKeys: String, CodingKey {
            case hot = "Hot"
            case hov = "Hov"
        }
    }

    public struct IsolineAvoidanceArea: AWSEncodableShape {
        /// Exceptions to the provided avoidance geometry, to be included while calculating an isoline.
        public let except: [IsolineAvoidanceAreaGeometry]?
        /// Geometry of the area to be avoided.
        public let geometry: IsolineAvoidanceAreaGeometry

        @inlinable
        public init(except: [IsolineAvoidanceAreaGeometry]? = nil, geometry: IsolineAvoidanceAreaGeometry) {
            self.except = except
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.except?.forEach {
                try $0.validate(name: "\(name).except[]")
            }
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case except = "Except"
            case geometry = "Geometry"
        }
    }

    public struct IsolineAvoidanceAreaGeometry: AWSEncodableShape {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public let boundingBox: [Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public let corridor: Corridor?
        /// A list of Polygon will be excluded for calculating isolines, the list can only contain 1 polygon.
        public let polygon: [[[Double]]]?
        /// Geometry defined as an encoded corridor – a polyline with a radius that defines the width of the corridor. For more information on polyline encoding, see https://github.com/heremaps/flexiblepolyline/blob/master/README.md.
        public let polylineCorridor: PolylineCorridor?
        /// A list of PolylinePolygon's that are excluded for calculating isolines, the list can only contain 1 polygon. For more information on polyline encoding, see https://github.com/heremaps/flexiblepolyline/blob/master/README.md.
        public let polylinePolygon: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, corridor: Corridor? = nil, polygon: [[[Double]]]? = nil, polylineCorridor: PolylineCorridor? = nil, polylinePolygon: [String]? = nil) {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.corridor?.validate(name: "\(name).corridor")
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
            try self.polylineCorridor?.validate(name: "\(name).polylineCorridor")
            try self.polylinePolygon?.forEach {
                try validate($0, name: "polylinePolygon[]", parent: name, min: 1)
            }
            try self.validate(self.polylinePolygon, name: "polylinePolygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case corridor = "Corridor"
            case polygon = "Polygon"
            case polylineCorridor = "PolylineCorridor"
            case polylinePolygon = "PolylinePolygon"
        }
    }

    public struct IsolineAvoidanceOptions: AWSEncodableShape {
        /// Areas to be avoided.
        public let areas: [IsolineAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating an isoline.
        public let carShuttleTrains: Bool?
        /// Avoid controlled access highways while calculating an isoline.
        public let controlledAccessHighways: Bool?
        /// Avoid dirt roads while calculating an isoline.
        public let dirtRoads: Bool?
        /// Avoid ferries while calculating an isoline.
        public let ferries: Bool?
        /// Avoid roads that have seasonal closure while calculating an isoline.
        public let seasonalClosure: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollRoads: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollTransponders: Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadTypes: [String]?
        /// Avoid tunnels while calculating an isoline.
        public let tunnels: Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public let uTurns: Bool?
        /// Zone categories to be avoided.
        public let zoneCategories: [IsolineAvoidanceZoneCategory]?

        @inlinable
        public init(areas: [IsolineAvoidanceArea]? = nil, carShuttleTrains: Bool? = nil, controlledAccessHighways: Bool? = nil, dirtRoads: Bool? = nil, ferries: Bool? = nil, seasonalClosure: Bool? = nil, tollRoads: Bool? = nil, tollTransponders: Bool? = nil, truckRoadTypes: [String]? = nil, tunnels: Bool? = nil, uTurns: Bool? = nil, zoneCategories: [IsolineAvoidanceZoneCategory]? = nil) {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }

        public func validate(name: String) throws {
            try self.areas?.forEach {
                try $0.validate(name: "\(name).areas[]")
            }
            try self.truckRoadTypes?.forEach {
                try validate($0, name: "truckRoadTypes[]", parent: name, max: 3)
                try validate($0, name: "truckRoadTypes[]", parent: name, min: 1)
            }
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, max: 12)
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, min: 1)
            try self.validate(self.zoneCategories, name: "zoneCategories", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case areas = "Areas"
            case carShuttleTrains = "CarShuttleTrains"
            case controlledAccessHighways = "ControlledAccessHighways"
            case dirtRoads = "DirtRoads"
            case ferries = "Ferries"
            case seasonalClosure = "SeasonalClosure"
            case tollRoads = "TollRoads"
            case tollTransponders = "TollTransponders"
            case truckRoadTypes = "TruckRoadTypes"
            case tunnels = "Tunnels"
            case uTurns = "UTurns"
            case zoneCategories = "ZoneCategories"
        }
    }

    public struct IsolineAvoidanceZoneCategory: AWSEncodableShape {
        /// Zone category to be avoided.
        public let category: IsolineZoneCategory?

        @inlinable
        public init(category: IsolineZoneCategory? = nil) {
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
        }
    }

    public struct IsolineCarOptions: AWSEncodableShape {
        /// Engine type of the vehicle.
        public let engineType: IsolineEngineType?
        /// The vehicle License Plate.
        public let licensePlate: IsolineVehicleLicensePlate?
        /// Maximum speed.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(engineType: IsolineEngineType? = nil, licensePlate: IsolineVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "EngineType"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct IsolineConnection: AWSDecodableShape {
        /// Index of the polygon corresponding to the "from" component of the connection. The polygon is available from Isoline[].Geometries.
        public let fromPolygonIndex: Int
        /// The isoline geometry.
        public let geometry: IsolineConnectionGeometry
        /// Index of the polygon corresponding to the "to" component of the connection. The polygon is available from Isoline[].Geometries.
        public let toPolygonIndex: Int

        @inlinable
        public init(fromPolygonIndex: Int, geometry: IsolineConnectionGeometry, toPolygonIndex: Int) {
            self.fromPolygonIndex = fromPolygonIndex
            self.geometry = geometry
            self.toPolygonIndex = toPolygonIndex
        }

        private enum CodingKeys: String, CodingKey {
            case fromPolygonIndex = "FromPolygonIndex"
            case geometry = "Geometry"
            case toPolygonIndex = "ToPolygonIndex"
        }
    }

    public struct IsolineConnectionGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  LineString and Polyline are mutually exclusive properties.
        public let lineString: [[Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format.  LineString and Polyline are mutually exclusive properties.
        public let polyline: String?

        @inlinable
        public init(lineString: [[Double]]? = nil, polyline: String? = nil) {
            self.lineString = lineString
            self.polyline = polyline
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
            case polyline = "Polyline"
        }
    }

    public struct IsolineDestinationOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: IsolineSideOfStreetOptions?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, heading: Double? = nil, matching: IsolineMatchingOptions? = nil, sideOfStreet: IsolineSideOfStreetOptions? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct IsolineGranularityOptions: AWSEncodableShape {
        /// Maximum number of points of returned Isoline.
        public let maxPoints: Int?
        /// Maximum resolution of the returned isoline.  Unit: meters
        public let maxResolution: Int64?

        @inlinable
        public init(maxPoints: Int? = nil, maxResolution: Int64? = nil) {
            self.maxPoints = maxPoints
            self.maxResolution = maxResolution
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResolution, name: "maxResolution", parent: name, max: 4294967295)
            try self.validate(self.maxResolution, name: "maxResolution", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxPoints = "MaxPoints"
            case maxResolution = "MaxResolution"
        }
    }

    public struct IsolineMatchingOptions: AWSEncodableShape {
        /// Attempts to match the provided position to a road similar to the provided name.
        public let nameHint: String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.  Unit: meters
        public let onRoadThreshold: Int64?
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy.  Unit: Meters
        public let radius: Int64?
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public let strategy: MatchingStrategy?

        @inlinable
        public init(nameHint: String? = nil, onRoadThreshold: Int64? = nil, radius: Int64? = nil, strategy: MatchingStrategy? = nil) {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }

        public func validate(name: String) throws {
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, max: 4294967295)
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, min: 0)
            try self.validate(self.radius, name: "radius", parent: name, max: 4294967295)
            try self.validate(self.radius, name: "radius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case nameHint = "NameHint"
            case onRoadThreshold = "OnRoadThreshold"
            case radius = "Radius"
            case strategy = "Strategy"
        }
    }

    public struct IsolineOriginOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: IsolineSideOfStreetOptions?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, heading: Double? = nil, matching: IsolineMatchingOptions? = nil, sideOfStreet: IsolineSideOfStreetOptions? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct IsolineScooterOptions: AWSEncodableShape {
        /// Engine type of the vehicle.
        public let engineType: IsolineEngineType?
        /// The vehicle License Plate.
        public let licensePlate: IsolineVehicleLicensePlate?
        /// Maximum speed specified.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(engineType: IsolineEngineType? = nil, licensePlate: IsolineVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "EngineType"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct IsolineShapeGeometry: AWSDecodableShape {
        /// A list of Isoline Polygons, for each isoline polygon, it contains polygons of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings).
        public let polygon: [[[Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see https://github.com/heremaps/flexiblepolyline/blob/master/README.md.
        public let polylinePolygon: [String]?

        @inlinable
        public init(polygon: [[[Double]]]? = nil, polylinePolygon: [String]? = nil) {
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }

        private enum CodingKeys: String, CodingKey {
            case polygon = "Polygon"
            case polylinePolygon = "PolylinePolygon"
        }
    }

    public struct IsolineSideOfStreetOptions: AWSEncodableShape {
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public let useWith: SideOfStreetMatchingStrategy?

        @inlinable
        public init(position: [Double], useWith: SideOfStreetMatchingStrategy? = nil) {
            self.position = position
            self.useWith = useWith
        }

        public func validate(name: String) throws {
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
            case useWith = "UseWith"
        }
    }

    public struct IsolineThresholds: AWSEncodableShape {
        /// Distance to be used for the isoline calculation.
        public let distance: [Int64]?
        /// Time to be used for the isoline calculation.
        public let time: [Int64]?

        @inlinable
        public init(distance: [Int64]? = nil, time: [Int64]? = nil) {
            self.distance = distance
            self.time = time
        }

        public func validate(name: String) throws {
            try self.distance?.forEach {
                try validate($0, name: "distance[]", parent: name, max: 4294967295)
                try validate($0, name: "distance[]", parent: name, min: 0)
            }
            try self.validate(self.distance, name: "distance", parent: name, max: 5)
            try self.validate(self.distance, name: "distance", parent: name, min: 1)
            try self.time?.forEach {
                try validate($0, name: "time[]", parent: name, max: 4294967295)
                try validate($0, name: "time[]", parent: name, min: 0)
            }
            try self.validate(self.time, name: "time", parent: name, max: 5)
            try self.validate(self.time, name: "time", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case time = "Time"
        }
    }

    public struct IsolineTrafficOptions: AWSEncodableShape {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.   Unit: seconds
        public let flowEventThresholdOverride: Int64?
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public let usage: TrafficUsage?

        @inlinable
        public init(flowEventThresholdOverride: Int64? = nil, usage: TrafficUsage? = nil) {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }

        public func validate(name: String) throws {
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, max: 4294967295)
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case flowEventThresholdOverride = "FlowEventThresholdOverride"
            case usage = "Usage"
        }
    }

    public struct IsolineTrailerOptions: AWSEncodableShape {
        /// Total number of axles of the vehicle.
        public let axleCount: Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: Int?

        @inlinable
        public init(axleCount: Int? = nil, trailerCount: Int? = nil) {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }

        private enum CodingKeys: String, CodingKey {
            case axleCount = "AxleCount"
            case trailerCount = "TrailerCount"
        }
    }

    public struct IsolineTravelModeOptions: AWSEncodableShape {
        /// Travel mode options when the provided travel mode is "Car"
        public let car: IsolineCarOptions?
        /// Travel mode options when the provided travel mode is Scooter   When travel mode is set to Scooter, then the avoidance option ControlledAccessHighways defaults to true.
        public let scooter: IsolineScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public let truck: IsolineTruckOptions?

        @inlinable
        public init(car: IsolineCarOptions? = nil, scooter: IsolineScooterOptions? = nil, truck: IsolineTruckOptions? = nil) {
            self.car = car
            self.scooter = scooter
            self.truck = truck
        }

        public func validate(name: String) throws {
            try self.car?.validate(name: "\(name).car")
            try self.scooter?.validate(name: "\(name).scooter")
            try self.truck?.validate(name: "\(name).truck")
        }

        private enum CodingKeys: String, CodingKey {
            case car = "Car"
            case scooter = "Scooter"
            case truck = "Truck"
        }
    }

    public struct IsolineTruckOptions: AWSEncodableShape {
        /// Total number of axles of the vehicle.
        public let axleCount: Int?
        /// Engine type of the vehicle.
        public let engineType: IsolineEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity.  Unit: Kilograms
        public let grossWeight: Int64?
        /// List of Hazardous cargo contained in the vehicle.
        public let hazardousCargos: [IsolineHazardousCargoType]?
        /// Height of the vehicle.  Unit: centimeters
        public let height: Int64?
        /// Height of the vehicle above its first axle.  Unit: centimeters
        public let heightAboveFirstAxle: Int64?
        /// Kingpin to rear axle length of the vehicle.  Unit: centimeters
        public let kpraLength: Int64?
        /// Length of the vehicle.  Unit: centimeters
        public let length: Int64?
        /// The vehicle License Plate.
        public let licensePlate: IsolineVehicleLicensePlate?
        /// Maximum speed specified.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?
        /// Payload capacity of the vehicle and trailers attached.  Unit: kilograms
        public let payloadCapacity: Int64?
        /// Number of tires on the vehicle.
        public let tireCount: Int?
        /// Trailer options corresponding to the vehicle.
        public let trailer: IsolineTrailerOptions?
        /// Type of the truck.
        public let truckType: IsolineTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished.  Unit: Kilograms
        public let weightPerAxle: Int64?
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.  Unit: Kilograms
        public let weightPerAxleGroup: WeightPerAxleGroup?
        /// Width of the vehicle.  Unit: centimeters
        public let width: Int64?

        @inlinable
        public init(axleCount: Int? = nil, engineType: IsolineEngineType? = nil, grossWeight: Int64? = nil, hazardousCargos: [IsolineHazardousCargoType]? = nil, height: Int64? = nil, heightAboveFirstAxle: Int64? = nil, kpraLength: Int64? = nil, length: Int64? = nil, licensePlate: IsolineVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil, payloadCapacity: Int64? = nil, tireCount: Int? = nil, trailer: IsolineTrailerOptions? = nil, truckType: IsolineTruckType? = nil, tunnelRestrictionCode: String? = nil, weightPerAxle: Int64? = nil, weightPerAxleGroup: WeightPerAxleGroup? = nil, width: Int64? = nil) {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, max: 4294967295)
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, min: 0)
            try self.validate(self.hazardousCargos, name: "hazardousCargos", parent: name, max: 11)
            try self.validate(self.height, name: "height", parent: name, max: 4294967295)
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.heightAboveFirstAxle, name: "heightAboveFirstAxle", parent: name, max: 4294967295)
            try self.validate(self.heightAboveFirstAxle, name: "heightAboveFirstAxle", parent: name, min: 0)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, max: 4294967295)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, max: 4294967295)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, max: 4294967295)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, min: 0)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, max: 1)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, min: 1)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, max: 4294967295)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, min: 0)
            try self.weightPerAxleGroup?.validate(name: "\(name).weightPerAxleGroup")
            try self.validate(self.width, name: "width", parent: name, max: 4294967295)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case axleCount = "AxleCount"
            case engineType = "EngineType"
            case grossWeight = "GrossWeight"
            case hazardousCargos = "HazardousCargos"
            case height = "Height"
            case heightAboveFirstAxle = "HeightAboveFirstAxle"
            case kpraLength = "KpraLength"
            case length = "Length"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
            case payloadCapacity = "PayloadCapacity"
            case tireCount = "TireCount"
            case trailer = "Trailer"
            case truckType = "TruckType"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
            case weightPerAxle = "WeightPerAxle"
            case weightPerAxleGroup = "WeightPerAxleGroup"
            case width = "Width"
        }
    }

    public struct IsolineVehicleLicensePlate: AWSEncodableShape {
        /// The last character of the License Plate.
        public let lastCharacter: String?

        @inlinable
        public init(lastCharacter: String? = nil) {
            self.lastCharacter = lastCharacter
        }

        private enum CodingKeys: String, CodingKey {
            case lastCharacter = "LastCharacter"
        }
    }

    public struct LocalizedString: AWSDecodableShape {
        /// A list of BCP 47 compliant language codes for the results to be rendered in. The request uses the regional default as the fallback if the requested language can't be provided.
        public let language: String?
        /// The value of the localized string.
        public let value: String

        @inlinable
        public init(language: String? = nil, value: String) {
            self.language = language
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case language = "Language"
            case value = "Value"
        }
    }

    public struct OptimizeWaypointsRequest: AWSEncodableShape {
        /// Features that are avoided. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, this setting is ignored.
        public let avoid: WaypointOptimizationAvoidanceOptions?
        /// Clustering allows you to specify how nearby waypoints can be clustered to improve the optimized sequence.
        public let clustering: WaypointOptimizationClusteringOptions?
        /// Departure time from the waypoint. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String?
        /// The final position for the route in the World Geodetic System (WGS 84) format: [longitude, latitude].
        public let destination: [Double]?
        /// Destination related options.
        public let destinationOptions: WaypointOptimizationDestinationOptions?
        /// Driver related options.
        public let driver: WaypointOptimizationDriverOptions?
        /// Features to be strictly excluded while calculating the route.
        public let exclude: WaypointOptimizationExclusionOptions?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Specifies the optimization criteria for the calculated sequence. Default Value: FastestRoute.
        public let optimizeSequencingFor: WaypointOptimizationSequencingObjective?
        /// The start position for the route.
        public let origin: [Double]
        /// Origin related options.
        public let originOptions: WaypointOptimizationOriginOptions?
        /// Traffic-related options.
        public let traffic: WaypointOptimizationTrafficOptions?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        public let travelMode: WaypointOptimizationTravelMode?
        /// Travel mode related options for the provided travel mode.
        public let travelModeOptions: WaypointOptimizationTravelModeOptions?
        /// List of waypoints between the Origin and Destination.
        public let waypoints: [WaypointOptimizationWaypoint]?

        @inlinable
        public init(avoid: WaypointOptimizationAvoidanceOptions? = nil, clustering: WaypointOptimizationClusteringOptions? = nil, departureTime: String? = nil, destination: [Double]? = nil, destinationOptions: WaypointOptimizationDestinationOptions? = nil, driver: WaypointOptimizationDriverOptions? = nil, exclude: WaypointOptimizationExclusionOptions? = nil, key: String? = nil, optimizeSequencingFor: WaypointOptimizationSequencingObjective? = nil, origin: [Double], originOptions: WaypointOptimizationOriginOptions? = nil, traffic: WaypointOptimizationTrafficOptions? = nil, travelMode: WaypointOptimizationTravelMode? = nil, travelModeOptions: WaypointOptimizationTravelModeOptions? = nil, waypoints: [WaypointOptimizationWaypoint]? = nil) {
            self.avoid = avoid
            self.clustering = clustering
            self.departureTime = departureTime
            self.destination = destination
            self.destinationOptions = destinationOptions
            self.driver = driver
            self.exclude = exclude
            self.key = key
            self.optimizeSequencingFor = optimizeSequencingFor
            self.origin = origin
            self.originOptions = originOptions
            self.traffic = traffic
            self.travelMode = travelMode
            self.travelModeOptions = travelModeOptions
            self.waypoints = waypoints
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.avoid, forKey: .avoid)
            try container.encodeIfPresent(self.clustering, forKey: .clustering)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encodeIfPresent(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationOptions, forKey: .destinationOptions)
            try container.encodeIfPresent(self.driver, forKey: .driver)
            try container.encodeIfPresent(self.exclude, forKey: .exclude)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.optimizeSequencingFor, forKey: .optimizeSequencingFor)
            try container.encode(self.origin, forKey: .origin)
            try container.encodeIfPresent(self.originOptions, forKey: .originOptions)
            try container.encodeIfPresent(self.traffic, forKey: .traffic)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.travelModeOptions, forKey: .travelModeOptions)
            try container.encodeIfPresent(self.waypoints, forKey: .waypoints)
        }

        public func validate(name: String) throws {
            try self.avoid?.validate(name: "\(name).avoid")
            try self.clustering?.validate(name: "\(name).clustering")
            try self.validate(self.departureTime, name: "departureTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.validate(self.destination, name: "destination", parent: name, max: 2)
            try self.validate(self.destination, name: "destination", parent: name, min: 2)
            try self.destinationOptions?.validate(name: "\(name).destinationOptions")
            try self.driver?.validate(name: "\(name).driver")
            try self.exclude?.validate(name: "\(name).exclude")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.origin, name: "origin", parent: name, max: 2)
            try self.validate(self.origin, name: "origin", parent: name, min: 2)
            try self.originOptions?.validate(name: "\(name).originOptions")
            try self.travelModeOptions?.validate(name: "\(name).travelModeOptions")
            try self.waypoints?.forEach {
                try $0.validate(name: "\(name).waypoints[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case avoid = "Avoid"
            case clustering = "Clustering"
            case departureTime = "DepartureTime"
            case destination = "Destination"
            case destinationOptions = "DestinationOptions"
            case driver = "Driver"
            case exclude = "Exclude"
            case optimizeSequencingFor = "OptimizeSequencingFor"
            case origin = "Origin"
            case originOptions = "OriginOptions"
            case traffic = "Traffic"
            case travelMode = "TravelMode"
            case travelModeOptions = "TravelModeOptions"
            case waypoints = "Waypoints"
        }
    }

    public struct OptimizeWaypointsResponse: AWSDecodableShape {
        /// Details about the connection from one waypoint to the next, within the optimized sequence.
        public let connections: [WaypointOptimizationConnection]
        /// Overall distance to travel the whole sequence.
        public let distance: Int64
        /// Overall duration to travel the whole sequence.  Unit: seconds
        public let duration: Int64
        /// Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.
        public let impedingWaypoints: [WaypointOptimizationImpedingWaypoint]
        /// Waypoints in the order of the optimized sequence.
        public let optimizedWaypoints: [WaypointOptimizationOptimizedWaypoint]
        /// The pricing bucket for which the query is charged at.
        public let pricingBucket: String
        /// Time breakdown for the sequence.
        public let timeBreakdown: WaypointOptimizationTimeBreakdown

        @inlinable
        public init(connections: [WaypointOptimizationConnection], distance: Int64, duration: Int64, impedingWaypoints: [WaypointOptimizationImpedingWaypoint], optimizedWaypoints: [WaypointOptimizationOptimizedWaypoint], pricingBucket: String, timeBreakdown: WaypointOptimizationTimeBreakdown) {
            self.connections = connections
            self.distance = distance
            self.duration = duration
            self.impedingWaypoints = impedingWaypoints
            self.optimizedWaypoints = optimizedWaypoints
            self.pricingBucket = pricingBucket
            self.timeBreakdown = timeBreakdown
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.connections = try container.decode([WaypointOptimizationConnection].self, forKey: .connections)
            self.distance = try container.decode(Int64.self, forKey: .distance)
            self.duration = try container.decode(Int64.self, forKey: .duration)
            self.impedingWaypoints = try container.decode([WaypointOptimizationImpedingWaypoint].self, forKey: .impedingWaypoints)
            self.optimizedWaypoints = try container.decode([WaypointOptimizationOptimizedWaypoint].self, forKey: .optimizedWaypoints)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.timeBreakdown = try container.decode(WaypointOptimizationTimeBreakdown.self, forKey: .timeBreakdown)
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case distance = "Distance"
            case duration = "Duration"
            case impedingWaypoints = "ImpedingWaypoints"
            case optimizedWaypoints = "OptimizedWaypoints"
            case timeBreakdown = "TimeBreakdown"
        }
    }

    public struct PolylineCorridor: AWSEncodableShape {
        /// An ordered list of positions used to plot a route on a map in a lossy compression format.  LineString and Polyline are mutually exclusive properties.
        public let polyline: String
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy.  Unit: Meters
        public let radius: Int

        @inlinable
        public init(polyline: String, radius: Int) {
            self.polyline = polyline
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.validate(self.polyline, name: "polyline", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case polyline = "Polyline"
            case radius = "Radius"
        }
    }

    public struct RoadSnapNotice: AWSDecodableShape {
        /// Code corresponding to the issue.
        public let code: RoadSnapNoticeCode
        /// The notice title.
        public let title: String
        /// TracePoint indices for which the provided notice code corresponds to.
        public let tracePointIndexes: [Int]

        @inlinable
        public init(code: RoadSnapNoticeCode, title: String, tracePointIndexes: [Int]) {
            self.code = code
            self.title = title
            self.tracePointIndexes = tracePointIndexes
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case title = "Title"
            case tracePointIndexes = "TracePointIndexes"
        }
    }

    public struct RoadSnapSnappedGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  LineString and Polyline are mutually exclusive properties.
        public let lineString: [[Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format.  LineString and Polyline are mutually exclusive properties.
        public let polyline: String?

        @inlinable
        public init(lineString: [[Double]]? = nil, polyline: String? = nil) {
            self.lineString = lineString
            self.polyline = polyline
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
            case polyline = "Polyline"
        }
    }

    public struct RoadSnapSnappedTracePoint: AWSDecodableShape {
        /// Confidence value for the correctness of this point match.
        public let confidence: Double
        /// Position of the TracePoint provided within the request, at the same index.
        public let originalPosition: [Double]
        /// Snapped position of the TracePoint provided within the request, at the same index.
        public let snappedPosition: [Double]

        @inlinable
        public init(confidence: Double, originalPosition: [Double], snappedPosition: [Double]) {
            self.confidence = confidence
            self.originalPosition = originalPosition
            self.snappedPosition = snappedPosition
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case originalPosition = "OriginalPosition"
            case snappedPosition = "SnappedPosition"
        }
    }

    public struct RoadSnapTracePoint: AWSEncodableShape {
        /// GPS Heading at the position.
        public let heading: Double?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Speed at the specified trace point .  Unit: KilometersPerHour
        public let speed: Double?
        /// Timestamp of the event.
        public let timestamp: String?

        @inlinable
        public init(heading: Double? = nil, position: [Double], speed: Double? = nil, timestamp: String? = nil) {
            self.heading = heading
            self.position = position
            self.speed = speed
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
            try self.validate(self.speed, name: "speed", parent: name, min: 0.0)
            try self.validate(self.timestamp, name: "timestamp", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case heading = "Heading"
            case position = "Position"
            case speed = "Speed"
            case timestamp = "Timestamp"
        }
    }

    public struct RoadSnapTrailerOptions: AWSEncodableShape {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: Int?

        @inlinable
        public init(trailerCount: Int? = nil) {
            self.trailerCount = trailerCount
        }

        private enum CodingKeys: String, CodingKey {
            case trailerCount = "TrailerCount"
        }
    }

    public struct RoadSnapTravelModeOptions: AWSEncodableShape {
        /// Travel mode options when the provided travel mode is "Truck".
        public let truck: RoadSnapTruckOptions?

        @inlinable
        public init(truck: RoadSnapTruckOptions? = nil) {
            self.truck = truck
        }

        public func validate(name: String) throws {
            try self.truck?.validate(name: "\(name).truck")
        }

        private enum CodingKeys: String, CodingKey {
            case truck = "Truck"
        }
    }

    public struct RoadSnapTruckOptions: AWSEncodableShape {
        /// Gross weight of the vehicle including trailers, and goods at capacity.  Unit: Kilograms
        public let grossWeight: Int64?
        /// List of Hazardous cargos contained in the vehicle.
        public let hazardousCargos: [RoadSnapHazardousCargoType]?
        /// Height of the vehicle.  Unit: centimeters
        public let height: Int64?
        /// Length of the vehicle.  Unit: centimeters
        public let length: Int64?
        /// Trailer options corresponding to the vehicle.
        public let trailer: RoadSnapTrailerOptions?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?
        /// Width of the vehicle in centimenters.
        public let width: Int64?

        @inlinable
        public init(grossWeight: Int64? = nil, hazardousCargos: [RoadSnapHazardousCargoType]? = nil, height: Int64? = nil, length: Int64? = nil, trailer: RoadSnapTrailerOptions? = nil, tunnelRestrictionCode: String? = nil, width: Int64? = nil) {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, max: 4294967295)
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, min: 0)
            try self.validate(self.hazardousCargos, name: "hazardousCargos", parent: name, max: 11)
            try self.validate(self.height, name: "height", parent: name, max: 4294967295)
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, max: 4294967295)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, max: 1)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, min: 1)
            try self.validate(self.width, name: "width", parent: name, max: 4294967295)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case grossWeight = "GrossWeight"
            case hazardousCargos = "HazardousCargos"
            case height = "Height"
            case length = "Length"
            case trailer = "Trailer"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
            case width = "Width"
        }
    }

    public struct Route: AWSDecodableShape {
        /// A leg is a section of a route from one waypoint to the next. A leg could be of type Vehicle, Pedestrian or Ferry. Legs of different types could occur together within a single route. For example, a car employing the use of a Ferry will contain Vehicle legs corresponding to journey on land, and Ferry legs corresponding to the journey via Ferry.
        public let legs: [RouteLeg]
        /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
        public let majorRoadLabels: [RouteMajorRoadLabel]
        /// Summarized details of the leg.
        public let summary: RouteSummary?

        @inlinable
        public init(legs: [RouteLeg], majorRoadLabels: [RouteMajorRoadLabel], summary: RouteSummary? = nil) {
            self.legs = legs
            self.majorRoadLabels = majorRoadLabels
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case legs = "Legs"
            case majorRoadLabels = "MajorRoadLabels"
            case summary = "Summary"
        }
    }

    public struct RouteAllowOptions: AWSEncodableShape {
        /// Allow Hot (High Occupancy Toll) lanes while calculating the route. Default value: false
        public let hot: Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating the route. Default value: false
        public let hov: Bool?

        @inlinable
        public init(hot: Bool? = nil, hov: Bool? = nil) {
            self.hot = hot
            self.hov = hov
        }

        private enum CodingKeys: String, CodingKey {
            case hot = "Hot"
            case hov = "Hov"
        }
    }

    public struct RouteAvoidanceArea: AWSEncodableShape {
        /// Exceptions to the provided avoidance geometry, to be included while calculating the route.
        public let except: [RouteAvoidanceAreaGeometry]?
        public let geometry: RouteAvoidanceAreaGeometry

        @inlinable
        public init(except: [RouteAvoidanceAreaGeometry]? = nil, geometry: RouteAvoidanceAreaGeometry) {
            self.except = except
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.except?.forEach {
                try $0.validate(name: "\(name).except[]")
            }
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case except = "Except"
            case geometry = "Geometry"
        }
    }

    public struct RouteAvoidanceAreaGeometry: AWSEncodableShape {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public let boundingBox: [Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public let corridor: Corridor?
        /// Geometry defined as a polygon with only one linear ring.
        public let polygon: [[[Double]]]?
        /// Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.
        public let polylineCorridor: PolylineCorridor?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see https://github.com/heremaps/flexiblepolyline/blob/master/README.md.
        public let polylinePolygon: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, corridor: Corridor? = nil, polygon: [[[Double]]]? = nil, polylineCorridor: PolylineCorridor? = nil, polylinePolygon: [String]? = nil) {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.corridor?.validate(name: "\(name).corridor")
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
            try self.polylineCorridor?.validate(name: "\(name).polylineCorridor")
            try self.polylinePolygon?.forEach {
                try validate($0, name: "polylinePolygon[]", parent: name, min: 1)
            }
            try self.validate(self.polylinePolygon, name: "polylinePolygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case corridor = "Corridor"
            case polygon = "Polygon"
            case polylineCorridor = "PolylineCorridor"
            case polylinePolygon = "PolylinePolygon"
        }
    }

    public struct RouteAvoidanceOptions: AWSEncodableShape {
        /// Areas to be avoided.
        public let areas: [RouteAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating the route.
        public let carShuttleTrains: Bool?
        /// Avoid controlled access highways while calculating the route.
        public let controlledAccessHighways: Bool?
        /// Avoid dirt roads while calculating the route.
        public let dirtRoads: Bool?
        /// Avoid ferries while calculating the route.
        public let ferries: Bool?
        /// Avoid roads that have seasonal closure while calculating the route.
        public let seasonalClosure: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollRoads: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollTransponders: Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadTypes: [String]?
        /// Avoid tunnels while calculating the route.
        public let tunnels: Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public let uTurns: Bool?
        /// Zone categories to be avoided.
        public let zoneCategories: [RouteAvoidanceZoneCategory]?

        @inlinable
        public init(areas: [RouteAvoidanceArea]? = nil, carShuttleTrains: Bool? = nil, controlledAccessHighways: Bool? = nil, dirtRoads: Bool? = nil, ferries: Bool? = nil, seasonalClosure: Bool? = nil, tollRoads: Bool? = nil, tollTransponders: Bool? = nil, truckRoadTypes: [String]? = nil, tunnels: Bool? = nil, uTurns: Bool? = nil, zoneCategories: [RouteAvoidanceZoneCategory]? = nil) {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }

        public func validate(name: String) throws {
            try self.areas?.forEach {
                try $0.validate(name: "\(name).areas[]")
            }
            try self.truckRoadTypes?.forEach {
                try validate($0, name: "truckRoadTypes[]", parent: name, max: 3)
                try validate($0, name: "truckRoadTypes[]", parent: name, min: 1)
            }
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, max: 12)
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, min: 1)
            try self.validate(self.zoneCategories, name: "zoneCategories", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case areas = "Areas"
            case carShuttleTrains = "CarShuttleTrains"
            case controlledAccessHighways = "ControlledAccessHighways"
            case dirtRoads = "DirtRoads"
            case ferries = "Ferries"
            case seasonalClosure = "SeasonalClosure"
            case tollRoads = "TollRoads"
            case tollTransponders = "TollTransponders"
            case truckRoadTypes = "TruckRoadTypes"
            case tunnels = "Tunnels"
            case uTurns = "UTurns"
            case zoneCategories = "ZoneCategories"
        }
    }

    public struct RouteAvoidanceZoneCategory: AWSEncodableShape {
        /// Zone category to be avoided.
        public let category: RouteZoneCategory

        @inlinable
        public init(category: RouteZoneCategory) {
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
        }
    }

    public struct RouteCarOptions: AWSEncodableShape {
        /// Engine type of the vehicle.
        public let engineType: RouteEngineType?
        /// The vehicle License Plate.
        public let licensePlate: RouteVehicleLicensePlate?
        /// Maximum speed specified.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(engineType: RouteEngineType? = nil, licensePlate: RouteVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "EngineType"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct RouteContinueHighwayStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteContinueStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]

        @inlinable
        public init(intersection: [LocalizedString]) {
            self.intersection = intersection
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
        }
    }

    public struct RouteDestinationOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// Avoid U-turns for calculation on highways and motorways.
        public let avoidUTurns: Bool?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteSideOfStreetOptions?
        /// Duration of the stop.  Unit: seconds
        public let stopDuration: Int64?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, avoidUTurns: Bool? = nil, heading: Double? = nil, matching: RouteMatchingOptions? = nil, sideOfStreet: RouteSideOfStreetOptions? = nil, stopDuration: Int64? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
            try self.validate(self.stopDuration, name: "stopDuration", parent: name, max: 4294967295)
            try self.validate(self.stopDuration, name: "stopDuration", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case avoidUTurns = "AvoidUTurns"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
            case stopDuration = "StopDuration"
        }
    }

    public struct RouteDriverOptions: AWSEncodableShape {
        /// Driver work-rest schedule. Stops are added to fulfil the provided rest schedule.
        public let schedule: [RouteDriverScheduleInterval]?

        @inlinable
        public init(schedule: [RouteDriverScheduleInterval]? = nil) {
            self.schedule = schedule
        }

        public func validate(name: String) throws {
            try self.schedule?.forEach {
                try $0.validate(name: "\(name).schedule[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
        }
    }

    public struct RouteDriverScheduleInterval: AWSEncodableShape {
        /// Maximum allowed driving time before stopping to rest.  Unit: seconds
        public let driveDuration: Int64
        /// Resting time before the driver can continue driving.  Unit: seconds
        public let restDuration: Int64

        @inlinable
        public init(driveDuration: Int64 = 0, restDuration: Int64 = 0) {
            self.driveDuration = driveDuration
            self.restDuration = restDuration
        }

        public func validate(name: String) throws {
            try self.validate(self.driveDuration, name: "driveDuration", parent: name, max: 4294967295)
            try self.validate(self.driveDuration, name: "driveDuration", parent: name, min: 0)
            try self.validate(self.restDuration, name: "restDuration", parent: name, max: 4294967295)
            try self.validate(self.restDuration, name: "restDuration", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case driveDuration = "DriveDuration"
            case restDuration = "RestDuration"
        }
    }

    public struct RouteEmissionType: AWSEncodableShape {
        /// The CO 2 emission classes.
        public let co2EmissionClass: String?
        /// Type of the emission.  Valid values: Euro1, Euro2, Euro3, Euro4, Euro5, Euro6, EuroEev
        public let type: String

        @inlinable
        public init(co2EmissionClass: String? = nil, type: String) {
            self.co2EmissionClass = co2EmissionClass
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case co2EmissionClass = "Co2EmissionClass"
            case type = "Type"
        }
    }

    public struct RouteEnterHighwayStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteExclusionOptions: AWSEncodableShape {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        public let countries: [String]

        @inlinable
        public init(countries: [String]) {
            self.countries = countries
        }

        public func validate(name: String) throws {
            try self.countries.forEach {
                try validate($0, name: "countries[]", parent: name, max: 3)
                try validate($0, name: "countries[]", parent: name, min: 2)
                try validate($0, name: "countries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.countries, name: "countries", parent: name, max: 100)
            try self.validate(self.countries, name: "countries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case countries = "Countries"
        }
    }

    public struct RouteExitStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Exit to be taken.
        public let relativeExit: Int?
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], relativeExit: Int? = nil, steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case relativeExit = "RelativeExit"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteFerryAfterTravelStep: AWSDecodableShape {
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Brief description of the step in the requested language.  Only available when the TravelStepType is Default.
        public let instruction: String?
        /// Type of the step.
        public let type: RouteFerryAfterTravelStepType

        @inlinable
        public init(duration: Int64, instruction: String? = nil, type: RouteFerryAfterTravelStepType) {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case instruction = "Instruction"
            case type = "Type"
        }
    }

    public struct RouteFerryArrival: AWSDecodableShape {
        /// The place details.
        public let place: RouteFerryPlace
        /// The time.
        public let time: String?

        @inlinable
        public init(place: RouteFerryPlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RouteFerryBeforeTravelStep: AWSDecodableShape {
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Brief description of the step in the requested language.  Only available when the TravelStepType is Default.
        public let instruction: String?
        /// Type of the step.
        public let type: RouteFerryBeforeTravelStepType

        @inlinable
        public init(duration: Int64, instruction: String? = nil, type: RouteFerryBeforeTravelStepType) {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case instruction = "Instruction"
            case type = "Type"
        }
    }

    public struct RouteFerryDeparture: AWSDecodableShape {
        /// The place details.
        public let place: RouteFerryPlace
        /// The time.
        public let time: String?

        @inlinable
        public init(place: RouteFerryPlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RouteFerryLegDetails: AWSDecodableShape {
        /// Steps of a leg that must be performed after the travel portion of the leg.
        public let afterTravelSteps: [RouteFerryAfterTravelStep]
        /// Details corresponding to the arrival for the leg.
        public let arrival: RouteFerryArrival
        /// Steps of a leg that must be performed before the travel portion of the leg.
        public let beforeTravelSteps: [RouteFerryBeforeTravelStep]
        /// Details corresponding to the departure for the leg.
        public let departure: RouteFerryDeparture
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [RouteFerryNotice]
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        public let passThroughWaypoints: [RoutePassThroughWaypoint]
        /// Route name of the ferry line.
        public let routeName: String?
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        public let spans: [RouteFerrySpan]
        /// Summarized details of the leg.
        public let summary: RouteFerrySummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        public let travelSteps: [RouteFerryTravelStep]

        @inlinable
        public init(afterTravelSteps: [RouteFerryAfterTravelStep], arrival: RouteFerryArrival, beforeTravelSteps: [RouteFerryBeforeTravelStep], departure: RouteFerryDeparture, notices: [RouteFerryNotice], passThroughWaypoints: [RoutePassThroughWaypoint], routeName: String? = nil, spans: [RouteFerrySpan], summary: RouteFerrySummary? = nil, travelSteps: [RouteFerryTravelStep]) {
            self.afterTravelSteps = afterTravelSteps
            self.arrival = arrival
            self.beforeTravelSteps = beforeTravelSteps
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.routeName = routeName
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }

        private enum CodingKeys: String, CodingKey {
            case afterTravelSteps = "AfterTravelSteps"
            case arrival = "Arrival"
            case beforeTravelSteps = "BeforeTravelSteps"
            case departure = "Departure"
            case notices = "Notices"
            case passThroughWaypoints = "PassThroughWaypoints"
            case routeName = "RouteName"
            case spans = "Spans"
            case summary = "Summary"
            case travelSteps = "TravelSteps"
        }
    }

    public struct RouteFerryNotice: AWSDecodableShape {
        /// Code corresponding to the issue.
        public let code: RouteFerryNoticeCode
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public let impact: RouteNoticeImpact?

        @inlinable
        public init(code: RouteFerryNoticeCode, impact: RouteNoticeImpact? = nil) {
            self.code = code
            self.impact = impact
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case impact = "Impact"
        }
    }

    public struct RouteFerryOverviewSummary: AWSDecodableShape {
        /// Distance of the step.
        public let distance: Int64
        /// Duration of the step.  Unit: seconds
        public let duration: Int64

        @inlinable
        public init(distance: Int64, duration: Int64) {
            self.distance = distance
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case duration = "Duration"
        }
    }

    public struct RouteFerryPlace: AWSDecodableShape {
        /// The name of the place.
        public let name: String?
        /// Position provided in the request.
        public let originalPosition: [Double]?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Index of the waypoint in the request.
        public let waypointIndex: Int?

        @inlinable
        public init(name: String? = nil, originalPosition: [Double]? = nil, position: [Double], waypointIndex: Int? = nil) {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case originalPosition = "OriginalPosition"
            case position = "Position"
            case waypointIndex = "WaypointIndex"
        }
    }

    public struct RouteFerrySpan: AWSDecodableShape {
        /// 3 letter Country code corresponding to the Span.
        public let country: String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.  Unit: meters
        public let distance: Int64?
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.  Unit: seconds
        public let duration: Int64?
        /// Offset in the leg geometry corresponding to the start of this span.
        public let geometryOffset: Int?
        /// Provides an array of names of the ferry span in available languages.
        public let names: [LocalizedString]?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public let region: String?

        @inlinable
        public init(country: String? = nil, distance: Int64? = nil, duration: Int64? = nil, geometryOffset: Int? = nil, names: [LocalizedString]? = nil, region: String? = nil) {
            self.country = country
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.names = names
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case country = "Country"
            case distance = "Distance"
            case duration = "Duration"
            case geometryOffset = "GeometryOffset"
            case names = "Names"
            case region = "Region"
        }
    }

    public struct RouteFerrySummary: AWSDecodableShape {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public let overview: RouteFerryOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public let travelOnly: RouteFerryTravelOnlySummary?

        @inlinable
        public init(overview: RouteFerryOverviewSummary? = nil, travelOnly: RouteFerryTravelOnlySummary? = nil) {
            self.overview = overview
            self.travelOnly = travelOnly
        }

        private enum CodingKeys: String, CodingKey {
            case overview = "Overview"
            case travelOnly = "TravelOnly"
        }
    }

    public struct RouteFerryTravelOnlySummary: AWSDecodableShape {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg.  Unit: seconds
        public let duration: Int64

        @inlinable
        public init(duration: Int64) {
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
        }
    }

    public struct RouteFerryTravelStep: AWSDecodableShape {
        /// Distance of the step.
        public let distance: Int64?
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Offset in the leg geometry corresponding to the start of this step.
        public let geometryOffset: Int?
        /// Brief description of the step in the requested language.  Only available when the TravelStepType is Default.
        public let instruction: String?
        /// Type of the step.
        public let type: RouteFerryTravelStepType

        @inlinable
        public init(distance: Int64? = nil, duration: Int64, geometryOffset: Int? = nil, instruction: String? = nil, type: RouteFerryTravelStepType) {
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case duration = "Duration"
            case geometryOffset = "GeometryOffset"
            case instruction = "Instruction"
            case type = "Type"
        }
    }

    public struct RouteKeepStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteLeg: AWSDecodableShape {
        /// FerryLegDetails is populated when the Leg type is Ferry, and provides additional information that is specific
        public let ferryLegDetails: RouteFerryLegDetails?
        /// Geometry of the area to be avoided.
        public let geometry: RouteLegGeometry
        /// List of languages for instructions within steps in the response.
        public let language: String?
        /// Details related to the pedestrian leg.
        public let pedestrianLegDetails: RoutePedestrianLegDetails?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        public let travelMode: RouteLegTravelMode
        /// Type of the leg.
        public let type: RouteLegType
        /// Details related to the vehicle leg.
        public let vehicleLegDetails: RouteVehicleLegDetails?

        @inlinable
        public init(ferryLegDetails: RouteFerryLegDetails? = nil, geometry: RouteLegGeometry, language: String? = nil, pedestrianLegDetails: RoutePedestrianLegDetails? = nil, travelMode: RouteLegTravelMode, type: RouteLegType, vehicleLegDetails: RouteVehicleLegDetails? = nil) {
            self.ferryLegDetails = ferryLegDetails
            self.geometry = geometry
            self.language = language
            self.pedestrianLegDetails = pedestrianLegDetails
            self.travelMode = travelMode
            self.type = type
            self.vehicleLegDetails = vehicleLegDetails
        }

        private enum CodingKeys: String, CodingKey {
            case ferryLegDetails = "FerryLegDetails"
            case geometry = "Geometry"
            case language = "Language"
            case pedestrianLegDetails = "PedestrianLegDetails"
            case travelMode = "TravelMode"
            case type = "Type"
            case vehicleLegDetails = "VehicleLegDetails"
        }
    }

    public struct RouteLegGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  LineString and Polyline are mutually exclusive properties.
        public let lineString: [[Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format.  LineString and Polyline are mutually exclusive properties.
        public let polyline: String?

        @inlinable
        public init(lineString: [[Double]]? = nil, polyline: String? = nil) {
            self.lineString = lineString
            self.polyline = polyline
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
            case polyline = "Polyline"
        }
    }

    public struct RouteMajorRoadLabel: AWSDecodableShape {
        /// Name of the road (localized).
        public let roadName: LocalizedString?
        /// Route number of the road.
        public let routeNumber: RouteNumber?

        @inlinable
        public init(roadName: LocalizedString? = nil, routeNumber: RouteNumber? = nil) {
            self.roadName = roadName
            self.routeNumber = routeNumber
        }

        private enum CodingKeys: String, CodingKey {
            case roadName = "RoadName"
            case routeNumber = "RouteNumber"
        }
    }

    public struct RouteMatchingOptions: AWSEncodableShape {
        /// Attempts to match the provided position to a road similar to the provided name.
        public let nameHint: String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.  Unit: meters
        public let onRoadThreshold: Int64?
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy.  Unit: Meters
        public let radius: Int64?
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public let strategy: MatchingStrategy?

        @inlinable
        public init(nameHint: String? = nil, onRoadThreshold: Int64? = nil, radius: Int64? = nil, strategy: MatchingStrategy? = nil) {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }

        public func validate(name: String) throws {
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, max: 4294967295)
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, min: 0)
            try self.validate(self.radius, name: "radius", parent: name, max: 4294967295)
            try self.validate(self.radius, name: "radius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case nameHint = "NameHint"
            case onRoadThreshold = "OnRoadThreshold"
            case radius = "Radius"
            case strategy = "Strategy"
        }
    }

    public struct RouteMatrixAllowOptions: AWSEncodableShape {
        /// Allow Hot (High Occupancy Toll) lanes while calculating the route. Default value: false
        public let hot: Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating the route. Default value: false
        public let hov: Bool?

        @inlinable
        public init(hot: Bool? = nil, hov: Bool? = nil) {
            self.hot = hot
            self.hov = hov
        }

        private enum CodingKeys: String, CodingKey {
            case hot = "Hot"
            case hov = "Hov"
        }
    }

    public struct RouteMatrixAutoCircle: AWSEncodableShape & AWSDecodableShape {
        /// The margin provided for the calculation.
        public let margin: Int64?
        /// The maximum size of the radius provided for the calculation.
        public let maxRadius: Int64?

        @inlinable
        public init(margin: Int64? = nil, maxRadius: Int64? = nil) {
            self.margin = margin
            self.maxRadius = maxRadius
        }

        public func validate(name: String) throws {
            try self.validate(self.margin, name: "margin", parent: name, max: 4294967295)
            try self.validate(self.margin, name: "margin", parent: name, min: 0)
            try self.validate(self.maxRadius, name: "maxRadius", parent: name, max: 4294967295)
            try self.validate(self.maxRadius, name: "maxRadius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case margin = "Margin"
            case maxRadius = "MaxRadius"
        }
    }

    public struct RouteMatrixAvoidanceArea: AWSEncodableShape {
        /// Geometry of the area to be avoided.
        public let geometry: RouteMatrixAvoidanceAreaGeometry

        @inlinable
        public init(geometry: RouteMatrixAvoidanceAreaGeometry) {
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
        }
    }

    public struct RouteMatrixAvoidanceAreaGeometry: AWSEncodableShape {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public let boundingBox: [Double]?
        /// Geometry defined as a polygon with only one linear ring.
        public let polygon: [[[Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from second item to the last item (the inner rings). For more information on polyline encoding, see https://github.com/heremaps/flexiblepolyline/blob/master/README.md.
        public let polylinePolygon: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, polygon: [[[Double]]]? = nil, polylinePolygon: [String]? = nil) {
            self.boundingBox = boundingBox
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
            try self.polylinePolygon?.forEach {
                try validate($0, name: "polylinePolygon[]", parent: name, min: 1)
            }
            try self.validate(self.polylinePolygon, name: "polylinePolygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case polygon = "Polygon"
            case polylinePolygon = "PolylinePolygon"
        }
    }

    public struct RouteMatrixAvoidanceOptions: AWSEncodableShape {
        /// Areas to be avoided.
        public let areas: [RouteMatrixAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating the route.
        public let carShuttleTrains: Bool?
        /// Avoid controlled access highways while calculating the route.
        public let controlledAccessHighways: Bool?
        /// Avoid dirt roads while calculating the route.
        public let dirtRoads: Bool?
        /// Avoid ferries while calculating the route.
        public let ferries: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollRoads: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollTransponders: Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadTypes: [String]?
        /// Avoid tunnels while calculating the route.
        public let tunnels: Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public let uTurns: Bool?
        /// Zone categories to be avoided.
        public let zoneCategories: [RouteMatrixAvoidanceZoneCategory]?

        @inlinable
        public init(areas: [RouteMatrixAvoidanceArea]? = nil, carShuttleTrains: Bool? = nil, controlledAccessHighways: Bool? = nil, dirtRoads: Bool? = nil, ferries: Bool? = nil, tollRoads: Bool? = nil, tollTransponders: Bool? = nil, truckRoadTypes: [String]? = nil, tunnels: Bool? = nil, uTurns: Bool? = nil, zoneCategories: [RouteMatrixAvoidanceZoneCategory]? = nil) {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }

        public func validate(name: String) throws {
            try self.areas?.forEach {
                try $0.validate(name: "\(name).areas[]")
            }
            try self.truckRoadTypes?.forEach {
                try validate($0, name: "truckRoadTypes[]", parent: name, max: 3)
                try validate($0, name: "truckRoadTypes[]", parent: name, min: 1)
            }
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, max: 12)
            try self.validate(self.truckRoadTypes, name: "truckRoadTypes", parent: name, min: 1)
            try self.validate(self.zoneCategories, name: "zoneCategories", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case areas = "Areas"
            case carShuttleTrains = "CarShuttleTrains"
            case controlledAccessHighways = "ControlledAccessHighways"
            case dirtRoads = "DirtRoads"
            case ferries = "Ferries"
            case tollRoads = "TollRoads"
            case tollTransponders = "TollTransponders"
            case truckRoadTypes = "TruckRoadTypes"
            case tunnels = "Tunnels"
            case uTurns = "UTurns"
            case zoneCategories = "ZoneCategories"
        }
    }

    public struct RouteMatrixAvoidanceZoneCategory: AWSEncodableShape {
        /// Zone category to be avoided.
        public let category: RouteMatrixZoneCategory?

        @inlinable
        public init(category: RouteMatrixZoneCategory? = nil) {
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
        }
    }

    public struct RouteMatrixBoundary: AWSEncodableShape & AWSDecodableShape {
        /// Geometry of the area to be avoided.
        public let geometry: RouteMatrixBoundaryGeometry?
        /// No restrictions in terms of a routing boundary, and is typically used for longer routes.
        public let unbounded: Bool?

        @inlinable
        public init(geometry: RouteMatrixBoundaryGeometry? = nil, unbounded: Bool? = nil) {
            self.geometry = geometry
            self.unbounded = unbounded
        }

        public func validate(name: String) throws {
            try self.geometry?.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
            case unbounded = "Unbounded"
        }
    }

    public struct RouteMatrixBoundaryGeometry: AWSEncodableShape & AWSDecodableShape {
        /// Provides the circle that was used while calculating the route.
        public let autoCircle: RouteMatrixAutoCircle?
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public let boundingBox: [Double]?
        /// Geometry defined as a circle. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
        public let circle: Circle?
        /// Geometry defined as a polygon with only one linear ring.
        public let polygon: [[[Double]]]?

        @inlinable
        public init(autoCircle: RouteMatrixAutoCircle? = nil, boundingBox: [Double]? = nil, circle: Circle? = nil, polygon: [[[Double]]]? = nil) {
            self.autoCircle = autoCircle
            self.boundingBox = boundingBox
            self.circle = circle
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.autoCircle?.validate(name: "\(name).autoCircle")
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.circle?.validate(name: "\(name).circle")
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoCircle = "AutoCircle"
            case boundingBox = "BoundingBox"
            case circle = "Circle"
            case polygon = "Polygon"
        }
    }

    public struct RouteMatrixCarOptions: AWSEncodableShape {
        /// The vehicle License Plate.
        public let licensePlate: RouteMatrixVehicleLicensePlate?
        /// Maximum speed  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(licensePlate: RouteMatrixVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct RouteMatrixDestination: AWSEncodableShape {
        /// Destination related options.
        public let options: RouteMatrixDestinationOptions?
        /// Position defined as [longitude, latitude].
        public let position: [Double]

        @inlinable
        public init(options: RouteMatrixDestinationOptions? = nil, position: [Double]) {
            self.options = options
            self.position = position
        }

        public func validate(name: String) throws {
            try self.options?.validate(name: "\(name).options")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case position = "Position"
        }
    }

    public struct RouteMatrixDestinationOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteMatrixSideOfStreetOptions?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, heading: Double? = nil, matching: RouteMatrixMatchingOptions? = nil, sideOfStreet: RouteMatrixSideOfStreetOptions? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct RouteMatrixEntry: AWSDecodableShape {
        /// The total distance of travel for the route.
        public let distance: Int64
        /// The expected duration of travel for the route.  Unit: seconds
        public let duration: Int64
        /// Error code that occurred during calculation of the route.
        public let error: RouteMatrixErrorCode?

        @inlinable
        public init(distance: Int64, duration: Int64, error: RouteMatrixErrorCode? = nil) {
            self.distance = distance
            self.duration = duration
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case duration = "Duration"
            case error = "Error"
        }
    }

    public struct RouteMatrixExclusionOptions: AWSEncodableShape {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        public let countries: [String]

        @inlinable
        public init(countries: [String]) {
            self.countries = countries
        }

        public func validate(name: String) throws {
            try self.countries.forEach {
                try validate($0, name: "countries[]", parent: name, max: 3)
                try validate($0, name: "countries[]", parent: name, min: 2)
                try validate($0, name: "countries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.countries, name: "countries", parent: name, max: 100)
            try self.validate(self.countries, name: "countries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case countries = "Countries"
        }
    }

    public struct RouteMatrixMatchingOptions: AWSEncodableShape {
        /// Attempts to match the provided position to a road similar to the provided name.
        public let nameHint: String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.  Unit: meters
        public let onRoadThreshold: Int64?
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy.  Unit: Meters
        public let radius: Int64?
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public let strategy: MatchingStrategy?

        @inlinable
        public init(nameHint: String? = nil, onRoadThreshold: Int64? = nil, radius: Int64? = nil, strategy: MatchingStrategy? = nil) {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }

        public func validate(name: String) throws {
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, max: 4294967295)
            try self.validate(self.onRoadThreshold, name: "onRoadThreshold", parent: name, min: 0)
            try self.validate(self.radius, name: "radius", parent: name, max: 4294967295)
            try self.validate(self.radius, name: "radius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case nameHint = "NameHint"
            case onRoadThreshold = "OnRoadThreshold"
            case radius = "Radius"
            case strategy = "Strategy"
        }
    }

    public struct RouteMatrixOrigin: AWSEncodableShape {
        /// Origin related options.
        public let options: RouteMatrixOriginOptions?
        /// Position defined as [longitude, latitude].
        public let position: [Double]

        @inlinable
        public init(options: RouteMatrixOriginOptions? = nil, position: [Double]) {
            self.options = options
            self.position = position
        }

        public func validate(name: String) throws {
            try self.options?.validate(name: "\(name).options")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case position = "Position"
        }
    }

    public struct RouteMatrixOriginOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteMatrixSideOfStreetOptions?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, heading: Double? = nil, matching: RouteMatrixMatchingOptions? = nil, sideOfStreet: RouteMatrixSideOfStreetOptions? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct RouteMatrixScooterOptions: AWSEncodableShape {
        /// The vehicle License Plate.
        public let licensePlate: RouteMatrixVehicleLicensePlate?
        /// Maximum speed.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(licensePlate: RouteMatrixVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct RouteMatrixSideOfStreetOptions: AWSEncodableShape {
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public let useWith: SideOfStreetMatchingStrategy?

        @inlinable
        public init(position: [Double], useWith: SideOfStreetMatchingStrategy? = nil) {
            self.position = position
            self.useWith = useWith
        }

        public func validate(name: String) throws {
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
            case useWith = "UseWith"
        }
    }

    public struct RouteMatrixTrafficOptions: AWSEncodableShape {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public let flowEventThresholdOverride: Int64?
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public let usage: TrafficUsage?

        @inlinable
        public init(flowEventThresholdOverride: Int64? = nil, usage: TrafficUsage? = nil) {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }

        public func validate(name: String) throws {
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, max: 4294967295)
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case flowEventThresholdOverride = "FlowEventThresholdOverride"
            case usage = "Usage"
        }
    }

    public struct RouteMatrixTrailerOptions: AWSEncodableShape {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: Int?

        @inlinable
        public init(trailerCount: Int? = nil) {
            self.trailerCount = trailerCount
        }

        private enum CodingKeys: String, CodingKey {
            case trailerCount = "TrailerCount"
        }
    }

    public struct RouteMatrixTravelModeOptions: AWSEncodableShape {
        /// Travel mode options when the provided travel mode is "Car"
        public let car: RouteMatrixCarOptions?
        /// Travel mode options when the provided travel mode is Scooter   When travel mode is set to Scooter, then the avoidance option ControlledAccessHighways defaults to true.
        public let scooter: RouteMatrixScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public let truck: RouteMatrixTruckOptions?

        @inlinable
        public init(car: RouteMatrixCarOptions? = nil, scooter: RouteMatrixScooterOptions? = nil, truck: RouteMatrixTruckOptions? = nil) {
            self.car = car
            self.scooter = scooter
            self.truck = truck
        }

        public func validate(name: String) throws {
            try self.car?.validate(name: "\(name).car")
            try self.scooter?.validate(name: "\(name).scooter")
            try self.truck?.validate(name: "\(name).truck")
        }

        private enum CodingKeys: String, CodingKey {
            case car = "Car"
            case scooter = "Scooter"
            case truck = "Truck"
        }
    }

    public struct RouteMatrixTruckOptions: AWSEncodableShape {
        /// Total number of axles of the vehicle.
        public let axleCount: Int?
        /// Gross weight of the vehicle including trailers, and goods at capacity.  Unit: Kilograms
        public let grossWeight: Int64?
        /// List of Hazardous cargo contained in the vehicle.
        public let hazardousCargos: [RouteMatrixHazardousCargoType]?
        /// Height of the vehicle.  Unit: centimeters
        public let height: Int64?
        /// Kingpin to rear axle length of the vehicle  Unit: centimeters
        public let kpraLength: Int64?
        /// Length of the vehicle.  Unit: centimeters
        public let length: Int64?
        /// The vehicle License Plate.
        public let licensePlate: RouteMatrixVehicleLicensePlate?
        /// Maximum speed  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?
        /// Payload capacity of the vehicle and trailers attached.  Unit: kilograms
        public let payloadCapacity: Int64?
        /// Trailer options corresponding to the vehicle.
        public let trailer: RouteMatrixTrailerOptions?
        /// Type of the truck.
        public let truckType: RouteMatrixTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished.  Unit: Kilograms
        public let weightPerAxle: Int64?
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
        public let weightPerAxleGroup: WeightPerAxleGroup?
        /// Width of the vehicle.  Unit: centimeters
        public let width: Int64?

        @inlinable
        public init(axleCount: Int? = nil, grossWeight: Int64? = nil, hazardousCargos: [RouteMatrixHazardousCargoType]? = nil, height: Int64? = nil, kpraLength: Int64? = nil, length: Int64? = nil, licensePlate: RouteMatrixVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil, payloadCapacity: Int64? = nil, trailer: RouteMatrixTrailerOptions? = nil, truckType: RouteMatrixTruckType? = nil, tunnelRestrictionCode: String? = nil, weightPerAxle: Int64? = nil, weightPerAxleGroup: WeightPerAxleGroup? = nil, width: Int64? = nil) {
            self.axleCount = axleCount
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, max: 4294967295)
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, min: 0)
            try self.validate(self.hazardousCargos, name: "hazardousCargos", parent: name, max: 11)
            try self.validate(self.height, name: "height", parent: name, max: 4294967295)
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, max: 4294967295)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, max: 4294967295)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, max: 4294967295)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, min: 0)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, max: 1)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, min: 1)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, max: 4294967295)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, min: 0)
            try self.weightPerAxleGroup?.validate(name: "\(name).weightPerAxleGroup")
            try self.validate(self.width, name: "width", parent: name, max: 4294967295)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case axleCount = "AxleCount"
            case grossWeight = "GrossWeight"
            case hazardousCargos = "HazardousCargos"
            case height = "Height"
            case kpraLength = "KpraLength"
            case length = "Length"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
            case payloadCapacity = "PayloadCapacity"
            case trailer = "Trailer"
            case truckType = "TruckType"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
            case weightPerAxle = "WeightPerAxle"
            case weightPerAxleGroup = "WeightPerAxleGroup"
            case width = "Width"
        }
    }

    public struct RouteMatrixVehicleLicensePlate: AWSEncodableShape {
        /// The last character of the License Plate.
        public let lastCharacter: String?

        @inlinable
        public init(lastCharacter: String? = nil) {
            self.lastCharacter = lastCharacter
        }

        private enum CodingKeys: String, CodingKey {
            case lastCharacter = "LastCharacter"
        }
    }

    public struct RouteNoticeDetailRange: AWSDecodableShape {
        /// Maximum value for the range.
        public let max: Int?
        /// Minimum value for the range.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct RouteNumber: AWSDecodableShape {
        /// Directional identifier of the route.
        public let direction: RouteDirection?
        /// List of languages for instructions corresponding to the route number.
        public let language: String?
        /// The route number.
        public let value: String

        @inlinable
        public init(direction: RouteDirection? = nil, language: String? = nil, value: String) {
            self.direction = direction
            self.language = language
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case language = "Language"
            case value = "Value"
        }
    }

    public struct RouteOriginOptions: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// Avoid U-turns for calculation on highways and motorways.
        public let avoidUTurns: Bool?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteSideOfStreetOptions?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, avoidUTurns: Bool? = nil, heading: Double? = nil, matching: RouteMatchingOptions? = nil, sideOfStreet: RouteSideOfStreetOptions? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case avoidUTurns = "AvoidUTurns"
            case heading = "Heading"
            case matching = "Matching"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct RoutePassThroughPlace: AWSDecodableShape {
        /// Position provided in the request.
        public let originalPosition: [Double]?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Index of the waypoint in the request.
        public let waypointIndex: Int?

        @inlinable
        public init(originalPosition: [Double]? = nil, position: [Double], waypointIndex: Int? = nil) {
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }

        private enum CodingKeys: String, CodingKey {
            case originalPosition = "OriginalPosition"
            case position = "Position"
            case waypointIndex = "WaypointIndex"
        }
    }

    public struct RoutePassThroughWaypoint: AWSDecodableShape {
        /// Offset in the leg geometry corresponding to the start of this step.
        public let geometryOffset: Int?
        /// The place details.
        public let place: RoutePassThroughPlace

        @inlinable
        public init(geometryOffset: Int? = nil, place: RoutePassThroughPlace) {
            self.geometryOffset = geometryOffset
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case geometryOffset = "GeometryOffset"
            case place = "Place"
        }
    }

    public struct RoutePedestrianArrival: AWSDecodableShape {
        /// The place details.
        public let place: RoutePedestrianPlace
        /// The time.
        public let time: String?

        @inlinable
        public init(place: RoutePedestrianPlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RoutePedestrianDeparture: AWSDecodableShape {
        /// The place details.
        public let place: RoutePedestrianPlace
        /// The time.
        public let time: String?

        @inlinable
        public init(place: RoutePedestrianPlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RoutePedestrianLegDetails: AWSDecodableShape {
        /// Details corresponding to the arrival for the leg.
        public let arrival: RoutePedestrianArrival
        /// Details corresponding to the departure for the leg.
        public let departure: RoutePedestrianDeparture
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [RoutePedestrianNotice]
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        public let passThroughWaypoints: [RoutePassThroughWaypoint]
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        public let spans: [RoutePedestrianSpan]
        /// Summarized details of the leg.
        public let summary: RoutePedestrianSummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        public let travelSteps: [RoutePedestrianTravelStep]

        @inlinable
        public init(arrival: RoutePedestrianArrival, departure: RoutePedestrianDeparture, notices: [RoutePedestrianNotice], passThroughWaypoints: [RoutePassThroughWaypoint], spans: [RoutePedestrianSpan], summary: RoutePedestrianSummary? = nil, travelSteps: [RoutePedestrianTravelStep]) {
            self.arrival = arrival
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }

        private enum CodingKeys: String, CodingKey {
            case arrival = "Arrival"
            case departure = "Departure"
            case notices = "Notices"
            case passThroughWaypoints = "PassThroughWaypoints"
            case spans = "Spans"
            case summary = "Summary"
            case travelSteps = "TravelSteps"
        }
    }

    public struct RoutePedestrianNotice: AWSDecodableShape {
        /// Code corresponding to the issue.
        public let code: RoutePedestrianNoticeCode
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public let impact: RouteNoticeImpact?

        @inlinable
        public init(code: RoutePedestrianNoticeCode, impact: RouteNoticeImpact? = nil) {
            self.code = code
            self.impact = impact
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case impact = "Impact"
        }
    }

    public struct RoutePedestrianOptions: AWSEncodableShape {
        /// Walking speed in Kilometers per hour.
        public let speed: Double?

        @inlinable
        public init(speed: Double? = nil) {
            self.speed = speed
        }

        public func validate(name: String) throws {
            try self.validate(self.speed, name: "speed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case speed = "Speed"
        }
    }

    public struct RoutePedestrianOverviewSummary: AWSDecodableShape {
        /// Distance of the step.
        public let distance: Int64
        /// Duration of the step.
        public let duration: Int64

        @inlinable
        public init(distance: Int64, duration: Int64) {
            self.distance = distance
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case duration = "Duration"
        }
    }

    public struct RoutePedestrianPlace: AWSDecodableShape {
        /// The name of the place.
        public let name: String?
        /// Position provided in the request.
        public let originalPosition: [Double]?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteSideOfStreet?
        /// Index of the waypoint in the request.
        public let waypointIndex: Int?

        @inlinable
        public init(name: String? = nil, originalPosition: [Double]? = nil, position: [Double], sideOfStreet: RouteSideOfStreet? = nil, waypointIndex: Int? = nil) {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case originalPosition = "OriginalPosition"
            case position = "Position"
            case sideOfStreet = "SideOfStreet"
            case waypointIndex = "WaypointIndex"
        }
    }

    public struct RoutePedestrianSpan: AWSDecodableShape {
        /// Duration of the computed span without traffic congestion.  Unit: seconds
        public let bestCaseDuration: Int64?
        /// 3 letter Country code corresponding to the Span.
        public let country: String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.
        public let distance: Int64?
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.  Unit: seconds
        public let duration: Int64?
        /// Dynamic speed details corresponding to the span.  Unit: KilometersPerHour
        public let dynamicSpeed: RouteSpanDynamicSpeedDetails?
        /// Functional classification of the road segment corresponding to the span.
        public let functionalClassification: Int?
        /// Offset in the leg geometry corresponding to the start of this span.
        public let geometryOffset: Int?
        /// Incidents corresponding to the span. These index into the Incidents in the parent Leg.
        public let incidents: [Int]?
        /// Provides an array of names of the pedestrian span in available languages.
        public let names: [LocalizedString]?
        /// Access attributes for a pedestrian corresponding to the span.
        public let pedestrianAccess: [RouteSpanPedestrianAccessAttribute]?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public let region: String?
        /// Attributes for the road segment corresponding to the span.
        public let roadAttributes: [RouteSpanRoadAttribute]?
        /// Designated route name or number corresponding to the span.
        public let routeNumbers: [RouteNumber]?
        /// Speed limit details corresponding to the span.  Unit: KilometersPerHour
        public let speedLimit: RouteSpanSpeedLimitDetails?
        /// Duration of the computed span under typical traffic congestion.  Unit: seconds
        public let typicalDuration: Int64?

        @inlinable
        public init(bestCaseDuration: Int64? = nil, country: String? = nil, distance: Int64? = nil, duration: Int64? = nil, dynamicSpeed: RouteSpanDynamicSpeedDetails? = nil, functionalClassification: Int? = nil, geometryOffset: Int? = nil, incidents: [Int]? = nil, names: [LocalizedString]? = nil, pedestrianAccess: [RouteSpanPedestrianAccessAttribute]? = nil, region: String? = nil, roadAttributes: [RouteSpanRoadAttribute]? = nil, routeNumbers: [RouteNumber]? = nil, speedLimit: RouteSpanSpeedLimitDetails? = nil, typicalDuration: Int64? = nil) {
            self.bestCaseDuration = bestCaseDuration
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.pedestrianAccess = pedestrianAccess
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.speedLimit = speedLimit
            self.typicalDuration = typicalDuration
        }

        private enum CodingKeys: String, CodingKey {
            case bestCaseDuration = "BestCaseDuration"
            case country = "Country"
            case distance = "Distance"
            case duration = "Duration"
            case dynamicSpeed = "DynamicSpeed"
            case functionalClassification = "FunctionalClassification"
            case geometryOffset = "GeometryOffset"
            case incidents = "Incidents"
            case names = "Names"
            case pedestrianAccess = "PedestrianAccess"
            case region = "Region"
            case roadAttributes = "RoadAttributes"
            case routeNumbers = "RouteNumbers"
            case speedLimit = "SpeedLimit"
            case typicalDuration = "TypicalDuration"
        }
    }

    public struct RoutePedestrianSummary: AWSDecodableShape {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public let overview: RoutePedestrianOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public let travelOnly: RoutePedestrianTravelOnlySummary?

        @inlinable
        public init(overview: RoutePedestrianOverviewSummary? = nil, travelOnly: RoutePedestrianTravelOnlySummary? = nil) {
            self.overview = overview
            self.travelOnly = travelOnly
        }

        private enum CodingKeys: String, CodingKey {
            case overview = "Overview"
            case travelOnly = "TravelOnly"
        }
    }

    public struct RoutePedestrianTravelOnlySummary: AWSDecodableShape {
        /// Duration of the step.  Unit: seconds
        public let duration: Int64

        @inlinable
        public init(duration: Int64) {
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
        }
    }

    public struct RoutePedestrianTravelStep: AWSDecodableShape {
        /// Details related to the continue step.
        public let continueStepDetails: RouteContinueStepDetails?
        /// Details of the current road. See RouteRoad for details of sub-attributes.
        public let currentRoad: RouteRoad?
        /// Distance of the step.
        public let distance: Int64?
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Exit number of the road exit, if applicable.
        public let exitNumber: [LocalizedString]?
        /// Offset in the leg geometry corresponding to the start of this step.
        public let geometryOffset: Int?
        /// Brief description of the step in the requested language.  Only available when the TravelStepType is Default.
        public let instruction: String?
        /// Details that are specific to a Keep step.
        public let keepStepDetails: RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public let nextRoad: RouteRoad?
        /// Details that are specific to a Roundabout Enter step.
        public let roundaboutEnterStepDetails: RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public let roundaboutExitStepDetails: RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public let roundaboutPassStepDetails: RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public let signpost: RouteSignpost?
        /// Details that are specific to a turn step.
        public let turnStepDetails: RouteTurnStepDetails?
        /// Type of the step.
        public let type: RoutePedestrianTravelStepType

        @inlinable
        public init(continueStepDetails: RouteContinueStepDetails? = nil, currentRoad: RouteRoad? = nil, distance: Int64? = nil, duration: Int64, exitNumber: [LocalizedString]? = nil, geometryOffset: Int? = nil, instruction: String? = nil, keepStepDetails: RouteKeepStepDetails? = nil, nextRoad: RouteRoad? = nil, roundaboutEnterStepDetails: RouteRoundaboutEnterStepDetails? = nil, roundaboutExitStepDetails: RouteRoundaboutExitStepDetails? = nil, roundaboutPassStepDetails: RouteRoundaboutPassStepDetails? = nil, signpost: RouteSignpost? = nil, turnStepDetails: RouteTurnStepDetails? = nil, type: RoutePedestrianTravelStepType) {
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.exitNumber = exitNumber
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case continueStepDetails = "ContinueStepDetails"
            case currentRoad = "CurrentRoad"
            case distance = "Distance"
            case duration = "Duration"
            case exitNumber = "ExitNumber"
            case geometryOffset = "GeometryOffset"
            case instruction = "Instruction"
            case keepStepDetails = "KeepStepDetails"
            case nextRoad = "NextRoad"
            case roundaboutEnterStepDetails = "RoundaboutEnterStepDetails"
            case roundaboutExitStepDetails = "RoundaboutExitStepDetails"
            case roundaboutPassStepDetails = "RoundaboutPassStepDetails"
            case signpost = "Signpost"
            case turnStepDetails = "TurnStepDetails"
            case type = "Type"
        }
    }

    public struct RouteRampStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteResponseNotice: AWSDecodableShape {
        /// Code corresponding to the issue.
        public let code: RouteResponseNoticeCode
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public let impact: RouteNoticeImpact?

        @inlinable
        public init(code: RouteResponseNoticeCode, impact: RouteNoticeImpact? = nil) {
            self.code = code
            self.impact = impact
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case impact = "Impact"
        }
    }

    public struct RouteRoad: AWSDecodableShape {
        /// Name of the road (localized).
        public let roadName: [LocalizedString]
        /// Route number of the road.
        public let routeNumber: [RouteNumber]
        /// Names of destinations that can be reached when traveling on the road.
        public let towards: [LocalizedString]
        /// The type of road.
        public let type: RouteRoadType?

        @inlinable
        public init(roadName: [LocalizedString], routeNumber: [RouteNumber], towards: [LocalizedString], type: RouteRoadType? = nil) {
            self.roadName = roadName
            self.routeNumber = routeNumber
            self.towards = towards
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case roadName = "RoadName"
            case routeNumber = "RouteNumber"
            case towards = "Towards"
            case type = "Type"
        }
    }

    public struct RouteRoundaboutEnterStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteRoundaboutExitStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Exit to be taken.
        public let relativeExit: Int?
        /// Angle of the roundabout.
        public let roundaboutAngle: Double?
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?

        @inlinable
        public init(intersection: [LocalizedString], relativeExit: Int? = nil, roundaboutAngle: Double? = nil, steeringDirection: RouteSteeringDirection? = nil) {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.roundaboutAngle = roundaboutAngle
            self.steeringDirection = steeringDirection
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case relativeExit = "RelativeExit"
            case roundaboutAngle = "RoundaboutAngle"
            case steeringDirection = "SteeringDirection"
        }
    }

    public struct RouteRoundaboutPassStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteScooterOptions: AWSEncodableShape {
        /// Engine type of the vehicle.
        public let engineType: RouteEngineType?
        /// The vehicle License Plate.
        public let licensePlate: RouteVehicleLicensePlate?
        /// Maximum speed  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?

        @inlinable
        public init(engineType: RouteEngineType? = nil, licensePlate: RouteVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil) {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "EngineType"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
        }
    }

    public struct RouteSideOfStreetOptions: AWSEncodableShape {
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Strategy that defines when the side of street position should be used. Default Value: DividedStreetOnly
        public let useWith: SideOfStreetMatchingStrategy?

        @inlinable
        public init(position: [Double], useWith: SideOfStreetMatchingStrategy? = nil) {
            self.position = position
            self.useWith = useWith
        }

        public func validate(name: String) throws {
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
            case useWith = "UseWith"
        }
    }

    public struct RouteSignpost: AWSDecodableShape {
        /// Labels present on the sign post.
        public let labels: [RouteSignpostLabel]

        @inlinable
        public init(labels: [RouteSignpostLabel]) {
            self.labels = labels
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "Labels"
        }
    }

    public struct RouteSignpostLabel: AWSDecodableShape {
        /// Route number of the road.
        public let routeNumber: RouteNumber?
        /// The Signpost text.
        public let text: LocalizedString?

        @inlinable
        public init(routeNumber: RouteNumber? = nil, text: LocalizedString? = nil) {
            self.routeNumber = routeNumber
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case routeNumber = "RouteNumber"
            case text = "Text"
        }
    }

    public struct RouteSpanDynamicSpeedDetails: AWSDecodableShape {
        /// Estimated speed while traversing the span without traffic congestion.  Unit: KilometersPerHour
        public let bestCaseSpeed: Double?
        /// Estimated time to turn from this span into the next.   Unit: seconds
        public let turnDuration: Int64?
        /// Estimated speed while traversing the span under typical traffic congestion.  Unit: KilometersPerHour
        public let typicalSpeed: Double?

        @inlinable
        public init(bestCaseSpeed: Double? = nil, turnDuration: Int64? = nil, typicalSpeed: Double? = nil) {
            self.bestCaseSpeed = bestCaseSpeed
            self.turnDuration = turnDuration
            self.typicalSpeed = typicalSpeed
        }

        private enum CodingKeys: String, CodingKey {
            case bestCaseSpeed = "BestCaseSpeed"
            case turnDuration = "TurnDuration"
            case typicalSpeed = "TypicalSpeed"
        }
    }

    public struct RouteSpanSpeedLimitDetails: AWSDecodableShape {
        /// Maximum speed.  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// If the span doesn't have a speed limit like the Autobahn.
        public let unlimited: Bool?

        @inlinable
        public init(maxSpeed: Double? = nil, unlimited: Bool? = nil) {
            self.maxSpeed = maxSpeed
            self.unlimited = unlimited
        }

        private enum CodingKeys: String, CodingKey {
            case maxSpeed = "MaxSpeed"
            case unlimited = "Unlimited"
        }
    }

    public struct RouteSummary: AWSDecodableShape {
        /// Distance of the route.
        public let distance: Int64?
        /// Duration of the route.  Unit: seconds
        public let duration: Int64?
        /// Toll summary for the complete route.
        public let tolls: RouteTollSummary?

        @inlinable
        public init(distance: Int64? = nil, duration: Int64? = nil, tolls: RouteTollSummary? = nil) {
            self.distance = distance
            self.duration = duration
            self.tolls = tolls
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case duration = "Duration"
            case tolls = "Tolls"
        }
    }

    public struct RouteToll: AWSDecodableShape {
        /// The alpha-2 or alpha-3 character code for the country.
        public let country: String?
        /// Locations or sites where the toll fare is collected.
        public let paymentSites: [RouteTollPaymentSite]
        /// Toll rates that need to be paid to travel this leg of the route.
        public let rates: [RouteTollRate]
        /// Toll systems are authorities that collect payments for the toll.
        public let systems: [Int]

        @inlinable
        public init(country: String? = nil, paymentSites: [RouteTollPaymentSite], rates: [RouteTollRate], systems: [Int]) {
            self.country = country
            self.paymentSites = paymentSites
            self.rates = rates
            self.systems = systems
        }

        private enum CodingKeys: String, CodingKey {
            case country = "Country"
            case paymentSites = "PaymentSites"
            case rates = "Rates"
            case systems = "Systems"
        }
    }

    public struct RouteTollOptions: AWSEncodableShape {
        /// Specifies if the user has valid transponder with access to all toll systems. This impacts toll calculation, and if true the price with transponders is used.
        public let allTransponders: Bool?
        /// Specifies if the user has valid vignettes with access for all toll roads. If a user has a vignette for a toll road, then toll cost for that road is omitted since no further payment is necessary.
        public let allVignettes: Bool?
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        public let currency: String?
        /// Emission type of the vehicle for toll cost calculation.  Valid values: Euro1, Euro2, Euro3, Euro4, Euro5, Euro6, EuroEev
        public let emissionType: RouteEmissionType?
        /// Vehicle category for toll cost calculation.
        public let vehicleCategory: RouteTollVehicleCategory?

        @inlinable
        public init(allTransponders: Bool? = nil, allVignettes: Bool? = nil, currency: String? = nil, emissionType: RouteEmissionType? = nil, vehicleCategory: RouteTollVehicleCategory? = nil) {
            self.allTransponders = allTransponders
            self.allVignettes = allVignettes
            self.currency = currency
            self.emissionType = emissionType
            self.vehicleCategory = vehicleCategory
        }

        public func validate(name: String) throws {
            try self.validate(self.currency, name: "currency", parent: name, max: 3)
            try self.validate(self.currency, name: "currency", parent: name, min: 3)
            try self.validate(self.currency, name: "currency", parent: name, pattern: "^[A-Z]{3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case allTransponders = "AllTransponders"
            case allVignettes = "AllVignettes"
            case currency = "Currency"
            case emissionType = "EmissionType"
            case vehicleCategory = "VehicleCategory"
        }
    }

    public struct RouteTollPass: AWSDecodableShape {
        /// If the pass includes the rate for the return leg of the trip.
        public let includesReturnTrip: Bool?
        /// If the pass is only valid for senior persons.
        public let seniorPass: Bool?
        /// If the toll pass can be transferred, and how many times.
        public let transferCount: Int?
        /// Number of trips the pass is valid for.
        public let tripCount: Int?
        /// Period for which the pass is valid.
        public let validityPeriod: RouteTollPassValidityPeriod?

        @inlinable
        public init(includesReturnTrip: Bool? = nil, seniorPass: Bool? = nil, transferCount: Int? = nil, tripCount: Int? = nil, validityPeriod: RouteTollPassValidityPeriod? = nil) {
            self.includesReturnTrip = includesReturnTrip
            self.seniorPass = seniorPass
            self.transferCount = transferCount
            self.tripCount = tripCount
            self.validityPeriod = validityPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case includesReturnTrip = "IncludesReturnTrip"
            case seniorPass = "SeniorPass"
            case transferCount = "TransferCount"
            case tripCount = "TripCount"
            case validityPeriod = "ValidityPeriod"
        }
    }

    public struct RouteTollPassValidityPeriod: AWSDecodableShape {
        /// Validity period.
        public let period: RouteTollPassValidityPeriodType
        /// Counts for the validity period.
        public let periodCount: Int?

        @inlinable
        public init(period: RouteTollPassValidityPeriodType, periodCount: Int? = nil) {
            self.period = period
            self.periodCount = periodCount
        }

        private enum CodingKeys: String, CodingKey {
            case period = "Period"
            case periodCount = "PeriodCount"
        }
    }

    public struct RouteTollPaymentSite: AWSDecodableShape {
        /// Name of the payment site.
        public let name: String?
        /// Position defined as [longitude, latitude].
        public let position: [Double]

        @inlinable
        public init(name: String? = nil, position: [Double]) {
            self.name = name
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case position = "Position"
        }
    }

    public struct RouteTollPrice: AWSDecodableShape {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        public let currency: String
        /// If the price is an estimate or an exact value.
        public let estimate: Bool
        /// Duration for which the price corresponds to.  Unit: seconds
        public let perDuration: Int64?
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        public let range: Bool
        /// Price range with a minimum and maximum value, if a range.
        public let rangeValue: RouteTollPriceValueRange?
        /// Exact price, if not a range.
        public let value: Double

        @inlinable
        public init(currency: String, estimate: Bool, perDuration: Int64? = nil, range: Bool, rangeValue: RouteTollPriceValueRange? = nil, value: Double) {
            self.currency = currency
            self.estimate = estimate
            self.perDuration = perDuration
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "Currency"
            case estimate = "Estimate"
            case perDuration = "PerDuration"
            case range = "Range"
            case rangeValue = "RangeValue"
            case value = "Value"
        }
    }

    public struct RouteTollPriceSummary: AWSDecodableShape {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        public let currency: String
        /// If the price is an estimate or an exact value.
        public let estimate: Bool
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        public let range: Bool
        /// Price range with a minimum and maximum value, if a range.
        public let rangeValue: RouteTollPriceValueRange?
        /// Exact price, if not a range.
        public let value: Double

        @inlinable
        public init(currency: String, estimate: Bool, range: Bool, rangeValue: RouteTollPriceValueRange? = nil, value: Double) {
            self.currency = currency
            self.estimate = estimate
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "Currency"
            case estimate = "Estimate"
            case range = "Range"
            case rangeValue = "RangeValue"
            case value = "Value"
        }
    }

    public struct RouteTollPriceValueRange: AWSDecodableShape {
        /// Maximum price.
        public let max: Double
        /// Minimum price.
        public let min: Double

        @inlinable
        public init(max: Double, min: Double) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct RouteTollRate: AWSDecodableShape {
        /// Time when the rate is valid.
        public let applicableTimes: String?
        /// Price in the converted currency as specified in the request.
        public let convertedPrice: RouteTollPrice?
        /// The Toll rate Id.
        public let id: String
        /// Price in the local regional currency.
        public let localPrice: RouteTollPrice
        /// The name of the toll.
        public let name: String
        /// Details if the toll rate can be a pass that supports multiple trips.
        public let pass: RouteTollPass?
        /// Accepted payment methods at the toll.
        public let paymentMethods: [RouteTollPaymentMethod]
        /// Transponders for which this toll can be applied.
        public let transponders: [RouteTransponder]

        @inlinable
        public init(applicableTimes: String? = nil, convertedPrice: RouteTollPrice? = nil, id: String, localPrice: RouteTollPrice, name: String, pass: RouteTollPass? = nil, paymentMethods: [RouteTollPaymentMethod], transponders: [RouteTransponder]) {
            self.applicableTimes = applicableTimes
            self.convertedPrice = convertedPrice
            self.id = id
            self.localPrice = localPrice
            self.name = name
            self.pass = pass
            self.paymentMethods = paymentMethods
            self.transponders = transponders
        }

        private enum CodingKeys: String, CodingKey {
            case applicableTimes = "ApplicableTimes"
            case convertedPrice = "ConvertedPrice"
            case id = "Id"
            case localPrice = "LocalPrice"
            case name = "Name"
            case pass = "Pass"
            case paymentMethods = "PaymentMethods"
            case transponders = "Transponders"
        }
    }

    public struct RouteTollSummary: AWSDecodableShape {
        /// Total toll summary for the complete route. Total is the only summary available today.
        public let total: RouteTollPriceSummary?

        @inlinable
        public init(total: RouteTollPriceSummary? = nil) {
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case total = "Total"
        }
    }

    public struct RouteTollSystem: AWSDecodableShape {
        /// The toll system name.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct RouteTrafficOptions: AWSEncodableShape {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public let flowEventThresholdOverride: Int64?
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public let usage: TrafficUsage?

        @inlinable
        public init(flowEventThresholdOverride: Int64? = nil, usage: TrafficUsage? = nil) {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }

        public func validate(name: String) throws {
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, max: 4294967295)
            try self.validate(self.flowEventThresholdOverride, name: "flowEventThresholdOverride", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case flowEventThresholdOverride = "FlowEventThresholdOverride"
            case usage = "Usage"
        }
    }

    public struct RouteTrailerOptions: AWSEncodableShape {
        /// Total number of axles of the vehicle.
        public let axleCount: Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: Int?

        @inlinable
        public init(axleCount: Int? = nil, trailerCount: Int? = nil) {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }

        private enum CodingKeys: String, CodingKey {
            case axleCount = "AxleCount"
            case trailerCount = "TrailerCount"
        }
    }

    public struct RouteTransponder: AWSDecodableShape {
        /// Names of the toll system collecting the toll.
        public let systemName: String?

        @inlinable
        public init(systemName: String? = nil) {
            self.systemName = systemName
        }

        private enum CodingKeys: String, CodingKey {
            case systemName = "SystemName"
        }
    }

    public struct RouteTravelModeOptions: AWSEncodableShape {
        /// Travel mode options when the provided travel mode is "Car"
        public let car: RouteCarOptions?
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public let pedestrian: RoutePedestrianOptions?
        /// Travel mode options when the provided travel mode is Scooter   When travel mode is set to Scooter, then the avoidance option ControlledAccessHighways defaults to true.
        public let scooter: RouteScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public let truck: RouteTruckOptions?

        @inlinable
        public init(car: RouteCarOptions? = nil, pedestrian: RoutePedestrianOptions? = nil, scooter: RouteScooterOptions? = nil, truck: RouteTruckOptions? = nil) {
            self.car = car
            self.pedestrian = pedestrian
            self.scooter = scooter
            self.truck = truck
        }

        public func validate(name: String) throws {
            try self.car?.validate(name: "\(name).car")
            try self.pedestrian?.validate(name: "\(name).pedestrian")
            try self.scooter?.validate(name: "\(name).scooter")
            try self.truck?.validate(name: "\(name).truck")
        }

        private enum CodingKeys: String, CodingKey {
            case car = "Car"
            case pedestrian = "Pedestrian"
            case scooter = "Scooter"
            case truck = "Truck"
        }
    }

    public struct RouteTruckOptions: AWSEncodableShape {
        /// Total number of axles of the vehicle.
        public let axleCount: Int?
        /// Engine type of the vehicle.
        public let engineType: RouteEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity.  Unit: Kilograms
        public let grossWeight: Int64?
        /// List of Hazardous cargo contained in the vehicle.
        public let hazardousCargos: [RouteHazardousCargoType]?
        /// Height of the vehicle.  Unit: centimeters
        public let height: Int64?
        /// Height of the vehicle above its first axle.  Unit: centimeters
        public let heightAboveFirstAxle: Int64?
        /// Kingpin to rear axle length of the vehicle.  Unit: centimeters
        public let kpraLength: Int64?
        /// Length of the vehicle.  Unit: c
        public let length: Int64?
        /// The vehicle License Plate.
        public let licensePlate: RouteVehicleLicensePlate?
        /// Maximum speed  Unit: KilometersPerHour
        public let maxSpeed: Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: Int?
        /// Payload capacity of the vehicle and trailers attached.  Unit: kilograms
        public let payloadCapacity: Int64?
        /// Number of tires on the vehicle.
        public let tireCount: Int?
        /// Trailer options corresponding to the vehicle.
        public let trailer: RouteTrailerOptions?
        /// Type of the truck.
        public let truckType: RouteTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished.  Unit: Kilograms
        public let weightPerAxle: Int64?
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.  Unit: Kilograms
        public let weightPerAxleGroup: WeightPerAxleGroup?
        /// Width of the vehicle.  Unit: centimeters
        public let width: Int64?

        @inlinable
        public init(axleCount: Int? = nil, engineType: RouteEngineType? = nil, grossWeight: Int64? = nil, hazardousCargos: [RouteHazardousCargoType]? = nil, height: Int64? = nil, heightAboveFirstAxle: Int64? = nil, kpraLength: Int64? = nil, length: Int64? = nil, licensePlate: RouteVehicleLicensePlate? = nil, maxSpeed: Double? = nil, occupancy: Int? = nil, payloadCapacity: Int64? = nil, tireCount: Int? = nil, trailer: RouteTrailerOptions? = nil, truckType: RouteTruckType? = nil, tunnelRestrictionCode: String? = nil, weightPerAxle: Int64? = nil, weightPerAxleGroup: WeightPerAxleGroup? = nil, width: Int64? = nil) {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, max: 4294967295)
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, min: 0)
            try self.validate(self.hazardousCargos, name: "hazardousCargos", parent: name, max: 11)
            try self.validate(self.height, name: "height", parent: name, max: 4294967295)
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.heightAboveFirstAxle, name: "heightAboveFirstAxle", parent: name, max: 4294967295)
            try self.validate(self.heightAboveFirstAxle, name: "heightAboveFirstAxle", parent: name, min: 0)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, max: 4294967295)
            try self.validate(self.kpraLength, name: "kpraLength", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, max: 4294967295)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.maxSpeed, name: "maxSpeed", parent: name, min: 0.0)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, max: 4294967295)
            try self.validate(self.payloadCapacity, name: "payloadCapacity", parent: name, min: 0)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, max: 1)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, min: 1)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, max: 4294967295)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, min: 0)
            try self.weightPerAxleGroup?.validate(name: "\(name).weightPerAxleGroup")
            try self.validate(self.width, name: "width", parent: name, max: 4294967295)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case axleCount = "AxleCount"
            case engineType = "EngineType"
            case grossWeight = "GrossWeight"
            case hazardousCargos = "HazardousCargos"
            case height = "Height"
            case heightAboveFirstAxle = "HeightAboveFirstAxle"
            case kpraLength = "KpraLength"
            case length = "Length"
            case licensePlate = "LicensePlate"
            case maxSpeed = "MaxSpeed"
            case occupancy = "Occupancy"
            case payloadCapacity = "PayloadCapacity"
            case tireCount = "TireCount"
            case trailer = "Trailer"
            case truckType = "TruckType"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
            case weightPerAxle = "WeightPerAxle"
            case weightPerAxleGroup = "WeightPerAxleGroup"
            case width = "Width"
        }
    }

    public struct RouteTurnStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteUTurnStepDetails: AWSDecodableShape {
        /// Name of the intersection, if applicable to the step.
        public let intersection: [LocalizedString]
        /// Steering direction for the step.
        public let steeringDirection: RouteSteeringDirection?
        /// Angle of the turn.
        public let turnAngle: Double?
        /// Intensity of the turn.
        public let turnIntensity: RouteTurnIntensity?

        @inlinable
        public init(intersection: [LocalizedString], steeringDirection: RouteSteeringDirection? = nil, turnAngle: Double? = nil, turnIntensity: RouteTurnIntensity? = nil) {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }

        private enum CodingKeys: String, CodingKey {
            case intersection = "Intersection"
            case steeringDirection = "SteeringDirection"
            case turnAngle = "TurnAngle"
            case turnIntensity = "TurnIntensity"
        }
    }

    public struct RouteVehicleArrival: AWSDecodableShape {
        /// The place details.
        public let place: RouteVehiclePlace
        /// The time.
        public let time: String?

        @inlinable
        public init(place: RouteVehiclePlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RouteVehicleDeparture: AWSDecodableShape {
        /// The place details.
        public let place: RouteVehiclePlace
        /// The departure time.
        public let time: String?

        @inlinable
        public init(place: RouteVehiclePlace, time: String? = nil) {
            self.place = place
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
            case time = "Time"
        }
    }

    public struct RouteVehicleIncident: AWSDecodableShape {
        /// Brief readable description of the incident.
        public let description: String?
        /// End timestamp of the incident.
        public let endTime: String?
        /// Severity of the incident Critical - The part of the route the incident affects is unusable. Major- Major impact on the leg duration, for example stop and go Minor- Minor impact on the leg duration, for example traffic jam Low - Low on duration, for example slightly increased traffic
        public let severity: RouteVehicleIncidentSeverity?
        /// Start time of the incident.
        public let startTime: String?
        /// Type of the incident.
        public let type: RouteVehicleIncidentType?

        @inlinable
        public init(description: String? = nil, endTime: String? = nil, severity: RouteVehicleIncidentSeverity? = nil, startTime: String? = nil, type: RouteVehicleIncidentType? = nil) {
            self.description = description
            self.endTime = endTime
            self.severity = severity
            self.startTime = startTime
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endTime = "EndTime"
            case severity = "Severity"
            case startTime = "StartTime"
            case type = "Type"
        }
    }

    public struct RouteVehicleLegDetails: AWSDecodableShape {
        /// Details corresponding to the arrival for the leg.
        public let arrival: RouteVehicleArrival
        /// Details corresponding to the departure for the leg.
        public let departure: RouteVehicleDeparture
        /// Incidents corresponding to this leg of the route.
        public let incidents: [RouteVehicleIncident]
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [RouteVehicleNotice]
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        public let passThroughWaypoints: [RoutePassThroughWaypoint]
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        public let spans: [RouteVehicleSpan]
        /// Summarized details of the leg.
        public let summary: RouteVehicleSummary?
        /// Toll related options.
        public let tolls: [RouteToll]
        /// Toll systems are authorities that collect payments for the toll.
        public let tollSystems: [RouteTollSystem]
        /// Steps of a leg that must be performed before the travel portion of the leg.
        public let travelSteps: [RouteVehicleTravelStep]
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadTypes: [String]
        /// Zones corresponding to this leg of the route.
        public let zones: [RouteZone]

        @inlinable
        public init(arrival: RouteVehicleArrival, departure: RouteVehicleDeparture, incidents: [RouteVehicleIncident], notices: [RouteVehicleNotice], passThroughWaypoints: [RoutePassThroughWaypoint], spans: [RouteVehicleSpan], summary: RouteVehicleSummary? = nil, tolls: [RouteToll], tollSystems: [RouteTollSystem], travelSteps: [RouteVehicleTravelStep], truckRoadTypes: [String], zones: [RouteZone]) {
            self.arrival = arrival
            self.departure = departure
            self.incidents = incidents
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.tolls = tolls
            self.tollSystems = tollSystems
            self.travelSteps = travelSteps
            self.truckRoadTypes = truckRoadTypes
            self.zones = zones
        }

        private enum CodingKeys: String, CodingKey {
            case arrival = "Arrival"
            case departure = "Departure"
            case incidents = "Incidents"
            case notices = "Notices"
            case passThroughWaypoints = "PassThroughWaypoints"
            case spans = "Spans"
            case summary = "Summary"
            case tolls = "Tolls"
            case tollSystems = "TollSystems"
            case travelSteps = "TravelSteps"
            case truckRoadTypes = "TruckRoadTypes"
            case zones = "Zones"
        }
    }

    public struct RouteVehicleLicensePlate: AWSEncodableShape {
        /// The last character of the License Plate.
        public let lastCharacter: String?

        @inlinable
        public init(lastCharacter: String? = nil) {
            self.lastCharacter = lastCharacter
        }

        private enum CodingKeys: String, CodingKey {
            case lastCharacter = "LastCharacter"
        }
    }

    public struct RouteVehicleNotice: AWSDecodableShape {
        /// Code corresponding to the issue.
        public let code: RouteVehicleNoticeCode
        /// Additional details of the notice.
        public let details: [RouteVehicleNoticeDetail]
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public let impact: RouteNoticeImpact?

        @inlinable
        public init(code: RouteVehicleNoticeCode, details: [RouteVehicleNoticeDetail], impact: RouteNoticeImpact? = nil) {
            self.code = code
            self.details = details
            self.impact = impact
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case details = "Details"
            case impact = "Impact"
        }
    }

    public struct RouteVehicleNoticeDetail: AWSDecodableShape {
        /// The notice title.
        public let title: String?
        /// Any violated constraints.
        public let violatedConstraints: RouteViolatedConstraints?

        @inlinable
        public init(title: String? = nil, violatedConstraints: RouteViolatedConstraints? = nil) {
            self.title = title
            self.violatedConstraints = violatedConstraints
        }

        private enum CodingKeys: String, CodingKey {
            case title = "Title"
            case violatedConstraints = "ViolatedConstraints"
        }
    }

    public struct RouteVehicleOverviewSummary: AWSDecodableShape {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg.  Unit: seconds
        public let bestCaseDuration: Int64?
        /// Distance of the step.
        public let distance: Int64
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Duration of the computed span under typical traffic congestion.   Unit: seconds
        public let typicalDuration: Int64?

        @inlinable
        public init(bestCaseDuration: Int64? = nil, distance: Int64, duration: Int64, typicalDuration: Int64? = nil) {
            self.bestCaseDuration = bestCaseDuration
            self.distance = distance
            self.duration = duration
            self.typicalDuration = typicalDuration
        }

        private enum CodingKeys: String, CodingKey {
            case bestCaseDuration = "BestCaseDuration"
            case distance = "Distance"
            case duration = "Duration"
            case typicalDuration = "TypicalDuration"
        }
    }

    public struct RouteVehiclePlace: AWSDecodableShape {
        /// The name of the place.
        public let name: String?
        /// Position provided in the request.
        public let originalPosition: [Double]?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteSideOfStreet?
        /// Index of the waypoint in the request.
        public let waypointIndex: Int?

        @inlinable
        public init(name: String? = nil, originalPosition: [Double]? = nil, position: [Double], sideOfStreet: RouteSideOfStreet? = nil, waypointIndex: Int? = nil) {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case originalPosition = "OriginalPosition"
            case position = "Position"
            case sideOfStreet = "SideOfStreet"
            case waypointIndex = "WaypointIndex"
        }
    }

    public struct RouteVehicleSpan: AWSDecodableShape {
        /// Duration of the computed span without traffic congestion.  Unit: seconds
        public let bestCaseDuration: Int64?
        /// Access attributes for a car corresponding to the span.
        public let carAccess: [RouteSpanCarAccessAttribute]?
        /// 3 letter Country code corresponding to the Span.
        public let country: String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.
        public let distance: Int64?
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.  Unit: seconds
        public let duration: Int64?
        /// Dynamic speed details corresponding to the span.  Unit: KilometersPerHour
        public let dynamicSpeed: RouteSpanDynamicSpeedDetails?
        /// Functional classification of the road segment corresponding to the span.
        public let functionalClassification: Int?
        /// Attributes corresponding to a gate. The gate is present at the end of the returned span.
        public let gate: RouteSpanGateAttribute?
        /// Offset in the leg geometry corresponding to the start of this span.
        public let geometryOffset: Int?
        /// Incidents corresponding to the span. These index into the Incidents in the parent Leg.
        public let incidents: [Int]?
        /// Provides an array of names of the vehicle span in available languages.
        public let names: [LocalizedString]?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [Int]?
        /// Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.
        public let railwayCrossing: RouteSpanRailwayCrossingAttribute?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public let region: String?
        /// Attributes for the road segment corresponding to the span.
        public let roadAttributes: [RouteSpanRoadAttribute]?
        /// Designated route name or number corresponding to the span.
        public let routeNumbers: [RouteNumber]?
        /// Access attributes for a scooter corresponding to the span.
        public let scooterAccess: [RouteSpanScooterAccessAttribute]?
        /// Speed limit details corresponding to the span.  Unit: KilometersPerHour
        public let speedLimit: RouteSpanSpeedLimitDetails?
        /// Toll systems are authorities that collect payments for the toll.
        public let tollSystems: [Int]?
        /// Access attributes for a truck corresponding to the span.
        public let truckAccess: [RouteSpanTruckAccessAttribute]?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadTypes: [Int]?
        /// Duration of the computed span under typical traffic congestion.   Unit: seconds
        public let typicalDuration: Int64?
        /// Zones corresponding to this leg of the route.
        public let zones: [Int]?

        @inlinable
        public init(bestCaseDuration: Int64? = nil, carAccess: [RouteSpanCarAccessAttribute]? = nil, country: String? = nil, distance: Int64? = nil, duration: Int64? = nil, dynamicSpeed: RouteSpanDynamicSpeedDetails? = nil, functionalClassification: Int? = nil, gate: RouteSpanGateAttribute? = nil, geometryOffset: Int? = nil, incidents: [Int]? = nil, names: [LocalizedString]? = nil, notices: [Int]? = nil, railwayCrossing: RouteSpanRailwayCrossingAttribute? = nil, region: String? = nil, roadAttributes: [RouteSpanRoadAttribute]? = nil, routeNumbers: [RouteNumber]? = nil, scooterAccess: [RouteSpanScooterAccessAttribute]? = nil, speedLimit: RouteSpanSpeedLimitDetails? = nil, tollSystems: [Int]? = nil, truckAccess: [RouteSpanTruckAccessAttribute]? = nil, truckRoadTypes: [Int]? = nil, typicalDuration: Int64? = nil, zones: [Int]? = nil) {
            self.bestCaseDuration = bestCaseDuration
            self.carAccess = carAccess
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.gate = gate
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.notices = notices
            self.railwayCrossing = railwayCrossing
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.scooterAccess = scooterAccess
            self.speedLimit = speedLimit
            self.tollSystems = tollSystems
            self.truckAccess = truckAccess
            self.truckRoadTypes = truckRoadTypes
            self.typicalDuration = typicalDuration
            self.zones = zones
        }

        private enum CodingKeys: String, CodingKey {
            case bestCaseDuration = "BestCaseDuration"
            case carAccess = "CarAccess"
            case country = "Country"
            case distance = "Distance"
            case duration = "Duration"
            case dynamicSpeed = "DynamicSpeed"
            case functionalClassification = "FunctionalClassification"
            case gate = "Gate"
            case geometryOffset = "GeometryOffset"
            case incidents = "Incidents"
            case names = "Names"
            case notices = "Notices"
            case railwayCrossing = "RailwayCrossing"
            case region = "Region"
            case roadAttributes = "RoadAttributes"
            case routeNumbers = "RouteNumbers"
            case scooterAccess = "ScooterAccess"
            case speedLimit = "SpeedLimit"
            case tollSystems = "TollSystems"
            case truckAccess = "TruckAccess"
            case truckRoadTypes = "TruckRoadTypes"
            case typicalDuration = "TypicalDuration"
            case zones = "Zones"
        }
    }

    public struct RouteVehicleSummary: AWSDecodableShape {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public let overview: RouteVehicleOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public let travelOnly: RouteVehicleTravelOnlySummary?

        @inlinable
        public init(overview: RouteVehicleOverviewSummary? = nil, travelOnly: RouteVehicleTravelOnlySummary? = nil) {
            self.overview = overview
            self.travelOnly = travelOnly
        }

        private enum CodingKeys: String, CodingKey {
            case overview = "Overview"
            case travelOnly = "TravelOnly"
        }
    }

    public struct RouteVehicleTravelOnlySummary: AWSDecodableShape {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg.  Unit: seconds
        public let bestCaseDuration: Int64?
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Duration of the computed span under typical traffic congestion.  Unit: seconds
        public let typicalDuration: Int64?

        @inlinable
        public init(bestCaseDuration: Int64? = nil, duration: Int64, typicalDuration: Int64? = nil) {
            self.bestCaseDuration = bestCaseDuration
            self.duration = duration
            self.typicalDuration = typicalDuration
        }

        private enum CodingKeys: String, CodingKey {
            case bestCaseDuration = "BestCaseDuration"
            case duration = "Duration"
            case typicalDuration = "TypicalDuration"
        }
    }

    public struct RouteVehicleTravelStep: AWSDecodableShape {
        /// Details that are specific to a Continue Highway step.
        public let continueHighwayStepDetails: RouteContinueHighwayStepDetails?
        /// Details that are specific to a Continue step.
        public let continueStepDetails: RouteContinueStepDetails?
        /// Details of the current road.
        public let currentRoad: RouteRoad?
        /// Distance of the step.
        public let distance: Int64?
        /// Duration of the step.  Unit: seconds
        public let duration: Int64
        /// Details that are specific to a Enter Highway step.
        public let enterHighwayStepDetails: RouteEnterHighwayStepDetails?
        /// Exit number of the road exit, if applicable.
        public let exitNumber: [LocalizedString]?
        /// Details that are specific to a Roundabout Exit step.
        public let exitStepDetails: RouteExitStepDetails?
        /// Offset in the leg geometry corresponding to the start of this step.
        public let geometryOffset: Int?
        /// Brief description of the step in the requested language.  Only available when the TravelStepType is Default.
        public let instruction: String?
        /// Details that are specific to a Keep step.
        public let keepStepDetails: RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public let nextRoad: RouteRoad?
        /// Details that are specific to a Ramp step.
        public let rampStepDetails: RouteRampStepDetails?
        /// Details that are specific to a Roundabout Enter step.
        public let roundaboutEnterStepDetails: RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public let roundaboutExitStepDetails: RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public let roundaboutPassStepDetails: RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public let signpost: RouteSignpost?
        /// Details that are specific to a Turn step.
        public let turnStepDetails: RouteTurnStepDetails?
        /// Type of the step.
        public let type: RouteVehicleTravelStepType
        /// Details that are specific to a Turn step.
        public let uTurnStepDetails: RouteUTurnStepDetails?

        @inlinable
        public init(continueHighwayStepDetails: RouteContinueHighwayStepDetails? = nil, continueStepDetails: RouteContinueStepDetails? = nil, currentRoad: RouteRoad? = nil, distance: Int64? = nil, duration: Int64, enterHighwayStepDetails: RouteEnterHighwayStepDetails? = nil, exitNumber: [LocalizedString]? = nil, exitStepDetails: RouteExitStepDetails? = nil, geometryOffset: Int? = nil, instruction: String? = nil, keepStepDetails: RouteKeepStepDetails? = nil, nextRoad: RouteRoad? = nil, rampStepDetails: RouteRampStepDetails? = nil, roundaboutEnterStepDetails: RouteRoundaboutEnterStepDetails? = nil, roundaboutExitStepDetails: RouteRoundaboutExitStepDetails? = nil, roundaboutPassStepDetails: RouteRoundaboutPassStepDetails? = nil, signpost: RouteSignpost? = nil, turnStepDetails: RouteTurnStepDetails? = nil, type: RouteVehicleTravelStepType, uTurnStepDetails: RouteUTurnStepDetails? = nil) {
            self.continueHighwayStepDetails = continueHighwayStepDetails
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.enterHighwayStepDetails = enterHighwayStepDetails
            self.exitNumber = exitNumber
            self.exitStepDetails = exitStepDetails
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.rampStepDetails = rampStepDetails
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
            self.uTurnStepDetails = uTurnStepDetails
        }

        private enum CodingKeys: String, CodingKey {
            case continueHighwayStepDetails = "ContinueHighwayStepDetails"
            case continueStepDetails = "ContinueStepDetails"
            case currentRoad = "CurrentRoad"
            case distance = "Distance"
            case duration = "Duration"
            case enterHighwayStepDetails = "EnterHighwayStepDetails"
            case exitNumber = "ExitNumber"
            case exitStepDetails = "ExitStepDetails"
            case geometryOffset = "GeometryOffset"
            case instruction = "Instruction"
            case keepStepDetails = "KeepStepDetails"
            case nextRoad = "NextRoad"
            case rampStepDetails = "RampStepDetails"
            case roundaboutEnterStepDetails = "RoundaboutEnterStepDetails"
            case roundaboutExitStepDetails = "RoundaboutExitStepDetails"
            case roundaboutPassStepDetails = "RoundaboutPassStepDetails"
            case signpost = "Signpost"
            case turnStepDetails = "TurnStepDetails"
            case type = "Type"
            case uTurnStepDetails = "UTurnStepDetails"
        }
    }

    public struct RouteViolatedConstraints: AWSDecodableShape {
        /// This restriction applies to truck cargo, where the resulting route excludes roads on which hazardous materials are prohibited from being transported.
        public let allHazardsRestricted: Bool?
        /// Total number of axles of the vehicle.
        public let axleCount: RouteNoticeDetailRange?
        /// List of Hazardous cargo contained in the vehicle.
        public let hazardousCargos: [RouteHazardousCargoType]
        /// The maximum height of the vehicle.
        public let maxHeight: Int64?
        /// The maximum Kpra length of the vehicle.  Unit: centimeters
        public let maxKpraLength: Int64?
        /// The maximum length of the vehicle.
        public let maxLength: Int64?
        /// The maximum load capacity of the vehicle.  Unit: kilograms
        public let maxPayloadCapacity: Int64?
        /// The maximum weight of the route.  Unit: Kilograms
        public let maxWeight: RouteWeightConstraint?
        /// The maximum weight per axle of the vehicle.  Unit: Kilograms
        public let maxWeightPerAxle: Int64?
        /// The maximum weight per axle group of the vehicle.  Unit: Kilograms
        public let maxWeightPerAxleGroup: WeightPerAxleGroup?
        /// The maximum width of the vehicle.
        public let maxWidth: Int64?
        /// The number of occupants in the vehicle. Default Value: 1
        public let occupancy: RouteNoticeDetailRange?
        /// Access radius restrictions based on time.
        public let restrictedTimes: String?
        /// The time dependent constraint.
        public let timeDependent: Bool?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: RouteNoticeDetailRange?
        /// Travel mode corresponding to the leg.
        public let travelMode: Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico.  There are currently no other supported values as of 26th April 2024.
        public let truckRoadType: String?
        /// Type of the truck.
        public let truckType: RouteTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?

        @inlinable
        public init(allHazardsRestricted: Bool? = nil, axleCount: RouteNoticeDetailRange? = nil, hazardousCargos: [RouteHazardousCargoType], maxHeight: Int64? = nil, maxKpraLength: Int64? = nil, maxLength: Int64? = nil, maxPayloadCapacity: Int64? = nil, maxWeight: RouteWeightConstraint? = nil, maxWeightPerAxle: Int64? = nil, maxWeightPerAxleGroup: WeightPerAxleGroup? = nil, maxWidth: Int64? = nil, occupancy: RouteNoticeDetailRange? = nil, restrictedTimes: String? = nil, timeDependent: Bool? = nil, trailerCount: RouteNoticeDetailRange? = nil, travelMode: Bool? = nil, truckRoadType: String? = nil, truckType: RouteTruckType? = nil, tunnelRestrictionCode: String? = nil) {
            self.allHazardsRestricted = allHazardsRestricted
            self.axleCount = axleCount
            self.hazardousCargos = hazardousCargos
            self.maxHeight = maxHeight
            self.maxKpraLength = maxKpraLength
            self.maxLength = maxLength
            self.maxPayloadCapacity = maxPayloadCapacity
            self.maxWeight = maxWeight
            self.maxWeightPerAxle = maxWeightPerAxle
            self.maxWeightPerAxleGroup = maxWeightPerAxleGroup
            self.maxWidth = maxWidth
            self.occupancy = occupancy
            self.restrictedTimes = restrictedTimes
            self.timeDependent = timeDependent
            self.trailerCount = trailerCount
            self.travelMode = travelMode
            self.truckRoadType = truckRoadType
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
        }

        private enum CodingKeys: String, CodingKey {
            case allHazardsRestricted = "AllHazardsRestricted"
            case axleCount = "AxleCount"
            case hazardousCargos = "HazardousCargos"
            case maxHeight = "MaxHeight"
            case maxKpraLength = "MaxKpraLength"
            case maxLength = "MaxLength"
            case maxPayloadCapacity = "MaxPayloadCapacity"
            case maxWeight = "MaxWeight"
            case maxWeightPerAxle = "MaxWeightPerAxle"
            case maxWeightPerAxleGroup = "MaxWeightPerAxleGroup"
            case maxWidth = "MaxWidth"
            case occupancy = "Occupancy"
            case restrictedTimes = "RestrictedTimes"
            case timeDependent = "TimeDependent"
            case trailerCount = "TrailerCount"
            case travelMode = "TravelMode"
            case truckRoadType = "TruckRoadType"
            case truckType = "TruckType"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
        }
    }

    public struct RouteWaypoint: AWSEncodableShape {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public let avoidActionsForDistance: Int64?
        /// Avoid U-turns for calculation on highways and motorways.
        public let avoidUTurns: Bool?
        /// GPS Heading at the position.
        public let heading: Double?
        /// Options to configure matching the provided position to the road network.
        public let matching: RouteMatchingOptions?
        /// If the waypoint should not be treated as a stop. If yes, the waypoint is passed through and doesn't split the route into different legs.
        public let passThrough: Bool?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: RouteSideOfStreetOptions?
        /// Duration of the stop.  Unit: seconds
        public let stopDuration: Int64?

        @inlinable
        public init(avoidActionsForDistance: Int64? = nil, avoidUTurns: Bool? = nil, heading: Double? = nil, matching: RouteMatchingOptions? = nil, passThrough: Bool? = nil, position: [Double], sideOfStreet: RouteSideOfStreetOptions? = nil, stopDuration: Int64? = nil) {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.passThrough = passThrough
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }

        public func validate(name: String) throws {
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, max: 4294967295)
            try self.validate(self.avoidActionsForDistance, name: "avoidActionsForDistance", parent: name, min: 0)
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.matching?.validate(name: "\(name).matching")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
            try self.validate(self.stopDuration, name: "stopDuration", parent: name, max: 4294967295)
            try self.validate(self.stopDuration, name: "stopDuration", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case avoidActionsForDistance = "AvoidActionsForDistance"
            case avoidUTurns = "AvoidUTurns"
            case heading = "Heading"
            case matching = "Matching"
            case passThrough = "PassThrough"
            case position = "Position"
            case sideOfStreet = "SideOfStreet"
            case stopDuration = "StopDuration"
        }
    }

    public struct RouteWeightConstraint: AWSDecodableShape {
        /// The type of constraint.
        public let type: RouteWeightConstraintType
        /// The constraint value.  Unit: Kilograms
        public let value: Int64

        @inlinable
        public init(type: RouteWeightConstraintType, value: Int64) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct RouteZone: AWSDecodableShape {
        /// The zone category.
        public let category: RouteZoneCategory?
        /// The name of the zone.
        public let name: String?

        @inlinable
        public init(category: RouteZoneCategory? = nil, name: String? = nil) {
            self.category = category
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case name = "Name"
        }
    }

    public struct SnapToRoadsRequest: AWSEncodableShape {
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Chooses what the returned SnappedGeometry format should be. Default Value: FlexiblePolyline
        public let snappedGeometryFormat: GeometryFormat?
        /// The radius around the provided tracepoint that is considered for snapping.  Unit: meters  Default value: 300
        public let snapRadius: Int64?
        /// List of trace points to be snapped onto the road network.
        public let tracePoints: [RoadSnapTracePoint]
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        public let travelMode: RoadSnapTravelMode?
        /// Travel mode related options for the provided travel mode.
        public let travelModeOptions: RoadSnapTravelModeOptions?

        @inlinable
        public init(key: String? = nil, snappedGeometryFormat: GeometryFormat? = nil, snapRadius: Int64? = nil, tracePoints: [RoadSnapTracePoint], travelMode: RoadSnapTravelMode? = nil, travelModeOptions: RoadSnapTravelModeOptions? = nil) {
            self.key = key
            self.snappedGeometryFormat = snappedGeometryFormat
            self.snapRadius = snapRadius
            self.tracePoints = tracePoints
            self.travelMode = travelMode
            self.travelModeOptions = travelModeOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.snappedGeometryFormat, forKey: .snappedGeometryFormat)
            try container.encodeIfPresent(self.snapRadius, forKey: .snapRadius)
            try container.encode(self.tracePoints, forKey: .tracePoints)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.travelModeOptions, forKey: .travelModeOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.snapRadius, name: "snapRadius", parent: name, max: 4294967295)
            try self.validate(self.snapRadius, name: "snapRadius", parent: name, min: 0)
            try self.tracePoints.forEach {
                try $0.validate(name: "\(name).tracePoints[]")
            }
            try self.travelModeOptions?.validate(name: "\(name).travelModeOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case snappedGeometryFormat = "SnappedGeometryFormat"
            case snapRadius = "SnapRadius"
            case tracePoints = "TracePoints"
            case travelMode = "TravelMode"
            case travelModeOptions = "TravelModeOptions"
        }
    }

    public struct SnapToRoadsResponse: AWSDecodableShape {
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public let notices: [RoadSnapNotice]
        /// The pricing bucket for which the query is charged at.
        public let pricingBucket: String
        /// The interpolated geometry for the snapped route onto the road network.
        public let snappedGeometry: RoadSnapSnappedGeometry?
        /// Specifies the format of the geometry returned for each leg of the route.
        public let snappedGeometryFormat: GeometryFormat
        /// The trace points snapped onto the road network.
        public let snappedTracePoints: [RoadSnapSnappedTracePoint]

        @inlinable
        public init(notices: [RoadSnapNotice], pricingBucket: String, snappedGeometry: RoadSnapSnappedGeometry? = nil, snappedGeometryFormat: GeometryFormat, snappedTracePoints: [RoadSnapSnappedTracePoint]) {
            self.notices = notices
            self.pricingBucket = pricingBucket
            self.snappedGeometry = snappedGeometry
            self.snappedGeometryFormat = snappedGeometryFormat
            self.snappedTracePoints = snappedTracePoints
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.notices = try container.decode([RoadSnapNotice].self, forKey: .notices)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.snappedGeometry = try container.decodeIfPresent(RoadSnapSnappedGeometry.self, forKey: .snappedGeometry)
            self.snappedGeometryFormat = try container.decode(GeometryFormat.self, forKey: .snappedGeometryFormat)
            self.snappedTracePoints = try container.decode([RoadSnapSnappedTracePoint].self, forKey: .snappedTracePoints)
        }

        private enum CodingKeys: String, CodingKey {
            case notices = "Notices"
            case snappedGeometry = "SnappedGeometry"
            case snappedGeometryFormat = "SnappedGeometryFormat"
            case snappedTracePoints = "SnappedTracePoints"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field where the invalid entry was detected.
        public let fieldList: [ValidationExceptionField]
        public let message: String
        /// A message with the reason for the validation exception error.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField], message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The error message.
        public let message: String
        /// The name of the Validation Exception Field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WaypointOptimizationAccessHours: AWSEncodableShape {
        /// Contains the ID of the starting waypoint in this connection.
        public let from: WaypointOptimizationAccessHoursEntry
        /// Contains the ID of the ending waypoint in this connection.
        public let to: WaypointOptimizationAccessHoursEntry

        @inlinable
        public init(from: WaypointOptimizationAccessHoursEntry, to: WaypointOptimizationAccessHoursEntry) {
            self.from = from
            self.to = to
        }

        public func validate(name: String) throws {
            try self.from.validate(name: "\(name).from")
            try self.to.validate(name: "\(name).to")
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct WaypointOptimizationAccessHoursEntry: AWSEncodableShape {
        /// Day of the week.
        public let dayOfWeek: DayOfWeek
        /// Time of the day.
        public let timeOfDay: String

        @inlinable
        public init(dayOfWeek: DayOfWeek, timeOfDay: String) {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
        }

        public func validate(name: String) throws {
            try self.validate(self.timeOfDay, name: "timeOfDay", parent: name, pattern: "^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](Z|[+-]([0-1]?[0-9]|2[0-3]):[0-5][0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek = "DayOfWeek"
            case timeOfDay = "TimeOfDay"
        }
    }

    public struct WaypointOptimizationAvoidanceArea: AWSEncodableShape {
        /// Geometry of the area to be avoided.
        public let geometry: WaypointOptimizationAvoidanceAreaGeometry

        @inlinable
        public init(geometry: WaypointOptimizationAvoidanceAreaGeometry) {
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
        }
    }

    public struct WaypointOptimizationAvoidanceAreaGeometry: AWSEncodableShape {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public let boundingBox: [Double]?

        @inlinable
        public init(boundingBox: [Double]? = nil) {
            self.boundingBox = boundingBox
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
        }
    }

    public struct WaypointOptimizationAvoidanceOptions: AWSEncodableShape {
        /// Areas to be avoided.
        public let areas: [WaypointOptimizationAvoidanceArea]?
        /// Avoidance options for cars-shuttles-trains.
        public let carShuttleTrains: Bool?
        /// Avoid controlled access highways while calculating the route.
        public let controlledAccessHighways: Bool?
        /// Avoid dirt roads while calculating the route.
        public let dirtRoads: Bool?
        /// Avoidance options for ferries.
        public let ferries: Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public let tollRoads: Bool?
        /// Avoid tunnels while calculating the route.
        public let tunnels: Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public let uTurns: Bool?

        @inlinable
        public init(areas: [WaypointOptimizationAvoidanceArea]? = nil, carShuttleTrains: Bool? = nil, controlledAccessHighways: Bool? = nil, dirtRoads: Bool? = nil, ferries: Bool? = nil, tollRoads: Bool? = nil, tunnels: Bool? = nil, uTurns: Bool? = nil) {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tunnels = tunnels
            self.uTurns = uTurns
        }

        public func validate(name: String) throws {
            try self.areas?.forEach {
                try $0.validate(name: "\(name).areas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case areas = "Areas"
            case carShuttleTrains = "CarShuttleTrains"
            case controlledAccessHighways = "ControlledAccessHighways"
            case dirtRoads = "DirtRoads"
            case ferries = "Ferries"
            case tollRoads = "TollRoads"
            case tunnels = "Tunnels"
            case uTurns = "UTurns"
        }
    }

    public struct WaypointOptimizationClusteringOptions: AWSEncodableShape {
        /// The algorithm to be used. DrivingDistance assigns all the waypoints that are within driving distance of each other into a single cluster. TopologySegment assigns all the waypoints that are within the same topology segment into a single cluster. A Topology segment is a linear stretch of road between two junctions.
        public let algorithm: WaypointOptimizationClusteringAlgorithm
        /// Driving distance options to be used when the clustering algorithm is DrivingDistance.
        public let drivingDistanceOptions: WaypointOptimizationDrivingDistanceOptions?

        @inlinable
        public init(algorithm: WaypointOptimizationClusteringAlgorithm, drivingDistanceOptions: WaypointOptimizationDrivingDistanceOptions? = nil) {
            self.algorithm = algorithm
            self.drivingDistanceOptions = drivingDistanceOptions
        }

        public func validate(name: String) throws {
            try self.drivingDistanceOptions?.validate(name: "\(name).drivingDistanceOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "Algorithm"
            case drivingDistanceOptions = "DrivingDistanceOptions"
        }
    }

    public struct WaypointOptimizationConnection: AWSDecodableShape {
        /// Distance of the step.
        public let distance: Int64
        /// contains the ID of the starting waypoint in this connection.
        public let from: String
        /// Resting time before the driver can continue driving.
        public let restDuration: Int64
        /// Contains the ID of the ending waypoint in this connection.
        public let to: String
        /// Total duration.  Unit: seconds
        public let travelDuration: Int64
        /// Duration of a wait step.  Unit: seconds
        public let waitDuration: Int64

        @inlinable
        public init(distance: Int64, from: String, restDuration: Int64, to: String, travelDuration: Int64, waitDuration: Int64) {
            self.distance = distance
            self.from = from
            self.restDuration = restDuration
            self.to = to
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case from = "From"
            case restDuration = "RestDuration"
            case to = "To"
            case travelDuration = "TravelDuration"
            case waitDuration = "WaitDuration"
        }
    }

    public struct WaypointOptimizationDestinationOptions: AWSEncodableShape {
        /// Access hours corresponding to when a waypoint can be visited.
        public let accessHours: WaypointOptimizationAccessHours?
        /// Appointment time at the destination.
        public let appointmentTime: String?
        /// GPS Heading at the position.
        public let heading: Double?
        /// The waypoint Id.
        public let id: String?
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration.  Unit: seconds
        public let serviceDuration: Int64?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: WaypointOptimizationSideOfStreetOptions?

        @inlinable
        public init(accessHours: WaypointOptimizationAccessHours? = nil, appointmentTime: String? = nil, heading: Double? = nil, id: String? = nil, serviceDuration: Int64? = nil, sideOfStreet: WaypointOptimizationSideOfStreetOptions? = nil) {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.heading = heading
            self.id = id
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.accessHours?.validate(name: "\(name).accessHours")
            try self.validate(self.appointmentTime, name: "appointmentTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.serviceDuration, name: "serviceDuration", parent: name, max: 4294967295)
            try self.validate(self.serviceDuration, name: "serviceDuration", parent: name, min: 0)
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case accessHours = "AccessHours"
            case appointmentTime = "AppointmentTime"
            case heading = "Heading"
            case id = "Id"
            case serviceDuration = "ServiceDuration"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct WaypointOptimizationDriverOptions: AWSEncodableShape {
        /// Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.
        public let restCycles: WaypointOptimizationRestCycles?
        /// Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.
        public let restProfile: WaypointOptimizationRestProfile?
        /// If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.
        public let treatServiceTimeAs: WaypointOptimizationServiceTimeTreatment?

        @inlinable
        public init(restCycles: WaypointOptimizationRestCycles? = nil, restProfile: WaypointOptimizationRestProfile? = nil, treatServiceTimeAs: WaypointOptimizationServiceTimeTreatment? = nil) {
            self.restCycles = restCycles
            self.restProfile = restProfile
            self.treatServiceTimeAs = treatServiceTimeAs
        }

        public func validate(name: String) throws {
            try self.restCycles?.validate(name: "\(name).restCycles")
        }

        private enum CodingKeys: String, CodingKey {
            case restCycles = "RestCycles"
            case restProfile = "RestProfile"
            case treatServiceTimeAs = "TreatServiceTimeAs"
        }
    }

    public struct WaypointOptimizationDrivingDistanceOptions: AWSEncodableShape {
        /// DrivingDistance assigns all the waypoints that are within driving distance of each other into a single cluster.
        public let drivingDistance: Int64

        @inlinable
        public init(drivingDistance: Int64 = 0) {
            self.drivingDistance = drivingDistance
        }

        public func validate(name: String) throws {
            try self.validate(self.drivingDistance, name: "drivingDistance", parent: name, max: 4294967295)
            try self.validate(self.drivingDistance, name: "drivingDistance", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case drivingDistance = "DrivingDistance"
        }
    }

    public struct WaypointOptimizationExclusionOptions: AWSEncodableShape {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        public let countries: [String]

        @inlinable
        public init(countries: [String]) {
            self.countries = countries
        }

        public func validate(name: String) throws {
            try self.countries.forEach {
                try validate($0, name: "countries[]", parent: name, max: 3)
                try validate($0, name: "countries[]", parent: name, min: 2)
                try validate($0, name: "countries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.countries, name: "countries", parent: name, max: 100)
            try self.validate(self.countries, name: "countries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case countries = "Countries"
        }
    }

    public struct WaypointOptimizationFailedConstraint: AWSDecodableShape {
        /// The failed constraint.
        public let constraint: WaypointOptimizationConstraint?
        /// Reason for the failed constraint.
        public let reason: String?

        @inlinable
        public init(constraint: WaypointOptimizationConstraint? = nil, reason: String? = nil) {
            self.constraint = constraint
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case constraint = "Constraint"
            case reason = "Reason"
        }
    }

    public struct WaypointOptimizationImpedingWaypoint: AWSDecodableShape {
        /// Failed constraints for an impeding waypoint.
        public let failedConstraints: [WaypointOptimizationFailedConstraint]
        /// The waypoint Id.
        public let id: String
        /// Position defined as [longitude, latitude].
        public let position: [Double]

        @inlinable
        public init(failedConstraints: [WaypointOptimizationFailedConstraint], id: String, position: [Double]) {
            self.failedConstraints = failedConstraints
            self.id = id
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case failedConstraints = "FailedConstraints"
            case id = "Id"
            case position = "Position"
        }
    }

    public struct WaypointOptimizationOptimizedWaypoint: AWSDecodableShape {
        /// Estimated time of arrival at the destination. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let arrivalTime: String?
        /// Index of the cluster the waypoint is associated with. The index is included in the response only if clustering was performed while processing the request.
        public let clusterIndex: Int?
        /// Estimated time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm  Examples:  2020-04-22T17:57:24Z   2020-04-22T17:57:24+02:00
        public let departureTime: String
        /// The waypoint Id.
        public let id: String
        /// Position defined as [longitude, latitude].
        public let position: [Double]

        @inlinable
        public init(arrivalTime: String? = nil, clusterIndex: Int? = nil, departureTime: String, id: String, position: [Double]) {
            self.arrivalTime = arrivalTime
            self.clusterIndex = clusterIndex
            self.departureTime = departureTime
            self.id = id
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case arrivalTime = "ArrivalTime"
            case clusterIndex = "ClusterIndex"
            case departureTime = "DepartureTime"
            case id = "Id"
            case position = "Position"
        }
    }

    public struct WaypointOptimizationOriginOptions: AWSEncodableShape {
        /// The Origin Id.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct WaypointOptimizationPedestrianOptions: AWSEncodableShape {
        /// Walking speed.  Unit: KilometersPerHour
        public let speed: Double?

        @inlinable
        public init(speed: Double? = nil) {
            self.speed = speed
        }

        public func validate(name: String) throws {
            try self.validate(self.speed, name: "speed", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case speed = "Speed"
        }
    }

    public struct WaypointOptimizationRestCycleDurations: AWSEncodableShape {
        /// Resting phase of the cycle.  Unit: seconds
        public let restDuration: Int64
        /// Working phase of the cycle.  Unit: seconds
        public let workDuration: Int64

        @inlinable
        public init(restDuration: Int64 = 0, workDuration: Int64 = 0) {
            self.restDuration = restDuration
            self.workDuration = workDuration
        }

        public func validate(name: String) throws {
            try self.validate(self.restDuration, name: "restDuration", parent: name, max: 4294967295)
            try self.validate(self.restDuration, name: "restDuration", parent: name, min: 0)
            try self.validate(self.workDuration, name: "workDuration", parent: name, max: 4294967295)
            try self.validate(self.workDuration, name: "workDuration", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case restDuration = "RestDuration"
            case workDuration = "WorkDuration"
        }
    }

    public struct WaypointOptimizationRestCycles: AWSEncodableShape {
        /// Long cycle for a driver work-rest schedule.
        public let longCycle: WaypointOptimizationRestCycleDurations
        /// Short cycle for a driver work-rest schedule
        public let shortCycle: WaypointOptimizationRestCycleDurations

        @inlinable
        public init(longCycle: WaypointOptimizationRestCycleDurations, shortCycle: WaypointOptimizationRestCycleDurations) {
            self.longCycle = longCycle
            self.shortCycle = shortCycle
        }

        public func validate(name: String) throws {
            try self.longCycle.validate(name: "\(name).longCycle")
            try self.shortCycle.validate(name: "\(name).shortCycle")
        }

        private enum CodingKeys: String, CodingKey {
            case longCycle = "LongCycle"
            case shortCycle = "ShortCycle"
        }
    }

    public struct WaypointOptimizationRestProfile: AWSEncodableShape {
        /// Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.
        public let profile: String

        @inlinable
        public init(profile: String) {
            self.profile = profile
        }

        private enum CodingKeys: String, CodingKey {
            case profile = "Profile"
        }
    }

    public struct WaypointOptimizationSideOfStreetOptions: AWSEncodableShape {
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public let useWith: SideOfStreetMatchingStrategy?

        @inlinable
        public init(position: [Double], useWith: SideOfStreetMatchingStrategy? = nil) {
            self.position = position
            self.useWith = useWith
        }

        public func validate(name: String) throws {
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
            case useWith = "UseWith"
        }
    }

    public struct WaypointOptimizationTimeBreakdown: AWSDecodableShape {
        /// Resting phase of the cycle.  Unit: seconds
        public let restDuration: Int64
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration.  Unit: seconds
        public let serviceDuration: Int64
        /// Traveling phase of the cycle.  Unit: seconds
        public let travelDuration: Int64
        /// Waiting phase of the cycle.  Unit: seconds
        public let waitDuration: Int64

        @inlinable
        public init(restDuration: Int64, serviceDuration: Int64, travelDuration: Int64, waitDuration: Int64) {
            self.restDuration = restDuration
            self.serviceDuration = serviceDuration
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }

        private enum CodingKeys: String, CodingKey {
            case restDuration = "RestDuration"
            case serviceDuration = "ServiceDuration"
            case travelDuration = "TravelDuration"
            case waitDuration = "WaitDuration"
        }
    }

    public struct WaypointOptimizationTrafficOptions: AWSEncodableShape {
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public let usage: TrafficUsage?

        @inlinable
        public init(usage: TrafficUsage? = nil) {
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case usage = "Usage"
        }
    }

    public struct WaypointOptimizationTrailerOptions: AWSEncodableShape {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public let trailerCount: Int?

        @inlinable
        public init(trailerCount: Int? = nil) {
            self.trailerCount = trailerCount
        }

        private enum CodingKeys: String, CodingKey {
            case trailerCount = "TrailerCount"
        }
    }

    public struct WaypointOptimizationTravelModeOptions: AWSEncodableShape {
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public let pedestrian: WaypointOptimizationPedestrianOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public let truck: WaypointOptimizationTruckOptions?

        @inlinable
        public init(pedestrian: WaypointOptimizationPedestrianOptions? = nil, truck: WaypointOptimizationTruckOptions? = nil) {
            self.pedestrian = pedestrian
            self.truck = truck
        }

        public func validate(name: String) throws {
            try self.pedestrian?.validate(name: "\(name).pedestrian")
            try self.truck?.validate(name: "\(name).truck")
        }

        private enum CodingKeys: String, CodingKey {
            case pedestrian = "Pedestrian"
            case truck = "Truck"
        }
    }

    public struct WaypointOptimizationTruckOptions: AWSEncodableShape {
        /// Gross weight of the vehicle including trailers, and goods at capacity.  Unit: Kilograms
        public let grossWeight: Int64?
        /// List of Hazardous cargo contained in the vehicle.
        public let hazardousCargos: [WaypointOptimizationHazardousCargoType]?
        /// Height of the vehicle.  Unit: centimeters
        public let height: Int64?
        /// Length of the vehicle.  Unit: centimeters
        public let length: Int64?
        /// Trailer options corresponding to the vehicle.
        public let trailer: WaypointOptimizationTrailerOptions?
        /// Type of the truck.
        public let truckType: WaypointOptimizationTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.    Tunnel Category B     Risk Level: Limited risk    Restrictions: Few restrictions      Tunnel Category C     Risk Level: Medium risk    Restrictions: Some restrictions      Tunnel Category D     Risk Level: High risk    Restrictions: Many restrictions occur      Tunnel Category E     Risk Level: Very high risk    Restrictions: Restricted tunnel
        public let tunnelRestrictionCode: String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished.  Unit: Kilograms
        public let weightPerAxle: Int64?
        /// Width of the vehicle.  Unit: centimeters
        public let width: Int64?

        @inlinable
        public init(grossWeight: Int64? = nil, hazardousCargos: [WaypointOptimizationHazardousCargoType]? = nil, height: Int64? = nil, length: Int64? = nil, trailer: WaypointOptimizationTrailerOptions? = nil, truckType: WaypointOptimizationTruckType? = nil, tunnelRestrictionCode: String? = nil, weightPerAxle: Int64? = nil, width: Int64? = nil) {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, max: 4294967295)
            try self.validate(self.grossWeight, name: "grossWeight", parent: name, min: 0)
            try self.validate(self.height, name: "height", parent: name, max: 4294967295)
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, max: 4294967295)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, max: 1)
            try self.validate(self.tunnelRestrictionCode, name: "tunnelRestrictionCode", parent: name, min: 1)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, max: 4294967295)
            try self.validate(self.weightPerAxle, name: "weightPerAxle", parent: name, min: 0)
            try self.validate(self.width, name: "width", parent: name, max: 4294967295)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case grossWeight = "GrossWeight"
            case hazardousCargos = "HazardousCargos"
            case height = "Height"
            case length = "Length"
            case trailer = "Trailer"
            case truckType = "TruckType"
            case tunnelRestrictionCode = "TunnelRestrictionCode"
            case weightPerAxle = "WeightPerAxle"
            case width = "Width"
        }
    }

    public struct WaypointOptimizationWaypoint: AWSEncodableShape {
        /// Access hours corresponding to when a waypoint can be visited.
        public let accessHours: WaypointOptimizationAccessHours?
        /// Appointment time at the waypoint.
        public let appointmentTime: String?
        /// Constraint defining what waypoints are to be visited after this waypoint.
        public let before: [Int]?
        /// GPS Heading at the position.
        public let heading: Double?
        /// The waypoint Id.
        public let id: String?
        /// Position defined as [longitude, latitude].
        public let position: [Double]
        /// Service time spent at the waypoint. At an appointment, the service time should be the appointment duration.  Unit: seconds
        public let serviceDuration: Int64?
        /// Options to configure matching the provided position to a side of the street.
        public let sideOfStreet: WaypointOptimizationSideOfStreetOptions?

        @inlinable
        public init(accessHours: WaypointOptimizationAccessHours? = nil, appointmentTime: String? = nil, before: [Int]? = nil, heading: Double? = nil, id: String? = nil, position: [Double], serviceDuration: Int64? = nil, sideOfStreet: WaypointOptimizationSideOfStreetOptions? = nil) {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.before = before
            self.heading = heading
            self.id = id
            self.position = position
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }

        public func validate(name: String) throws {
            try self.accessHours?.validate(name: "\(name).accessHours")
            try self.validate(self.appointmentTime, name: "appointmentTime", parent: name, pattern: "^([1-2][0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]{0,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$")
            try self.validate(self.heading, name: "heading", parent: name, max: 360.0)
            try self.validate(self.heading, name: "heading", parent: name, min: 0.0)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
            try self.validate(self.serviceDuration, name: "serviceDuration", parent: name, max: 4294967295)
            try self.validate(self.serviceDuration, name: "serviceDuration", parent: name, min: 0)
            try self.sideOfStreet?.validate(name: "\(name).sideOfStreet")
        }

        private enum CodingKeys: String, CodingKey {
            case accessHours = "AccessHours"
            case appointmentTime = "AppointmentTime"
            case before = "Before"
            case heading = "Heading"
            case id = "Id"
            case position = "Position"
            case serviceDuration = "ServiceDuration"
            case sideOfStreet = "SideOfStreet"
        }
    }

    public struct WeightPerAxleGroup: AWSEncodableShape & AWSDecodableShape {
        /// Weight for quad axle group.  Unit: Kilograms
        public let quad: Int64?
        /// Weight for quad quint group.  Unit: Kilograms
        public let quint: Int64?
        /// Weight for single axle group.  Unit: Kilograms
        public let single: Int64?
        /// Weight for tandem axle group.  Unit: Kilograms
        public let tandem: Int64?
        /// Weight for triple axle group.  Unit: Kilograms
        public let triple: Int64?

        @inlinable
        public init(quad: Int64? = nil, quint: Int64? = nil, single: Int64? = nil, tandem: Int64? = nil, triple: Int64? = nil) {
            self.quad = quad
            self.quint = quint
            self.single = single
            self.tandem = tandem
            self.triple = triple
        }

        public func validate(name: String) throws {
            try self.validate(self.quad, name: "quad", parent: name, max: 4294967295)
            try self.validate(self.quad, name: "quad", parent: name, min: 0)
            try self.validate(self.quint, name: "quint", parent: name, max: 4294967295)
            try self.validate(self.quint, name: "quint", parent: name, min: 0)
            try self.validate(self.single, name: "single", parent: name, max: 4294967295)
            try self.validate(self.single, name: "single", parent: name, min: 0)
            try self.validate(self.tandem, name: "tandem", parent: name, max: 4294967295)
            try self.validate(self.tandem, name: "tandem", parent: name, min: 0)
            try self.validate(self.triple, name: "triple", parent: name, max: 4294967295)
            try self.validate(self.triple, name: "triple", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case quad = "Quad"
            case quint = "Quint"
            case single = "Single"
            case tandem = "Tandem"
            case triple = "Triple"
        }
    }
}

// MARK: - Errors

/// Error enum for GeoRoutes
public struct GeoRoutesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GeoRoutes
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension GeoRoutesErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": GeoRoutes.ValidationException.self
    ]
}

extension GeoRoutesErrorType: Equatable {
    public static func == (lhs: GeoRoutesErrorType, rhs: GeoRoutesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GeoRoutesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
