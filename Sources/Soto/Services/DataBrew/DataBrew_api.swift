//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS DataBrew service.
///
/// Glue DataBrew is a visual, cloud-scale data-preparation service. DataBrew simplifies data preparation tasks, targeting data issues that are hard to spot and time-consuming to fix. DataBrew empowers users of all technical levels to visualize the data and perform one-click data transformations, with no coding required.
public struct DataBrew: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the DataBrew client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "DataBrew",
            serviceIdentifier: "databrew",
            serviceProtocol: .restjson,
            apiVersion: "2017-07-25",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: DataBrewErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "databrew-fips.us-east-1.amazonaws.com",
            "us-east-2": "databrew-fips.us-east-2.amazonaws.com",
            "us-gov-west-1": "databrew.us-gov-west-1.amazonaws.com",
            "us-west-1": "databrew-fips.us-west-1.amazonaws.com",
            "us-west-2": "databrew-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Deletes one or more versions of a recipe at a time. The entire request will be rejected if:   The recipe does not exist.   There is an invalid version identifier in the list of versions.   The version list is empty.   The version list size exceeds 50.   The version list contains duplicate entries.   The request will complete successfully, but with partial failures, if:   A version does not exist.   A version is being used by a job.   You specify LATEST_WORKING, but it's being used by a project.   The version fails to be deleted.   The LATEST_WORKING version will only be deleted if the recipe has no other versions. If you try to delete LATEST_WORKING while other versions exist (or if they can't be deleted), then LATEST_WORKING will be listed as partial failure in the response.
    @Sendable
    @inlinable
    public func batchDeleteRecipeVersion(_ input: BatchDeleteRecipeVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteRecipeVersionResponse {
        try await self.client.execute(
            operation: "BatchDeleteRecipeVersion", 
            path: "/recipes/{Name}/batchDeleteRecipeVersion", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes one or more versions of a recipe at a time. The entire request will be rejected if:   The recipe does not exist.   There is an invalid version identifier in the list of versions.   The version list is empty.   The version list size exceeds 50.   The version list contains duplicate entries.   The request will complete successfully, but with partial failures, if:   A version does not exist.   A version is being used by a job.   You specify LATEST_WORKING, but it's being used by a project.   The version fails to be deleted.   The LATEST_WORKING version will only be deleted if the recipe has no other versions. If you try to delete LATEST_WORKING while other versions exist (or if they can't be deleted), then LATEST_WORKING will be listed as partial failure in the response.
    ///
    /// Parameters:
    ///   - name: The name of the recipe whose versions are to be deleted.
    ///   - recipeVersions: An array of version identifiers, for the recipe versions to be deleted. You can specify numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteRecipeVersion(
        name: String,
        recipeVersions: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteRecipeVersionResponse {
        let input = BatchDeleteRecipeVersionRequest(
            name: name, 
            recipeVersions: recipeVersions
        )
        return try await self.batchDeleteRecipeVersion(input, logger: logger)
    }

    /// Creates a new DataBrew dataset.
    @Sendable
    @inlinable
    public func createDataset(_ input: CreateDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatasetResponse {
        try await self.client.execute(
            operation: "CreateDataset", 
            path: "/datasets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new DataBrew dataset.
    ///
    /// Parameters:
    ///   - format: The file format of a dataset that is created from an Amazon S3 file or folder.
    ///   - formatOptions: 
    ///   - input: 
    ///   - name: The name of the dataset to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - pathOptions: A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
    ///   - tags: Metadata tags to apply to this dataset.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataset(
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input,
        name: String,
        pathOptions: PathOptions? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatasetResponse {
        let input = CreateDatasetRequest(
            format: format, 
            formatOptions: formatOptions, 
            input: input, 
            name: name, 
            pathOptions: pathOptions, 
            tags: tags
        )
        return try await self.createDataset(input, logger: logger)
    }

    /// Creates a new job to analyze a dataset and create its data profile.
    @Sendable
    @inlinable
    public func createProfileJob(_ input: CreateProfileJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProfileJobResponse {
        try await self.client.execute(
            operation: "CreateProfileJob", 
            path: "/profileJobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new job to analyze a dataset and create its data profile.
    ///
    /// Parameters:
    ///   - configuration: Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    ///   - datasetName: The name of the dataset that this job is to act upon.
    ///   - encryptionKeyArn: The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    ///   - encryptionMode: The encryption mode for the job, which can be one of the following:    SSE-KMS - SSE-KMS - Server-side encryption with  KMS-managed keys.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    ///   - jobSample: Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
    ///   - logSubscription: Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    ///   - maxCapacity: The maximum number of nodes that DataBrew can use when the job processes data.
    ///   - maxRetries: The maximum number of times to retry the job after a job run fails.
    ///   - name: The name of the job to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - outputLocation: 
    ///   - roleArn: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    ///   - tags: Metadata tags to apply to this job.
    ///   - timeout: The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    ///   - validationConfigurations: List of validation configurations that are applied to the profile job.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProfileJob(
        configuration: ProfileConfiguration? = nil,
        datasetName: String,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int? = nil,
        maxRetries: Int? = nil,
        name: String,
        outputLocation: S3Location,
        roleArn: String,
        tags: [String: String]? = nil,
        timeout: Int? = nil,
        validationConfigurations: [ValidationConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProfileJobResponse {
        let input = CreateProfileJobRequest(
            configuration: configuration, 
            datasetName: datasetName, 
            encryptionKeyArn: encryptionKeyArn, 
            encryptionMode: encryptionMode, 
            jobSample: jobSample, 
            logSubscription: logSubscription, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            outputLocation: outputLocation, 
            roleArn: roleArn, 
            tags: tags, 
            timeout: timeout, 
            validationConfigurations: validationConfigurations
        )
        return try await self.createProfileJob(input, logger: logger)
    }

    /// Creates a new DataBrew project.
    @Sendable
    @inlinable
    public func createProject(_ input: CreateProjectRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProjectResponse {
        try await self.client.execute(
            operation: "CreateProject", 
            path: "/projects", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new DataBrew project.
    ///
    /// Parameters:
    ///   - datasetName: The name of an existing dataset to associate this project with.
    ///   - name: A unique name for the new project. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - recipeName: The name of an existing recipe to associate with the project.
    ///   - roleArn: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed for this request.
    ///   - sample: 
    ///   - tags: Metadata tags to apply to this project.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProject(
        datasetName: String,
        name: String,
        recipeName: String,
        roleArn: String,
        sample: Sample? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProjectResponse {
        let input = CreateProjectRequest(
            datasetName: datasetName, 
            name: name, 
            recipeName: recipeName, 
            roleArn: roleArn, 
            sample: sample, 
            tags: tags
        )
        return try await self.createProject(input, logger: logger)
    }

    /// Creates a new DataBrew recipe.
    @Sendable
    @inlinable
    public func createRecipe(_ input: CreateRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRecipeResponse {
        try await self.client.execute(
            operation: "CreateRecipe", 
            path: "/recipes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new DataBrew recipe.
    ///
    /// Parameters:
    ///   - description: A description for the recipe.
    ///   - name: A unique name for the recipe. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - steps: An array containing the steps to be performed by the recipe. Each recipe step consists of one recipe action and (optionally) an array of condition expressions.
    ///   - tags: Metadata tags to apply to this recipe.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRecipe(
        description: String? = nil,
        name: String,
        steps: [RecipeStep],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRecipeResponse {
        let input = CreateRecipeRequest(
            description: description, 
            name: name, 
            steps: steps, 
            tags: tags
        )
        return try await self.createRecipe(input, logger: logger)
    }

    /// Creates a new job to transform input data, using steps defined in an existing Glue DataBrew recipe
    @Sendable
    @inlinable
    public func createRecipeJob(_ input: CreateRecipeJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRecipeJobResponse {
        try await self.client.execute(
            operation: "CreateRecipeJob", 
            path: "/recipeJobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new job to transform input data, using steps defined in an existing Glue DataBrew recipe
    ///
    /// Parameters:
    ///   - databaseOutputs: Represents a list of JDBC database output objects which defines the output destination for  a DataBrew recipe job to write to.
    ///   - dataCatalogOutputs: One or more artifacts that represent the Glue Data Catalog output from running the job.
    ///   - datasetName: The name of the dataset that this job processes.
    ///   - encryptionKeyArn: The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    ///   - encryptionMode: The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    ///   - logSubscription: Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    ///   - maxCapacity: The maximum number of nodes that DataBrew can consume when the job processes data.
    ///   - maxRetries: The maximum number of times to retry the job after a job run fails.
    ///   - name: A unique name for the job. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - outputs: One or more artifacts that represent the output from running the job.
    ///   - projectName: Either the name of an existing project, or a combination of a recipe and a dataset to associate with the recipe.
    ///   - recipeReference: 
    ///   - roleArn: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    ///   - tags: Metadata tags to apply to this job.
    ///   - timeout: The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRecipeJob(
        databaseOutputs: [DatabaseOutput]? = nil,
        dataCatalogOutputs: [DataCatalogOutput]? = nil,
        datasetName: String? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int? = nil,
        maxRetries: Int? = nil,
        name: String,
        outputs: [Output]? = nil,
        projectName: String? = nil,
        recipeReference: RecipeReference? = nil,
        roleArn: String,
        tags: [String: String]? = nil,
        timeout: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRecipeJobResponse {
        let input = CreateRecipeJobRequest(
            databaseOutputs: databaseOutputs, 
            dataCatalogOutputs: dataCatalogOutputs, 
            datasetName: datasetName, 
            encryptionKeyArn: encryptionKeyArn, 
            encryptionMode: encryptionMode, 
            logSubscription: logSubscription, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            outputs: outputs, 
            projectName: projectName, 
            recipeReference: recipeReference, 
            roleArn: roleArn, 
            tags: tags, 
            timeout: timeout
        )
        return try await self.createRecipeJob(input, logger: logger)
    }

    /// Creates a new ruleset that can be used in a profile job to validate  the data quality of a dataset.
    @Sendable
    @inlinable
    public func createRuleset(_ input: CreateRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRulesetResponse {
        try await self.client.execute(
            operation: "CreateRuleset", 
            path: "/rulesets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new ruleset that can be used in a profile job to validate  the data quality of a dataset.
    ///
    /// Parameters:
    ///   - description: The description of the ruleset.
    ///   - name: The name of the ruleset to be created. Valid characters are alphanumeric  (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - rules: A list of rules that are defined with the ruleset. A rule includes  one or more checks to be validated on a DataBrew dataset.
    ///   - tags: Metadata tags to apply to the ruleset.
    ///   - targetArn: The Amazon Resource Name (ARN) of a resource (dataset) that the  ruleset is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRuleset(
        description: String? = nil,
        name: String,
        rules: [Rule],
        tags: [String: String]? = nil,
        targetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRulesetResponse {
        let input = CreateRulesetRequest(
            description: description, 
            name: name, 
            rules: rules, 
            tags: tags, 
            targetArn: targetArn
        )
        return try await self.createRuleset(input, logger: logger)
    }

    /// Creates a new schedule for one or more DataBrew jobs. Jobs can be run at a specific date and time, or at regular intervals.
    @Sendable
    @inlinable
    public func createSchedule(_ input: CreateScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScheduleResponse {
        try await self.client.execute(
            operation: "CreateSchedule", 
            path: "/schedules", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new schedule for one or more DataBrew jobs. Jobs can be run at a specific date and time, or at regular intervals.
    ///
    /// Parameters:
    ///   - cronExpression: The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
    ///   - jobNames: The name or names of one or more jobs to be run.
    ///   - name: A unique name for the schedule. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    ///   - tags: Metadata tags to apply to this schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSchedule(
        cronExpression: String,
        jobNames: [String]? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScheduleResponse {
        let input = CreateScheduleRequest(
            cronExpression: cronExpression, 
            jobNames: jobNames, 
            name: name, 
            tags: tags
        )
        return try await self.createSchedule(input, logger: logger)
    }

    /// Deletes a dataset from DataBrew.
    @Sendable
    @inlinable
    public func deleteDataset(_ input: DeleteDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDatasetResponse {
        try await self.client.execute(
            operation: "DeleteDataset", 
            path: "/datasets/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a dataset from DataBrew.
    ///
    /// Parameters:
    ///   - name: The name of the dataset to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDatasetResponse {
        let input = DeleteDatasetRequest(
            name: name
        )
        return try await self.deleteDataset(input, logger: logger)
    }

    /// Deletes the specified DataBrew job.
    @Sendable
    @inlinable
    public func deleteJob(_ input: DeleteJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobResponse {
        try await self.client.execute(
            operation: "DeleteJob", 
            path: "/jobs/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified DataBrew job.
    ///
    /// Parameters:
    ///   - name: The name of the job to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJob(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobResponse {
        let input = DeleteJobRequest(
            name: name
        )
        return try await self.deleteJob(input, logger: logger)
    }

    /// Deletes an existing DataBrew project.
    @Sendable
    @inlinable
    public func deleteProject(_ input: DeleteProjectRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteProjectResponse {
        try await self.client.execute(
            operation: "DeleteProject", 
            path: "/projects/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing DataBrew project.
    ///
    /// Parameters:
    ///   - name: The name of the project to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProject(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteProjectResponse {
        let input = DeleteProjectRequest(
            name: name
        )
        return try await self.deleteProject(input, logger: logger)
    }

    /// Deletes a single version of a DataBrew recipe.
    @Sendable
    @inlinable
    public func deleteRecipeVersion(_ input: DeleteRecipeVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRecipeVersionResponse {
        try await self.client.execute(
            operation: "DeleteRecipeVersion", 
            path: "/recipes/{Name}/recipeVersion/{RecipeVersion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single version of a DataBrew recipe.
    ///
    /// Parameters:
    ///   - name: The name of the recipe.
    ///   - recipeVersion: The version of the recipe to be deleted. You can specify a numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRecipeVersion(
        name: String,
        recipeVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRecipeVersionResponse {
        let input = DeleteRecipeVersionRequest(
            name: name, 
            recipeVersion: recipeVersion
        )
        return try await self.deleteRecipeVersion(input, logger: logger)
    }

    /// Deletes a ruleset.
    @Sendable
    @inlinable
    public func deleteRuleset(_ input: DeleteRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRulesetResponse {
        try await self.client.execute(
            operation: "DeleteRuleset", 
            path: "/rulesets/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a ruleset.
    ///
    /// Parameters:
    ///   - name: The name of the ruleset to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRuleset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRulesetResponse {
        let input = DeleteRulesetRequest(
            name: name
        )
        return try await self.deleteRuleset(input, logger: logger)
    }

    /// Deletes the specified DataBrew schedule.
    @Sendable
    @inlinable
    public func deleteSchedule(_ input: DeleteScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScheduleResponse {
        try await self.client.execute(
            operation: "DeleteSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified DataBrew schedule.
    ///
    /// Parameters:
    ///   - name: The name of the schedule to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchedule(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScheduleResponse {
        let input = DeleteScheduleRequest(
            name: name
        )
        return try await self.deleteSchedule(input, logger: logger)
    }

    /// Returns the definition of a specific DataBrew dataset.
    @Sendable
    @inlinable
    public func describeDataset(_ input: DescribeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDatasetResponse {
        try await self.client.execute(
            operation: "DescribeDataset", 
            path: "/datasets/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the definition of a specific DataBrew dataset.
    ///
    /// Parameters:
    ///   - name: The name of the dataset to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDataset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDatasetResponse {
        let input = DescribeDatasetRequest(
            name: name
        )
        return try await self.describeDataset(input, logger: logger)
    }

    /// Returns the definition of a specific DataBrew job.
    @Sendable
    @inlinable
    public func describeJob(_ input: DescribeJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobResponse {
        try await self.client.execute(
            operation: "DescribeJob", 
            path: "/jobs/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the definition of a specific DataBrew job.
    ///
    /// Parameters:
    ///   - name: The name of the job to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJob(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobResponse {
        let input = DescribeJobRequest(
            name: name
        )
        return try await self.describeJob(input, logger: logger)
    }

    /// Represents one run of a DataBrew job.
    @Sendable
    @inlinable
    public func describeJobRun(_ input: DescribeJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobRunResponse {
        try await self.client.execute(
            operation: "DescribeJobRun", 
            path: "/jobs/{Name}/jobRun/{RunId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Represents one run of a DataBrew job.
    ///
    /// Parameters:
    ///   - name: The name of the job being processed during this run.
    ///   - runId: The unique identifier of the job run.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobRun(
        name: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobRunResponse {
        let input = DescribeJobRunRequest(
            name: name, 
            runId: runId
        )
        return try await self.describeJobRun(input, logger: logger)
    }

    /// Returns the definition of a specific DataBrew project.
    @Sendable
    @inlinable
    public func describeProject(_ input: DescribeProjectRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeProjectResponse {
        try await self.client.execute(
            operation: "DescribeProject", 
            path: "/projects/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the definition of a specific DataBrew project.
    ///
    /// Parameters:
    ///   - name: The name of the project to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeProject(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeProjectResponse {
        let input = DescribeProjectRequest(
            name: name
        )
        return try await self.describeProject(input, logger: logger)
    }

    /// Returns the definition of a specific DataBrew recipe corresponding to a particular version.
    @Sendable
    @inlinable
    public func describeRecipe(_ input: DescribeRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRecipeResponse {
        try await self.client.execute(
            operation: "DescribeRecipe", 
            path: "/recipes/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the definition of a specific DataBrew recipe corresponding to a particular version.
    ///
    /// Parameters:
    ///   - name: The name of the recipe to be described.
    ///   - recipeVersion: The recipe version identifier. If this parameter isn't specified, then the latest published version is returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRecipe(
        name: String,
        recipeVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRecipeResponse {
        let input = DescribeRecipeRequest(
            name: name, 
            recipeVersion: recipeVersion
        )
        return try await self.describeRecipe(input, logger: logger)
    }

    /// Retrieves detailed information about the ruleset.
    @Sendable
    @inlinable
    public func describeRuleset(_ input: DescribeRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRulesetResponse {
        try await self.client.execute(
            operation: "DescribeRuleset", 
            path: "/rulesets/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed information about the ruleset.
    ///
    /// Parameters:
    ///   - name: The name of the ruleset to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRuleset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRulesetResponse {
        let input = DescribeRulesetRequest(
            name: name
        )
        return try await self.describeRuleset(input, logger: logger)
    }

    /// Returns the definition of a specific DataBrew schedule.
    @Sendable
    @inlinable
    public func describeSchedule(_ input: DescribeScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeScheduleResponse {
        try await self.client.execute(
            operation: "DescribeSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the definition of a specific DataBrew schedule.
    ///
    /// Parameters:
    ///   - name: The name of the schedule to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSchedule(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeScheduleResponse {
        let input = DescribeScheduleRequest(
            name: name
        )
        return try await self.describeSchedule(input, logger: logger)
    }

    /// Lists all of the DataBrew datasets.
    @Sendable
    @inlinable
    public func listDatasets(_ input: ListDatasetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDatasetsResponse {
        try await self.client.execute(
            operation: "ListDatasets", 
            path: "/datasets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the DataBrew datasets.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDatasets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDatasetsResponse {
        let input = ListDatasetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDatasets(input, logger: logger)
    }

    /// Lists all of the previous runs of a particular DataBrew job.
    @Sendable
    @inlinable
    public func listJobRuns(_ input: ListJobRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobRunsResponse {
        try await self.client.execute(
            operation: "ListJobRuns", 
            path: "/jobs/{Name}/jobRuns", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the previous runs of a particular DataBrew job.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - name: The name of the job.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobRuns(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobRunsResponse {
        let input = ListJobRunsRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listJobRuns(input, logger: logger)
    }

    /// Lists all of the DataBrew jobs that are defined.
    @Sendable
    @inlinable
    public func listJobs(_ input: ListJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobsResponse {
        try await self.client.execute(
            operation: "ListJobs", 
            path: "/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the DataBrew jobs that are defined.
    ///
    /// Parameters:
    ///   - datasetName: The name of a dataset. Using this parameter indicates to return only those jobs that act on the specified dataset.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token generated by DataBrew that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the NextToken value from the response object of the previous page call.
    ///   - projectName: The name of a project. Using this parameter indicates to return only those jobs that are associated with the specified project.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobs(
        datasetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobsResponse {
        let input = ListJobsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            projectName: projectName
        )
        return try await self.listJobs(input, logger: logger)
    }

    /// Lists all of the DataBrew projects that are defined.
    @Sendable
    @inlinable
    public func listProjects(_ input: ListProjectsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProjectsResponse {
        try await self.client.execute(
            operation: "ListProjects", 
            path: "/projects", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the DataBrew projects that are defined.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listProjects(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProjectsResponse {
        let input = ListProjectsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listProjects(input, logger: logger)
    }

    /// Lists the versions of a particular DataBrew recipe, except for LATEST_WORKING.
    @Sendable
    @inlinable
    public func listRecipeVersions(_ input: ListRecipeVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRecipeVersionsResponse {
        try await self.client.execute(
            operation: "ListRecipeVersions", 
            path: "/recipeVersions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the versions of a particular DataBrew recipe, except for LATEST_WORKING.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - name: The name of the recipe for which to return version information.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRecipeVersions(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRecipeVersionsResponse {
        let input = ListRecipeVersionsRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listRecipeVersions(input, logger: logger)
    }

    /// Lists all of the DataBrew recipes that are defined.
    @Sendable
    @inlinable
    public func listRecipes(_ input: ListRecipesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRecipesResponse {
        try await self.client.execute(
            operation: "ListRecipes", 
            path: "/recipes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the DataBrew recipes that are defined.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - recipeVersion: Return only those recipes with a version identifier of LATEST_WORKING or LATEST_PUBLISHED. If RecipeVersion is omitted, ListRecipes returns all of the LATEST_PUBLISHED recipe versions. Valid values: LATEST_WORKING | LATEST_PUBLISHED
    ///   - logger: Logger use during operation
    @inlinable
    public func listRecipes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recipeVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRecipesResponse {
        let input = ListRecipesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            recipeVersion: recipeVersion
        )
        return try await self.listRecipes(input, logger: logger)
    }

    /// List all rulesets available in the current account or rulesets associated  with a specific resource (dataset).
    @Sendable
    @inlinable
    public func listRulesets(_ input: ListRulesetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRulesetsResponse {
        try await self.client.execute(
            operation: "ListRulesets", 
            path: "/rulesets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all rulesets available in the current account or rulesets associated  with a specific resource (dataset).
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token generated by DataBrew that specifies where to continue pagination  if a previous request was truncated. To get the next set of pages, pass in  the NextToken value from the response object of the previous page call.
    ///   - targetArn: The Amazon Resource Name (ARN) of a resource (dataset). Using this parameter  indicates to return only those rulesets that are associated with the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRulesets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        targetArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRulesetsResponse {
        let input = ListRulesetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            targetArn: targetArn
        )
        return try await self.listRulesets(input, logger: logger)
    }

    /// Lists the DataBrew schedules that are defined.
    @Sendable
    @inlinable
    public func listSchedules(_ input: ListSchedulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSchedulesResponse {
        try await self.client.execute(
            operation: "ListSchedules", 
            path: "/schedules", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the DataBrew schedules that are defined.
    ///
    /// Parameters:
    ///   - jobName: The name of the job that these schedules apply to.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSchedules(
        jobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSchedulesResponse {
        let input = ListSchedulesRequest(
            jobName: jobName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSchedules(input, logger: logger)
    }

    /// Lists all the tags for a DataBrew resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the tags for a DataBrew resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) string that uniquely identifies the DataBrew resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Publishes a new version of a DataBrew recipe.
    @Sendable
    @inlinable
    public func publishRecipe(_ input: PublishRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PublishRecipeResponse {
        try await self.client.execute(
            operation: "PublishRecipe", 
            path: "/recipes/{Name}/publishRecipe", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Publishes a new version of a DataBrew recipe.
    ///
    /// Parameters:
    ///   - description: A description of the recipe to be published, for this version of the recipe.
    ///   - name: The name of the recipe to be published.
    ///   - logger: Logger use during operation
    @inlinable
    public func publishRecipe(
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PublishRecipeResponse {
        let input = PublishRecipeRequest(
            description: description, 
            name: name
        )
        return try await self.publishRecipe(input, logger: logger)
    }

    /// Performs a recipe step within an interactive DataBrew session that's currently open.
    @Sendable
    @inlinable
    public func sendProjectSessionAction(_ input: SendProjectSessionActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SendProjectSessionActionResponse {
        try await self.client.execute(
            operation: "SendProjectSessionAction", 
            path: "/projects/{Name}/sendProjectSessionAction", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Performs a recipe step within an interactive DataBrew session that's currently open.
    ///
    /// Parameters:
    ///   - clientSessionId: A unique identifier for an interactive session that's currently open and ready for work. The action will be performed on this session.
    ///   - name: The name of the project to apply the action to.
    ///   - preview: If true, the result of the recipe step will be returned, but not applied.
    ///   - recipeStep: 
    ///   - stepIndex: The index from which to preview a step. This index is used to preview the result of steps that have already been applied, so that the resulting view frame is from earlier in the view frame stack.
    ///   - viewFrame: 
    ///   - logger: Logger use during operation
    @inlinable
    public func sendProjectSessionAction(
        clientSessionId: String? = nil,
        name: String,
        preview: Bool? = nil,
        recipeStep: RecipeStep? = nil,
        stepIndex: Int? = nil,
        viewFrame: ViewFrame? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SendProjectSessionActionResponse {
        let input = SendProjectSessionActionRequest(
            clientSessionId: clientSessionId, 
            name: name, 
            preview: preview, 
            recipeStep: recipeStep, 
            stepIndex: stepIndex, 
            viewFrame: viewFrame
        )
        return try await self.sendProjectSessionAction(input, logger: logger)
    }

    /// Runs a DataBrew job.
    @Sendable
    @inlinable
    public func startJobRun(_ input: StartJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartJobRunResponse {
        try await self.client.execute(
            operation: "StartJobRun", 
            path: "/jobs/{Name}/startJobRun", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Runs a DataBrew job.
    ///
    /// Parameters:
    ///   - name: The name of the job to be run.
    ///   - logger: Logger use during operation
    @inlinable
    public func startJobRun(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartJobRunResponse {
        let input = StartJobRunRequest(
            name: name
        )
        return try await self.startJobRun(input, logger: logger)
    }

    /// Creates an interactive session, enabling you to manipulate data in a DataBrew project.
    @Sendable
    @inlinable
    public func startProjectSession(_ input: StartProjectSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartProjectSessionResponse {
        try await self.client.execute(
            operation: "StartProjectSession", 
            path: "/projects/{Name}/startProjectSession", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an interactive session, enabling you to manipulate data in a DataBrew project.
    ///
    /// Parameters:
    ///   - assumeControl: A value that, if true, enables you to take control of a session, even if a different client is currently accessing the project.
    ///   - name: The name of the project to act upon.
    ///   - logger: Logger use during operation
    @inlinable
    public func startProjectSession(
        assumeControl: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartProjectSessionResponse {
        let input = StartProjectSessionRequest(
            assumeControl: assumeControl, 
            name: name
        )
        return try await self.startProjectSession(input, logger: logger)
    }

    /// Stops a particular run of a job.
    @Sendable
    @inlinable
    public func stopJobRun(_ input: StopJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopJobRunResponse {
        try await self.client.execute(
            operation: "StopJobRun", 
            path: "/jobs/{Name}/jobRun/{RunId}/stopJobRun", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a particular run of a job.
    ///
    /// Parameters:
    ///   - name: The name of the job to be stopped.
    ///   - runId: The ID of the job run to be stopped.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopJobRun(
        name: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopJobRunResponse {
        let input = StopJobRunRequest(
            name: name, 
            runId: runId
        )
        return try await self.stopJobRun(input, logger: logger)
    }

    /// Adds metadata tags to a DataBrew resource, such as a dataset, project, recipe, job, or schedule.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds metadata tags to a DataBrew resource, such as a dataset, project, recipe, job, or schedule.
    ///
    /// Parameters:
    ///   - resourceArn: The DataBrew resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DataBrew, you can tag a dataset, a job, a project, or a recipe.
    ///   - tags: One or more tags to be assigned to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes metadata tags from a DataBrew resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes metadata tags from a DataBrew resource.
    ///
    /// Parameters:
    ///   - resourceArn: A DataBrew resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    ///   - tagKeys: The tag keys (names) of one or more tags to be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Modifies the definition of an existing DataBrew dataset.
    @Sendable
    @inlinable
    public func updateDataset(_ input: UpdateDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDatasetResponse {
        try await self.client.execute(
            operation: "UpdateDataset", 
            path: "/datasets/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of an existing DataBrew dataset.
    ///
    /// Parameters:
    ///   - format: The file format of a dataset that is created from an Amazon S3 file or folder.
    ///   - formatOptions: 
    ///   - input: 
    ///   - name: The name of the dataset to be updated.
    ///   - pathOptions: A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataset(
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input,
        name: String,
        pathOptions: PathOptions? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDatasetResponse {
        let input = UpdateDatasetRequest(
            format: format, 
            formatOptions: formatOptions, 
            input: input, 
            name: name, 
            pathOptions: pathOptions
        )
        return try await self.updateDataset(input, logger: logger)
    }

    /// Modifies the definition of an existing profile job.
    @Sendable
    @inlinable
    public func updateProfileJob(_ input: UpdateProfileJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateProfileJobResponse {
        try await self.client.execute(
            operation: "UpdateProfileJob", 
            path: "/profileJobs/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of an existing profile job.
    ///
    /// Parameters:
    ///   - configuration: Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    ///   - encryptionKeyArn: The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    ///   - encryptionMode: The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    ///   - jobSample: Sample configuration for Profile Jobs only. Determines the number of rows on which the Profile job will be executed. If a JobSample value is not provided for profile jobs, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
    ///   - logSubscription: Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    ///   - maxCapacity: The maximum number of compute nodes that DataBrew can use when the job processes data.
    ///   - maxRetries: The maximum number of times to retry the job after a job run fails.
    ///   - name: The name of the job to be updated.
    ///   - outputLocation: 
    ///   - roleArn: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    ///   - timeout: The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    ///   - validationConfigurations: List of validation configurations that are applied to the profile job.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateProfileJob(
        configuration: ProfileConfiguration? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int? = nil,
        maxRetries: Int? = nil,
        name: String,
        outputLocation: S3Location,
        roleArn: String,
        timeout: Int? = nil,
        validationConfigurations: [ValidationConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateProfileJobResponse {
        let input = UpdateProfileJobRequest(
            configuration: configuration, 
            encryptionKeyArn: encryptionKeyArn, 
            encryptionMode: encryptionMode, 
            jobSample: jobSample, 
            logSubscription: logSubscription, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            outputLocation: outputLocation, 
            roleArn: roleArn, 
            timeout: timeout, 
            validationConfigurations: validationConfigurations
        )
        return try await self.updateProfileJob(input, logger: logger)
    }

    /// Modifies the definition of an existing DataBrew project.
    @Sendable
    @inlinable
    public func updateProject(_ input: UpdateProjectRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateProjectResponse {
        try await self.client.execute(
            operation: "UpdateProject", 
            path: "/projects/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of an existing DataBrew project.
    ///
    /// Parameters:
    ///   - name: The name of the project to be updated.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role to be assumed for this request.
    ///   - sample: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateProject(
        name: String,
        roleArn: String,
        sample: Sample? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateProjectResponse {
        let input = UpdateProjectRequest(
            name: name, 
            roleArn: roleArn, 
            sample: sample
        )
        return try await self.updateProject(input, logger: logger)
    }

    /// Modifies the definition of the LATEST_WORKING version of a DataBrew recipe.
    @Sendable
    @inlinable
    public func updateRecipe(_ input: UpdateRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRecipeResponse {
        try await self.client.execute(
            operation: "UpdateRecipe", 
            path: "/recipes/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of the LATEST_WORKING version of a DataBrew recipe.
    ///
    /// Parameters:
    ///   - description: A description of the recipe.
    ///   - name: The name of the recipe to be updated.
    ///   - steps: One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRecipe(
        description: String? = nil,
        name: String,
        steps: [RecipeStep]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRecipeResponse {
        let input = UpdateRecipeRequest(
            description: description, 
            name: name, 
            steps: steps
        )
        return try await self.updateRecipe(input, logger: logger)
    }

    /// Modifies the definition of an existing DataBrew recipe job.
    @Sendable
    @inlinable
    public func updateRecipeJob(_ input: UpdateRecipeJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRecipeJobResponse {
        try await self.client.execute(
            operation: "UpdateRecipeJob", 
            path: "/recipeJobs/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of an existing DataBrew recipe job.
    ///
    /// Parameters:
    ///   - databaseOutputs: Represents a list of JDBC database output objects which defines the output destination for a  DataBrew recipe job to write into.
    ///   - dataCatalogOutputs: One or more artifacts that represent the Glue Data Catalog output from running the job.
    ///   - encryptionKeyArn: The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    ///   - encryptionMode: The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    ///   - logSubscription: Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    ///   - maxCapacity: The maximum number of nodes that DataBrew can consume when the job processes data.
    ///   - maxRetries: The maximum number of times to retry the job after a job run fails.
    ///   - name: The name of the job to update.
    ///   - outputs: One or more artifacts that represent the output from running the job.
    ///   - roleArn: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    ///   - timeout: The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRecipeJob(
        databaseOutputs: [DatabaseOutput]? = nil,
        dataCatalogOutputs: [DataCatalogOutput]? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int? = nil,
        maxRetries: Int? = nil,
        name: String,
        outputs: [Output]? = nil,
        roleArn: String,
        timeout: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRecipeJobResponse {
        let input = UpdateRecipeJobRequest(
            databaseOutputs: databaseOutputs, 
            dataCatalogOutputs: dataCatalogOutputs, 
            encryptionKeyArn: encryptionKeyArn, 
            encryptionMode: encryptionMode, 
            logSubscription: logSubscription, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            outputs: outputs, 
            roleArn: roleArn, 
            timeout: timeout
        )
        return try await self.updateRecipeJob(input, logger: logger)
    }

    /// Updates specified ruleset.
    @Sendable
    @inlinable
    public func updateRuleset(_ input: UpdateRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRulesetResponse {
        try await self.client.execute(
            operation: "UpdateRuleset", 
            path: "/rulesets/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates specified ruleset.
    ///
    /// Parameters:
    ///   - description: The description of the ruleset.
    ///   - name: The name of the ruleset to be updated.
    ///   - rules: A list of rules that are defined with the ruleset. A rule includes one or more  checks to be validated on a DataBrew dataset.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRuleset(
        description: String? = nil,
        name: String,
        rules: [Rule],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRulesetResponse {
        let input = UpdateRulesetRequest(
            description: description, 
            name: name, 
            rules: rules
        )
        return try await self.updateRuleset(input, logger: logger)
    }

    /// Modifies the definition of an existing DataBrew schedule.
    @Sendable
    @inlinable
    public func updateSchedule(_ input: UpdateScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateScheduleResponse {
        try await self.client.execute(
            operation: "UpdateSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the definition of an existing DataBrew schedule.
    ///
    /// Parameters:
    ///   - cronExpression: The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
    ///   - jobNames: The name or names of one or more jobs to be run for this schedule.
    ///   - name: The name of the schedule to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSchedule(
        cronExpression: String,
        jobNames: [String]? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateScheduleResponse {
        let input = UpdateScheduleRequest(
            cronExpression: cronExpression, 
            jobNames: jobNames, 
            name: name
        )
        return try await self.updateSchedule(input, logger: logger)
    }
}

extension DataBrew {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: DataBrew, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DataBrew {
    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        _ input: ListDatasetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        return .init(
            input: input,
            command: self.listDatasets,
            inputKey: \ListDatasetsRequest.nextToken,
            outputKey: \ListDatasetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        let input = ListDatasetsRequest(
            maxResults: maxResults
        )
        return self.listDatasetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobRunsPaginator(
        _ input: ListJobRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobRunsRequest, ListJobRunsResponse> {
        return .init(
            input: input,
            command: self.listJobRuns,
            inputKey: \ListJobRunsRequest.nextToken,
            outputKey: \ListJobRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - name: The name of the job.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobRunsPaginator(
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobRunsRequest, ListJobRunsResponse> {
        let input = ListJobRunsRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listJobRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        return .init(
            input: input,
            command: self.listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetName: The name of a dataset. Using this parameter indicates to return only those jobs that act on the specified dataset.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - projectName: The name of a project. Using this parameter indicates to return only those jobs that are associated with the specified project.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        datasetName: String? = nil,
        maxResults: Int? = nil,
        projectName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        let input = ListJobsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            projectName: projectName
        )
        return self.listJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProjects(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProjectsPaginator(
        _ input: ListProjectsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProjectsRequest, ListProjectsResponse> {
        return .init(
            input: input,
            command: self.listProjects,
            inputKey: \ListProjectsRequest.nextToken,
            outputKey: \ListProjectsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProjects(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listProjectsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProjectsRequest, ListProjectsResponse> {
        let input = ListProjectsRequest(
            maxResults: maxResults
        )
        return self.listProjectsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRecipeVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecipeVersionsPaginator(
        _ input: ListRecipeVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRecipeVersionsRequest, ListRecipeVersionsResponse> {
        return .init(
            input: input,
            command: self.listRecipeVersions,
            inputKey: \ListRecipeVersionsRequest.nextToken,
            outputKey: \ListRecipeVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRecipeVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - name: The name of the recipe for which to return version information.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecipeVersionsPaginator(
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRecipeVersionsRequest, ListRecipeVersionsResponse> {
        let input = ListRecipeVersionsRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listRecipeVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecipesPaginator(
        _ input: ListRecipesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRecipesRequest, ListRecipesResponse> {
        return .init(
            input: input,
            command: self.listRecipes,
            inputKey: \ListRecipesRequest.nextToken,
            outputKey: \ListRecipesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - recipeVersion: Return only those recipes with a version identifier of LATEST_WORKING or LATEST_PUBLISHED. If RecipeVersion is omitted, ListRecipes returns all of the LATEST_PUBLISHED recipe versions. Valid values: LATEST_WORKING | LATEST_PUBLISHED
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecipesPaginator(
        maxResults: Int? = nil,
        recipeVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRecipesRequest, ListRecipesResponse> {
        let input = ListRecipesRequest(
            maxResults: maxResults, 
            recipeVersion: recipeVersion
        )
        return self.listRecipesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRulesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRulesetsPaginator(
        _ input: ListRulesetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRulesetsRequest, ListRulesetsResponse> {
        return .init(
            input: input,
            command: self.listRulesets,
            inputKey: \ListRulesetsRequest.nextToken,
            outputKey: \ListRulesetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRulesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - targetArn: The Amazon Resource Name (ARN) of a resource (dataset). Using this parameter  indicates to return only those rulesets that are associated with the specified resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRulesetsPaginator(
        maxResults: Int? = nil,
        targetArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRulesetsRequest, ListRulesetsResponse> {
        let input = ListRulesetsRequest(
            maxResults: maxResults, 
            targetArn: targetArn
        )
        return self.listRulesetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchedulesPaginator(
        _ input: ListSchedulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSchedulesRequest, ListSchedulesResponse> {
        return .init(
            input: input,
            command: self.listSchedules,
            inputKey: \ListSchedulesRequest.nextToken,
            outputKey: \ListSchedulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobName: The name of the job that these schedules apply to.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchedulesPaginator(
        jobName: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSchedulesRequest, ListSchedulesResponse> {
        let input = ListSchedulesRequest(
            jobName: jobName, 
            maxResults: maxResults
        )
        return self.listSchedulesPaginator(input, logger: logger)
    }
}

extension DataBrew.ListDatasetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListDatasetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension DataBrew.ListJobRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListJobRunsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension DataBrew.ListJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListJobsRequest {
        return .init(
            datasetName: self.datasetName,
            maxResults: self.maxResults,
            nextToken: token,
            projectName: self.projectName
        )
    }
}

extension DataBrew.ListProjectsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListProjectsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension DataBrew.ListRecipeVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListRecipeVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension DataBrew.ListRecipesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListRecipesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recipeVersion: self.recipeVersion
        )
    }
}

extension DataBrew.ListRulesetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListRulesetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            targetArn: self.targetArn
        )
    }
}

extension DataBrew.ListSchedulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DataBrew.ListSchedulesRequest {
        return .init(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
