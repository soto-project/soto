//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DataBrew {
    // MARK: Enums

    public enum AnalyticsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        public var description: String { return self.rawValue }
    }

    public enum CompressionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case brotli = "BROTLI"
        case bzip2 = "BZIP2"
        case deflate = "DEFLATE"
        case gzip = "GZIP"
        case lz4 = "LZ4"
        case lzo = "LZO"
        case snappy = "SNAPPY"
        case zlib = "ZLIB"
        case zstd = "ZSTD"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseOutputMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case newTable = "NEW_TABLE"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
        public var description: String { return self.rawValue }
    }

    public enum InputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case excel = "EXCEL"
        case json = "JSON"
        case orc = "ORC"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profile = "PROFILE"
        case recipe = "RECIPE"
        public var description: String { return self.rawValue }
    }

    public enum LogSubscription: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum OrderedBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastModifiedDate = "LAST_MODIFIED_DATE"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avro = "AVRO"
        case csv = "CSV"
        case glueparquet = "GLUEPARQUET"
        case json = "JSON"
        case orc = "ORC"
        case parquet = "PARQUET"
        case tableauhyper = "TABLEAUHYPER"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datetime = "Datetime"
        case number = "Number"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum SampleMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customRows = "CUSTOM_ROWS"
        case fullDataset = "FULL_DATASET"
        public var description: String { return self.rawValue }
    }

    public enum SampleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case firstN = "FIRST_N"
        case lastN = "LAST_N"
        case random = "RANDOM"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case provisioning = "PROVISIONING"
        case ready = "READY"
        case recycling = "RECYCLING"
        case rotating = "ROTATING"
        case terminated = "TERMINATED"
        case terminating = "TERMINATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case database = "DATABASE"
        case datacatalog = "DATA-CATALOG"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum ThresholdType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum ThresholdUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "COUNT"
        case percentage = "PERCENTAGE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case checkAll = "CHECK_ALL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AllowedStatistics: AWSEncodableShape & AWSDecodableShape {
        /// One or more column statistics to allow for columns that contain detected entities.
        public let statistics: [String]

        public init(statistics: [String]) {
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.statistics.forEach {
                try validate($0, name: "statistics[]", parent: name, max: 128)
                try validate($0, name: "statistics[]", parent: name, min: 1)
                try validate($0, name: "statistics[]", parent: name, pattern: "^[A-Z\\_]+$")
            }
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case statistics = "Statistics"
        }
    }

    public struct BatchDeleteRecipeVersionRequest: AWSEncodableShape {
        /// The name of the recipe whose versions are to be deleted.
        public let name: String
        /// An array of version identifiers, for the recipe versions to be deleted. You can specify numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
        public let recipeVersions: [String]

        public init(name: String, recipeVersions: [String]) {
            self.name = name
            self.recipeVersions = recipeVersions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.recipeVersions, forKey: .recipeVersions)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.recipeVersions.forEach {
                try validate($0, name: "recipeVersions[]", parent: name, max: 16)
                try validate($0, name: "recipeVersions[]", parent: name, min: 1)
            }
            try self.validate(self.recipeVersions, name: "recipeVersions", parent: name, max: 50)
            try self.validate(self.recipeVersions, name: "recipeVersions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recipeVersions = "RecipeVersions"
        }
    }

    public struct BatchDeleteRecipeVersionResponse: AWSDecodableShape {
        /// Errors, if any, that occurred while attempting to delete the recipe versions.
        public let errors: [RecipeVersionErrorDetail]?
        /// The name of the recipe that was modified.
        public let name: String

        public init(errors: [RecipeVersionErrorDetail]? = nil, name: String) {
            self.errors = errors
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case name = "Name"
        }
    }

    public struct ColumnSelector: AWSEncodableShape & AWSDecodableShape {
        /// The name of a column from a dataset.
        public let name: String?
        /// A regular expression for selecting a column from a dataset.
        public let regex: String?

        public init(name: String? = nil, regex: String? = nil) {
            self.name = name
            self.regex = regex
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case regex = "Regex"
        }
    }

    public struct ColumnStatisticsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of column selectors. Selectors can be used to select columns from the dataset.  When selectors are undefined, configuration will be applied to all supported columns.
        public let selectors: [ColumnSelector]?
        /// Configuration for evaluations. Statistics can be used to select evaluations and override  parameters of evaluations.
        public let statistics: StatisticsConfiguration

        public init(selectors: [ColumnSelector]? = nil, statistics: StatisticsConfiguration) {
            self.selectors = selectors
            self.statistics = statistics
        }

        public func validate(name: String) throws {
            try self.selectors?.forEach {
                try $0.validate(name: "\(name).selectors[]")
            }
            try self.validate(self.selectors, name: "selectors", parent: name, min: 1)
            try self.statistics.validate(name: "\(name).statistics")
        }

        private enum CodingKeys: String, CodingKey {
            case selectors = "Selectors"
            case statistics = "Statistics"
        }
    }

    public struct ConditionExpression: AWSEncodableShape & AWSDecodableShape {
        /// A specific condition to apply to a recipe action. For more information, see Recipe structure in the Glue DataBrew Developer Guide.
        public let condition: String
        /// A column to apply this condition to.
        public let targetColumn: String
        /// A value that the condition must evaluate to for the condition to succeed.
        public let value: String?

        public init(condition: String, targetColumn: String, value: String? = nil) {
            self.condition = condition
            self.targetColumn = targetColumn
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 128)
            try self.validate(self.condition, name: "condition", parent: name, min: 1)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^[A-Z\\_]+$")
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, max: 1024)
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case targetColumn = "TargetColumn"
            case value = "Value"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The name of the dataset to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?
        /// Metadata tags to apply to this dataset.
        public let tags: [String: String]?

        public init(format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, name: String, pathOptions: PathOptions? = nil, tags: [String: String]? = nil) {
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.name = name
            self.pathOptions = pathOptions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.input.validate(name: "\(name).input")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.pathOptions?.validate(name: "\(name).pathOptions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case name = "Name"
            case pathOptions = "PathOptions"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateProfileJobRequest: AWSEncodableShape {
        /// Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
        public let configuration: ProfileConfiguration?
        /// The name of the dataset that this job is to act upon.
        public let datasetName: String
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - SSE-KMS - Server-side encryption with  KMS-managed keys.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can use when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        public let outputLocation: S3Location
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// Metadata tags to apply to this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// List of validation configurations that are applied to the profile job.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(configuration: ProfileConfiguration? = nil, datasetName: String, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputLocation: S3Location, roleArn: String, tags: [String: String]? = nil, timeout: Int? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.configuration = configuration
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputLocation = outputLocation
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.validationConfigurations = validationConfigurations
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
            try self.validationConfigurations?.forEach {
                try $0.validate(name: "\(name).validationConfigurations[]")
            }
            try self.validate(self.validationConfigurations, name: "validationConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputLocation = "OutputLocation"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct CreateProfileJobResponse: AWSDecodableShape {
        /// The name of the job that was created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// The name of an existing dataset to associate this project with.
        public let datasetName: String
        /// A unique name for the new project. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// The name of an existing recipe to associate with the project.
        public let recipeName: String
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed for this request.
        public let roleArn: String
        public let sample: Sample?
        /// Metadata tags to apply to this project.
        public let tags: [String: String]?

        public init(datasetName: String, name: String, recipeName: String, roleArn: String, sample: Sample? = nil, tags: [String: String]? = nil) {
            self.datasetName = datasetName
            self.name = name
            self.recipeName = recipeName
            self.roleArn = roleArn
            self.sample = sample
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeName, name: "recipeName", parent: name, max: 255)
            try self.validate(self.recipeName, name: "recipeName", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.sample?.validate(name: "\(name).sample")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetName = "DatasetName"
            case name = "Name"
            case recipeName = "RecipeName"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case tags = "Tags"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The name of the project that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateRecipeJobRequest: AWSEncodableShape {
        /// Represents a list of JDBC database output objects which defines the output destination for  a DataBrew recipe job to write to.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset that this job processes.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// A unique name for the job. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// Either the name of an existing project, or a combination of a recipe and a dataset to associate with the recipe.
        public let projectName: String?
        public let recipeReference: RecipeReference?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// Metadata tags to apply to this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, roleArn: String, tags: [String: String]? = nil, timeout: Int? = nil) {
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.databaseOutputs?.forEach {
                try $0.validate(name: "\(name).databaseOutputs[]")
            }
            try self.validate(self.databaseOutputs, name: "databaseOutputs", parent: name, min: 1)
            try self.dataCatalogOutputs?.forEach {
                try $0.validate(name: "\(name).dataCatalogOutputs[]")
            }
            try self.validate(self.dataCatalogOutputs, name: "dataCatalogOutputs", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.recipeReference?.validate(name: "\(name).recipeReference")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
        }
    }

    public struct CreateRecipeJobResponse: AWSDecodableShape {
        /// The name of the job that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateRecipeRequest: AWSEncodableShape {
        /// A description for the recipe.
        public let description: String?
        /// A unique name for the recipe. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// An array containing the steps to be performed by the recipe. Each recipe step consists of one recipe action and (optionally) an array of condition expressions.
        public let steps: [RecipeStep]
        /// Metadata tags to apply to this recipe.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, steps: [RecipeStep], tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.steps = steps
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.steps.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct CreateRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateRulesetRequest: AWSEncodableShape {
        /// The description of the ruleset.
        public let description: String?
        /// The name of the ruleset to be created. Valid characters are alphanumeric  (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// A list of rules that are defined with the ruleset. A rule includes  one or more checks to be validated on a DataBrew dataset.
        public let rules: [Rule]
        /// Metadata tags to apply to the ruleset.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of a resource (dataset) that the  ruleset is associated with.
        public let targetArn: String

        public init(description: String? = nil, name: String, rules: [Rule], tags: [String: String]? = nil, targetArn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.tags = tags
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 2048)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case rules = "Rules"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct CreateRulesetResponse: AWSDecodableShape {
        /// The unique name of the created ruleset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateScheduleRequest: AWSEncodableShape {
        /// The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String
        /// The name or names of one or more jobs to be run.
        public let jobNames: [String]?
        /// A unique name for the schedule. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// Metadata tags to apply to this schedule.
        public let tags: [String: String]?

        public init(cronExpression: String, jobNames: [String]? = nil, name: String, tags: [String: String]? = nil) {
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, max: 512)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, min: 1)
            try self.jobNames?.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 240)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
            }
            try self.validate(self.jobNames, name: "jobNames", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CsvOptions: AWSEncodableShape & AWSDecodableShape {
        /// A single character that specifies the delimiter being used in the CSV file.
        public let delimiter: String?
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public let headerRow: Bool?

        public init(delimiter: String? = nil, headerRow: Bool? = nil) {
            self.delimiter = delimiter
            self.headerRow = headerRow
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case headerRow = "HeaderRow"
        }
    }

    public struct CsvOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// A single character that specifies the delimiter used to create CSV job output.
        public let delimiter: String?

        public init(delimiter: String? = nil) {
            self.delimiter = delimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
        }
    }

    public struct DataCatalogInputDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the Amazon Web Services account that holds the Data Catalog that stores the data.
        public let catalogId: String?
        /// The name of a database in the Data Catalog.
        public let databaseName: String
        /// The name of a database table in the Data Catalog. This table corresponds to a DataBrew dataset.
        public let tableName: String
        /// Represents an Amazon location where DataBrew can store intermediate results.
        public let tempDirectory: S3Location?

        public init(catalogId: String? = nil, databaseName: String, tableName: String, tempDirectory: S3Location? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct DataCatalogOutput: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the Amazon Web Services account that holds the Data Catalog that  stores the data.
        public let catalogId: String?
        /// The name of a database in the Data Catalog.
        public let databaseName: String
        /// Represents options that specify how and where DataBrew writes the database output  generated by recipe jobs.
        public let databaseOptions: DatabaseTableOutputOptions?
        /// A value that, if true, means that any data in the location specified for output  is overwritten with new output. Not supported with DatabaseOptions.
        public let overwrite: Bool?
        /// Represents options that specify how and where DataBrew writes the Amazon S3  output generated by recipe jobs.
        public let s3Options: S3TableOutputOptions?
        /// The name of a table in the Data Catalog.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, databaseOptions: DatabaseTableOutputOptions? = nil, overwrite: Bool? = nil, s3Options: S3TableOutputOptions? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.databaseOptions = databaseOptions
            self.overwrite = overwrite
            self.s3Options = s3Options
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.databaseOptions?.validate(name: "\(name).databaseOptions")
            try self.s3Options?.validate(name: "\(name).s3Options")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case databaseOptions = "DatabaseOptions"
            case overwrite = "Overwrite"
            case s3Options = "S3Options"
            case tableName = "TableName"
        }
    }

    public struct DatabaseInputDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The table within the target database.
        public let databaseTableName: String?
        /// The Glue Connection that stores the connection information for the target database.
        public let glueConnectionName: String
        /// Custom SQL to run against the provided Glue connection. This SQL will be used as  the input for DataBrew projects and jobs.
        public let queryString: String?
        public let tempDirectory: S3Location?

        public init(databaseTableName: String? = nil, glueConnectionName: String, queryString: String? = nil, tempDirectory: S3Location? = nil) {
            self.databaseTableName = databaseTableName
            self.glueConnectionName = glueConnectionName
            self.queryString = queryString
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseTableName, name: "databaseTableName", parent: name, max: 255)
            try self.validate(self.databaseTableName, name: "databaseTableName", parent: name, min: 1)
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, max: 255)
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, min: 1)
            try self.validate(self.queryString, name: "queryString", parent: name, max: 10000)
            try self.validate(self.queryString, name: "queryString", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseTableName = "DatabaseTableName"
            case glueConnectionName = "GlueConnectionName"
            case queryString = "QueryString"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct DatabaseOutput: AWSEncodableShape & AWSDecodableShape {
        /// Represents options that specify how and where DataBrew writes the database output  generated by recipe jobs.
        public let databaseOptions: DatabaseTableOutputOptions
        /// The output mode to write into the database. Currently supported option: NEW_TABLE.
        public let databaseOutputMode: DatabaseOutputMode?
        /// The Glue connection that stores the connection information for the  target database.
        public let glueConnectionName: String

        public init(databaseOptions: DatabaseTableOutputOptions, databaseOutputMode: DatabaseOutputMode? = nil, glueConnectionName: String) {
            self.databaseOptions = databaseOptions
            self.databaseOutputMode = databaseOutputMode
            self.glueConnectionName = glueConnectionName
        }

        public func validate(name: String) throws {
            try self.databaseOptions.validate(name: "\(name).databaseOptions")
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, max: 255)
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseOptions = "DatabaseOptions"
            case databaseOutputMode = "DatabaseOutputMode"
            case glueConnectionName = "GlueConnectionName"
        }
    }

    public struct DatabaseTableOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// A prefix for the name of a table DataBrew will create in the database.
        public let tableName: String
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can store  intermediate results.
        public let tempDirectory: S3Location?

        public init(tableName: String, tempDirectory: S3Location? = nil) {
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case tableName = "TableName"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct Dataset: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the dataset.
        public let accountId: String?
        /// The date and time that the dataset was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the dataset.
        public let createdBy: String?
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        /// A set of options that define how DataBrew interprets the data in the dataset.
        public let formatOptions: FormatOptions?
        /// Information on how DataBrew can find the dataset, in either the Glue Data Catalog or Amazon S3.
        public let input: Input
        /// The Amazon Resource Name (ARN) of the user who last modified the dataset.
        public let lastModifiedBy: String?
        /// The last modification date and time of the dataset.
        public let lastModifiedDate: Date?
        /// The unique name of the dataset.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3  path of the dataset.
        public let pathOptions: PathOptions?
        /// The unique Amazon Resource Name (ARN) for the dataset.
        public let resourceArn: String?
        /// The location of the data for the dataset, either Amazon S3 or the Glue Data Catalog.
        public let source: Source?
        /// Metadata tags that have been applied to the dataset.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, pathOptions: PathOptions? = nil, resourceArn: String? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.pathOptions = pathOptions
            self.resourceArn = resourceArn
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case pathOptions = "PathOptions"
            case resourceArn = "ResourceArn"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct DatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// Optional boolean value that defines whether the captured value of this parameter  should be used to create a new column in a dataset.
        public let createColumn: Bool?
        /// Additional parameter options such as a format and a timezone. Required for datetime parameters.
        public let datetimeOptions: DatetimeOptions?
        /// The optional filter expression structure to apply additional matching criteria to the parameter.
        public let filter: FilterExpression?
        /// The name of the parameter that is used in the dataset's Amazon S3 path.
        public let name: String
        /// The type of the dataset parameter, can be one of a 'String', 'Number' or 'Datetime'.
        public let type: ParameterType

        public init(createColumn: Bool? = nil, datetimeOptions: DatetimeOptions? = nil, filter: FilterExpression? = nil, name: String, type: ParameterType) {
            self.createColumn = createColumn
            self.datetimeOptions = datetimeOptions
            self.filter = filter
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.datetimeOptions?.validate(name: "\(name).datetimeOptions")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case createColumn = "CreateColumn"
            case datetimeOptions = "DatetimeOptions"
            case filter = "Filter"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DatetimeOptions: AWSEncodableShape & AWSDecodableShape {
        /// Required option, that defines the datetime format used for a date parameter in the  Amazon S3 path. Should use only supported datetime specifiers and separation characters, all  literal a-z or A-Z characters should be escaped with single quotes. E.g. "MM.dd.yyyy-'at'-HH:mm".
        public let format: String
        /// Optional value for a non-US locale code, needed for correct interpretation of some date formats.
        public let localeCode: String?
        /// Optional value for a timezone offset of the datetime parameter value in the Amazon S3  path. Shouldn't be used if Format for this parameter includes timezone fields. If no offset specified, UTC is assumed.
        public let timezoneOffset: String?

        public init(format: String, localeCode: String? = nil, timezoneOffset: String? = nil) {
            self.format = format
            self.localeCode = localeCode
            self.timezoneOffset = timezoneOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.format, name: "format", parent: name, max: 100)
            try self.validate(self.format, name: "format", parent: name, min: 2)
            try self.validate(self.localeCode, name: "localeCode", parent: name, max: 100)
            try self.validate(self.localeCode, name: "localeCode", parent: name, min: 2)
            try self.validate(self.localeCode, name: "localeCode", parent: name, pattern: "^[A-Za-z0-9_\\.#@\\-]+$")
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, max: 6)
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, min: 1)
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, pattern: "^(Z|[-+](\\d|\\d{2}|\\d{2}:?\\d{2}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case localeCode = "LocaleCode"
            case timezoneOffset = "TimezoneOffset"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// The name of the dataset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// The name of the job to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        /// The name of the job that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// The name of the project to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        /// The name of the project that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteRecipeVersionRequest: AWSEncodableShape {
        /// The name of the recipe.
        public let name: String
        /// The version of the recipe to be deleted. You can specify a numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
        public let recipeVersion: String

        public init(name: String, recipeVersion: String) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.recipeVersion, key: "RecipeVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRecipeVersionResponse: AWSDecodableShape {
        /// The name of the recipe that was deleted.
        public let name: String
        /// The version of the recipe that was deleted.
        public let recipeVersion: String

        public init(name: String, recipeVersion: String) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct DeleteRulesetRequest: AWSEncodableShape {
        /// The name of the ruleset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRulesetResponse: AWSDecodableShape {
        /// The name of the deleted ruleset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteScheduleRequest: AWSEncodableShape {
        /// The name of the schedule to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The name of the dataset to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// The date and time that the dataset was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the dataset.
        public let createdBy: String?
        /// The file format of a dataset that is created from an Amazon S3 file  or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The identifier (user name) of the user who last modified the dataset.
        public let lastModifiedBy: String?
        /// The date and time that the dataset was last modified.
        public let lastModifiedDate: Date?
        /// The name of the dataset.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3  path of the dataset.
        public let pathOptions: PathOptions?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let resourceArn: String?
        /// The location of the data for this dataset, Amazon S3 or the  Glue Data Catalog.
        public let source: Source?
        /// Metadata tags associated with this dataset.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, pathOptions: PathOptions? = nil, resourceArn: String? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.pathOptions = pathOptions
            self.resourceArn = resourceArn
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case pathOptions = "PathOptions"
            case resourceArn = "ResourceArn"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct DescribeJobRequest: AWSEncodableShape {
        /// The name of the job to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobResponse: AWSDecodableShape {
        /// The date and time that the job was created.
        public let createDate: Date?
        /// The identifier (user name) of the user associated with the creation of the job.
        public let createdBy: String?
        /// Represents a list of JDBC database output objects which defines the output  destination for a DataBrew recipe job to write into.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The dataset that the job acts upon.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed.
        public let jobSample: JobSample?
        /// The identifier (user name) of the user who last modified the job.
        public let lastModifiedBy: String?
        /// The date and time that the job was last modified.
        public let lastModifiedDate: Date?
        /// Indicates whether Amazon CloudWatch logging is enabled for this job.
        public let logSubscription: LogSubscription?
        /// The maximum number of compute nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
        public let profileConfiguration: ProfileConfiguration?
        /// The DataBrew project associated with this job.
        public let projectName: String?
        public let recipeReference: RecipeReference?
        /// The Amazon Resource Name (ARN) of the job.
        public let resourceArn: String?
        /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String?
        /// Metadata tags associated with this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// The job type, which must be one of the following:    PROFILE - The job analyzes the dataset to determine its size, data types, data distribution, and more.    RECIPE - The job applies one or more transformations to a dataset.
        public let type: JobType?
        /// List of validation configurations that are applied to the profile job.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(createDate: Date? = nil, createdBy: String? = nil, databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, profileConfiguration: ProfileConfiguration? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, resourceArn: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, type: JobType? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.profileConfiguration = profileConfiguration
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.type = type
            self.validationConfigurations = validationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case profileConfiguration = "ProfileConfiguration"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
            case type = "Type"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct DescribeJobRunRequest: AWSEncodableShape {
        /// The name of the job being processed during this run.
        public let name: String
        /// The unique identifier of the job run.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.runId, key: "RunId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobRunResponse: AWSDecodableShape {
        /// The number of times that DataBrew has attempted to run the job.
        public let attempt: Int?
        /// The date and time when the job completed processing.
        public let completedOn: Date?
        /// Represents a list of JDBC database output objects which defines the output  destination for a DataBrew recipe job to write into.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset for the job to process.
        public let datasetName: String?
        /// A message indicating an error (if any) that was encountered when the job ran.
        public let errorMessage: String?
        /// The amount of time, in seconds, during which the job run consumed resources.
        public let executionTime: Int?
        /// The name of the job being processed during this run.
        public let jobName: String
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
        public let logGroupName: String?
        /// The current status of Amazon CloudWatch logging for the job run.
        public let logSubscription: LogSubscription?
        /// One or more output artifacts from a job run.
        public let outputs: [Output]?
        /// Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
        public let profileConfiguration: ProfileConfiguration?
        public let recipeReference: RecipeReference?
        /// The unique identifier of the job run.
        public let runId: String?
        /// The Amazon Resource Name (ARN) of the user who started the job run.
        public let startedBy: String?
        /// The date and time when the job run began.
        public let startedOn: Date?
        /// The current state of the job run entity itself.
        public let state: JobRunState?
        /// List of validation configurations that are applied to the profile job.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(attempt: Int? = nil, completedOn: Date? = nil, databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, errorMessage: String? = nil, executionTime: Int? = nil, jobName: String, jobSample: JobSample? = nil, logGroupName: String? = nil, logSubscription: LogSubscription? = nil, outputs: [Output]? = nil, profileConfiguration: ProfileConfiguration? = nil, recipeReference: RecipeReference? = nil, runId: String? = nil, startedBy: String? = nil, startedOn: Date? = nil, state: JobRunState? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.attempt = attempt
            self.completedOn = completedOn
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.jobName = jobName
            self.jobSample = jobSample
            self.logGroupName = logGroupName
            self.logSubscription = logSubscription
            self.outputs = outputs
            self.profileConfiguration = profileConfiguration
            self.recipeReference = recipeReference
            self.runId = runId
            self.startedBy = startedBy
            self.startedOn = startedOn
            self.state = state
            self.validationConfigurations = validationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case jobName = "JobName"
            case jobSample = "JobSample"
            case logGroupName = "LogGroupName"
            case logSubscription = "LogSubscription"
            case outputs = "Outputs"
            case profileConfiguration = "ProfileConfiguration"
            case recipeReference = "RecipeReference"
            case runId = "RunId"
            case startedBy = "StartedBy"
            case startedOn = "StartedOn"
            case state = "State"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        /// The name of the project to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The date and time that the project was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the project.
        public let createdBy: String?
        /// The dataset associated with the project.
        public let datasetName: String?
        /// The identifier (user name) of the user who last modified the project.
        public let lastModifiedBy: String?
        /// The date and time that the project was last modified.
        public let lastModifiedDate: Date?
        /// The name of the project.
        public let name: String
        /// The date and time when the project was opened.
        public let openDate: Date?
        /// The identifier (user name) of the user that opened the project for use.
        public let openedBy: String?
        /// The recipe associated with this job.
        public let recipeName: String?
        /// The Amazon Resource Name (ARN) of the project.
        public let resourceArn: String?
        /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String?
        public let sample: Sample?
        /// Describes the current state of the session:    PROVISIONING - allocating resources for the session.    INITIALIZING - getting the session ready for first use.    ASSIGNED - the session is ready for use.
        public let sessionStatus: SessionStatus?
        /// Metadata tags associated with this project.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, datasetName: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, openDate: Date? = nil, openedBy: String? = nil, recipeName: String? = nil, resourceArn: String? = nil, roleArn: String? = nil, sample: Sample? = nil, sessionStatus: SessionStatus? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.datasetName = datasetName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.openDate = openDate
            self.openedBy = openedBy
            self.recipeName = recipeName
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.sample = sample
            self.sessionStatus = sessionStatus
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case datasetName = "DatasetName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case openDate = "OpenDate"
            case openedBy = "OpenedBy"
            case recipeName = "RecipeName"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case sessionStatus = "SessionStatus"
            case tags = "Tags"
        }
    }

    public struct DescribeRecipeRequest: AWSEncodableShape {
        /// The name of the recipe to be described.
        public let name: String
        /// The recipe version identifier. If this parameter isn't specified, then the latest published version is returned.
        public let recipeVersion: String?

        public init(name: String, recipeVersion: String? = nil) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodeQuery(self.recipeVersion, key: "recipeVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRecipeResponse: AWSDecodableShape {
        /// The date and time that the recipe was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the recipe.
        public let createdBy: String?
        /// The description of the recipe.
        public let description: String?
        /// The identifier (user name) of the user who last modified the recipe.
        public let lastModifiedBy: String?
        /// The date and time that the recipe was last modified.
        public let lastModifiedDate: Date?
        /// The name of the recipe.
        public let name: String
        /// The name of the project associated with this recipe.
        public let projectName: String?
        /// The identifier (user name) of the user who last published the recipe.
        public let publishedBy: String?
        /// The date and time when the recipe was last published.
        public let publishedDate: Date?
        /// The recipe version identifier.
        public let recipeVersion: String?
        /// The ARN of the recipe.
        public let resourceArn: String?
        /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
        public let steps: [RecipeStep]?
        /// Metadata tags associated with this project.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, projectName: String? = nil, publishedBy: String? = nil, publishedDate: Date? = nil, recipeVersion: String? = nil, resourceArn: String? = nil, steps: [RecipeStep]? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.projectName = projectName
            self.publishedBy = publishedBy
            self.publishedDate = publishedDate
            self.recipeVersion = recipeVersion
            self.resourceArn = resourceArn
            self.steps = steps
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case projectName = "ProjectName"
            case publishedBy = "PublishedBy"
            case publishedDate = "PublishedDate"
            case recipeVersion = "RecipeVersion"
            case resourceArn = "ResourceArn"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct DescribeRulesetRequest: AWSEncodableShape {
        /// The name of the ruleset to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRulesetResponse: AWSDecodableShape {
        /// The date and time that the ruleset was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the ruleset.
        public let createdBy: String?
        /// The description of the ruleset.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the ruleset.
        public let lastModifiedBy: String?
        /// The modification date and time of the ruleset.
        public let lastModifiedDate: Date?
        /// The name of the ruleset.
        public let name: String
        /// The Amazon Resource Name (ARN) for the ruleset.
        public let resourceArn: String?
        /// A list of rules that are defined with the ruleset. A rule includes one  or more checks to be validated on a DataBrew dataset.
        public let rules: [Rule]?
        /// Metadata tags that have been applied to the ruleset.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset is  associated with.
        public let targetArn: String?

        public init(createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, rules: [Rule]? = nil, tags: [String: String]? = nil, targetArn: String? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.rules = rules
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case rules = "Rules"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct DescribeScheduleRequest: AWSEncodableShape {
        /// The name of the schedule to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeScheduleResponse: AWSDecodableShape {
        /// The date and time that the schedule was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the schedule.
        public let createdBy: String?
        /// The date or dates and time or times when the jobs are to be run for the schedule. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String?
        /// The name or names of one or more jobs to be run by using the schedule.
        public let jobNames: [String]?
        /// The identifier (user name) of the user who last modified the schedule.
        public let lastModifiedBy: String?
        /// The date and time that the schedule was last modified.
        public let lastModifiedDate: Date?
        /// The name of the schedule.
        public let name: String
        /// The Amazon Resource Name (ARN) of the schedule.
        public let resourceArn: String?
        /// Metadata tags associated with this schedule.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, cronExpression: String? = nil, jobNames: [String]? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct EntityDetectorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration of statistics that are allowed to be run on columns that  contain detected entities. When undefined, no statistics will be computed  on columns that contain detected entities.
        public let allowedStatistics: [AllowedStatistics]?
        /// Entity types to detect. Can be any of the following:   USA_SSN   EMAIL   USA_ITIN   USA_PASSPORT_NUMBER   PHONE_NUMBER   USA_DRIVING_LICENSE   BANK_ACCOUNT   CREDIT_CARD   IP_ADDRESS   MAC_ADDRESS   USA_DEA_NUMBER   USA_HCPCS_CODE   USA_NATIONAL_PROVIDER_IDENTIFIER   USA_NATIONAL_DRUG_CODE   USA_HEALTH_INSURANCE_CLAIM_NUMBER   USA_MEDICARE_BENEFICIARY_IDENTIFIER   USA_CPT_CODE   PERSON_NAME   DATE   The Entity type group USA_ALL is also supported, and includes all of the  above entity types except PERSON_NAME and DATE.
        public let entityTypes: [String]

        public init(allowedStatistics: [AllowedStatistics]? = nil, entityTypes: [String]) {
            self.allowedStatistics = allowedStatistics
            self.entityTypes = entityTypes
        }

        public func validate(name: String) throws {
            try self.allowedStatistics?.forEach {
                try $0.validate(name: "\(name).allowedStatistics[]")
            }
            try self.validate(self.allowedStatistics, name: "allowedStatistics", parent: name, min: 1)
            try self.entityTypes.forEach {
                try validate($0, name: "entityTypes[]", parent: name, max: 128)
                try validate($0, name: "entityTypes[]", parent: name, min: 1)
                try validate($0, name: "entityTypes[]", parent: name, pattern: "^[A-Z_][A-Z\\\\d_]*$")
            }
            try self.validate(self.entityTypes, name: "entityTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedStatistics = "AllowedStatistics"
            case entityTypes = "EntityTypes"
        }
    }

    public struct ExcelOptions: AWSEncodableShape & AWSDecodableShape {
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public let headerRow: Bool?
        /// One or more sheet numbers in the Excel file that will be included in the dataset.
        public let sheetIndexes: [Int]?
        /// One or more named sheets in the Excel file that will be included in the dataset.
        public let sheetNames: [String]?

        public init(headerRow: Bool? = nil, sheetIndexes: [Int]? = nil, sheetNames: [String]? = nil) {
            self.headerRow = headerRow
            self.sheetIndexes = sheetIndexes
            self.sheetNames = sheetNames
        }

        public func validate(name: String) throws {
            try self.sheetIndexes?.forEach {
                try validate($0, name: "sheetIndexes[]", parent: name, max: 200)
                try validate($0, name: "sheetIndexes[]", parent: name, min: 0)
            }
            try self.validate(self.sheetIndexes, name: "sheetIndexes", parent: name, max: 1)
            try self.validate(self.sheetIndexes, name: "sheetIndexes", parent: name, min: 1)
            try self.sheetNames?.forEach {
                try validate($0, name: "sheetNames[]", parent: name, max: 31)
                try validate($0, name: "sheetNames[]", parent: name, min: 1)
            }
            try self.validate(self.sheetNames, name: "sheetNames", parent: name, max: 1)
            try self.validate(self.sheetNames, name: "sheetNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headerRow = "HeaderRow"
            case sheetIndexes = "SheetIndexes"
            case sheetNames = "SheetNames"
        }
    }

    public struct FilesLimit: AWSEncodableShape & AWSDecodableShape {
        /// The number of Amazon S3 files to select.
        public let maxFiles: Int
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses DESCENDING order, i.e. most recent files are selected first. Another possible value is ASCENDING.
        public let order: Order?
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses LAST_MODIFIED_DATE as  a sorting criteria. Currently it's the only allowed value.
        public let orderedBy: OrderedBy?

        public init(maxFiles: Int, order: Order? = nil, orderedBy: OrderedBy? = nil) {
            self.maxFiles = maxFiles
            self.order = order
            self.orderedBy = orderedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxFiles, name: "maxFiles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxFiles = "MaxFiles"
            case order = "Order"
            case orderedBy = "OrderedBy"
        }
    }

    public struct FilterExpression: AWSEncodableShape & AWSDecodableShape {
        /// The expression which includes condition names followed by substitution variables, possibly grouped  and combined with other conditions. For example, "(starts_with :prefix1 or starts_with :prefix2) and  (ends_with :suffix1 or ends_with :suffix2)". Substitution variables should start with ':' symbol.
        public let expression: String
        /// The map of substitution variable names to their values used in this filter expression.
        public let valuesMap: [String: String]

        public init(expression: String, valuesMap: [String: String]) {
            self.expression = expression
            self.valuesMap = valuesMap
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 4)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[<>0-9A-Za-z_.,:)(!= ]+$")
            try self.valuesMap.forEach {
                try validate($0.key, name: "valuesMap.key", parent: name, max: 128)
                try validate($0.key, name: "valuesMap.key", parent: name, min: 2)
                try validate($0.key, name: "valuesMap.key", parent: name, pattern: "^:[A-Za-z0-9_]+$")
                try validate($0.value, name: "valuesMap[\"\($0.key)\"]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case valuesMap = "ValuesMap"
        }
    }

    public struct FormatOptions: AWSEncodableShape & AWSDecodableShape {
        /// Options that define how CSV input is to be interpreted by DataBrew.
        public let csv: CsvOptions?
        /// Options that define how Excel input is to be interpreted by DataBrew.
        public let excel: ExcelOptions?
        /// Options that define how JSON input is to be interpreted by DataBrew.
        public let json: JsonOptions?

        public init(csv: CsvOptions? = nil, excel: ExcelOptions? = nil, json: JsonOptions? = nil) {
            self.csv = csv
            self.excel = excel
            self.json = json
        }

        public func validate(name: String) throws {
            try self.csv?.validate(name: "\(name).csv")
            try self.excel?.validate(name: "\(name).excel")
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "Csv"
            case excel = "Excel"
            case json = "Json"
        }
    }

    public struct Input: AWSEncodableShape & AWSDecodableShape {
        /// Connection information for dataset input files stored in a database.
        public let databaseInputDefinition: DatabaseInputDefinition?
        /// The Glue Data Catalog parameters for the data.
        public let dataCatalogInputDefinition: DataCatalogInputDefinition?
        /// Contains additional resource information needed for specific datasets.
        public let metadata: Metadata?
        /// The Amazon S3 location where the data is stored.
        public let s3InputDefinition: S3Location?

        public init(databaseInputDefinition: DatabaseInputDefinition? = nil, dataCatalogInputDefinition: DataCatalogInputDefinition? = nil, metadata: Metadata? = nil, s3InputDefinition: S3Location? = nil) {
            self.databaseInputDefinition = databaseInputDefinition
            self.dataCatalogInputDefinition = dataCatalogInputDefinition
            self.metadata = metadata
            self.s3InputDefinition = s3InputDefinition
        }

        public func validate(name: String) throws {
            try self.databaseInputDefinition?.validate(name: "\(name).databaseInputDefinition")
            try self.dataCatalogInputDefinition?.validate(name: "\(name).dataCatalogInputDefinition")
            try self.metadata?.validate(name: "\(name).metadata")
            try self.s3InputDefinition?.validate(name: "\(name).s3InputDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseInputDefinition = "DatabaseInputDefinition"
            case dataCatalogInputDefinition = "DataCatalogInputDefinition"
            case metadata = "Metadata"
            case s3InputDefinition = "S3InputDefinition"
        }
    }

    public struct Job: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the job.
        public let accountId: String?
        /// The date and time that the job was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the job.
        public let createdBy: String?
        /// Represents a list of JDBC database output objects which defines the output  destination for a DataBrew recipe job to write into.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output  from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// A dataset that the job is to process.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job output. For more information, see Encrypting data written by DataBrew jobs
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default value is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public let jobSample: JobSample?
        /// The Amazon Resource Name (ARN) of the user who last modified the job.
        public let lastModifiedBy: String?
        /// The modification date and time of the job.
        public let lastModifiedDate: Date?
        /// The current status of Amazon CloudWatch logging for the job.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that can be consumed when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The unique name of the job.
        public let name: String
        /// One or more artifacts that represent output from running the job.
        public let outputs: [Output]?
        /// The name of the project that the job is associated with.
        public let projectName: String?
        /// A set of steps that the job runs.
        public let recipeReference: RecipeReference?
        /// The unique Amazon Resource Name (ARN) for the job.
        public let resourceArn: String?
        /// The Amazon Resource Name (ARN) of the role to be assumed for this job.
        public let roleArn: String?
        /// Metadata tags that have been applied to the job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// The job type of the job, which must be one of the following:    PROFILE - A job to analyze a dataset, to determine its size, data types, data distribution, and more.    RECIPE - A job to apply one or more transformations to a dataset.
        public let type: JobType?
        /// List of validation configurations that are applied to the profile job.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, resourceArn: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, type: JobType? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.type = type
            self.validationConfigurations = validationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
            case type = "Type"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct JobRun: AWSDecodableShape {
        /// The number of times that DataBrew has attempted to run the job.
        public let attempt: Int?
        /// The date and time when the job completed processing.
        public let completedOn: Date?
        /// Represents a list of JDBC database output objects which defines the output  destination for a DataBrew recipe job to write into.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output  from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset for the job to process.
        public let datasetName: String?
        /// A message indicating an error (if any) that was encountered when the job ran.
        public let errorMessage: String?
        /// The amount of time, in seconds, during which a job run consumed resources.
        public let executionTime: Int?
        /// The name of the job being processed during this run.
        public let jobName: String?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public let jobSample: JobSample?
        /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
        public let logGroupName: String?
        /// The current status of Amazon CloudWatch logging for the job run.
        public let logSubscription: LogSubscription?
        /// One or more output artifacts from a job run.
        public let outputs: [Output]?
        /// The set of steps processed by the job.
        public let recipeReference: RecipeReference?
        /// The unique identifier of the job run.
        public let runId: String?
        /// The Amazon Resource Name (ARN) of the user who initiated the job run.
        public let startedBy: String?
        /// The date and time when the job run began.
        public let startedOn: Date?
        /// The current state of the job run entity itself.
        public let state: JobRunState?
        /// List of validation configurations that are applied to the profile job run.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(attempt: Int? = nil, completedOn: Date? = nil, databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, errorMessage: String? = nil, executionTime: Int? = nil, jobName: String? = nil, jobSample: JobSample? = nil, logGroupName: String? = nil, logSubscription: LogSubscription? = nil, outputs: [Output]? = nil, recipeReference: RecipeReference? = nil, runId: String? = nil, startedBy: String? = nil, startedOn: Date? = nil, state: JobRunState? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.attempt = attempt
            self.completedOn = completedOn
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.jobName = jobName
            self.jobSample = jobSample
            self.logGroupName = logGroupName
            self.logSubscription = logSubscription
            self.outputs = outputs
            self.recipeReference = recipeReference
            self.runId = runId
            self.startedBy = startedBy
            self.startedOn = startedOn
            self.state = state
            self.validationConfigurations = validationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case jobName = "JobName"
            case jobSample = "JobSample"
            case logGroupName = "LogGroupName"
            case logSubscription = "LogSubscription"
            case outputs = "Outputs"
            case recipeReference = "RecipeReference"
            case runId = "RunId"
            case startedBy = "StartedBy"
            case startedOn = "StartedOn"
            case state = "State"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct JobSample: AWSEncodableShape & AWSDecodableShape {
        /// A value that determines whether the profile job is run on the entire dataset or a specified number of rows. This value must be one of the following:   FULL_DATASET - The profile job is run on the entire dataset.   CUSTOM_ROWS - The profile job is run on the number of rows specified in the Size parameter.
        public let mode: SampleMode?
        /// The Size parameter is only required when the mode is CUSTOM_ROWS. The profile job is run on the specified number of rows. The maximum value for size is Long.MAX_VALUE. Long.MAX_VALUE = 9223372036854775807
        public let size: Int64?

        public init(mode: SampleMode? = nil, size: Int64? = nil) {
            self.mode = mode
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
            case size = "Size"
        }
    }

    public struct JsonOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value that specifies whether JSON input contains embedded new line characters.
        public let multiLine: Bool?

        public init(multiLine: Bool? = nil) {
            self.multiLine = multiLine
        }

        private enum CodingKeys: String, CodingKey {
            case multiLine = "MultiLine"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// A list of datasets that are defined.
        public let datasets: [Dataset]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(datasets: [Dataset], nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "Datasets"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobRunsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The name of the job.
        public let name: String
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "Name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobRunsResponse: AWSDecodableShape {
        /// A list of job runs that have occurred for the specified job.
        public let jobRuns: [JobRun]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobRuns: [JobRun], nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The name of a dataset. Using this parameter indicates to return only those jobs that act on the specified dataset.
        public let datasetName: String?
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token generated by DataBrew that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the NextToken value from the response object of the previous page call.
        public let nextToken: String?
        /// The name of a project. Using this parameter indicates to return only those jobs that are associated with the specified project.
        public let projectName: String?

        public init(datasetName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectName: String? = nil) {
            self.datasetName = datasetName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.datasetName, key: "datasetName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectName, key: "projectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// A list of jobs that are defined.
        public let jobs: [Job]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobs: [Job], nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of projects that are defined .
        public let projects: [Project]

        public init(nextToken: String? = nil, projects: [Project]) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projects = "Projects"
        }
    }

    public struct ListRecipeVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The name of the recipe for which to return version information.
        public let name: String
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecipeVersionsResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of versions for the specified recipe.
        public let recipes: [Recipe]

        public init(nextToken: String? = nil, recipes: [Recipe]) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recipes = "Recipes"
        }
    }

    public struct ListRecipesRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// Return only those recipes with a version identifier of LATEST_WORKING or LATEST_PUBLISHED. If RecipeVersion is omitted, ListRecipes returns all of the LATEST_PUBLISHED recipe versions. Valid values: LATEST_WORKING | LATEST_PUBLISHED
        public let recipeVersion: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, recipeVersion: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeVersion = recipeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.recipeVersion, key: "recipeVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecipesResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of recipes that are defined.
        public let recipes: [Recipe]

        public init(nextToken: String? = nil, recipes: [Recipe]) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recipes = "Recipes"
        }
    }

    public struct ListRulesetsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token generated by DataBrew that specifies where to continue pagination  if a previous request was truncated. To get the next set of pages, pass in  the NextToken value from the response object of the previous page call.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of a resource (dataset). Using this parameter  indicates to return only those rulesets that are associated with the specified resource.
        public let targetArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, targetArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetArn = targetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetArn, key: "targetArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 2048)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesetsResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of RulesetItem. RulesetItem contains meta data of a ruleset.
        public let rulesets: [RulesetItem]

        public init(nextToken: String? = nil, rulesets: [RulesetItem]) {
            self.nextToken = nextToken
            self.rulesets = rulesets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case rulesets = "Rulesets"
        }
    }

    public struct ListSchedulesRequest: AWSEncodableShape {
        /// The name of the job that these schedules apply to.
        public let jobName: String?
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.jobName, key: "jobName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 240)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchedulesResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of schedules that are defined.
        public let schedules: [Schedule]

        public init(nextToken: String? = nil, schedules: [Schedule]) {
            self.nextToken = nextToken
            self.schedules = schedules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schedules = "Schedules"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the DataBrew resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the DataBrew resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Metadata: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the dataset. Currently, DataBrew  only supports ARNs from Amazon AppFlow.
        public let sourceArn: String?

        public init(sourceArn: String? = nil) {
            self.sourceArn = sourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 2048)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "SourceArn"
        }
    }

    public struct Output: AWSEncodableShape & AWSDecodableShape {
        /// The compression algorithm used to compress the output text of the job.
        public let compressionFormat: CompressionFormat?
        /// The data format of the output of the job.
        public let format: OutputFormat?
        /// Represents options that define how DataBrew formats job output files.
        public let formatOptions: OutputFormatOptions?
        /// The location in Amazon S3 where the job writes its output.
        public let location: S3Location
        /// Maximum number of files to be generated by the job and written to the output folder. For output partitioned  by column(s), the MaxOutputFiles value is the maximum number of files per partition.
        public let maxOutputFiles: Int?
        /// A value that, if true, means that any data in the location specified for output is overwritten with new output.
        public let overwrite: Bool?
        /// The names of one or more partition columns for the output of the job.
        public let partitionColumns: [String]?

        public init(compressionFormat: CompressionFormat? = nil, format: OutputFormat? = nil, formatOptions: OutputFormatOptions? = nil, location: S3Location, maxOutputFiles: Int? = nil, overwrite: Bool? = nil, partitionColumns: [String]? = nil) {
            self.compressionFormat = compressionFormat
            self.format = format
            self.formatOptions = formatOptions
            self.location = location
            self.maxOutputFiles = maxOutputFiles
            self.overwrite = overwrite
            self.partitionColumns = partitionColumns
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.location.validate(name: "\(name).location")
            try self.validate(self.maxOutputFiles, name: "maxOutputFiles", parent: name, max: 999)
            try self.validate(self.maxOutputFiles, name: "maxOutputFiles", parent: name, min: 1)
            try self.partitionColumns?.forEach {
                try validate($0, name: "partitionColumns[]", parent: name, max: 255)
                try validate($0, name: "partitionColumns[]", parent: name, min: 1)
            }
            try self.validate(self.partitionColumns, name: "partitionColumns", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case compressionFormat = "CompressionFormat"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case location = "Location"
            case maxOutputFiles = "MaxOutputFiles"
            case overwrite = "Overwrite"
            case partitionColumns = "PartitionColumns"
        }
    }

    public struct OutputFormatOptions: AWSEncodableShape & AWSDecodableShape {
        /// Represents a set of options that define the structure of comma-separated value (CSV) job output.
        public let csv: CsvOutputOptions?

        public init(csv: CsvOutputOptions? = nil) {
            self.csv = csv
        }

        public func validate(name: String) throws {
            try self.csv?.validate(name: "\(name).csv")
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "Csv"
        }
    }

    public struct PathOptions: AWSEncodableShape & AWSDecodableShape {
        /// If provided, this structure imposes a limit on a number of files that should be selected.
        public let filesLimit: FilesLimit?
        /// If provided, this structure defines a date range for matching Amazon S3 objects based on their  LastModifiedDate attribute in Amazon S3.
        public let lastModifiedDateCondition: FilterExpression?
        /// A structure that maps names of parameters used in the Amazon S3 path of a dataset to their definitions.
        public let parameters: [String: DatasetParameter]?

        public init(filesLimit: FilesLimit? = nil, lastModifiedDateCondition: FilterExpression? = nil, parameters: [String: DatasetParameter]? = nil) {
            self.filesLimit = filesLimit
            self.lastModifiedDateCondition = lastModifiedDateCondition
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.filesLimit?.validate(name: "\(name).filesLimit")
            try self.lastModifiedDateCondition?.validate(name: "\(name).lastModifiedDateCondition")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filesLimit = "FilesLimit"
            case lastModifiedDateCondition = "LastModifiedDateCondition"
            case parameters = "Parameters"
        }
    }

    public struct ProfileConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of configurations for column evaluations. ColumnStatisticsConfigurations are used to  select evaluations and override parameters of evaluations for particular columns. When  ColumnStatisticsConfigurations is undefined,  the profile job will profile all supported columns  and run all supported  evaluations.
        public let columnStatisticsConfigurations: [ColumnStatisticsConfiguration]?
        /// Configuration for inter-column evaluations. Configuration can be used to select evaluations and override  parameters of evaluations. When configuration is undefined, the profile job will run all supported  inter-column evaluations.
        public let datasetStatisticsConfiguration: StatisticsConfiguration?
        /// Configuration of entity detection for a profile job. When undefined, entity detection is disabled.
        public let entityDetectorConfiguration: EntityDetectorConfiguration?
        /// List of column selectors. ProfileColumns can be used to select columns from the dataset. When  ProfileColumns is undefined, the profile job will profile all supported columns.
        public let profileColumns: [ColumnSelector]?

        public init(columnStatisticsConfigurations: [ColumnStatisticsConfiguration]? = nil, datasetStatisticsConfiguration: StatisticsConfiguration? = nil, entityDetectorConfiguration: EntityDetectorConfiguration? = nil, profileColumns: [ColumnSelector]? = nil) {
            self.columnStatisticsConfigurations = columnStatisticsConfigurations
            self.datasetStatisticsConfiguration = datasetStatisticsConfiguration
            self.entityDetectorConfiguration = entityDetectorConfiguration
            self.profileColumns = profileColumns
        }

        public func validate(name: String) throws {
            try self.columnStatisticsConfigurations?.forEach {
                try $0.validate(name: "\(name).columnStatisticsConfigurations[]")
            }
            try self.validate(self.columnStatisticsConfigurations, name: "columnStatisticsConfigurations", parent: name, min: 1)
            try self.datasetStatisticsConfiguration?.validate(name: "\(name).datasetStatisticsConfiguration")
            try self.entityDetectorConfiguration?.validate(name: "\(name).entityDetectorConfiguration")
            try self.profileColumns?.forEach {
                try $0.validate(name: "\(name).profileColumns[]")
            }
            try self.validate(self.profileColumns, name: "profileColumns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsConfigurations = "ColumnStatisticsConfigurations"
            case datasetStatisticsConfiguration = "DatasetStatisticsConfiguration"
            case entityDetectorConfiguration = "EntityDetectorConfiguration"
            case profileColumns = "ProfileColumns"
        }
    }

    public struct Project: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the project.
        public let accountId: String?
        /// The date and time that the project was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who crated the project.
        public let createdBy: String?
        /// The dataset that the project is to act upon.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the project.
        public let lastModifiedBy: String?
        /// The last modification date and time for the project.
        public let lastModifiedDate: Date?
        /// The unique name of a project.
        public let name: String
        /// The date and time when the project was opened.
        public let openDate: Date?
        /// The Amazon Resource Name (ARN) of the user that opened the project for use.
        public let openedBy: String?
        /// The name of a recipe that will be developed during a project session.
        public let recipeName: String
        /// The Amazon Resource Name (ARN) for the project.
        public let resourceArn: String?
        /// The Amazon Resource Name (ARN) of the role that will be assumed for this project.
        public let roleArn: String?
        /// The sample size and sampling type to apply to the data. If this parameter isn't specified, then the sample consists of the first 500 rows from the dataset.
        public let sample: Sample?
        /// Metadata tags that have been applied to the project.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, datasetName: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, openDate: Date? = nil, openedBy: String? = nil, recipeName: String, resourceArn: String? = nil, roleArn: String? = nil, sample: Sample? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.datasetName = datasetName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.openDate = openDate
            self.openedBy = openedBy
            self.recipeName = recipeName
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.sample = sample
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case datasetName = "DatasetName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case openDate = "OpenDate"
            case openedBy = "OpenedBy"
            case recipeName = "RecipeName"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case tags = "Tags"
        }
    }

    public struct PublishRecipeRequest: AWSEncodableShape {
        /// A description of the recipe to be published, for this version of the recipe.
        public let description: String?
        /// The name of the recipe to be published.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct PublishRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that you published.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Recipe: AWSDecodableShape {
        /// The date and time that the recipe was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the recipe.
        public let createdBy: String?
        /// The description of the recipe.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the recipe.
        public let lastModifiedBy: String?
        /// The last modification date and time of the recipe.
        public let lastModifiedDate: Date?
        /// The unique name for the recipe.
        public let name: String
        /// The name of the project that the recipe is associated with.
        public let projectName: String?
        /// The Amazon Resource Name (ARN) of the user who published the recipe.
        public let publishedBy: String?
        /// The date and time when the recipe was published.
        public let publishedDate: Date?
        /// The identifier for the version for the recipe. Must be one of the following:   Numeric version (X.Y) - X and Y stand for major and minor version numbers. The maximum length of each is 6 digits, and neither can be negative values. Both X and Y are required, and "0.0" isn't a valid version.    LATEST_WORKING - the most recent valid version being developed in a DataBrew project.    LATEST_PUBLISHED - the most recent published version.
        public let recipeVersion: String?
        /// The Amazon Resource Name (ARN) for the recipe.
        public let resourceArn: String?
        /// A list of steps that are defined by the recipe.
        public let steps: [RecipeStep]?
        /// Metadata tags that have been applied to the recipe.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, projectName: String? = nil, publishedBy: String? = nil, publishedDate: Date? = nil, recipeVersion: String? = nil, resourceArn: String? = nil, steps: [RecipeStep]? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.projectName = projectName
            self.publishedBy = publishedBy
            self.publishedDate = publishedDate
            self.recipeVersion = recipeVersion
            self.resourceArn = resourceArn
            self.steps = steps
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case projectName = "ProjectName"
            case publishedBy = "PublishedBy"
            case publishedDate = "PublishedDate"
            case recipeVersion = "RecipeVersion"
            case resourceArn = "ResourceArn"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct RecipeAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of a valid DataBrew transformation to be performed on the data.
        public let operation: String
        /// Contextual parameters for the transformation.
        public let parameters: [String: String]?

        public init(operation: String, parameters: [String: String]? = nil) {
            self.operation = operation
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.operation, name: "operation", parent: name, max: 128)
            try self.validate(self.operation, name: "operation", parent: name, min: 1)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[A-Z\\_]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 128)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[A-Za-z0-9]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 32768)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "Operation"
            case parameters = "Parameters"
        }
    }

    public struct RecipeReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the recipe.
        public let name: String
        /// The identifier for the version for the recipe.
        public let recipeVersion: String?

        public init(name: String, recipeVersion: String? = nil) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct RecipeStep: AWSEncodableShape & AWSDecodableShape {
        /// The particular action to be performed in the recipe step.
        public let action: RecipeAction
        /// One or more conditions that must be met for the recipe step to succeed.  All of the conditions in the array must be met. In other words, all of the conditions must be combined using a logical AND operation.
        public let conditionExpressions: [ConditionExpression]?

        public init(action: RecipeAction, conditionExpressions: [ConditionExpression]? = nil) {
            self.action = action
            self.conditionExpressions = conditionExpressions
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.conditionExpressions?.forEach {
                try $0.validate(name: "\(name).conditionExpressions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case conditionExpressions = "ConditionExpressions"
        }
    }

    public struct RecipeVersionErrorDetail: AWSDecodableShape {
        /// The HTTP status code for the error.
        public let errorCode: String?
        /// The text of the error message.
        public let errorMessage: String?
        /// The identifier for the recipe version associated with this error.
        public let recipeVersion: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, recipeVersion: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.recipeVersion = recipeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// The expression which includes column references, condition names followed by variable references, possibly grouped and combined with other conditions. For example, (:col1 starts_with :prefix1 or :col1 starts_with :prefix2) and (:col1 ends_with :suffix1 or :col1 ends_with :suffix2). Column and value references are substitution variables that should start with the ':' symbol. Depending on the context, substitution variables' values can be either an actual value or a column name. These values are defined in the SubstitutionMap. If a CheckExpression starts with a column reference, then ColumnSelectors in the rule should be null. If ColumnSelectors has been defined, then there should be no column reference in the left side of a condition, for example, is_between :val1 and :val2. For more information, see Available checks
        public let checkExpression: String
        /// List of column selectors. Selectors can be used to select columns using a name or regular  expression from the dataset. Rule will be applied to selected columns.
        public let columnSelectors: [ColumnSelector]?
        /// A value that specifies whether the rule is disabled. Once a rule is  disabled, a profile job will not validate it during a job run. Default  value is false.
        public let disabled: Bool?
        /// The name of the rule.
        public let name: String
        /// The map of substitution variable names to their values used in a check  expression. Variable names should start with a ':' (colon).  Variable values can either  be actual values or column names. To differentiate between the two, column names  should be enclosed in backticks, for example, ":col1": "`Column A`".
        public let substitutionMap: [String: String]?
        /// The threshold used with a non-aggregate check expression. Non-aggregate check expressions  will be applied to each row in a specific column, and the threshold will be used to determine  whether the validation succeeds.
        public let threshold: Threshold?

        public init(checkExpression: String, columnSelectors: [ColumnSelector]? = nil, disabled: Bool? = nil, name: String, substitutionMap: [String: String]? = nil, threshold: Threshold? = nil) {
            self.checkExpression = checkExpression
            self.columnSelectors = columnSelectors
            self.disabled = disabled
            self.name = name
            self.substitutionMap = substitutionMap
            self.threshold = threshold
        }

        public func validate(name: String) throws {
            try self.validate(self.checkExpression, name: "checkExpression", parent: name, max: 1024)
            try self.validate(self.checkExpression, name: "checkExpression", parent: name, min: 4)
            try self.validate(self.checkExpression, name: "checkExpression", parent: name, pattern: "^[<>0-9A-Za-z_.,:)(!= ]+$")
            try self.columnSelectors?.forEach {
                try $0.validate(name: "\(name).columnSelectors[]")
            }
            try self.validate(self.columnSelectors, name: "columnSelectors", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.substitutionMap?.forEach {
                try validate($0.key, name: "substitutionMap.key", parent: name, max: 128)
                try validate($0.key, name: "substitutionMap.key", parent: name, min: 2)
                try validate($0.key, name: "substitutionMap.key", parent: name, pattern: "^:[A-Za-z0-9_]+$")
                try validate($0.value, name: "substitutionMap[\"\($0.key)\"]", parent: name, max: 1024)
            }
            try self.threshold?.validate(name: "\(name).threshold")
        }

        private enum CodingKeys: String, CodingKey {
            case checkExpression = "CheckExpression"
            case columnSelectors = "ColumnSelectors"
            case disabled = "Disabled"
            case name = "Name"
            case substitutionMap = "SubstitutionMap"
            case threshold = "Threshold"
        }
    }

    public struct RulesetItem: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the ruleset.
        public let accountId: String?
        /// The date and time that the ruleset was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the ruleset.
        public let createdBy: String?
        /// The description of the ruleset.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the ruleset.
        public let lastModifiedBy: String?
        /// The modification date and time of the ruleset.
        public let lastModifiedDate: Date?
        /// The name of the ruleset.
        public let name: String
        /// The Amazon Resource Name (ARN) for the ruleset.
        public let resourceArn: String?
        /// The number of rules that are defined in the ruleset.
        public let ruleCount: Int?
        /// Metadata tags that have been applied to the ruleset.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset is  associated with.
        public let targetArn: String

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, ruleCount: Int? = nil, tags: [String: String]? = nil, targetArn: String) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.ruleCount = ruleCount
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case ruleCount = "RuleCount"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucket: String
        /// The Amazon Web Services account ID of the bucket owner.
        public let bucketOwner: String?
        /// The unique name of the object in the bucket.
        public let key: String?

        public init(bucket: String, bucketOwner: String? = nil, key: String? = nil) {
            self.bucket = bucket
            self.bucketOwner = bucketOwner
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, max: 12)
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, min: 12)
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.key, name: "key", parent: name, max: 1280)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case bucketOwner = "BucketOwner"
            case key = "Key"
        }
    }

    public struct S3TableOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can write output  from a job.
        public let location: S3Location

        public init(location: S3Location) {
            self.location = location
        }

        public func validate(name: String) throws {
            try self.location.validate(name: "\(name).location")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
        }
    }

    public struct Sample: AWSEncodableShape & AWSDecodableShape {
        /// The number of rows in the sample.
        public let size: Int?
        /// The way in which DataBrew obtains rows from a dataset.
        public let type: SampleType

        public init(size: Int? = nil, type: SampleType) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 5000)
            try self.validate(self.size, name: "size", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
            case type = "Type"
        }
    }

    public struct Schedule: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the schedule.
        public let accountId: String?
        /// The date and time that the schedule was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the schedule.
        public let createdBy: String?
        /// The dates and times when the job is to run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String?
        /// A list of jobs to be run, according to the schedule.
        public let jobNames: [String]?
        /// The Amazon Resource Name (ARN) of the user who last modified the schedule.
        public let lastModifiedBy: String?
        /// The date and time when the schedule was last modified.
        public let lastModifiedDate: Date?
        /// The name of the schedule.
        public let name: String
        /// The Amazon Resource Name (ARN) of the schedule.
        public let resourceArn: String?
        /// Metadata tags that have been applied to the schedule.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, cronExpression: String? = nil, jobNames: [String]? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct SendProjectSessionActionRequest: AWSEncodableShape {
        /// A unique identifier for an interactive session that's currently open and ready for work. The action will be performed on this session.
        public let clientSessionId: String?
        /// The name of the project to apply the action to.
        public let name: String
        /// If true, the result of the recipe step will be returned, but not applied.
        public let preview: Bool?
        public let recipeStep: RecipeStep?
        /// The index from which to preview a step. This index is used to preview the result of steps that have already been applied, so that the resulting view frame is from earlier in the view frame stack.
        public let stepIndex: Int?
        public let viewFrame: ViewFrame?

        public init(clientSessionId: String? = nil, name: String, preview: Bool? = nil, recipeStep: RecipeStep? = nil, stepIndex: Int? = nil, viewFrame: ViewFrame? = nil) {
            self.clientSessionId = clientSessionId
            self.name = name
            self.preview = preview
            self.recipeStep = recipeStep
            self.stepIndex = stepIndex
            self.viewFrame = viewFrame
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientSessionId, forKey: .clientSessionId)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.preview, forKey: .preview)
            try container.encodeIfPresent(self.recipeStep, forKey: .recipeStep)
            try container.encodeIfPresent(self.stepIndex, forKey: .stepIndex)
            try container.encodeIfPresent(self.viewFrame, forKey: .viewFrame)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, max: 255)
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, min: 1)
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.recipeStep?.validate(name: "\(name).recipeStep")
            try self.validate(self.stepIndex, name: "stepIndex", parent: name, min: 0)
            try self.viewFrame?.validate(name: "\(name).viewFrame")
        }

        private enum CodingKeys: String, CodingKey {
            case clientSessionId = "ClientSessionId"
            case preview = "Preview"
            case recipeStep = "RecipeStep"
            case stepIndex = "StepIndex"
            case viewFrame = "ViewFrame"
        }
    }

    public struct SendProjectSessionActionResponse: AWSDecodableShape {
        /// A unique identifier for the action that was performed.
        public let actionId: Int?
        /// The name of the project that was affected by the action.
        public let name: String
        /// A message indicating the result of performing the action.
        public let result: String?

        public init(actionId: Int? = nil, name: String, result: String? = nil) {
            self.actionId = actionId
            self.name = name
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "ActionId"
            case name = "Name"
            case result = "Result"
        }
    }

    public struct StartJobRunRequest: AWSEncodableShape {
        /// The name of the job to be run.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartJobRunResponse: AWSDecodableShape {
        /// A system-generated identifier for this particular job run.
        public let runId: String

        public init(runId: String) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartProjectSessionRequest: AWSEncodableShape {
        /// A value that, if true, enables you to take control of a session, even if a different client is currently accessing the project.
        public let assumeControl: Bool?
        /// The name of the project to act upon.
        public let name: String

        public init(assumeControl: Bool? = nil, name: String) {
            self.assumeControl = assumeControl
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assumeControl, forKey: .assumeControl)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assumeControl = "AssumeControl"
        }
    }

    public struct StartProjectSessionResponse: AWSDecodableShape {
        /// A system-generated identifier for the session.
        public let clientSessionId: String?
        /// The name of the project to be acted upon.
        public let name: String

        public init(clientSessionId: String? = nil, name: String) {
            self.clientSessionId = clientSessionId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case clientSessionId = "ClientSessionId"
            case name = "Name"
        }
    }

    public struct StatisticOverride: AWSEncodableShape & AWSDecodableShape {
        /// A map that includes overrides of an evaluation’s parameters.
        public let parameters: [String: String]
        /// The name of an evaluation
        public let statistic: String

        public init(parameters: [String: String], statistic: String) {
            self.parameters = parameters
            self.statistic = statistic
        }

        public func validate(name: String) throws {
            try self.parameters.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 128)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[A-Za-z0-9]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 32768)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.statistic, name: "statistic", parent: name, max: 128)
            try self.validate(self.statistic, name: "statistic", parent: name, min: 1)
            try self.validate(self.statistic, name: "statistic", parent: name, pattern: "^[A-Z\\_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case statistic = "Statistic"
        }
    }

    public struct StatisticsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of included evaluations. When the list is undefined, all supported  evaluations will be included.
        public let includedStatistics: [String]?
        /// List of overrides for evaluations.
        public let overrides: [StatisticOverride]?

        public init(includedStatistics: [String]? = nil, overrides: [StatisticOverride]? = nil) {
            self.includedStatistics = includedStatistics
            self.overrides = overrides
        }

        public func validate(name: String) throws {
            try self.includedStatistics?.forEach {
                try validate($0, name: "includedStatistics[]", parent: name, max: 128)
                try validate($0, name: "includedStatistics[]", parent: name, min: 1)
                try validate($0, name: "includedStatistics[]", parent: name, pattern: "^[A-Z\\_]+$")
            }
            try self.validate(self.includedStatistics, name: "includedStatistics", parent: name, min: 1)
            try self.overrides?.forEach {
                try $0.validate(name: "\(name).overrides[]")
            }
            try self.validate(self.overrides, name: "overrides", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includedStatistics = "IncludedStatistics"
            case overrides = "Overrides"
        }
    }

    public struct StopJobRunRequest: AWSEncodableShape {
        /// The name of the job to be stopped.
        public let name: String
        /// The ID of the job run to be stopped.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.runId, key: "RunId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopJobRunResponse: AWSDecodableShape {
        /// The ID of the job run that you stopped.
        public let runId: String

        public init(runId: String) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The DataBrew resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DataBrew, you can tag a dataset, a job, a project, or a recipe.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Threshold: AWSEncodableShape & AWSDecodableShape {
        /// The type of a threshold. Used for comparison of an actual count of rows that satisfy the  rule to the threshold value.
        public let type: ThresholdType?
        /// Unit of threshold value. Can be either a COUNT or PERCENTAGE of the full sample size  used for validation.
        public let unit: ThresholdUnit?
        /// The value of a threshold.
        public let value: Double

        public init(type: ThresholdType? = nil, unit: ThresholdUnit? = nil, value: Double) {
            self.type = type
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// A DataBrew resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag keys (names) of one or more tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetRequest: AWSEncodableShape {
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The name of the dataset to be updated.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?

        public init(format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, name: String, pathOptions: PathOptions? = nil) {
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.name = name
            self.pathOptions = pathOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.format, forKey: .format)
            try container.encodeIfPresent(self.formatOptions, forKey: .formatOptions)
            try container.encode(self.input, forKey: .input)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.pathOptions, forKey: .pathOptions)
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.input.validate(name: "\(name).input")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.pathOptions?.validate(name: "\(name).pathOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case pathOptions = "PathOptions"
        }
    }

    public struct UpdateDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateProfileJobRequest: AWSEncodableShape {
        /// Configuration for profile jobs. Used to select columns, do evaluations,  and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
        public let configuration: ProfileConfiguration?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for Profile Jobs only. Determines the number of rows on which the Profile job will be executed. If a JobSample value is not provided for profile jobs, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of compute nodes that DataBrew can use when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to be updated.
        public let name: String
        public let outputLocation: S3Location
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// List of validation configurations that are applied to the profile job.
        public let validationConfigurations: [ValidationConfiguration]?

        public init(configuration: ProfileConfiguration? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputLocation: S3Location, roleArn: String, timeout: Int? = nil, validationConfigurations: [ValidationConfiguration]? = nil) {
            self.configuration = configuration
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputLocation = outputLocation
            self.roleArn = roleArn
            self.timeout = timeout
            self.validationConfigurations = validationConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.encryptionKeyArn, forKey: .encryptionKeyArn)
            try container.encodeIfPresent(self.encryptionMode, forKey: .encryptionMode)
            try container.encodeIfPresent(self.jobSample, forKey: .jobSample)
            try container.encodeIfPresent(self.logSubscription, forKey: .logSubscription)
            try container.encodeIfPresent(self.maxCapacity, forKey: .maxCapacity)
            try container.encodeIfPresent(self.maxRetries, forKey: .maxRetries)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.outputLocation, forKey: .outputLocation)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.timeout, forKey: .timeout)
            try container.encodeIfPresent(self.validationConfigurations, forKey: .validationConfigurations)
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
            try self.validationConfigurations?.forEach {
                try $0.validate(name: "\(name).validationConfigurations[]")
            }
            try self.validate(self.validationConfigurations, name: "validationConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case outputLocation = "OutputLocation"
            case roleArn = "RoleArn"
            case timeout = "Timeout"
            case validationConfigurations = "ValidationConfigurations"
        }
    }

    public struct UpdateProfileJobResponse: AWSDecodableShape {
        /// The name of the job that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        /// The name of the project to be updated.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role to be assumed for this request.
        public let roleArn: String
        public let sample: Sample?

        public init(name: String, roleArn: String, sample: Sample? = nil) {
            self.name = name
            self.roleArn = roleArn
            self.sample = sample
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.sample, forKey: .sample)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.sample?.validate(name: "\(name).sample")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case sample = "Sample"
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        /// The date and time that the project was last modified.
        public let lastModifiedDate: Date?
        /// The name of the project that you updated.
        public let name: String

        public init(lastModifiedDate: Date? = nil, name: String) {
            self.lastModifiedDate = lastModifiedDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
        }
    }

    public struct UpdateRecipeJobRequest: AWSEncodableShape {
        /// Represents a list of JDBC database output objects which defines the output destination for a  DataBrew recipe job to write into.
        public let databaseOutputs: [DatabaseOutput]?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to update.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(databaseOutputs: [DatabaseOutput]? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, roleArn: String, timeout: Int? = nil) {
            self.databaseOutputs = databaseOutputs
            self.dataCatalogOutputs = dataCatalogOutputs
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.roleArn = roleArn
            self.timeout = timeout
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.databaseOutputs, forKey: .databaseOutputs)
            try container.encodeIfPresent(self.dataCatalogOutputs, forKey: .dataCatalogOutputs)
            try container.encodeIfPresent(self.encryptionKeyArn, forKey: .encryptionKeyArn)
            try container.encodeIfPresent(self.encryptionMode, forKey: .encryptionMode)
            try container.encodeIfPresent(self.logSubscription, forKey: .logSubscription)
            try container.encodeIfPresent(self.maxCapacity, forKey: .maxCapacity)
            try container.encodeIfPresent(self.maxRetries, forKey: .maxRetries)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.outputs, forKey: .outputs)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.timeout, forKey: .timeout)
        }

        public func validate(name: String) throws {
            try self.databaseOutputs?.forEach {
                try $0.validate(name: "\(name).databaseOutputs[]")
            }
            try self.validate(self.databaseOutputs, name: "databaseOutputs", parent: name, min: 1)
            try self.dataCatalogOutputs?.forEach {
                try $0.validate(name: "\(name).dataCatalogOutputs[]")
            }
            try self.validate(self.dataCatalogOutputs, name: "dataCatalogOutputs", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseOutputs = "DatabaseOutputs"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case outputs = "Outputs"
            case roleArn = "RoleArn"
            case timeout = "Timeout"
        }
    }

    public struct UpdateRecipeJobResponse: AWSDecodableShape {
        /// The name of the job that you updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateRecipeRequest: AWSEncodableShape {
        /// A description of the recipe.
        public let description: String?
        /// The name of the recipe to be updated.
        public let name: String
        /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
        public let steps: [RecipeStep]?

        public init(description: String? = nil, name: String, steps: [RecipeStep]? = nil) {
            self.description = description
            self.name = name
            self.steps = steps
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.steps, forKey: .steps)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.steps?.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case steps = "Steps"
        }
    }

    public struct UpdateRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateRulesetRequest: AWSEncodableShape {
        /// The description of the ruleset.
        public let description: String?
        /// The name of the ruleset to be updated.
        public let name: String
        /// A list of rules that are defined with the ruleset. A rule includes one or more  checks to be validated on a DataBrew dataset.
        public let rules: [Rule]

        public init(description: String? = nil, name: String, rules: [Rule]) {
            self.description = description
            self.name = name
            self.rules = rules
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.rules, forKey: .rules)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case rules = "Rules"
        }
    }

    public struct UpdateRulesetResponse: AWSDecodableShape {
        /// The name of the updated ruleset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateScheduleRequest: AWSEncodableShape {
        /// The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String
        /// The name or names of one or more jobs to be run for this schedule.
        public let jobNames: [String]?
        /// The name of the schedule to update.
        public let name: String

        public init(cronExpression: String, jobNames: [String]? = nil, name: String) {
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.cronExpression, forKey: .cronExpression)
            try container.encodeIfPresent(self.jobNames, forKey: .jobNames)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, max: 512)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, min: 1)
            try self.jobNames?.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 240)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
            }
            try self.validate(self.jobNames, name: "jobNames", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
        }
    }

    public struct UpdateScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the ruleset to be validated in the profile job.  The TargetArn of the selected ruleset should be the same as the Amazon Resource Name (ARN) of  the dataset that is associated with the profile job.
        public let rulesetArn: String
        /// Mode of data quality validation. Default mode is “CHECK_ALL” which verifies all rules  defined in the selected ruleset.
        public let validationMode: ValidationMode?

        public init(rulesetArn: String, validationMode: ValidationMode? = nil) {
            self.rulesetArn = rulesetArn
            self.validationMode = validationMode
        }

        public func validate(name: String) throws {
            try self.validate(self.rulesetArn, name: "rulesetArn", parent: name, max: 2048)
            try self.validate(self.rulesetArn, name: "rulesetArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case rulesetArn = "RulesetArn"
            case validationMode = "ValidationMode"
        }
    }

    public struct ViewFrame: AWSEncodableShape {
        /// Controls if analytics computation is enabled or disabled. Enabled by default.
        public let analytics: AnalyticsMode?
        /// The number of columns to include in the view frame, beginning with the StartColumnIndex value and ignoring any columns in the HiddenColumns list.
        public let columnRange: Int?
        /// A list of columns to hide in the view frame.
        public let hiddenColumns: [String]?
        /// The number of rows to include in the view frame, beginning with the  StartRowIndex value.
        public let rowRange: Int?
        /// The starting index for the range of columns to return in the view frame.
        public let startColumnIndex: Int
        /// The starting index for the range of rows to return in the view frame.
        public let startRowIndex: Int?

        public init(analytics: AnalyticsMode? = nil, columnRange: Int? = nil, hiddenColumns: [String]? = nil, rowRange: Int? = nil, startColumnIndex: Int, startRowIndex: Int? = nil) {
            self.analytics = analytics
            self.columnRange = columnRange
            self.hiddenColumns = hiddenColumns
            self.rowRange = rowRange
            self.startColumnIndex = startColumnIndex
            self.startRowIndex = startRowIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.columnRange, name: "columnRange", parent: name, max: 20)
            try self.validate(self.columnRange, name: "columnRange", parent: name, min: 0)
            try self.hiddenColumns?.forEach {
                try validate($0, name: "hiddenColumns[]", parent: name, max: 255)
                try validate($0, name: "hiddenColumns[]", parent: name, min: 1)
            }
            try self.validate(self.startColumnIndex, name: "startColumnIndex", parent: name, min: 0)
            try self.validate(self.startRowIndex, name: "startRowIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case analytics = "Analytics"
            case columnRange = "ColumnRange"
            case hiddenColumns = "HiddenColumns"
            case rowRange = "RowRange"
            case startColumnIndex = "StartColumnIndex"
            case startRowIndex = "StartRowIndex"
        }
    }
}

// MARK: - Errors

/// Error enum for DataBrew
public struct DataBrewErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DataBrew
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access to the specified resource was denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal service failure occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// One or more resources can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service quota is exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The input parameters for this request failed validation.
    public static var validationException: Self { .init(.validationException) }
}

extension DataBrewErrorType: Equatable {
    public static func == (lhs: DataBrewErrorType, rhs: DataBrewErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DataBrewErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
