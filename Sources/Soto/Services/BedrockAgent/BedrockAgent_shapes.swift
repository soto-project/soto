//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgent {
    // MARK: Enums

    public enum ActionGroupSignature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonUserinput = "AMAZON.UserInput"
        public var description: String { return self.rawValue }
    }

    public enum ActionGroupState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AgentAliasStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case prepared = "PREPARED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case notPrepared = "NOT_PREPARED"
        case prepared = "PREPARED"
        case preparing = "PREPARING"
        case updating = "UPDATING"
        case versioning = "VERSIONING"
        public var description: String { return self.rawValue }
    }

    public enum ChunkingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedSize = "FIXED_SIZE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobSortByAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startedAt = "STARTED_AT"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case starting = "STARTING"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case opensearchServerless = "OPENSEARCH_SERVERLESS"
        case pinecone = "PINECONE"
        case rds = "RDS"
        case redisEnterpriseCloud = "REDIS_ENTERPRISE_CLOUD"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case vector = "VECTOR"
        public var description: String { return self.rawValue }
    }

    public enum PromptState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum APISchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case payload(String)
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case s3(S3Identifier)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .payload:
                let value = try container.decode(String.self, forKey: .payload)
                self = .payload(value)
            case .s3:
                let value = try container.decode(S3Identifier.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .payload(let value):
                try container.encode(value, forKey: .payload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case s3 = "s3"
        }
    }

    // MARK: Shapes

    public struct ActionGroupSummary: AWSDecodableShape {
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The description of the action group.
        public let description: String?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, description: String? = nil, updatedAt: Date) {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case description = "description"
            case updatedAt = "updatedAt"
        }
    }

    public struct Agent: AWSDecodableShape {
        /// The ARN of the agent.
        public let agentArn: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The ARN of the IAM role with permissions to call API operations on the agent. The ARN must begin with AmazonBedrockExecutionRoleForAgents_.
        public let agentResourceRoleArn: String
        /// The status of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent is being created.   PREPARING – The agent is being prepared.   PREPARED – The agent is prepared and ready to be invoked.   NOT_PREPARED – The agent has been created but not yet prepared.   FAILED – The agent API operation failed.   UPDATING – The agent is being updated.   DELETING – The agent is being deleted.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ARN of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        /// The description of the agent.
        public let description: String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public let failureReasons: [String]?
        /// The foundation model used for orchestration by the agent.
        public let foundationModel: String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// The time at which the agent was last prepared.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var preparedAt: Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public let recommendedActions: [String]?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentArn: String, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, agentVersion: String, clientToken: String? = nil, createdAt: Date, customerEncryptionKeyArn: String? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, preparedAt: Date? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date) {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case preparedAt = "preparedAt"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentActionGroup: AWSDecodableShape {
        /// The ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The unique identifier of the agent to which the action group belongs.
        public let agentId: String
        /// The version of the agent to which the action group belongs.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the action group was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the action group.
        public let description: String?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionSignature: ActionGroupSignature?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = nil, createdAt: Date, description: String? = nil, parentActionSignature: ActionGroupSignature? = nil, updatedAt: Date) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case parentActionSignature = "parentActionSignature"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAlias: AWSDecodableShape {
        /// The ARN of the alias of the agent.
        public let agentAliasArn: String
        /// Contains details about the history of the alias.
        public let agentAliasHistoryEvents: [AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String
        /// The name of the alias of the agent.
        public let agentAliasName: String
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent alias is being created.   PREPARED – The agent alias is finished being created or updated and is ready to be invoked.   FAILED – The agent alias API operation failed.   UPDATING – The agent alias is being updated.   DELETING – The agent alias is being deleted.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias of the agent.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentAliasArn: String, agentAliasHistoryEvents: [AgentAliasHistoryEvent]? = nil, agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, agentId: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
            case agentAliasHistoryEvents = "agentAliasHistoryEvents"
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAliasHistoryEvent: AWSDecodableShape {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?

        public init(endDate: Date? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, startDate: Date? = nil) {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case routingConfiguration = "routingConfiguration"
            case startDate = "startDate"
        }
    }

    public struct AgentAliasRoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The version of the agent with which the alias is associated.
        public let agentVersion: String

        public init(agentVersion: String) {
            self.agentVersion = agentVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
        }
    }

    public struct AgentAliasSummary: AWSDecodableShape {
        /// Contains details about
        public let agentAliasId: String
        /// The name of the alias.
        public let agentAliasName: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias.
        public let description: String?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, createdAt: Date, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, updatedAt: Date) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case createdAt = "createdAt"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentKnowledgeBase: AWSDecodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The time at which the association between the agent and the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the association between the agent and the knowledge base.
        public let description: String
        /// The unique identifier of the association between the agent and the knowledge base.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the association between the agent and the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentId: String, agentVersion: String, createdAt: Date, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentKnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the knowledge base associated with an agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentSummary: AWSDecodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The status of the agent.
        public let agentStatus: AgentStatus
        /// The description of the agent.
        public let description: String?
        /// The latest version of the agent.
        public let latestAgentVersion: String?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentId: String, agentName: String, agentStatus: AgentStatus, description: String? = nil, latestAgentVersion: String? = nil, updatedAt: Date) {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case description = "description"
            case latestAgentVersion = "latestAgentVersion"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentVersion: AWSDecodableShape {
        /// The ARN of the agent that the version belongs to.
        public let agentArn: String
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The name of the agent that the version belongs to.
        public let agentName: String
        /// The ARN of the IAM role with permissions to invoke API operations on the agent. The ARN must begin with AmazonBedrockExecutionRoleForAgents_.
        public let agentResourceRoleArn: String
        /// The status of the agent that the version belongs to.
        public let agentStatus: AgentStatus
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ARN of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        /// The description of the version.
        public let description: String?
        /// A list of reasons that the API operation on the version failed.
        public let failureReasons: [String]?
        /// The foundation model that the version invokes.
        public let foundationModel: String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// The instructions provided to the agent.
        public let instruction: String?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public let recommendedActions: [String]?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version number.
        public let version: String

        public init(agentArn: String, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, createdAt: Date, customerEncryptionKeyArn: String? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date, version: String) {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct AgentVersionSummary: AWSDecodableShape {
        /// The name of the agent to which the version belongs.
        public let agentName: String
        /// The status of the agent to which the version belongs.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the version of the agent.
        public let description: String?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(agentName: String, agentStatus: AgentStatus, agentVersion: String, createdAt: Date, description: String? = nil, updatedAt: Date) {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case updatedAt = "updatedAt"
        }
    }

    public struct AssociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which you want to associate the knowledge base.
        public let agentId: String
        /// The version of the agent with which you want to associate the knowledge base.
        public let agentVersion: String
        /// A description of what the agent should use the knowledge base for.
        public let description: String
        /// The unique identifier of the knowledge base to associate with the agent.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        public init(agentId: String, agentVersion: String, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encode(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseId, forKey: .knowledgeBaseId)
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct AssociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with the agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct ChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.    FIXED_SIZE – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.    NONE – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        public let chunkingStrategy: ChunkingStrategy
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public let fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration?

        public init(chunkingStrategy: ChunkingStrategy, fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration? = nil) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingStrategy = "chunkingStrategy"
            case fixedSizeChunkingConfiguration = "fixedSizeChunkingConfiguration"
        }
    }

    public struct CreateAgentActionGroupRequest: AWSEncodableShape {
        /// The ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The name to give the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to create the action group.
        public let agentId: String
        /// The version of the agent for which to create the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the action group.
        public let description: String?
        /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?

        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = CreateAgentActionGroupRequest.idempotencyToken(), description: String? = nil, parentActionGroupSignature: ActionGroupSignature? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.description = description
            self.parentActionGroupSignature = parentActionGroupSignature
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case description = "description"
            case parentActionGroupSignature = "parentActionGroupSignature"
        }
    }

    public struct CreateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was created.
        public let agentActionGroup: AgentActionGroup

        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct CreateAgentAliasRequest: AWSEncodableShape {
        /// The name of the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the alias of the agent.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// Any tags that you want to attach to the alias of the agent.
        public let tags: [String: String]?

        public init(agentAliasName: String, agentId: String, clientToken: String? = CreateAgentAliasRequest.idempotencyToken(), description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, tags: [String: String]? = nil) {
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.clientToken = clientToken
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case clientToken = "clientToken"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was created.
        public let agentAlias: AgentAlias

        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct CreateAgentRequest: AWSEncodableShape {
        /// A name for the agent that you create.
        public let agentName: String
        /// The ARN of the IAM role with permissions to create the agent. The ARN must begin with AmazonBedrockExecutionRoleForAgents_.
        public let agentResourceRoleArn: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The ARN of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        /// A description of the agent.
        public let description: String?
        /// The foundation model to be used for orchestration by the agent you create.
        public let foundationModel: String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Any tags that you want to attach to the agent.
        public let tags: [String: String]?

        public init(agentName: String, agentResourceRoleArn: String, clientToken: String? = CreateAgentRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, description: String? = nil, foundationModel: String? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, tags: [String: String]? = nil) {
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?AmazonBedrockExecutionRoleForAgents_.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 1200)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case foundationModel = "foundationModel"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent created.
        public let agent: Agent

        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// Contains metadata about where the data source is stored.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// A description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which to add the data source.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the server-side encryption for the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        public init(clientToken: String? = CreateDataSourceRequest.idempotencyToken(), dataSourceConfiguration: DataSourceConfiguration, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.clientToken = clientToken
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the knowledge base.
        public let description: String?
        /// Contains details about the embeddings model used for the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// A name for the knowledge base.
        public let name: String
        /// The ARN of the IAM role with permissions to create the knowledge base.
        public let roleArn: String
        /// Contains details about the configuration of the vector database used for the knowledge base.
        public let storageConfiguration: StorageConfiguration
        /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, name: String, roleArn: String, storageConfiguration: StorageConfiguration, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration.validate(name: "\(name).storageConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The time at which the data source was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Contains details about how the data source is stored.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the configuration of the server-side encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:   Available – The data source has been created and is ready for ingestion into the knowledge base.   Deleting – The data source is being deleted.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        public init(createdAt: Date, dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: DataSourceStatus, updatedAt: Date, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.createdAt = createdAt
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case updatedAt = "updatedAt"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains details about the configuration of the S3 object containing the data source.
        public let s3Configuration: S3DataSourceConfiguration?
        /// The type of storage for the data source.
        public let type: DataSourceType

        public init(s3Configuration: S3DataSourceConfiguration? = nil, type: DataSourceType) {
            self.s3Configuration = s3Configuration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "s3Configuration"
            case type = "type"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// The status of the data source.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, status: DataSourceStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group to delete.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        public init(actionGroupId: String, agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentActionGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias to delete.
        public let agentAliasId: String
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentAliasResponse: AWSDecodableShape {
        /// The unique identifier of the alias that was deleted.
        public let agentAliasId: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        public init(agentAliasId: String, agentAliasStatus: AgentAliasStatus, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
        }
    }

    public struct DeleteAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent to delete.
        public let agentId: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        public init(agentId: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent that was deleted.
        public let agentId: String
        /// The status of the agent.
        public let agentStatus: AgentStatus

        public init(agentId: String, agentStatus: AgentStatus) {
            self.agentId = agentId
            self.agentStatus = agentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
        }
    }

    public struct DeleteAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The version of the agent to delete.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        public init(agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentVersionResponse: AWSDecodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The status of the agent version.
        public let agentStatus: AgentStatus
        /// The version that was deleted.
        public let agentVersion: String

        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source to delete.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base from which to delete the data source.
        public let knowledgeBaseId: String

        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        /// The unique identifier of the data source that was deleted.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
        public let knowledgeBaseId: String
        /// The status of the data source.
        public let status: DataSourceStatus

        public init(dataSourceId: String, knowledgeBaseId: String, status: DataSourceStatus) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base to delete.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        /// The unique identifier of the knowledge base that was deleted.
        public let knowledgeBaseId: String
        /// The status of the knowledge base and whether it has been successfully deleted.
        public let status: KnowledgeBaseStatus

        public init(knowledgeBaseId: String, status: KnowledgeBaseStatus) {
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DisassociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent from which to disassociate the knowledge base.
        public let agentId: String
        /// The version of the agent from which to disassociate the knowledge base.
        public let agentVersion: String
        /// The unique identifier of the knowledge base to disassociate.
        public let knowledgeBaseId: String

        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FixedSizeChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to include in a chunk.
        public let maxTokens: Int
        /// The percentage of overlap between adjacent chunks of a data source.
        public let overlapPercentage: Int

        public init(maxTokens: Int, overlapPercentage: Int) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case overlapPercentage = "overlapPercentage"
        }
    }

    public struct GetAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group for which to get information.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String

        public init(actionGroupId: String, agentId: String, agentVersion: String) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group.
        public let agentActionGroup: AgentActionGroup

        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct GetAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias for which to get information.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias to get information belongs.
        public let agentId: String

        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentAliasResponse: AWSDecodableShape {
        /// Contains information about the alias.
        public let agentAlias: AgentAlias

        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct GetAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The unique identifier of the knowledge base associated with the agent.
        public let knowledgeBaseId: String

        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about a knowledge base attached to an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct GetAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String

        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentResponse: AWSDecodableShape {
        /// Contains details about the agent.
        public let agent: Agent

        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct GetAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String

        public init(agentId: String, agentVersion: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentVersionResponse: AWSDecodableShape {
        /// Contains details about the version of the agent.
        public let agentVersion: AgentVersion

        public init(agentVersion: AgentVersion) {
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base that the data source was added to.
        public let knowledgeBaseId: String

        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetIngestionJobRequest: AWSEncodableShape {
        /// The unique identifier of the data source in the ingestion job.
        public let dataSourceId: String
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base for which the ingestion job applies.
        public let knowledgeBaseId: String

        public init(dataSourceId: String, ingestionJobId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.ingestionJobId, key: "ingestionJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.ingestionJobId, name: "ingestionJobId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIngestionJobResponse: AWSDecodableShape {
        /// Contains details about the ingestion job.
        public let ingestionJob: IngestionJob

        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base for which to get information.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to allow in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, max: 4096)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topK, name: "topK", parent: name, max: 500)
            try self.validate(self.topK, name: "topK", parent: name, min: 0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct IngestionJob: AWSDecodableShape {
        /// The unique identifier of the ingested data source.
        public let dataSourceId: String
        /// The description of the ingestion job.
        public let description: String?
        /// A list of reasons that the ingestion job failed.
        public let failureReasons: [String]?
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base to which the data source is being added.
        public let knowledgeBaseId: String
        /// The time at which the ingestion job started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics about the ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the ingestion job.
        public let status: IngestionJobStatus
        /// The time at which the ingestion job was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(dataSourceId: String, description: String? = nil, failureReasons: [String]? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case failureReasons = "failureReasons"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct IngestionJobFilter: AWSEncodableShape {
        /// The attribute by which to filter the results.
        public let attribute: IngestionJobFilterAttribute
        /// The operation to carry out between the attribute and the values.
        public let `operator`: IngestionJobFilterOperator
        /// A list of values for the attribute.
        public let values: [String]

        public init(attribute: IngestionJobFilterAttribute, operator: IngestionJobFilterOperator, values: [String]) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct IngestionJobSortBy: AWSEncodableShape {
        /// The attribute by which to sort the results.
        public let attribute: IngestionJobSortByAttribute
        /// The order by which to sort the results.
        public let order: SortOrder

        public init(attribute: IngestionJobSortByAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct IngestionJobStatistics: AWSDecodableShape {
        /// The number of source documents that was deleted.
        public let numberOfDocumentsDeleted: Int64?
        /// The number of source documents that failed to be ingested.
        public let numberOfDocumentsFailed: Int64?
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public let numberOfDocumentsScanned: Int64?
        /// The number of metadata files that were updated or deleted.
        public let numberOfMetadataDocumentsModified: Int64?
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public let numberOfMetadataDocumentsScanned: Int64?
        /// The number of modified source documents in the data source that were successfully indexed.
        public let numberOfModifiedDocumentsIndexed: Int64?
        /// The number of new source documents in the data source that were successfully indexed.
        public let numberOfNewDocumentsIndexed: Int64?

        public init(numberOfDocumentsDeleted: Int64? = nil, numberOfDocumentsFailed: Int64? = nil, numberOfDocumentsScanned: Int64? = nil, numberOfMetadataDocumentsModified: Int64? = nil, numberOfMetadataDocumentsScanned: Int64? = nil, numberOfModifiedDocumentsIndexed: Int64? = nil, numberOfNewDocumentsIndexed: Int64? = nil) {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDocumentsDeleted = "numberOfDocumentsDeleted"
            case numberOfDocumentsFailed = "numberOfDocumentsFailed"
            case numberOfDocumentsScanned = "numberOfDocumentsScanned"
            case numberOfMetadataDocumentsModified = "numberOfMetadataDocumentsModified"
            case numberOfMetadataDocumentsScanned = "numberOfMetadataDocumentsScanned"
            case numberOfModifiedDocumentsIndexed = "numberOfModifiedDocumentsIndexed"
            case numberOfNewDocumentsIndexed = "numberOfNewDocumentsIndexed"
        }
    }

    public struct IngestionJobSummary: AWSDecodableShape {
        /// The unique identifier of the data source in the ingestion job.
        public let dataSourceId: String
        /// The description of the ingestion job.
        public let description: String?
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base to which the data source is added.
        public let knowledgeBaseId: String
        /// The time at which the ingestion job was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics for the ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the ingestion job.
        public let status: IngestionJobStatus
        /// The time at which the ingestion job was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(dataSourceId: String, description: String? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct KnowledgeBase: AWSDecodableShape {
        /// The time at which the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the knowledge base.
        public let description: String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public let failureReasons: [String]?
        /// The ARN of the knowledge base.
        public let knowledgeBaseArn: String
        /// Contains details about the embeddings configuration of the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The ARN of the IAM role with permissions to invoke API operations on the knowledge base. The ARN must begin with AmazonBedrockExecutionRoleForKnowledgeBase_.
        public let roleArn: String
        /// The status of the knowledge base. The following statuses are possible:   CREATING – The knowledge base is being created.   ACTIVE – The knowledge base is ready to be queried.   DELETING – The knowledge base is being deleted.   UPDATING – The knowledge base is being updated.   FAILED – The knowledge base API operation failed.
        public let status: KnowledgeBaseStatus
        /// Contains details about the storage configuration of the knowledge base.
        public let storageConfiguration: StorageConfiguration
        /// The time at which the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, description: String? = nil, failureReasons: [String]? = nil, knowledgeBaseArn: String, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, status: KnowledgeBaseStatus, storageConfiguration: StorageConfiguration, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case failureReasons = "failureReasons"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case storageConfiguration = "storageConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct KnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of data that the data source is converted into for the knowledge base.
        public let type: KnowledgeBaseType
        /// Contains details about the embeddings model that'sused to convert the data source.
        public let vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration?

        public init(type: KnowledgeBaseType, vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration? = nil) {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorKnowledgeBaseConfiguration?.validate(name: "\(name).vectorKnowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case vectorKnowledgeBaseConfiguration = "vectorKnowledgeBaseConfiguration"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The time at which the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(description: String? = nil, knowledgeBaseId: String, name: String, status: KnowledgeBaseStatus, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ListAgentActionGroupsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentActionGroupsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an action group.
        public let actionGroupSummaries: [ActionGroupSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(actionGroupSummaries: [ActionGroupSummary], nextToken: String? = nil) {
            self.actionGroupSummaries = actionGroupSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupSummaries = "actionGroupSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an alias of the agent.
        public let agentAliasSummaries: [AgentAliasSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(agentAliasSummaries: [AgentAliasSummary], nextToken: String? = nil) {
            self.agentAliasSummaries = agentAliasSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasSummaries = "agentAliasSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
        public let agentId: String
        /// The version of the agent for which to return information about knowledge bases associated with it.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a knowledge base associated with the agent.
        public let agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary], nextToken: String? = nil) {
            self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBaseSummaries = "agentKnowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a version of the agent.
        public let agentVersionSummaries: [AgentVersionSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(agentVersionSummaries: [AgentVersionSummary], nextToken: String? = nil) {
            self.agentVersionSummaries = agentVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersionSummaries = "agentVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an agent.
        public let agentSummaries: [AgentSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(agentSummaries: [AgentSummary], nextToken: String? = nil) {
            self.agentSummaries = agentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentSummaries = "agentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base for which to return a list of information.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a data source.
        public let dataSourceSummaries: [DataSourceSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(dataSourceSummaries: [DataSourceSummary], nextToken: String? = nil) {
            self.dataSourceSummaries = dataSourceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSummaries = "dataSourceSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestionJobsRequest: AWSEncodableShape {
        /// The unique identifier of the data source for which to return ingestion jobs.
        public let dataSourceId: String
        /// Contains a definition of a filter for which to filter the results.
        public let filters: [IngestionJobFilter]?
        /// The unique identifier of the knowledge base for which to return ingestion jobs.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// Contains details about how to sort the results.
        public let sortBy: IngestionJobSortBy?

        public init(dataSourceId: String, filters: [IngestionJobFilter]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: IngestionJobSortBy? = nil) {
            self.dataSourceId = dataSourceId
            self.filters = filters
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListIngestionJobsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an ingestion job.
        public let ingestionJobSummaries: [IngestionJobSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(ingestionJobSummaries: [IngestionJobSummary], nextToken: String? = nil) {
            self.ingestionJobSummaries = ingestionJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJobSummaries = "ingestionJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a knowledge base.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pairs for the tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct OpenSearchServerlessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the OpenSearch Service vector store.
        public let collectionArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: OpenSearchServerlessFieldMapping
        /// The name of the vector store.
        public let vectorIndexName: String

        public init(collectionArn: String, fieldMapping: OpenSearchServerlessFieldMapping, vectorIndexName: String) {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, max: 2048)
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, pattern: "^arn:aws:aoss:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:collection/[a-z0-9-]{3,32}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "collectionArn"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct OpenSearchServerlessFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct PineconeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint URL for your index management page.
        public let connectionString: String
        /// The ARN of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        public let credentialsSecretArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: PineconeFieldMapping
        /// The namespace to be used to write new data to your database.
        public let namespace: String?

        public init(connectionString: String, credentialsSecretArn: String, fieldMapping: PineconeFieldMapping, namespace: String? = nil) {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionString, name: "connectionString", parent: name, max: 2048)
            try self.validate(self.connectionString, name: "connectionString", parent: name, pattern: "^.*$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 2048)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionString = "connectionString"
            case credentialsSecretArn = "credentialsSecretArn"
            case fieldMapping = "fieldMapping"
            case namespace = "namespace"
        }
    }

    public struct PineconeFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String

        public init(metadataField: String, textField: String) {
            self.metadataField = metadataField
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
        }
    }

    public struct PrepareAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to create a DRAFT version.
        public let agentId: String

        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PrepareAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent for which the DRAFT version was created.
        public let agentId: String
        /// The status of the DRAFT version and whether it is ready for use.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the DRAFT version of the agent was last prepared.
        @CustomCoding<ISO8601DateCoder>
        public var preparedAt: Date

        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String, preparedAt: Date) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.preparedAt = preparedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case preparedAt = "preparedAt"
        }
    }

    public struct PromptConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see Prompt template placeholder variables.
        public let basePromptTemplate: String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDEN, the overrideLambda field in the PromptOverrideConfiguration must be specified with the ARN of a Lambda function.
        public let parserMode: CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public let promptCreationMode: CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.    PRE_PROCESSING – ENABLED     ORCHESTRATION – ENABLED     KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED     POST_PROCESSING – DISABLED
        public let promptState: PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public let promptType: PromptType?

        public init(basePromptTemplate: String? = nil, inferenceConfiguration: InferenceConfiguration? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, promptState: PromptState? = nil, promptType: PromptType? = nil) {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }

        public func validate(name: String) throws {
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, max: 100000)
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, min: 1)
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case basePromptTemplate = "basePromptTemplate"
            case inferenceConfiguration = "inferenceConfiguration"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case promptState = "promptState"
            case promptType = "promptType"
        }
    }

    public struct PromptOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN.
        public let overrideLambda: String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see Advanced prompts.
        public let promptConfigurations: [PromptConfiguration]

        public init(overrideLambda: String? = nil, promptConfigurations: [PromptConfiguration]) {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, max: 2048)
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.promptConfigurations.forEach {
                try $0.validate(name: "\(name).promptConfigurations[]")
            }
            try self.validate(self.promptConfigurations, name: "promptConfigurations", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case overrideLambda = "overrideLambda"
            case promptConfigurations = "promptConfigurations"
        }
    }

    public struct RdsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        public let credentialsSecretArn: String
        /// The name of your Amazon RDS database.
        public let databaseName: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RdsFieldMapping
        /// The ARN of the vector store.
        public let resourceArn: String
        /// The name of the table in the database.
        public let tableName: String

        public init(credentialsSecretArn: String, databaseName: String, fieldMapping: RdsFieldMapping, resourceArn: String, tableName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):rds:[a-zA-Z0-9-]*:[0-9]{12}:cluster:[a-zA-Z0-9-]{1,63}$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 63)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_\\.\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case databaseName = "databaseName"
            case fieldMapping = "fieldMapping"
            case resourceArn = "resourceArn"
            case tableName = "tableName"
        }
    }

    public struct RdsFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        public let primaryKeyField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        public init(metadataField: String, primaryKeyField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 63)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, max: 63)
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.textField, name: "textField", parent: name, max: 63)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 63)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case primaryKeyField = "primaryKeyField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct RedisEnterpriseCloudConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        public let credentialsSecretArn: String
        /// The endpoint URL of the Redis Enterprise Cloud database.
        public let endpoint: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RedisEnterpriseCloudFieldMapping
        /// The name of the vector index.
        public let vectorIndexName: String

        public init(credentialsSecretArn: String, endpoint: String, fieldMapping: RedisEnterpriseCloudFieldMapping, vectorIndexName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 2048)
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^.*$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case endpoint = "endpoint"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct RedisEnterpriseCloudFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct S3DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the bucket that contains the data source.
        public let bucketArn: String
        /// A list of S3 prefixes that define the object containing the data sources. For more information, see Organizing objects using prefixes.
        public let inclusionPrefixes: [String]?

        public init(bucketArn: String, inclusionPrefixes: [String]? = nil) {
            self.bucketArn = bucketArn
            self.inclusionPrefixes = inclusionPrefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 2048)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, min: 1)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):s3:::[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$")
            try self.inclusionPrefixes?.forEach {
                try validate($0, name: "inclusionPrefixes[]", parent: name, max: 300)
                try validate($0, name: "inclusionPrefixes[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, max: 1)
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case inclusionPrefixes = "inclusionPrefixes"
        }
    }

    public struct S3Identifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket.
        public let s3BucketName: String?
        /// The S3 object key containing the resource.
        public let s3ObjectKey: String?

        public init(s3BucketName: String? = nil, s3ObjectKey: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, max: 1024)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, min: 1)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the KMS key used to encrypt the resource.
        public let kmsKeyArn: String?

        public init(kmsKeyArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct StartIngestionJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The unique identifier of the data source to ingest.
        public let dataSourceId: String
        /// A description of the ingestion job.
        public let description: String?
        /// The unique identifier of the knowledge base to which to add the data source.
        public let knowledgeBaseId: String

        public init(clientToken: String? = StartIngestionJobRequest.idempotencyToken(), dataSourceId: String, description: String? = nil, knowledgeBaseId: String) {
            self.clientToken = clientToken
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct StartIngestionJobResponse: AWSDecodableShape {
        /// An object containing information about the ingestion job.
        public let ingestionJob: IngestionJob

        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct StorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public let opensearchServerlessConfiguration: OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public let pineconeConfiguration: PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        public let rdsConfiguration: RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public let redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        public let type: KnowledgeBaseStorageType

        public init(opensearchServerlessConfiguration: OpenSearchServerlessConfiguration? = nil, pineconeConfiguration: PineconeConfiguration? = nil, rdsConfiguration: RdsConfiguration? = nil, redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration? = nil, type: KnowledgeBaseStorageType) {
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.opensearchServerlessConfiguration?.validate(name: "\(name).opensearchServerlessConfiguration")
            try self.pineconeConfiguration?.validate(name: "\(name).pineconeConfiguration")
            try self.rdsConfiguration?.validate(name: "\(name).rdsConfiguration")
            try self.redisEnterpriseCloudConfiguration?.validate(name: "\(name).redisEnterpriseCloudConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case opensearchServerlessConfiguration = "opensearchServerlessConfiguration"
            case pineconeConfiguration = "pineconeConfiguration"
            case rdsConfiguration = "rdsConfiguration"
            case redisEnterpriseCloudConfiguration = "redisEnterpriseCloudConfiguration"
            case type = "type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// An object containing key-value pairs that define the tags to attach to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$)")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which to remove tags.
        public let resourceArn: String
        /// A list of keys of the tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$)")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentActionGroupRequest: AWSEncodableShape {
        /// The ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// Specifies a new name for the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to update the action group.
        public let agentId: String
        /// The unique identifier of the agent version for which to update the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// Specifies a new name for the action group.
        public let description: String?
        /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?

        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, description: String? = nil, parentActionGroupSignature: ActionGroupSignature? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.description = description
            self.parentActionGroupSignature = parentActionGroupSignature
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case description = "description"
            case parentActionGroupSignature = "parentActionGroupSignature"
        }
    }

    public struct UpdateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was updated.
        public let agentActionGroup: AgentActionGroup

        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct UpdateAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias.
        public let agentAliasId: String
        /// Specifies a new name for the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new description for the alias.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?

        public init(agentAliasId: String, agentAliasName: String, agentId: String, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.description = description
            self.routingConfiguration = routingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct UpdateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was updated.
        public let agentAlias: AgentAlias

        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct UpdateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent associated with the knowledge base that you want to update.
        public let agentId: String
        /// The version of the agent associated with the knowledge base that you want to update.
        public let agentVersion: String
        /// Specifies a new description for the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base that has been associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        public init(agentId: String, agentVersion: String, description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct UpdateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct UpdateAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new name for the agent.
        public let agentName: String
        /// The ARN of the IAM role with permissions to update the agent. The ARN must begin with AmazonBedrockExecutionRoleForAgents_.
        public let agentResourceRoleArn: String
        /// The ARN of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        /// Specifies a new description of the agent.
        public let description: String?
        /// Specifies a new foundation model to be used for orchestration by the agent.
        public let foundationModel: String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?

        public init(agentId: String, agentName: String, agentResourceRoleArn: String, customerEncryptionKeyArn: String? = nil, description: String? = nil, foundationModel: String? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil) {
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encode(self.agentName, forKey: .agentName)
            try container.encode(self.agentResourceRoleArn, forKey: .agentResourceRoleArn)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.foundationModel, forKey: .foundationModel)
            try container.encodeIfPresent(self.idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
            try container.encodeIfPresent(self.instruction, forKey: .instruction)
            try container.encodeIfPresent(self.promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?AmazonBedrockExecutionRoleForAgents_.+$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 1200)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case foundationModel = "foundationModel"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
        }
    }

    public struct UpdateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent that was updated.
        public let agent: Agent

        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// Contains details about the storage configuration of the data source.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// Specifies a new description for the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// Specifies a new name for the data source.
        public let name: String
        /// Contains details about server-side encryption of the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        public init(dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct UpdateKnowledgeBaseRequest: AWSEncodableShape {
        /// Specifies a new description for the knowledge base.
        public let description: String?
        /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base to update.
        public let knowledgeBaseId: String
        /// Specifies a new name for the knowledge base.
        public let name: String
        /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to modify the knowledge base.
        public let roleArn: String
        /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let storageConfiguration: StorageConfiguration

        public init(description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, storageConfiguration: StorageConfiguration) {
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.storageConfiguration, forKey: .storageConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration.validate(name: "\(name).storageConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct UpdateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct VectorIngestionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public let chunkingConfiguration: ChunkingConfiguration?

        public init(chunkingConfiguration: ChunkingConfiguration? = nil) {
            self.chunkingConfiguration = chunkingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingConfiguration = "chunkingConfiguration"
        }
    }

    public struct VectorKnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the model used to create vector embeddings for the knowledge base.
        public let embeddingModelArn: String

        public init(embeddingModelArn: String) {
            self.embeddingModelArn = embeddingModelArn
        }

        public func validate(name: String) throws {
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, max: 1011)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, min: 20)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case embeddingModelArn = "embeddingModelArn"
        }
    }

    public struct ActionGroupExecutor: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let lambda: String?

        public init(lambda: String? = nil) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.validate(self.lambda, name: "lambda", parent: name, max: 2048)
            try self.validate(self.lambda, name: "lambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgent
public struct BedrockAgentErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgent
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource ARN was not found. Check the ARN and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentErrorType: Equatable {
    public static func == (lhs: BedrockAgentErrorType, rhs: BedrockAgentErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
