//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgent {
    // MARK: Enums

    public enum ActionGroupSignature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCodeinterpreter = "AMAZON.CodeInterpreter"
        case amazonUserinput = "AMAZON.UserInput"
        public var description: String { return self.rawValue }
    }

    public enum ActionGroupState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AgentAliasStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case prepared = "PREPARED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case notPrepared = "NOT_PREPARED"
        case prepared = "PREPARED"
        case preparing = "PREPARING"
        case updating = "UPDATING"
        case versioning = "VERSIONING"
        public var description: String { return self.rawValue }
    }

    public enum ChunkingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedSize = "FIXED_SIZE"
        case hierarchical = "HIERARCHICAL"
        case none = "NONE"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ConfluenceAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum ConfluenceHostType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case saas = "SAAS"
        public var description: String { return self.rawValue }
    }

    public enum CrawlFilterConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pattern = "PATTERN"
        public var description: String { return self.rawValue }
    }

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum CustomControlMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case returnControl = "RETURN_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum DataDeletionPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleteUnsuccessful = "DELETE_UNSUCCESSFUL"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confluence = "CONFLUENCE"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case sharepoint = "SHAREPOINT"
        case web = "WEB"
        public var description: String { return self.rawValue }
    }

    public enum FlowConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditional = "Conditional"
        case data = "Data"
        public var description: String { return self.rawValue }
    }

    public enum FlowNodeIODataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "Array"
        case boolean = "Boolean"
        case number = "Number"
        case object = "Object"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum FlowNodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "Agent"
        case collector = "Collector"
        case condition = "Condition"
        case input = "Input"
        case iterator = "Iterator"
        case knowledgeBase = "KnowledgeBase"
        case lambdaFunction = "LambdaFunction"
        case lex = "Lex"
        case output = "Output"
        case prompt = "Prompt"
        case retrieval = "Retrieval"
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum FlowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case notPrepared = "NotPrepared"
        case prepared = "Prepared"
        case preparing = "Preparing"
        public var description: String { return self.rawValue }
    }

    public enum FlowValidationSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "Error"
        case warning = "Warning"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobSortByAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startedAt = "STARTED_AT"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case starting = "STARTING"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleteUnsuccessful = "DELETE_UNSUCCESSFUL"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mongoDbAtlas = "MONGO_DB_ATLAS"
        case opensearchServerless = "OPENSEARCH_SERVERLESS"
        case pinecone = "PINECONE"
        case rds = "RDS"
        case redisEnterpriseCloud = "REDIS_ENTERPRISE_CLOUD"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case vector = "VECTOR"
        public var description: String { return self.rawValue }
    }

    public enum MemoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sessionSummary = "SESSION_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum ParsingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockFoundationModel = "BEDROCK_FOUNDATION_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum PromptState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PromptTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum RequireConfirmation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum SharePointAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum SharePointHostType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case online = "ONLINE"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum StepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case postChunking = "POST_CHUNKING"
        public var description: String { return self.rawValue }
    }

    public enum WebScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hostOnly = "HOST_ONLY"
        case subdomains = "SUBDOMAINS"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum APISchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case payload(String)
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case s3(S3Identifier)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .payload:
                let value = try container.decode(String.self, forKey: .payload)
                self = .payload(value)
            case .s3:
                let value = try container.decode(S3Identifier.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .payload(let value):
                try container.encode(value, forKey: .payload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case s3 = "s3"
        }
    }

    public enum ActionGroupExecutor: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// To return the action group invocation results directly in the InvokeAgent response, specify RETURN_CONTROL.
        case customControl(CustomControlMethod)
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customControl:
                let value = try container.decode(CustomControlMethod.self, forKey: .customControl)
                self = .customControl(value)
            case .lambda:
                let value = try container.decode(String.self, forKey: .lambda)
                self = .lambda(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customControl(let value):
                try container.encode(value, forKey: .customControl)
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try self.validate(value, name: "lambda", parent: name, max: 2048)
                try self.validate(value, name: "lambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customControl = "customControl"
            case lambda = "lambda"
        }
    }

    public enum FlowConnectionConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration of a connection originating from a Condition node.
        case conditional(FlowConditionalConnectionConfiguration)
        /// The configuration of a connection originating from a node that isn't a Condition node.
        case data(FlowDataConnectionConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditional:
                let value = try container.decode(FlowConditionalConnectionConfiguration.self, forKey: .conditional)
                self = .conditional(value)
            case .data:
                let value = try container.decode(FlowDataConnectionConfiguration.self, forKey: .data)
                self = .data(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conditional(let value):
                try container.encode(value, forKey: .conditional)
            case .data(let value):
                try container.encode(value, forKey: .data)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .conditional(let value):
                try value.validate(name: "\(name).conditional")
            case .data(let value):
                try value.validate(name: "\(name).data")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditional = "conditional"
            case data = "data"
        }
    }

    public enum FlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response.
        case agent(AgentFlowNodeConfiguration)
        /// Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs.
        case collector(CollectorFlowNodeConfiguration)
        /// Contains configurations for a Condition node in your flow. Defines conditions that lead to different branches of the flow.
        case condition(ConditionFlowNodeConfiguration)
        /// Contains configurations for an input flow node in your flow. The first node in the flow. inputs can't be specified for this node.
        case input(InputFlowNodeConfiguration)
        /// Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
        case iterator(IteratorFlowNodeConfiguration)
        /// Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response.
        case knowledgeBase(KnowledgeBaseFlowNodeConfiguration)
        /// Contains configurations for a Lambda function node in your flow. Invokes an Lambda function.
        case lambdaFunction(LambdaFunctionFlowNodeConfiguration)
        /// Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.
        case lex(LexFlowNodeConfiguration)
        /// Contains configurations for an output flow node in your flow. The last node in the flow. outputs can't be specified for this node.
        case output(OutputFlowNodeConfiguration)
        /// Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.
        case prompt(PromptFlowNodeConfiguration)
        /// Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output.
        case retrieval(RetrievalFlowNodeConfiguration)
        /// Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location.
        case storage(StorageFlowNodeConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .agent:
                let value = try container.decode(AgentFlowNodeConfiguration.self, forKey: .agent)
                self = .agent(value)
            case .collector:
                let value = try container.decode(CollectorFlowNodeConfiguration.self, forKey: .collector)
                self = .collector(value)
            case .condition:
                let value = try container.decode(ConditionFlowNodeConfiguration.self, forKey: .condition)
                self = .condition(value)
            case .input:
                let value = try container.decode(InputFlowNodeConfiguration.self, forKey: .input)
                self = .input(value)
            case .iterator:
                let value = try container.decode(IteratorFlowNodeConfiguration.self, forKey: .iterator)
                self = .iterator(value)
            case .knowledgeBase:
                let value = try container.decode(KnowledgeBaseFlowNodeConfiguration.self, forKey: .knowledgeBase)
                self = .knowledgeBase(value)
            case .lambdaFunction:
                let value = try container.decode(LambdaFunctionFlowNodeConfiguration.self, forKey: .lambdaFunction)
                self = .lambdaFunction(value)
            case .lex:
                let value = try container.decode(LexFlowNodeConfiguration.self, forKey: .lex)
                self = .lex(value)
            case .output:
                let value = try container.decode(OutputFlowNodeConfiguration.self, forKey: .output)
                self = .output(value)
            case .prompt:
                let value = try container.decode(PromptFlowNodeConfiguration.self, forKey: .prompt)
                self = .prompt(value)
            case .retrieval:
                let value = try container.decode(RetrievalFlowNodeConfiguration.self, forKey: .retrieval)
                self = .retrieval(value)
            case .storage:
                let value = try container.decode(StorageFlowNodeConfiguration.self, forKey: .storage)
                self = .storage(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .agent(let value):
                try container.encode(value, forKey: .agent)
            case .collector(let value):
                try container.encode(value, forKey: .collector)
            case .condition(let value):
                try container.encode(value, forKey: .condition)
            case .input(let value):
                try container.encode(value, forKey: .input)
            case .iterator(let value):
                try container.encode(value, forKey: .iterator)
            case .knowledgeBase(let value):
                try container.encode(value, forKey: .knowledgeBase)
            case .lambdaFunction(let value):
                try container.encode(value, forKey: .lambdaFunction)
            case .lex(let value):
                try container.encode(value, forKey: .lex)
            case .output(let value):
                try container.encode(value, forKey: .output)
            case .prompt(let value):
                try container.encode(value, forKey: .prompt)
            case .retrieval(let value):
                try container.encode(value, forKey: .retrieval)
            case .storage(let value):
                try container.encode(value, forKey: .storage)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .agent(let value):
                try value.validate(name: "\(name).agent")
            case .condition(let value):
                try value.validate(name: "\(name).condition")
            case .knowledgeBase(let value):
                try value.validate(name: "\(name).knowledgeBase")
            case .lambdaFunction(let value):
                try value.validate(name: "\(name).lambdaFunction")
            case .lex(let value):
                try value.validate(name: "\(name).lex")
            case .prompt(let value):
                try value.validate(name: "\(name).prompt")
            case .retrieval(let value):
                try value.validate(name: "\(name).retrieval")
            case .storage(let value):
                try value.validate(name: "\(name).storage")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
            case collector = "collector"
            case condition = "condition"
            case input = "input"
            case iterator = "iterator"
            case knowledgeBase = "knowledgeBase"
            case lambdaFunction = "lambdaFunction"
            case lex = "lex"
            case output = "output"
            case prompt = "prompt"
            case retrieval = "retrieval"
            case storage = "storage"
        }
    }

    public enum PromptFlowNodeSourceConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configurations for a prompt that is defined inline
        case inline(PromptFlowNodeInlineConfiguration)
        /// Contains configurations for a prompt from Prompt management.
        case resource(PromptFlowNodeResourceConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inline:
                let value = try container.decode(PromptFlowNodeInlineConfiguration.self, forKey: .inline)
                self = .inline(value)
            case .resource:
                let value = try container.decode(PromptFlowNodeResourceConfiguration.self, forKey: .resource)
                self = .resource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inline(let value):
                try container.encode(value, forKey: .inline)
            case .resource(let value):
                try container.encode(value, forKey: .resource)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .inline(let value):
                try value.validate(name: "\(name).inline")
            case .resource(let value):
                try value.validate(name: "\(name).resource")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inline = "inline"
            case resource = "resource"
        }
    }

    // MARK: Shapes

    public struct ActionGroupSummary: AWSDecodableShape {
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The description of the action group.
        public let description: String?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, description: String? = nil, updatedAt: Date) {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case description = "description"
            case updatedAt = "updatedAt"
        }
    }

    public struct Agent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent.
        public let agentArn: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The status of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent is being created.   PREPARING – The agent is being prepared.   PREPARED – The agent is prepared and ready to be invoked.   NOT_PREPARED – The agent has been created but not yet prepared.   FAILED – The agent API operation failed.   UPDATING – The agent is being updated.   DELETING – The agent is being deleted.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        /// The description of the agent.
        public let description: String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public let failureReasons: [String]?
        /// The foundation model used for orchestration by the agent.
        public let foundationModel: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Contains memory configuration for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        /// The time at which the agent was last prepared.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var preparedAt: Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public let recommendedActions: [String]?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentArn: String, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, agentVersion: String, clientToken: String? = nil, createdAt: Date, customerEncryptionKeyArn: String? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, preparedAt: Date? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date) {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case preparedAt = "preparedAt"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentActionGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The unique identifier of the agent to which the action group belongs.
        public let agentId: String
        /// The version of the agent to which the action group belongs.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the action group was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the action group.
        public let description: String?
        /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        public let functionSchema: FunctionSchema?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionSignature: ActionGroupSignature?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = nil, createdAt: Date, description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionSignature: ActionGroupSignature? = nil, updatedAt: Date) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionSignature = "parentActionSignature"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAlias: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias of the agent.
        public let agentAliasArn: String
        /// Contains details about the history of the alias.
        public let agentAliasHistoryEvents: [AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String
        /// The name of the alias of the agent.
        public let agentAliasName: String
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent alias is being created.   PREPARED – The agent alias is finished being created or updated and is ready to be invoked.   FAILED – The agent alias API operation failed.   UPDATING – The agent alias is being updated.   DELETING – The agent alias is being deleted.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias of the agent.
        public let description: String?
        /// Information on the failure of Provisioned Throughput assigned to an agent alias.
        public let failureReasons: [String]?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentAliasArn: String, agentAliasHistoryEvents: [AgentAliasHistoryEvent]? = nil, agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, agentId: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, failureReasons: [String]? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
            case agentAliasHistoryEvents = "agentAliasHistoryEvents"
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case failureReasons = "failureReasons"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAliasHistoryEvent: AWSDecodableShape {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?

        @inlinable
        public init(endDate: Date? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, startDate: Date? = nil) {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case routingConfiguration = "routingConfiguration"
            case startDate = "startDate"
        }
    }

    public struct AgentAliasRoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The version of the agent with which the alias is associated.
        public let agentVersion: String?
        /// Information on the Provisioned Throughput assigned to an agent alias.
        public let provisionedThroughput: String?

        @inlinable
        public init(agentVersion: String? = nil, provisionedThroughput: String? = nil) {
            self.agentVersion = agentVersion
            self.provisionedThroughput = provisionedThroughput
        }

        public func validate(name: String) throws {
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, max: 2048)
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, min: 1)
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, pattern: "^((([0-9a-zA-Z][_-]?){1,63})|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
            case provisionedThroughput = "provisionedThroughput"
        }
    }

    public struct AgentAliasSummary: AWSDecodableShape {
        /// Contains details about
        public let agentAliasId: String
        /// The name of the alias.
        public let agentAliasName: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias.
        public let description: String?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, createdAt: Date, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, updatedAt: Date) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case createdAt = "createdAt"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        public let agentAliasArn: String

        @inlinable
        public init(agentAliasArn: String) {
            self.agentAliasArn = agentAliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasArn, name: "agentAliasArn", parent: name, max: 2048)
            try self.validate(self.agentAliasArn, name: "agentAliasArn", parent: name, pattern: "^arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:agent-alias/[0-9a-zA-Z]{10}/[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
        }
    }

    public struct AgentKnowledgeBase: AWSDecodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The time at which the association between the agent and the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the association between the agent and the knowledge base.
        public let description: String
        /// The unique identifier of the association between the agent and the knowledge base.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the association between the agent and the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentId: String, agentVersion: String, createdAt: Date, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentKnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the knowledge base associated with an agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentSummary: AWSDecodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The status of the agent.
        public let agentStatus: AgentStatus
        /// The description of the agent.
        public let description: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The latest version of the agent.
        public let latestAgentVersion: String?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentId: String, agentName: String, agentStatus: AgentStatus, description: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, latestAgentVersion: String? = nil, updatedAt: Date) {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case description = "description"
            case guardrailConfiguration = "guardrailConfiguration"
            case latestAgentVersion = "latestAgentVersion"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent that the version belongs to.
        public let agentArn: String
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The name of the agent that the version belongs to.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The status of the agent that the version belongs to.
        public let agentStatus: AgentStatus
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        /// The description of the version.
        public let description: String?
        /// A list of reasons that the API operation on the version failed.
        public let failureReasons: [String]?
        /// The foundation model that the version invokes.
        public let foundationModel: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// The instructions provided to the agent.
        public let instruction: String?
        ///  Contains details of the memory configuration on the version of the agent.
        public let memoryConfiguration: MemoryConfiguration?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public let recommendedActions: [String]?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version number.
        public let version: String

        @inlinable
        public init(agentArn: String, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, createdAt: Date, customerEncryptionKeyArn: String? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date, version: String) {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct AgentVersionSummary: AWSDecodableShape {
        /// The name of the agent to which the version belongs.
        public let agentName: String
        /// The status of the agent to which the version belongs.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the version of the agent.
        public let description: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentName: String, agentStatus: AgentStatus, agentVersion: String, createdAt: Date, description: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, updatedAt: Date) {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case guardrailConfiguration = "guardrailConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AssociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which you want to associate the knowledge base.
        public let agentId: String
        /// The version of the agent with which you want to associate the knowledge base.
        public let agentVersion: String
        /// A description of what the agent should use the knowledge base for.
        public let description: String
        /// The unique identifier of the knowledge base to associate with the agent.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        @inlinable
        public init(agentId: String, agentVersion: String, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encode(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseId, forKey: .knowledgeBaseId)
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct AssociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with the agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct BedrockEmbeddingModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dimensions details for the vector configuration used on the Bedrock embeddings model.
        public let dimensions: Int?

        @inlinable
        public init(dimensions: Int? = nil) {
            self.dimensions = dimensions
        }

        public func validate(name: String) throws {
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 4096)
            try self.validate(self.dimensions, name: "dimensions", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "dimensions"
        }
    }

    public struct BedrockFoundationModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the foundation model or inference profile.
        public let modelArn: String
        /// Instructions for interpreting the contents of a document.
        public let parsingPrompt: ParsingPrompt?

        @inlinable
        public init(modelArn: String, parsingPrompt: ParsingPrompt? = nil) {
            self.modelArn = modelArn
            self.parsingPrompt = parsingPrompt
        }

        public func validate(name: String) throws {
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})|(arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{1,20}):(|[0-9]{12}):inference-profile/[a-zA-Z0-9-:.]+)$")
            try self.parsingPrompt?.validate(name: "\(name).parsingPrompt")
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
            case parsingPrompt = "parsingPrompt"
        }
    }

    public struct ChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.    FIXED_SIZE – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.    HIERARCHICAL – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.    SEMANTIC – Split documents into chunks based on groups of similar content derived with natural language processing.    NONE – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        public let chunkingStrategy: ChunkingStrategy
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public let fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public let hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        public let semanticChunkingConfiguration: SemanticChunkingConfiguration?

        @inlinable
        public init(chunkingStrategy: ChunkingStrategy, fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration? = nil, hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration? = nil, semanticChunkingConfiguration: SemanticChunkingConfiguration? = nil) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }

        public func validate(name: String) throws {
            try self.hierarchicalChunkingConfiguration?.validate(name: "\(name).hierarchicalChunkingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingStrategy = "chunkingStrategy"
            case fixedSizeChunkingConfiguration = "fixedSizeChunkingConfiguration"
            case hierarchicalChunkingConfiguration = "hierarchicalChunkingConfiguration"
            case semanticChunkingConfiguration = "semanticChunkingConfiguration"
        }
    }

    public struct CollectorFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct ConditionFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of conditions. Each member contains the name of a condition and an expression that defines the condition.
        public let conditions: [FlowCondition]

        @inlinable
        public init(conditions: [FlowCondition]) {
            self.conditions = conditions
        }

        public func validate(name: String) throws {
            try self.conditions.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, max: 5)
            try self.validate(self.conditions, name: "conditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "conditions"
        }
    }

    public struct ConfluenceCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the Confluence content. For example, configuring  regular expression patterns to include or exclude certain content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct ConfluenceDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Confluence content. For example, configuring  specific types of Confluence content.
        public let crawlerConfiguration: ConfluenceCrawlerConfiguration?
        /// The endpoint information to connect to your Confluence data source.
        public let sourceConfiguration: ConfluenceSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: ConfluenceCrawlerConfiguration? = nil, sourceConfiguration: ConfluenceSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct ConfluenceSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect to your  Confluence instance.
        public let authType: ConfluenceAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your Confluence instance URL.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  Confluence connection configuration.
        public let credentialsSecretArn: String
        /// The supported host type, whether online/cloud or server/on-premises.
        public let hostType: ConfluenceHostType
        /// The Confluence host URL or instance URL.
        public let hostUrl: String

        @inlinable
        public init(authType: ConfluenceAuthType, credentialsSecretArn: String, hostType: ConfluenceHostType, hostUrl: String) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostType = hostType
            self.hostUrl = hostUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.hostUrl, name: "hostUrl", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case hostType = "hostType"
            case hostUrl = "hostUrl"
        }
    }

    public struct CrawlFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering certain objects or content types of the data source.
        public let patternObjectFilter: PatternObjectFilterConfiguration?
        /// The type of filtering that you want to apply to certain objects or content of the  data source. For example, the PATTERN type is regular expression patterns  you can apply to filter your content.
        public let type: CrawlFilterConfigurationType

        @inlinable
        public init(patternObjectFilter: PatternObjectFilterConfiguration? = nil, type: CrawlFilterConfigurationType) {
            self.patternObjectFilter = patternObjectFilter
            self.type = type
        }

        public func validate(name: String) throws {
            try self.patternObjectFilter?.validate(name: "\(name).patternObjectFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case patternObjectFilter = "patternObjectFilter"
            case type = "type"
        }
    }

    public struct CreateAgentActionGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The name to give the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to create the action group.
        public let agentId: String
        /// The version of the agent for which to create the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the action group.
        public let description: String?
        /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let functionSchema: FunctionSchema?
        /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = CreateAgentActionGroupRequest.idempotencyToken(), description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignature: ActionGroupSignature? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.functionSchema, forKey: .functionSchema)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.functionSchema?.validate(name: "\(name).functionSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignature = "parentActionGroupSignature"
        }
    }

    public struct CreateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was created.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct CreateAgentAliasRequest: AWSEncodableShape {
        /// The name of the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the alias of the agent.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// Any tags that you want to attach to the alias of the agent.
        public let tags: [String: String]?

        @inlinable
        public init(agentAliasName: String, agentId: String, clientToken: String? = CreateAgentAliasRequest.idempotencyToken(), description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, tags: [String: String]? = nil) {
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.clientToken = clientToken
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case clientToken = "clientToken"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was created.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct CreateAgentRequest: AWSEncodableShape {
        /// A name for the agent that you create.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        /// A description of the agent.
        public let description: String?
        /// The foundation model to be used for orchestration by the agent you create.
        public let foundationModel: String?
        /// The unique Guardrail configuration assigned to the agent when it is created.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        ///  Contains the details of the memory configured for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Any tags that you want to attach to the agent.
        public let tags: [String: String]?

        @inlinable
        public init(agentName: String, agentResourceRoleArn: String? = nil, clientToken: String? = CreateAgentRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, description: String? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, tags: [String: String]? = nil) {
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 4000)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.memoryConfiguration?.validate(name: "\(name).memoryConfiguration")
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent created.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The data deletion policy for the data source. You can set the data deletion policy to:   DELETE: Deletes all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted,  only the data. This flag is ignored if an Amazon Web Services account is deleted.   RETAIN: Retains all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted  if you delete a knowledge base or data source resource.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// A description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which to add the data source.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the server-side encryption for the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(clientToken: String? = CreateDataSourceRequest.idempotencyToken(), dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.clientToken = clientToken
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.dataDeletionPolicy, forKey: .dataDeletionPolicy)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateFlowAliasRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description for the alias.
        public let description: String?
        /// The unique identifier of the flow for which to create an alias.
        public let flowIdentifier: String
        /// A name for the alias.
        public let name: String
        /// Contains information about the version to which to map the alias.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// Any tags that you want to attach to the alias of the flow. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFlowAliasRequest.idempotencyToken(), description: String? = nil, flowIdentifier: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.flowIdentifier = flowIdentifier
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.routingConfiguration, forKey: .routingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.routingConfiguration.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let arn: String
        /// The time at which the alias was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias.
        public let description: String?
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the alias.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias of the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateFlowRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// A description for the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// A name for the flow.
        public let name: String
        /// Any tags that you want to attach to the flow. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFlowRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the flow with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If creation fails, the status becomes Failed.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the flow. When you create a flow, the version created is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct CreateFlowVersionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the version of the flow.
        public let description: String?
        /// The unique identifier of the flow that you want to create a version of.
        public let flowIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateFlowVersionRequest.idempotencyToken(), description: String? = nil, flowIdentifier: String) {
            self.clientToken = clientToken
            self.description = description
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct CreateFlowVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The KMS key that the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections in the flow.
        public let definition: FlowDefinition?
        /// The description of the version.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the version.
        public let name: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow that was created. Versions are numbered incrementally, starting from 1.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case version = "version"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the knowledge base.
        public let description: String?
        /// Contains details about the embeddings model used for the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// A name for the knowledge base.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// Contains details about the configuration of the vector database used for the knowledge base.
        public let storageConfiguration: StorageConfiguration
        /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, name: String, roleArn: String, storageConfiguration: StorageConfiguration, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration.validate(name: "\(name).storageConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct CreatePromptRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the prompt.
        public let description: String?
        /// A name for the prompt.
        public let name: String
        /// Any tags that you want to attach to the prompt. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?

        @inlinable
        public init(clientToken: String? = CreatePromptRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, name: String, tags: [String: String]? = nil, variants: [PromptVariant]? = nil) {
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.name = name
            self.tags = tags
            self.variants = variants
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.defaultVariant, name: "defaultVariant", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.variants?.forEach {
                try $0.validate(name: "\(name).variants[]")
            }
            try self.validate(self.variants, name: "variants", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case variants = "variants"
        }
    }

    public struct CreatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the prompt with.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for your prompt.
        public let defaultVariant: String?
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt. When you create a prompt, the version created is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct CreatePromptVersionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description for the version of the prompt.
        public let description: String?
        /// The unique identifier of the prompt that you want to create a version of.
        public let promptIdentifier: String
        /// Any tags that you want to attach to the version of the prompt. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreatePromptVersionRequest.idempotencyToken(), description: String? = nil, promptIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.promptIdentifier = promptIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case tags = "tags"
        }
    }

    public struct CreatePromptVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the version of the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the version.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt that was created. Versions are numbered incrementally, starting from 1.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct CustomTransformationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An S3 bucket path for input and output objects.
        public let intermediateStorage: IntermediateStorage
        /// A Lambda function that processes documents.
        public let transformations: [Transformation]

        @inlinable
        public init(intermediateStorage: IntermediateStorage, transformations: [Transformation]) {
            self.intermediateStorage = intermediateStorage
            self.transformations = transformations
        }

        public func validate(name: String) throws {
            try self.intermediateStorage.validate(name: "\(name).intermediateStorage")
            try self.transformations.forEach {
                try $0.validate(name: "\(name).transformations[]")
            }
            try self.validate(self.transformations, name: "transformations", parent: name, max: 1)
            try self.validate(self.transformations, name: "transformations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateStorage = "intermediateStorage"
            case transformations = "transformations"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The time at which the data source was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The data deletion policy for the data source.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The detailed reasons on the failure to delete a data source.
        public let failureReasons: [String]?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the configuration of the server-side encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:   Available – The data source has been created and is ready for ingestion into the knowledge base.   Deleting – The data source is being deleted.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(createdAt: Date, dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, failureReasons: [String]? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: DataSourceStatus, updatedAt: Date, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.createdAt = createdAt
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case failureReasons = "failureReasons"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case updatedAt = "updatedAt"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information to connect to Confluence as your data source.  Confluence data source connector is in preview release and is subject to change.
        public let confluenceConfiguration: ConfluenceDataSourceConfiguration?
        /// The configuration information to connect to Amazon S3 as your data source.
        public let s3Configuration: S3DataSourceConfiguration?
        /// The configuration information to connect to Salesforce as your data source.  Salesforce data source connector is in preview release and is subject to change.
        public let salesforceConfiguration: SalesforceDataSourceConfiguration?
        /// The configuration information to connect to SharePoint as your data source.  SharePoint data source connector is in preview release and is subject to change.
        public let sharePointConfiguration: SharePointDataSourceConfiguration?
        /// The type of data source.
        public let type: DataSourceType
        /// The configuration of web URLs to crawl for your data source.  You should be authorized to crawl the URLs.  Crawling web URLs as your data source is in preview release  and is subject to change.
        public let webConfiguration: WebDataSourceConfiguration?

        @inlinable
        public init(confluenceConfiguration: ConfluenceDataSourceConfiguration? = nil, s3Configuration: S3DataSourceConfiguration? = nil, salesforceConfiguration: SalesforceDataSourceConfiguration? = nil, sharePointConfiguration: SharePointDataSourceConfiguration? = nil, type: DataSourceType, webConfiguration: WebDataSourceConfiguration? = nil) {
            self.confluenceConfiguration = confluenceConfiguration
            self.s3Configuration = s3Configuration
            self.salesforceConfiguration = salesforceConfiguration
            self.sharePointConfiguration = sharePointConfiguration
            self.type = type
            self.webConfiguration = webConfiguration
        }

        public func validate(name: String) throws {
            try self.confluenceConfiguration?.validate(name: "\(name).confluenceConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
            try self.salesforceConfiguration?.validate(name: "\(name).salesforceConfiguration")
            try self.sharePointConfiguration?.validate(name: "\(name).sharePointConfiguration")
            try self.webConfiguration?.validate(name: "\(name).webConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case confluenceConfiguration = "confluenceConfiguration"
            case s3Configuration = "s3Configuration"
            case salesforceConfiguration = "salesforceConfiguration"
            case sharePointConfiguration = "sharePointConfiguration"
            case type = "type"
            case webConfiguration = "webConfiguration"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// The status of the data source.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, status: DataSourceStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group to delete.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(actionGroupId: String, agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentActionGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias to delete.
        public let agentAliasId: String
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentAliasResponse: AWSDecodableShape {
        /// The unique identifier of the alias that was deleted.
        public let agentAliasId: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentAliasStatus: AgentAliasStatus, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
        }
    }

    public struct DeleteAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent to delete.
        public let agentId: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(agentId: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent that was deleted.
        public let agentId: String
        /// The status of the agent.
        public let agentStatus: AgentStatus

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus) {
            self.agentId = agentId
            self.agentStatus = agentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
        }
    }

    public struct DeleteAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The version of the agent to delete.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentVersionResponse: AWSDecodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The status of the agent version.
        public let agentStatus: AgentStatus
        /// The version that was deleted.
        public let agentVersion: String

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source to delete.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base from which to delete the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        /// The unique identifier of the data source that was deleted.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
        public let knowledgeBaseId: String
        /// The status of the data source.
        public let status: DataSourceStatus

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String, status: DataSourceStatus) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DeleteFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias to be deleted.
        public let aliasIdentifier: String
        /// The unique identifier of the flow that the alias belongs to.
        public let flowIdentifier: String

        @inlinable
        public init(aliasIdentifier: String, flowIdentifier: String) {
            self.aliasIdentifier = aliasIdentifier
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowAliasResponse: AWSDecodableShape {
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the flow.
        public let id: String

        @inlinable
        public init(flowId: String, id: String) {
            self.flowId = flowId
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "flowId"
            case id = "id"
        }
    }

    public struct DeleteFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(flowIdentifier: String, skipResourceInUseCheck: Bool? = nil) {
            self.flowIdentifier = flowIdentifier
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteFlowVersionRequest: AWSEncodableShape {
        /// The unique identifier of the flow whose version that you want to delete
        public let flowIdentifier: String
        /// The version of the flow that you want to delete.
        public let flowVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(flowIdentifier: String, flowVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.flowIdentifier = flowIdentifier
            self.flowVersion = flowVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodePath(self.flowVersion, key: "flowVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowVersionResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String
        /// The version of the flow being deleted.
        public let version: String

        @inlinable
        public init(id: String, version: String) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case version = "version"
        }
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base to delete.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        /// The unique identifier of the knowledge base that was deleted.
        public let knowledgeBaseId: String
        /// The status of the knowledge base and whether it has been successfully deleted.
        public let status: KnowledgeBaseStatus

        @inlinable
        public init(knowledgeBaseId: String, status: KnowledgeBaseStatus) {
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DeletePromptRequest: AWSEncodableShape {
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// The version of the prompt to delete. To delete the prompt, omit this field.
        public let promptVersion: String?

        @inlinable
        public init(promptIdentifier: String, promptVersion: String? = nil) {
            self.promptIdentifier = promptIdentifier
            self.promptVersion = promptVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            request.encodeQuery(self.promptVersion, key: "promptVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePromptResponse: AWSDecodableShape {
        /// The unique identifier of the prompt that was deleted.
        public let id: String
        /// The version of the prompt that was deleted.
        public let version: String?

        @inlinable
        public init(id: String, version: String? = nil) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case version = "version"
        }
    }

    public struct DisassociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent from which to disassociate the knowledge base.
        public let agentId: String
        /// The version of the agent from which to disassociate the knowledge base.
        public let agentVersion: String
        /// The unique identifier of the knowledge base to disassociate.
        public let knowledgeBaseId: String

        @inlinable
        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EmbeddingModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The vector configuration details on the Bedrock embeddings model.
        public let bedrockEmbeddingModelConfiguration: BedrockEmbeddingModelConfiguration?

        @inlinable
        public init(bedrockEmbeddingModelConfiguration: BedrockEmbeddingModelConfiguration? = nil) {
            self.bedrockEmbeddingModelConfiguration = bedrockEmbeddingModelConfiguration
        }

        public func validate(name: String) throws {
            try self.bedrockEmbeddingModelConfiguration?.validate(name: "\(name).bedrockEmbeddingModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockEmbeddingModelConfiguration = "bedrockEmbeddingModelConfiguration"
        }
    }

    public struct FixedSizeChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to include in a chunk.
        public let maxTokens: Int
        /// The percentage of overlap between adjacent chunks of a data source.
        public let overlapPercentage: Int

        @inlinable
        public init(maxTokens: Int, overlapPercentage: Int) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case overlapPercentage = "overlapPercentage"
        }
    }

    public struct FlowAliasRoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The version that the alias maps to.
        public let flowVersion: String?

        @inlinable
        public init(flowVersion: String? = nil) {
            self.flowVersion = flowVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, max: 5)
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, min: 1)
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowVersion = "flowVersion"
        }
    }

    public struct FlowAliasSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let arn: String
        /// The time at which the alias was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the alias.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowId: String
        /// The unique identifier of the alias of the flow.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// A list of configurations about the versions that the alias maps to. Currently, you can only specify one.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct FlowCondition: AWSEncodableShape & AWSDecodableShape {
        /// Defines the condition. You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in Node types in prompt flows.
        public let expression: String?
        /// A name for the condition that you can reference.
        public let name: String

        @inlinable
        public init(expression: String? = nil, name: String) {
            self.expression = expression
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 64)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case name = "name"
        }
    }

    public struct FlowConditionalConnectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The condition that triggers this connection. For more information about how to write conditions, see the Condition node type in the Node types topic in the Amazon Bedrock User Guide.
        public let condition: String

        @inlinable
        public init(condition: String) {
            self.condition = condition
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
        }
    }

    public struct FlowConnection: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the connection.
        public let configuration: FlowConnectionConfiguration?
        /// A name for the connection that you can reference.
        public let name: String
        /// The node that the connection starts at.
        public let source: String
        /// The node that the connection ends at.
        public let target: String
        /// Whether the source node that the connection begins from is a condition node (Conditional) or not (Data).
        public let type: FlowConnectionType

        @inlinable
        public init(configuration: FlowConnectionConfiguration? = nil, name: String, source: String, target: String, type: FlowConnectionType) {
            self.configuration = configuration
            self.name = name
            self.source = source
            self.target = target
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,100}$")
            try self.validate(self.source, name: "source", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.validate(self.target, name: "target", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case name = "name"
            case source = "source"
            case target = "target"
            case type = "type"
        }
    }

    public struct FlowDataConnectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the output in the source node that the connection begins from.
        public let sourceOutput: String
        /// The name of the input in the target node that the connection ends at.
        public let targetInput: String

        @inlinable
        public init(sourceOutput: String, targetInput: String) {
            self.sourceOutput = sourceOutput
            self.targetInput = targetInput
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceOutput, name: "sourceOutput", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.validate(self.targetInput, name: "targetInput", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceOutput = "sourceOutput"
            case targetInput = "targetInput"
        }
    }

    public struct FlowDefinition: AWSEncodableShape & AWSDecodableShape {
        /// An array of connection definitions in the flow.
        public let connections: [FlowConnection]?
        /// An array of node definitions in the flow.
        public let nodes: [FlowNode]?

        @inlinable
        public init(connections: [FlowConnection]? = nil, nodes: [FlowNode]? = nil) {
            self.connections = connections
            self.nodes = nodes
        }

        public func validate(name: String) throws {
            try self.connections?.forEach {
                try $0.validate(name: "\(name).connections[]")
            }
            try self.validate(self.connections, name: "connections", parent: name, max: 20)
            try self.nodes?.forEach {
                try $0.validate(name: "\(name).nodes[]")
            }
            try self.validate(self.nodes, name: "nodes", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
            case nodes = "nodes"
        }
    }

    public struct FlowNode: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the node.
        public let configuration: FlowNodeConfiguration?
        /// An array of objects, each of which contains information about an input into the node.
        public let inputs: [FlowNodeInput]?
        /// A name for the node.
        public let name: String
        /// A list of objects, each of which contains information about an output from the node.
        public let outputs: [FlowNodeOutput]?
        /// The type of node. This value must match the name of the key that you provide in the configuration you provide in the FlowNodeConfiguration field.
        public let type: FlowNodeType

        @inlinable
        public init(configuration: FlowNodeConfiguration? = nil, inputs: [FlowNodeInput]? = nil, name: String, outputs: [FlowNodeOutput]? = nil, type: FlowNodeType) {
            self.configuration = configuration
            self.inputs = inputs
            self.name = name
            self.outputs = outputs
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.inputs?.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case inputs = "inputs"
            case name = "name"
            case outputs = "outputs"
            case type = "type"
        }
    }

    public struct FlowNodeInput: AWSEncodableShape & AWSDecodableShape {
        /// An expression that formats the input for the node. For an explanation of how to create expressions, see Expressions in Prompt flows in Amazon Bedrock.
        public let expression: String
        /// A name for the input that you can reference.
        public let name: String
        /// The data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        public let type: FlowNodeIODataType

        @inlinable
        public init(expression: String, name: String, type: FlowNodeIODataType) {
            self.expression = expression
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 64)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case name = "name"
            case type = "type"
        }
    }

    public struct FlowNodeOutput: AWSEncodableShape & AWSDecodableShape {
        /// A name for the output that you can reference.
        public let name: String
        /// The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        public let type: FlowNodeIODataType

        @inlinable
        public init(name: String, type: FlowNodeIODataType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct FlowSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the flow.
        public let description: String?
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. The following statuses are possible:   NotPrepared – The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a PrepareFlow request to package the latest changes into the DRAFT version.   Preparing – The flow is being prepared so that the DRAFT version contains the latest changes for testing.   Prepared – The flow is prepared and the DRAFT version contains the latest changes for testing.   Failed – The last API operation that you invoked on the flow failed. Send a GetFlow request and check the error message in the validations field.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The latest version of the flow.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct FlowValidation: AWSDecodableShape {
        /// A message describing the validation error.
        public let message: String
        /// The severity of the issue described in the message.
        public let severity: FlowValidationSeverity

        @inlinable
        public init(message: String, severity: FlowValidationSeverity) {
            self.message = message
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case severity = "severity"
        }
    }

    public struct FlowVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow that the version belongs to.
        public let arn: String
        /// The time at the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the flow.
        public let id: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, id: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case version = "version"
        }
    }

    public struct Function: AWSEncodableShape & AWSDecodableShape {
        /// A description of the function and its purpose.
        public let description: String?
        /// A name for the function.
        public let name: String
        /// The parameters that the agent elicits from the user to fulfill the function.
        public let parameters: [String: ParameterDetail]?
        /// Contains information if user confirmation is required to invoke the function.
        public let requireConfirmation: RequireConfirmation?

        @inlinable
        public init(description: String? = nil, name: String, parameters: [String: ParameterDetail]? = nil, requireConfirmation: RequireConfirmation? = nil) {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.requireConfirmation = requireConfirmation
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
            case requireConfirmation = "requireConfirmation"
        }
    }

    public struct GetAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group for which to get information.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String

        @inlinable
        public init(actionGroupId: String, agentId: String, agentVersion: String) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct GetAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias for which to get information.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias to get information belongs.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentAliasResponse: AWSDecodableShape {
        /// Contains information about the alias.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct GetAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The unique identifier of the knowledge base associated with the agent.
        public let knowledgeBaseId: String

        @inlinable
        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about a knowledge base attached to an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct GetAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentResponse: AWSDecodableShape {
        /// Contains details about the agent.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct GetAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String

        @inlinable
        public init(agentId: String, agentVersion: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentVersionResponse: AWSDecodableShape {
        /// Contains details about the version of the agent.
        public let agentVersion: AgentVersion

        @inlinable
        public init(agentVersion: AgentVersion) {
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base that the data source was added to.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias for which to retrieve information.
        public let aliasIdentifier: String
        /// The unique identifier of the flow that the alias belongs to.
        public let flowIdentifier: String

        @inlinable
        public init(aliasIdentifier: String, flowIdentifier: String) {
            self.aliasIdentifier = aliasIdentifier
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the flow.
        public let description: String?
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the alias of the flow.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String

        @inlinable
        public init(flowIdentifier: String) {
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The definition of the nodes and connections between the nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow.  For more information, see Create a service row for flows in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. The following statuses are possible:   NotPrepared – The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a PrepareFlow request to package the latest changes into the DRAFT version.   Preparing – The flow is being prepared so that the DRAFT version contains the latest changes for testing.   Prepared – The flow is prepared and the DRAFT version contains the latest changes for testing.   Failed – The last API operation that you invoked on the flow failed. Send a GetFlow request and check the error message in the validations field.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of validation error messages related to the last failed operation on the flow.
        public let validations: [FlowValidation]?
        /// The version of the flow for which information was retrieved.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, validations: [FlowValidation]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.validations = validations
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case validations = "validations"
            case version = "version"
        }
    }

    public struct GetFlowVersionRequest: AWSEncodableShape {
        /// The unique identifier of the flow for which to get information.
        public let flowIdentifier: String
        /// The version of the flow for which to get information.
        public let flowVersion: String

        @inlinable
        public init(flowIdentifier: String, flowVersion: String) {
            self.flowIdentifier = flowIdentifier
            self.flowVersion = flowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodePath(self.flowVersion, key: "flowVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the version of the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the version.
        public let name: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow for which information was retrieved.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case version = "version"
        }
    }

    public struct GetIngestionJobRequest: AWSEncodableShape {
        /// The unique identifier of the data source in the ingestion job.
        public let dataSourceId: String
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base for which the ingestion job applies.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, ingestionJobId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.ingestionJobId, key: "ingestionJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.ingestionJobId, name: "ingestionJobId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIngestionJobResponse: AWSDecodableShape {
        /// Contains details about the ingestion job.
        public let ingestionJob: IngestionJob

        @inlinable
        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base for which to get information.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct GetPromptRequest: AWSEncodableShape {
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// The version of the prompt about which you want to retrieve information. Omit this field to return information about the working draft of the prompt.
        public let promptVersion: String?

        @inlinable
        public init(promptIdentifier: String, promptVersion: String? = nil) {
            self.promptIdentifier = promptIdentifier
            self.promptVersion = promptVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            request.encodeQuery(self.promptVersion, key: "promptVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, max: 5)
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, min: 1)
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the prompt is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// The descriptino of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the guardrail.
        public let guardrailIdentifier: String?
        /// The version of the guardrail.
        public let guardrailVersion: String?

        @inlinable
        public init(guardrailIdentifier: String? = nil, guardrailVersion: String? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([0-9]{1,8})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailIdentifier = "guardrailIdentifier"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct HierarchicalChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Token settings for each layer.
        public let levelConfigurations: [HierarchicalChunkingLevelConfiguration]
        /// The number of tokens to repeat across chunks in the same layer.
        public let overlapTokens: Int

        @inlinable
        public init(levelConfigurations: [HierarchicalChunkingLevelConfiguration], overlapTokens: Int) {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, max: 2)
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case levelConfigurations = "levelConfigurations"
            case overlapTokens = "overlapTokens"
        }
    }

    public struct HierarchicalChunkingLevelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens that a chunk can contain in this layer.
        public let maxTokens: Int

        @inlinable
        public init(maxTokens: Int) {
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to allow in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        @inlinable
        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, max: 4096)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topK, name: "topK", parent: name, max: 500)
            try self.validate(self.topK, name: "topK", parent: name, min: 0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct IngestionJob: AWSDecodableShape {
        /// The unique identifier of the ingested data source.
        public let dataSourceId: String
        /// The description of the ingestion job.
        public let description: String?
        /// A list of reasons that the ingestion job failed.
        public let failureReasons: [String]?
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base to which the data source is being added.
        public let knowledgeBaseId: String
        /// The time at which the ingestion job started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics about the ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the ingestion job.
        public let status: IngestionJobStatus
        /// The time at which the ingestion job was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, failureReasons: [String]? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case failureReasons = "failureReasons"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct IngestionJobFilter: AWSEncodableShape {
        /// The attribute by which to filter the results.
        public let attribute: IngestionJobFilterAttribute
        /// The operation to carry out between the attribute and the values.
        public let `operator`: IngestionJobFilterOperator
        /// A list of values for the attribute.
        public let values: [String]

        @inlinable
        public init(attribute: IngestionJobFilterAttribute, operator: IngestionJobFilterOperator, values: [String]) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct IngestionJobSortBy: AWSEncodableShape {
        /// The attribute by which to sort the results.
        public let attribute: IngestionJobSortByAttribute
        /// The order by which to sort the results.
        public let order: SortOrder

        @inlinable
        public init(attribute: IngestionJobSortByAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct IngestionJobStatistics: AWSDecodableShape {
        /// The number of source documents that was deleted.
        public let numberOfDocumentsDeleted: Int64?
        /// The number of source documents that failed to be ingested.
        public let numberOfDocumentsFailed: Int64?
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public let numberOfDocumentsScanned: Int64?
        /// The number of metadata files that were updated or deleted.
        public let numberOfMetadataDocumentsModified: Int64?
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public let numberOfMetadataDocumentsScanned: Int64?
        /// The number of modified source documents in the data source that were successfully indexed.
        public let numberOfModifiedDocumentsIndexed: Int64?
        /// The number of new source documents in the data source that were successfully indexed.
        public let numberOfNewDocumentsIndexed: Int64?

        @inlinable
        public init(numberOfDocumentsDeleted: Int64? = nil, numberOfDocumentsFailed: Int64? = nil, numberOfDocumentsScanned: Int64? = nil, numberOfMetadataDocumentsModified: Int64? = nil, numberOfMetadataDocumentsScanned: Int64? = nil, numberOfModifiedDocumentsIndexed: Int64? = nil, numberOfNewDocumentsIndexed: Int64? = nil) {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDocumentsDeleted = "numberOfDocumentsDeleted"
            case numberOfDocumentsFailed = "numberOfDocumentsFailed"
            case numberOfDocumentsScanned = "numberOfDocumentsScanned"
            case numberOfMetadataDocumentsModified = "numberOfMetadataDocumentsModified"
            case numberOfMetadataDocumentsScanned = "numberOfMetadataDocumentsScanned"
            case numberOfModifiedDocumentsIndexed = "numberOfModifiedDocumentsIndexed"
            case numberOfNewDocumentsIndexed = "numberOfNewDocumentsIndexed"
        }
    }

    public struct IngestionJobSummary: AWSDecodableShape {
        /// The unique identifier of the data source in the ingestion job.
        public let dataSourceId: String
        /// The description of the ingestion job.
        public let description: String?
        /// The unique identifier of the ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base to which the data source is added.
        public let knowledgeBaseId: String
        /// The time at which the ingestion job was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics for the ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the ingestion job.
        public let status: IngestionJobStatus
        /// The time at which the ingestion job was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct InputFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct IntermediateStorage: AWSEncodableShape & AWSDecodableShape {
        /// An S3 bucket path.
        public let s3Location: S3Location

        @inlinable
        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct IteratorFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct KnowledgeBase: AWSDecodableShape {
        /// The time at which the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the knowledge base.
        public let description: String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public let failureReasons: [String]?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// Contains details about the embeddings configuration of the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// The status of the knowledge base. The following statuses are possible:   CREATING – The knowledge base is being created.   ACTIVE – The knowledge base is ready to be queried.   DELETING – The knowledge base is being deleted.   UPDATING – The knowledge base is being updated.   FAILED – The knowledge base API operation failed.
        public let status: KnowledgeBaseStatus
        /// Contains details about the storage configuration of the knowledge base.
        public let storageConfiguration: StorageConfiguration
        /// The time at which the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, failureReasons: [String]? = nil, knowledgeBaseArn: String, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, status: KnowledgeBaseStatus, storageConfiguration: StorageConfiguration, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case failureReasons = "failureReasons"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case storageConfiguration = "storageConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct KnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of data that the data source is converted into for the knowledge base.
        public let type: KnowledgeBaseType
        /// Contains details about the embeddings model that'sused to convert the data source.
        public let vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration?

        @inlinable
        public init(type: KnowledgeBaseType, vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration? = nil) {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorKnowledgeBaseConfiguration?.validate(name: "\(name).vectorKnowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case vectorKnowledgeBaseConfiguration = "vectorKnowledgeBaseConfiguration"
        }
    }

    public struct KnowledgeBaseFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the knowledge base to query.
        public let knowledgeBaseId: String
        /// The unique identifier of the model to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.
        public let modelId: String?

        @inlinable
        public init(knowledgeBaseId: String, modelId: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case modelId = "modelId"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The time at which the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(description: String? = nil, knowledgeBaseId: String, name: String, status: KnowledgeBaseStatus, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct LambdaFunctionFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function to invoke.
        public let lambdaArn: String

        @inlinable
        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
        }
    }

    public struct LexFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        public let botAliasArn: String
        /// The Region to invoke the Amazon Lex bot in.
        public let localeId: String

        @inlinable
        public init(botAliasArn: String, localeId: String) {
            self.botAliasArn = botAliasArn
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasArn, name: "botAliasArn", parent: name, max: 78)
            try self.validate(self.botAliasArn, name: "botAliasArn", parent: name, pattern: "^arn:aws(|-us-gov):lex:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:bot-alias/[0-9a-zA-Z]+/[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, max: 10)
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasArn = "botAliasArn"
            case localeId = "localeId"
        }
    }

    public struct ListAgentActionGroupsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentActionGroupsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an action group.
        public let actionGroupSummaries: [ActionGroupSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(actionGroupSummaries: [ActionGroupSummary], nextToken: String? = nil) {
            self.actionGroupSummaries = actionGroupSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupSummaries = "actionGroupSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an alias of the agent.
        public let agentAliasSummaries: [AgentAliasSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentAliasSummaries: [AgentAliasSummary], nextToken: String? = nil) {
            self.agentAliasSummaries = agentAliasSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasSummaries = "agentAliasSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
        public let agentId: String
        /// The version of the agent for which to return information about knowledge bases associated with it.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a knowledge base associated with the agent.
        public let agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary], nextToken: String? = nil) {
            self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBaseSummaries = "agentKnowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a version of the agent.
        public let agentVersionSummaries: [AgentVersionSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentVersionSummaries: [AgentVersionSummary], nextToken: String? = nil) {
            self.agentVersionSummaries = agentVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersionSummaries = "agentVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an agent.
        public let agentSummaries: [AgentSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentSummaries: [AgentSummary], nextToken: String? = nil) {
            self.agentSummaries = agentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentSummaries = "agentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base for which to return a list of information.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a data source.
        public let dataSourceSummaries: [DataSourceSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(dataSourceSummaries: [DataSourceSummary], nextToken: String? = nil) {
            self.dataSourceSummaries = dataSourceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSummaries = "dataSourceSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowAliasesRequest: AWSEncodableShape {
        /// The unique identifier of the flow for which aliases are being returned.
        public let flowIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowIdentifier = flowIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowAliasesResponse: AWSDecodableShape {
        /// A list, each member of which contains information about an alias.
        public let flowAliasSummaries: [FlowAliasSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowAliasSummaries: [FlowAliasSummary], nextToken: String? = nil) {
            self.flowAliasSummaries = flowAliasSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowAliasSummaries = "flowAliasSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowIdentifier = flowIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowVersionsResponse: AWSDecodableShape {
        /// A list, each member of which contains information about a flow.
        public let flowVersionSummaries: [FlowVersionSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowVersionSummaries: [FlowVersionSummary], nextToken: String? = nil) {
            self.flowVersionSummaries = flowVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowVersionSummaries = "flowVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowsResponse: AWSDecodableShape {
        /// A list, each member of which contains information about a flow.
        public let flowSummaries: [FlowSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowSummaries: [FlowSummary], nextToken: String? = nil) {
            self.flowSummaries = flowSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowSummaries = "flowSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestionJobsRequest: AWSEncodableShape {
        /// The unique identifier of the data source for which to return ingestion jobs.
        public let dataSourceId: String
        /// Contains a definition of a filter for which to filter the results.
        public let filters: [IngestionJobFilter]?
        /// The unique identifier of the knowledge base for which to return ingestion jobs.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// Contains details about how to sort the results.
        public let sortBy: IngestionJobSortBy?

        @inlinable
        public init(dataSourceId: String, filters: [IngestionJobFilter]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: IngestionJobSortBy? = nil) {
            self.dataSourceId = dataSourceId
            self.filters = filters
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListIngestionJobsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an ingestion job.
        public let ingestionJobSummaries: [IngestionJobSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(ingestionJobSummaries: [IngestionJobSummary], nextToken: String? = nil) {
            self.ingestionJobSummaries = ingestionJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJobSummaries = "ingestionJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a knowledge base.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPromptsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The unique identifier of the prompt for whose versions you want to return information. Omit this field to list information about all prompts in an account.
        public let promptIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, promptIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.promptIdentifier = promptIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.promptIdentifier, key: "promptIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPromptsResponse: AWSDecodableShape {
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?
        /// A list, each member of which contains information about a prompt using Prompt management.
        public let promptSummaries: [PromptSummary]

        @inlinable
        public init(nextToken: String? = nil, promptSummaries: [PromptSummary]) {
            self.nextToken = nextToken
            self.promptSummaries = promptSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case promptSummaries = "promptSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pairs for the tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MemoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of memory that is stored.
        public let enabledMemoryTypes: [MemoryType]
        /// The number of days the agent is configured to retain the conversational context.
        public let storageDays: Int?

        @inlinable
        public init(enabledMemoryTypes: [MemoryType], storageDays: Int? = nil) {
            self.enabledMemoryTypes = enabledMemoryTypes
            self.storageDays = storageDays
        }

        public func validate(name: String) throws {
            try self.validate(self.enabledMemoryTypes, name: "enabledMemoryTypes", parent: name, max: 1)
            try self.validate(self.enabledMemoryTypes, name: "enabledMemoryTypes", parent: name, min: 1)
            try self.validate(self.storageDays, name: "storageDays", parent: name, max: 30)
            try self.validate(self.storageDays, name: "storageDays", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabledMemoryTypes = "enabledMemoryTypes"
            case storageDays = "storageDays"
        }
    }

    public struct MongoDbAtlasConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The collection name of the knowledge base in MongoDB Atlas.
        public let collectionName: String
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
        public let credentialsSecretArn: String
        /// The database name in your MongoDB Atlas cluster for your knowledge base.
        public let databaseName: String
        /// The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
        public let endpoint: String
        /// The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
        public let endpointServiceName: String?
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: MongoDbAtlasFieldMapping
        /// The name of the MongoDB Atlas vector search index.
        public let vectorIndexName: String

        @inlinable
        public init(collectionName: String, credentialsSecretArn: String, databaseName: String, endpoint: String, endpointServiceName: String? = nil, fieldMapping: MongoDbAtlasFieldMapping, vectorIndexName: String) {
            self.collectionName = collectionName
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.endpoint = endpoint
            self.endpointServiceName = endpointServiceName
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 63)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^.*$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^.*$")
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 2048)
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^.*$")
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, max: 255)
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, min: 1)
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, pattern: "^(?:arn:aws(?:-us-gov|-cn|-iso|-iso-[a-z])*:.+:.*:\\d+:.+/.+$|[a-zA-Z0-9*]+[a-zA-Z0-9._-]*)$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "collectionName"
            case credentialsSecretArn = "credentialsSecretArn"
            case databaseName = "databaseName"
            case endpoint = "endpoint"
            case endpointServiceName = "endpointServiceName"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct MongoDbAtlasFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct OpenSearchServerlessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
        public let collectionArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: OpenSearchServerlessFieldMapping
        /// The name of the vector store.
        public let vectorIndexName: String

        @inlinable
        public init(collectionArn: String, fieldMapping: OpenSearchServerlessFieldMapping, vectorIndexName: String) {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, max: 2048)
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, pattern: "^arn:aws:aoss:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:collection/[a-z0-9-]{3,32}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "collectionArn"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct OpenSearchServerlessFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct OutputFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct ParameterDetail: AWSEncodableShape & AWSDecodableShape {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public let description: String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public let required: Bool?
        /// The data type of the parameter.
        public let type: `Type`

        @inlinable
        public init(description: String? = nil, required: Bool? = nil, type: `Type`) {
            self.description = description
            self.required = required
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case required = "required"
            case type = "type"
        }
    }

    public struct ParsingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Settings for a foundation model used to parse documents for a data source.
        public let bedrockFoundationModelConfiguration: BedrockFoundationModelConfiguration?
        /// The parsing strategy for the data source.
        public let parsingStrategy: ParsingStrategy

        @inlinable
        public init(bedrockFoundationModelConfiguration: BedrockFoundationModelConfiguration? = nil, parsingStrategy: ParsingStrategy) {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }

        public func validate(name: String) throws {
            try self.bedrockFoundationModelConfiguration?.validate(name: "\(name).bedrockFoundationModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockFoundationModelConfiguration = "bedrockFoundationModelConfiguration"
            case parsingStrategy = "parsingStrategy"
        }
    }

    public struct ParsingPrompt: AWSEncodableShape & AWSDecodableShape {
        /// Instructions for interpreting the contents of a document.
        public let parsingPromptText: String

        @inlinable
        public init(parsingPromptText: String) {
            self.parsingPromptText = parsingPromptText
        }

        public func validate(name: String) throws {
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, max: 10000)
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parsingPromptText = "parsingPromptText"
        }
    }

    public struct PatternObjectFilter: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more exclusion regular expression patterns to exclude certain  object types that adhere to the pattern. If you specify an inclusion and exclusion  filter/pattern and both match a document, the exclusion filter takes precedence  and the document isn’t crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include certain  object types that adhere to the pattern. If you specify an inclusion and exclusion  filter/pattern and both match a document, the exclusion filter takes precedence  and the document isn’t crawled.
        public let inclusionFilters: [String]?
        /// The supported object type or content type of the data source.
        public let objectType: String

        @inlinable
        public init(exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, objectType: String) {
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.objectType = objectType
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
            try self.validate(self.objectType, name: "objectType", parent: name, max: 50)
            try self.validate(self.objectType, name: "objectType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case objectType = "objectType"
        }
    }

    public struct PatternObjectFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of specific filters applied to your data source content. You can  filter out or include certain content.
        public let filters: [PatternObjectFilter]

        @inlinable
        public init(filters: [PatternObjectFilter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct PineconeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint URL for your index management page.
        public let connectionString: String
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        public let credentialsSecretArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: PineconeFieldMapping
        /// The namespace to be used to write new data to your database.
        public let namespace: String?

        @inlinable
        public init(connectionString: String, credentialsSecretArn: String, fieldMapping: PineconeFieldMapping, namespace: String? = nil) {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionString, name: "connectionString", parent: name, max: 2048)
            try self.validate(self.connectionString, name: "connectionString", parent: name, pattern: "^.*$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 2048)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionString = "connectionString"
            case credentialsSecretArn = "credentialsSecretArn"
            case fieldMapping = "fieldMapping"
            case namespace = "namespace"
        }
    }

    public struct PineconeFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String

        @inlinable
        public init(metadataField: String, textField: String) {
            self.metadataField = metadataField
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
        }
    }

    public struct PrepareAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to create a DRAFT version.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PrepareAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent for which the DRAFT version was created.
        public let agentId: String
        /// The status of the DRAFT version and whether it is ready for use.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the DRAFT version of the agent was last prepared.
        @CustomCoding<ISO8601DateCoder>
        public var preparedAt: Date

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String, preparedAt: Date) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.preparedAt = preparedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case preparedAt = "preparedAt"
        }
    }

    public struct PrepareFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String

        @inlinable
        public init(flowIdentifier: String) {
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PrepareFlowResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If preparation succeeds, the status becomes Prepared. If it fails, the status becomes FAILED.
        public let status: FlowStatus

        @inlinable
        public init(id: String, status: FlowStatus) {
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case status = "status"
        }
    }

    public struct PromptConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see Prompt template placeholder variables. For more information, see Configure the prompt templates.
        public let basePromptTemplate: String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDEN, the overrideLambda field in the PromptOverrideConfiguration must be specified with the ARN of a Lambda function.
        public let parserMode: CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public let promptCreationMode: CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.    PRE_PROCESSING – ENABLED     ORCHESTRATION – ENABLED     KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED     POST_PROCESSING – DISABLED
        public let promptState: PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public let promptType: PromptType?

        @inlinable
        public init(basePromptTemplate: String? = nil, inferenceConfiguration: InferenceConfiguration? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, promptState: PromptState? = nil, promptType: PromptType? = nil) {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }

        public func validate(name: String) throws {
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, max: 100000)
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, min: 1)
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case basePromptTemplate = "basePromptTemplate"
            case inferenceConfiguration = "inferenceConfiguration"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case promptState = "promptState"
            case promptType = "promptType"
        }
    }

    public struct PromptFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the prompt is from Prompt management or defined inline.
        public let sourceConfiguration: PromptFlowNodeSourceConfiguration

        @inlinable
        public init(sourceConfiguration: PromptFlowNodeSourceConfiguration) {
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct PromptFlowNodeInlineConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains inference configurations for the prompt.
        public let inferenceConfiguration: PromptInferenceConfiguration?
        /// The unique identifier of the model to run inference with.
        public let modelId: String
        /// Contains a prompt and variables in the prompt that can be replaced with values at runtime.
        public let templateConfiguration: PromptTemplateConfiguration
        /// The type of prompt template.
        public let templateType: PromptTemplateType

        @inlinable
        public init(inferenceConfiguration: PromptInferenceConfiguration? = nil, modelId: String, templateConfiguration: PromptTemplateConfiguration, templateType: PromptTemplateType) {
            self.inferenceConfiguration = inferenceConfiguration
            self.modelId = modelId
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.templateConfiguration.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceConfiguration = "inferenceConfiguration"
            case modelId = "modelId"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
        }
    }

    public struct PromptFlowNodeResourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt from Prompt management.
        public let promptArn: String

        @inlinable
        public init(promptArn: String) {
            self.promptArn = promptArn
        }

        public func validate(name: String) throws {
            try self.validate(self.promptArn, name: "promptArn", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case promptArn = "promptArn"
        }
    }

    public struct PromptInputVariable: AWSEncodableShape & AWSDecodableShape {
        /// The name of the variable.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct PromptMetadataEntry: AWSEncodableShape & AWSDecodableShape {
        /// The key of a metadata tag for a prompt variant.
        public let key: String
        /// The value of a metadata tag for a prompt variant.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct PromptModelInferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to return in the response.
        public let maxTokens: Int?
        /// A list of strings that define sequences after which the model will stop generating.
        public let stopSequences: [String]?
        /// Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        public let temperature: Float?
        /// The number of most-likely candidates that the model considers for the next token during generation.
        public let topK: Int?
        /// The percentage of most-likely candidates that the model considers for the next token.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, max: 4096)
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topK, name: "topK", parent: name, max: 500)
            try self.validate(self.topK, name: "topK", parent: name, min: 0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct PromptOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN. For more information, see Parser Lambda function in Agents for Amazon Bedrock.
        public let overrideLambda: String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see Advanced prompts.
        public let promptConfigurations: [PromptConfiguration]

        @inlinable
        public init(overrideLambda: String? = nil, promptConfigurations: [PromptConfiguration]) {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, max: 2048)
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.promptConfigurations.forEach {
                try $0.validate(name: "\(name).promptConfigurations[]")
            }
            try self.validate(self.promptConfigurations, name: "promptConfigurations", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case overrideLambda = "overrideLambda"
            case promptConfigurations = "promptConfigurations"
        }
    }

    public struct PromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the prompt that this summary applies to.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, id: String, name: String, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct PromptVariant: AWSEncodableShape & AWSDecodableShape {
        /// Contains inference configurations for the prompt variant.
        public let inferenceConfiguration: PromptInferenceConfiguration?
        /// An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. For more information, see Create a prompt using Prompt management.
        public let metadata: [PromptMetadataEntry]?
        /// The unique identifier of the model with which to run inference on the prompt.
        public let modelId: String?
        /// The name of the prompt variant.
        public let name: String
        /// Contains configurations for the prompt template.
        public let templateConfiguration: PromptTemplateConfiguration?
        /// The type of prompt template to use.
        public let templateType: PromptTemplateType

        @inlinable
        public init(inferenceConfiguration: PromptInferenceConfiguration? = nil, metadata: [PromptMetadataEntry]? = nil, modelId: String? = nil, name: String, templateConfiguration: PromptTemplateConfiguration? = nil, templateType: PromptTemplateType) {
            self.inferenceConfiguration = inferenceConfiguration
            self.metadata = metadata
            self.modelId = modelId
            self.name = name
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 50)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.templateConfiguration?.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceConfiguration = "inferenceConfiguration"
            case metadata = "metadata"
            case modelId = "modelId"
            case name = "name"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
        }
    }

    public struct RdsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        public let credentialsSecretArn: String
        /// The name of your Amazon RDS database.
        public let databaseName: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RdsFieldMapping
        /// The Amazon Resource Name (ARN) of the vector store.
        public let resourceArn: String
        /// The name of the table in the database.
        public let tableName: String

        @inlinable
        public init(credentialsSecretArn: String, databaseName: String, fieldMapping: RdsFieldMapping, resourceArn: String, tableName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):rds:[a-zA-Z0-9-]*:[0-9]{12}:cluster:[a-zA-Z0-9-]{1,63}$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 63)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_\\.\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case databaseName = "databaseName"
            case fieldMapping = "fieldMapping"
            case resourceArn = "resourceArn"
            case tableName = "tableName"
        }
    }

    public struct RdsFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        public let primaryKeyField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, primaryKeyField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 63)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, max: 63)
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.textField, name: "textField", parent: name, max: 63)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 63)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case primaryKeyField = "primaryKeyField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct RedisEnterpriseCloudConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        public let credentialsSecretArn: String
        /// The endpoint URL of the Redis Enterprise Cloud database.
        public let endpoint: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RedisEnterpriseCloudFieldMapping
        /// The name of the vector index.
        public let vectorIndexName: String

        @inlinable
        public init(credentialsSecretArn: String, endpoint: String, fieldMapping: RedisEnterpriseCloudFieldMapping, vectorIndexName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 2048)
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^.*$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case endpoint = "endpoint"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct RedisEnterpriseCloudFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct RetrievalFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the service to use for retrieving data to return as the output from the node.
        public let serviceConfiguration: RetrievalFlowNodeServiceConfiguration

        @inlinable
        public init(serviceConfiguration: RetrievalFlowNodeServiceConfiguration) {
            self.serviceConfiguration = serviceConfiguration
        }

        public func validate(name: String) throws {
            try self.serviceConfiguration.validate(name: "\(name).serviceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceConfiguration = "serviceConfiguration"
        }
    }

    public struct RetrievalFlowNodeS3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket from which to retrieve data.
        public let bucketName: String

        @inlinable
        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct S3DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket that contains your data.
        public let bucketArn: String
        /// The account ID for the owner of the S3 bucket.
        public let bucketOwnerAccountId: String?
        /// A list of S3 prefixes to include certain files or content. For more information,  see Organizing objects using prefixes.
        public let inclusionPrefixes: [String]?

        @inlinable
        public init(bucketArn: String, bucketOwnerAccountId: String? = nil, inclusionPrefixes: [String]? = nil) {
            self.bucketArn = bucketArn
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.inclusionPrefixes = inclusionPrefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 2048)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, min: 1)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):s3:::[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$")
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, max: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, min: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.inclusionPrefixes?.forEach {
                try validate($0, name: "inclusionPrefixes[]", parent: name, max: 300)
                try validate($0, name: "inclusionPrefixes[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, max: 1)
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case inclusionPrefixes = "inclusionPrefixes"
        }
    }

    public struct S3Identifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket.
        public let s3BucketName: String?
        /// The S3 object key for the S3 resource.
        public let s3ObjectKey: String?

        @inlinable
        public init(s3BucketName: String? = nil, s3ObjectKey: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, max: 1024)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, min: 1)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The location's URI. For example, s3://my-bucket/chunk-processor/.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 2048)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://.{1,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct SalesforceCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the Salesforce content. For example,  configuring regular expression patterns to include or exclude certain  content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct SalesforceDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Salesforce content. For example, configuring  specific types of Salesforce content.
        public let crawlerConfiguration: SalesforceCrawlerConfiguration?
        /// The endpoint information to connect to your Salesforce data source.
        public let sourceConfiguration: SalesforceSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: SalesforceCrawlerConfiguration? = nil, sourceConfiguration: SalesforceSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct SalesforceSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect to your  Salesforce instance.
        public let authType: SalesforceAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your Salesforce instance URL.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  Salesforce connection configuration.
        public let credentialsSecretArn: String
        /// The Salesforce host URL or instance URL.
        public let hostUrl: String

        @inlinable
        public init(authType: SalesforceAuthType, credentialsSecretArn: String, hostUrl: String) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostUrl = hostUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.hostUrl, name: "hostUrl", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case hostUrl = "hostUrl"
        }
    }

    public struct SeedUrl: AWSEncodableShape & AWSDecodableShape {
        /// A seed or starting point URL.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.url, name: "url", parent: name, pattern: "^https?://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct SemanticChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dissimilarity threshold for splitting chunks.
        public let breakpointPercentileThreshold: Int
        /// The buffer size.
        public let bufferSize: Int
        /// The maximum number of tokens that a chunk can contain.
        public let maxTokens: Int

        @inlinable
        public init(breakpointPercentileThreshold: Int, bufferSize: Int, maxTokens: Int) {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case breakpointPercentileThreshold = "breakpointPercentileThreshold"
            case bufferSize = "bufferSize"
            case maxTokens = "maxTokens"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the resource.
        public let kmsKeyArn: String?

        @inlinable
        public init(kmsKeyArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct SharePointCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the SharePoint content. For example,  configuring regular expression patterns to include or exclude certain content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct SharePointDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the SharePoint content. For example, configuring  specific types of SharePoint content.
        public let crawlerConfiguration: SharePointCrawlerConfiguration?
        /// The endpoint information to connect to your SharePoint data source.
        public let sourceConfiguration: SharePointSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: SharePointCrawlerConfiguration? = nil, sourceConfiguration: SharePointSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct SharePointSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect  to your SharePoint site/sites.
        public let authType: SharePointAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your SharePoint site/sites.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  SharePoint connection configuration.
        public let credentialsSecretArn: String
        /// The domain of your SharePoint instance or site URL/URLs.
        public let domain: String
        /// The supported host type, whether online/cloud or server/on-premises.
        public let hostType: SharePointHostType
        /// A list of one or more SharePoint site URLs.
        public let siteUrls: [String]
        /// The identifier of your Microsoft 365 tenant.
        public let tenantId: String?

        @inlinable
        public init(authType: SharePointAuthType, credentialsSecretArn: String, domain: String, hostType: SharePointHostType, siteUrls: [String], tenantId: String? = nil) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.domain = domain
            self.hostType = hostType
            self.siteUrls = siteUrls
            self.tenantId = tenantId
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
            try self.siteUrls.forEach {
                try validate($0, name: "siteUrls[]", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
            }
            try self.validate(self.siteUrls, name: "siteUrls", parent: name, max: 100)
            try self.validate(self.siteUrls, name: "siteUrls", parent: name, min: 1)
            try self.validate(self.tenantId, name: "tenantId", parent: name, max: 36)
            try self.validate(self.tenantId, name: "tenantId", parent: name, min: 36)
            try self.validate(self.tenantId, name: "tenantId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case domain = "domain"
            case hostType = "hostType"
            case siteUrls = "siteUrls"
            case tenantId = "tenantId"
        }
    }

    public struct StartIngestionJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The unique identifier of the data source to ingest.
        public let dataSourceId: String
        /// A description of the ingestion job.
        public let description: String?
        /// The unique identifier of the knowledge base to which to add the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(clientToken: String? = StartIngestionJobRequest.idempotencyToken(), dataSourceId: String, description: String? = nil, knowledgeBaseId: String) {
            self.clientToken = clientToken
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct StartIngestionJobResponse: AWSDecodableShape {
        /// An object containing information about the ingestion job.
        public let ingestionJob: IngestionJob

        @inlinable
        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct StorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the storage configuration of the knowledge base in MongoDB Atlas.
        public let mongoDbAtlasConfiguration: MongoDbAtlasConfiguration?
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public let opensearchServerlessConfiguration: OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public let pineconeConfiguration: PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        public let rdsConfiguration: RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public let redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        public let type: KnowledgeBaseStorageType

        @inlinable
        public init(mongoDbAtlasConfiguration: MongoDbAtlasConfiguration? = nil, opensearchServerlessConfiguration: OpenSearchServerlessConfiguration? = nil, pineconeConfiguration: PineconeConfiguration? = nil, rdsConfiguration: RdsConfiguration? = nil, redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration? = nil, type: KnowledgeBaseStorageType) {
            self.mongoDbAtlasConfiguration = mongoDbAtlasConfiguration
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.mongoDbAtlasConfiguration?.validate(name: "\(name).mongoDbAtlasConfiguration")
            try self.opensearchServerlessConfiguration?.validate(name: "\(name).opensearchServerlessConfiguration")
            try self.pineconeConfiguration?.validate(name: "\(name).pineconeConfiguration")
            try self.rdsConfiguration?.validate(name: "\(name).rdsConfiguration")
            try self.redisEnterpriseCloudConfiguration?.validate(name: "\(name).redisEnterpriseCloudConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case mongoDbAtlasConfiguration = "mongoDbAtlasConfiguration"
            case opensearchServerlessConfiguration = "opensearchServerlessConfiguration"
            case pineconeConfiguration = "pineconeConfiguration"
            case rdsConfiguration = "rdsConfiguration"
            case redisEnterpriseCloudConfiguration = "redisEnterpriseCloudConfiguration"
            case type = "type"
        }
    }

    public struct StorageFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the service to use for storing the input into the node.
        public let serviceConfiguration: StorageFlowNodeServiceConfiguration

        @inlinable
        public init(serviceConfiguration: StorageFlowNodeServiceConfiguration) {
            self.serviceConfiguration = serviceConfiguration
        }

        public func validate(name: String) throws {
            try self.serviceConfiguration.validate(name: "\(name).serviceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceConfiguration = "serviceConfiguration"
        }
    }

    public struct StorageFlowNodeS3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket in which to store the input into the node.
        public let bucketName: String

        @inlinable
        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// An object containing key-value pairs that define the tags to attach to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextPromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of the variables in the prompt template.
        public let inputVariables: [PromptInputVariable]?
        /// The message for the prompt.
        public let text: String

        @inlinable
        public init(inputVariables: [PromptInputVariable]? = nil, text: String) {
            self.inputVariables = inputVariables
            self.text = text
        }

        public func validate(name: String) throws {
            try self.inputVariables?.forEach {
                try $0.validate(name: "\(name).inputVariables[]")
            }
            try self.validate(self.inputVariables, name: "inputVariables", parent: name, max: 5)
            try self.validate(self.text, name: "text", parent: name, max: 200000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inputVariables = "inputVariables"
            case text = "text"
        }
    }

    public struct Transformation: AWSEncodableShape & AWSDecodableShape {
        /// When the service applies the transformation.
        public let stepToApply: StepType
        /// A Lambda function that processes documents.
        public let transformationFunction: TransformationFunction

        @inlinable
        public init(stepToApply: StepType, transformationFunction: TransformationFunction) {
            self.stepToApply = stepToApply
            self.transformationFunction = transformationFunction
        }

        public func validate(name: String) throws {
            try self.transformationFunction.validate(name: "\(name).transformationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case stepToApply = "stepToApply"
            case transformationFunction = "transformationFunction"
        }
    }

    public struct TransformationFunction: AWSEncodableShape & AWSDecodableShape {
        /// The Lambda function.
        public let transformationLambdaConfiguration: TransformationLambdaConfiguration

        @inlinable
        public init(transformationLambdaConfiguration: TransformationLambdaConfiguration) {
            self.transformationLambdaConfiguration = transformationLambdaConfiguration
        }

        public func validate(name: String) throws {
            try self.transformationLambdaConfiguration.validate(name: "\(name).transformationLambdaConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case transformationLambdaConfiguration = "transformationLambdaConfiguration"
        }
    }

    public struct TransformationLambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The function's ARN identifier.
        public let lambdaArn: String

        @inlinable
        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
        public let resourceArn: String
        /// A list of keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentActionGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// Specifies a new name for the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to update the action group.
        public let agentId: String
        /// The unique identifier of the agent version for which to update the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// Specifies a new name for the action group.
        public let description: String?
        /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let functionSchema: FunctionSchema?
        /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignature: ActionGroupSignature? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.functionSchema, forKey: .functionSchema)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.functionSchema?.validate(name: "\(name).functionSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignature = "parentActionGroupSignature"
        }
    }

    public struct UpdateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was updated.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct UpdateAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias.
        public let agentAliasId: String
        /// Specifies a new name for the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new description for the alias.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?

        @inlinable
        public init(agentAliasId: String, agentAliasName: String, agentId: String, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.description = description
            self.routingConfiguration = routingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct UpdateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was updated.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct UpdateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent associated with the knowledge base that you want to update.
        public let agentId: String
        /// The version of the agent associated with the knowledge base that you want to update.
        public let agentVersion: String
        /// Specifies a new description for the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base that has been associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        @inlinable
        public init(agentId: String, agentVersion: String, description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct UpdateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct UpdateAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new name for the agent.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        /// Specifies a new description of the agent.
        public let description: String?
        /// Specifies a new foundation model to be used for orchestration by the agent.
        public let foundationModel: String?
        /// The unique Guardrail configuration assigned to the agent when it is updated.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Specifies the new memory configuration for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?

        @inlinable
        public init(agentId: String, agentName: String, agentResourceRoleArn: String, customerEncryptionKeyArn: String? = nil, description: String? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil) {
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.promptOverrideConfiguration = promptOverrideConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encode(self.agentName, forKey: .agentName)
            try container.encode(self.agentResourceRoleArn, forKey: .agentResourceRoleArn)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.foundationModel, forKey: .foundationModel)
            try container.encodeIfPresent(self.guardrailConfiguration, forKey: .guardrailConfiguration)
            try container.encodeIfPresent(self.idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
            try container.encodeIfPresent(self.instruction, forKey: .instruction)
            try container.encodeIfPresent(self.memoryConfiguration, forKey: .memoryConfiguration)
            try container.encodeIfPresent(self.promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 4000)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.memoryConfiguration?.validate(name: "\(name).memoryConfiguration")
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
        }
    }

    public struct UpdateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent that was updated.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// The data deletion policy for the data source that you want to update.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source that you want to update.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// Specifies a new description for the data source.
        public let description: String?
        /// The unique identifier of the knowledge base for the data source.
        public let knowledgeBaseId: String
        /// Specifies a new name for the data source.
        public let name: String
        /// Contains details about server-side encryption of the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataDeletionPolicy, forKey: .dataDeletionPolicy)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct UpdateFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias.
        public let aliasIdentifier: String
        /// A description for the alias.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version to which to map the alias.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]

        @inlinable
        public init(aliasIdentifier: String, description: String? = nil, flowIdentifier: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem]) {
            self.aliasIdentifier = aliasIdentifier
            self.description = description
            self.flowIdentifier = flowIdentifier
            self.name = name
            self.routingConfiguration = routingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.routingConfiguration, forKey: .routingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.routingConfiguration.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct UpdateFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the flow.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowId: String
        /// The unique identifier of the alias.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateFlowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and the connections between the nodes in the flow.
        public let definition: FlowDefinition?
        /// A description for the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// A name for the flow.
        public let name: String

        @inlinable
        public init(customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, flowIdentifier: String, name: String) {
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.flowIdentifier = flowIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.executionRoleArn, forKey: .executionRoleArn)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?.+$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
        }
    }

    public struct UpdateFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the flow was encrypted with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and the connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If updating fails, the status becomes Failed.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the flow. When you update a flow, the version updated is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct UpdateKnowledgeBaseRequest: AWSEncodableShape {
        /// Specifies a new description for the knowledge base.
        public let description: String?
        /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base to update.
        public let knowledgeBaseId: String
        /// Specifies a new name for the knowledge base.
        public let name: String
        /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let storageConfiguration: StorageConfiguration

        @inlinable
        public init(description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, storageConfiguration: StorageConfiguration) {
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.storageConfiguration, forKey: .storageConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration.validate(name: "\(name).storageConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct UpdateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct UpdatePromptRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the prompt.
        public let description: String?
        /// A name for the prompt.
        public let name: String
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?

        @inlinable
        public init(customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, name: String, promptIdentifier: String, variants: [PromptVariant]? = nil) {
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.name = name
            self.promptIdentifier = promptIdentifier
            self.variants = variants
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.defaultVariant, forKey: .defaultVariant)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            try container.encodeIfPresent(self.variants, forKey: .variants)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.defaultVariant, name: "defaultVariant", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.variants?.forEach {
                try $0.validate(name: "\(name).variants[]")
            }
            try self.validate(self.variants, name: "variants", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case name = "name"
            case variants = "variants"
        }
    }

    public struct UpdatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt. When you update a prompt, the version updated is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct UrlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// One or more seed or starting point URLs.
        public let seedUrls: [SeedUrl]?

        @inlinable
        public init(seedUrls: [SeedUrl]? = nil) {
            self.seedUrls = seedUrls
        }

        public func validate(name: String) throws {
            try self.seedUrls?.forEach {
                try $0.validate(name: "\(name).seedUrls[]")
            }
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, max: 100)
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case seedUrls = "seedUrls"
        }
    }

    public struct VectorIngestionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public let chunkingConfiguration: ChunkingConfiguration?
        /// A custom document transformer for parsed data source documents.
        public let customTransformationConfiguration: CustomTransformationConfiguration?
        /// A custom parser for data source documents.
        public let parsingConfiguration: ParsingConfiguration?

        @inlinable
        public init(chunkingConfiguration: ChunkingConfiguration? = nil, customTransformationConfiguration: CustomTransformationConfiguration? = nil, parsingConfiguration: ParsingConfiguration? = nil) {
            self.chunkingConfiguration = chunkingConfiguration
            self.customTransformationConfiguration = customTransformationConfiguration
            self.parsingConfiguration = parsingConfiguration
        }

        public func validate(name: String) throws {
            try self.chunkingConfiguration?.validate(name: "\(name).chunkingConfiguration")
            try self.customTransformationConfiguration?.validate(name: "\(name).customTransformationConfiguration")
            try self.parsingConfiguration?.validate(name: "\(name).parsingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingConfiguration = "chunkingConfiguration"
            case customTransformationConfiguration = "customTransformationConfiguration"
            case parsingConfiguration = "parsingConfiguration"
        }
    }

    public struct VectorKnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        public let embeddingModelArn: String
        /// The embeddings model configuration details for the vector model used in Knowledge Base.
        public let embeddingModelConfiguration: EmbeddingModelConfiguration?

        @inlinable
        public init(embeddingModelArn: String, embeddingModelConfiguration: EmbeddingModelConfiguration? = nil) {
            self.embeddingModelArn = embeddingModelArn
            self.embeddingModelConfiguration = embeddingModelConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, max: 2048)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, min: 20)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.embeddingModelConfiguration?.validate(name: "\(name).embeddingModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case embeddingModelArn = "embeddingModelArn"
            case embeddingModelConfiguration = "embeddingModelConfiguration"
        }
    }

    public struct WebCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of crawl limits for the web URLs.
        public let crawlerLimits: WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude  certain URLs. If you specify an inclusion and exclusion filter/pattern  and both match a URL, the exclusion filter takes precedence and the web  content of the URL isn’t crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include  certain URLs. If you specify an inclusion and exclusion filter/pattern  and both match a URL, the exclusion filter takes precedence and the web  content of the URL isn’t crawled.
        public let inclusionFilters: [String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary  domain. For example, only web pages that contain the seed URL  "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains.  You can choose to include sub domains in addition to the host or primary domain.  For example, web pages that contain "aws.amazon.com" can also include sub domain  "docs.aws.amazon.com".
        public let scope: WebScopeType?

        @inlinable
        public init(crawlerLimits: WebCrawlerLimits? = nil, exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, scope: WebScopeType? = nil) {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLimits = "crawlerLimits"
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case scope = "scope"
        }
    }

    public struct WebCrawlerLimits: AWSEncodableShape & AWSDecodableShape {
        /// The max rate at which pages are crawled, up to 300 per minute per host.
        public let rateLimit: Int?

        @inlinable
        public init(rateLimit: Int? = nil) {
            self.rateLimit = rateLimit
        }

        private enum CodingKeys: String, CodingKey {
            case rateLimit = "rateLimit"
        }
    }

    public struct WebDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Web Crawler configuration details for the web data source.
        public let crawlerConfiguration: WebCrawlerConfiguration?
        /// The source configuration details for the web data source.
        public let sourceConfiguration: WebSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: WebCrawlerConfiguration? = nil, sourceConfiguration: WebSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct WebSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the URL/URLs.
        public let urlConfiguration: UrlConfiguration

        @inlinable
        public init(urlConfiguration: UrlConfiguration) {
            self.urlConfiguration = urlConfiguration
        }

        public func validate(name: String) throws {
            try self.urlConfiguration.validate(name: "\(name).urlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case urlConfiguration = "urlConfiguration"
        }
    }

    public struct FunctionSchema: AWSEncodableShape & AWSDecodableShape {
        /// A list of functions that each define an action in the action group.
        public let functions: [Function]?

        @inlinable
        public init(functions: [Function]? = nil) {
            self.functions = functions
        }

        public func validate(name: String) throws {
            try self.functions?.forEach {
                try $0.validate(name: "\(name).functions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
        }
    }

    public struct PromptInferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains inference configurations for a text prompt.
        public let text: PromptModelInferenceConfiguration?

        @inlinable
        public init(text: PromptModelInferenceConfiguration? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.text?.validate(name: "\(name).text")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct PromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the text in a message for a prompt.
        public let text: TextPromptTemplateConfiguration?

        @inlinable
        public init(text: TextPromptTemplateConfiguration? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.text?.validate(name: "\(name).text")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrievalFlowNodeServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.
        public let s3: RetrievalFlowNodeS3Configuration?

        @inlinable
        public init(s3: RetrievalFlowNodeS3Configuration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct StorageFlowNodeServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the Amazon S3 location in which to store the input into the node.
        public let s3: StorageFlowNodeS3Configuration?

        @inlinable
        public init(s3: StorageFlowNodeS3Configuration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgent
public struct BedrockAgentErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgent
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentErrorType: Equatable {
    public static func == (lhs: BedrockAgentErrorType, rhs: BedrockAgentErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
