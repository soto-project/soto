//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgent {
    // MARK: Enums

    public enum ActionGroupSignature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCodeinterpreter = "AMAZON.CodeInterpreter"
        case amazonUserinput = "AMAZON.UserInput"
        case anthropicBash = "ANTHROPIC.Bash"
        case anthropicComputer = "ANTHROPIC.Computer"
        case anthropicTexteditor = "ANTHROPIC.TextEditor"
        public var description: String { return self.rawValue }
    }

    public enum ActionGroupState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AgentAliasStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case dissociated = "DISSOCIATED"
        case failed = "FAILED"
        case prepared = "PREPARED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentCollaboration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case supervisor = "SUPERVISOR"
        case supervisorRouter = "SUPERVISOR_ROUTER"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case notPrepared = "NOT_PREPARED"
        case prepared = "PREPARED"
        case preparing = "PREPARING"
        case updating = "UPDATING"
        case versioning = "VERSIONING"
        public var description: String { return self.rawValue }
    }

    public enum CachePointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        public var description: String { return self.rawValue }
    }

    public enum ChunkingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedSize = "FIXED_SIZE"
        case hierarchical = "HIERARCHICAL"
        case none = "NONE"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ConfluenceAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum ConfluenceHostType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case saas = "SAAS"
        public var description: String { return self.rawValue }
    }

    public enum ContentDataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum ContextEnrichmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockFoundationModel = "BEDROCK_FOUNDATION_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum ConversationRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assistant = "assistant"
        case user = "user"
        public var description: String { return self.rawValue }
    }

    public enum CrawlFilterConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pattern = "PATTERN"
        public var description: String { return self.rawValue }
    }

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum CustomControlMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case returnControl = "RETURN_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum CustomSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inLine = "IN_LINE"
        case s3Location = "S3_LOCATION"
        public var description: String { return self.rawValue }
    }

    public enum DataDeletionPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleteUnsuccessful = "DELETE_UNSUCCESSFUL"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confluence = "CONFLUENCE"
        case custom = "CUSTOM"
        case redshiftMetadata = "REDSHIFT_METADATA"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case sharepoint = "SHAREPOINT"
        case web = "WEB"
        public var description: String { return self.rawValue }
    }

    public enum DocumentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ignored = "IGNORED"
        case inProgress = "IN_PROGRESS"
        case indexed = "INDEXED"
        case metadataPartiallyIndexed = "METADATA_PARTIALLY_INDEXED"
        case metadataUpdateFailed = "METADATA_UPDATE_FAILED"
        case notFound = "NOT_FOUND"
        case partiallyIndexed = "PARTIALLY_INDEXED"
        case pending = "PENDING"
        case starting = "STARTING"
        public var description: String { return self.rawValue }
    }

    public enum EmbeddingDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "BINARY"
        case float32 = "FLOAT32"
        public var description: String { return self.rawValue }
    }

    public enum EnrichmentStrategyMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chunkEntityExtraction = "CHUNK_ENTITY_EXTRACTION"
        public var description: String { return self.rawValue }
    }

    public enum FlowConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditional = "Conditional"
        case data = "Data"
        public var description: String { return self.rawValue }
    }

    public enum FlowNodeIODataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "Array"
        case boolean = "Boolean"
        case number = "Number"
        case object = "Object"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum FlowNodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "Agent"
        case collector = "Collector"
        case condition = "Condition"
        case input = "Input"
        case iterator = "Iterator"
        case knowledgeBase = "KnowledgeBase"
        case lambdaFunction = "LambdaFunction"
        case lex = "Lex"
        case output = "Output"
        case prompt = "Prompt"
        case retrieval = "Retrieval"
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum FlowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case notPrepared = "NotPrepared"
        case prepared = "Prepared"
        case preparing = "Preparing"
        public var description: String { return self.rawValue }
    }

    public enum FlowValidationSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "Error"
        case warning = "Warning"
        public var description: String { return self.rawValue }
    }

    public enum FlowValidationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cyclicConnection = "CyclicConnection"
        case duplicateConditionExpression = "DuplicateConditionExpression"
        case duplicateConnections = "DuplicateConnections"
        case incompatibleConnectionDataType = "IncompatibleConnectionDataType"
        case malformedConditionExpression = "MalformedConditionExpression"
        case malformedNodeInputExpression = "MalformedNodeInputExpression"
        case mismatchedNodeInputType = "MismatchedNodeInputType"
        case mismatchedNodeOutputType = "MismatchedNodeOutputType"
        case missingConnectionConfiguration = "MissingConnectionConfiguration"
        case missingDefaultCondition = "MissingDefaultCondition"
        case missingEndingNodes = "MissingEndingNodes"
        case missingNodeConfiguration = "MissingNodeConfiguration"
        case missingNodeInput = "MissingNodeInput"
        case missingNodeOutput = "MissingNodeOutput"
        case missingStartingNodes = "MissingStartingNodes"
        case multipleNodeInputConnections = "MultipleNodeInputConnections"
        case unfulfilledNodeInput = "UnfulfilledNodeInput"
        case unknownConnectionCondition = "UnknownConnectionCondition"
        case unknownConnectionSource = "UnknownConnectionSource"
        case unknownConnectionSourceOutput = "UnknownConnectionSourceOutput"
        case unknownConnectionTarget = "UnknownConnectionTarget"
        case unknownConnectionTargetInput = "UnknownConnectionTargetInput"
        case unknownNodeInput = "UnknownNodeInput"
        case unknownNodeOutput = "UnknownNodeOutput"
        case unreachableNode = "UnreachableNode"
        case unsatisfiedConnectionConditions = "UnsatisfiedConnectionConditions"
        case unspecified = "Unspecified"
        public var description: String { return self.rawValue }
    }

    public enum IncludeExclude: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobSortByAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startedAt = "STARTED_AT"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum IngestionJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum InlineContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byte = "BYTE"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleteUnsuccessful = "DELETE_UNSUCCESSFUL"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mongoDbAtlas = "MONGO_DB_ATLAS"
        case neptuneAnalytics = "NEPTUNE_ANALYTICS"
        case opensearchServerless = "OPENSEARCH_SERVERLESS"
        case pinecone = "PINECONE"
        case rds = "RDS"
        case redisEnterpriseCloud = "REDIS_ENTERPRISE_CLOUD"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kendra = "KENDRA"
        case sql = "SQL"
        case vector = "VECTOR"
        public var description: String { return self.rawValue }
    }

    public enum MemoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sessionSummary = "SESSION_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum MetadataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inLineAttribute = "IN_LINE_ATTRIBUTE"
        case s3Location = "S3_LOCATION"
        public var description: String { return self.rawValue }
    }

    public enum MetadataValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case number = "NUMBER"
        case string = "STRING"
        case stringList = "STRING_LIST"
        public var description: String { return self.rawValue }
    }

    public enum OrchestrationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case customOrchestration = "CUSTOM_ORCHESTRATION"
        public var description: String { return self.rawValue }
    }

    public enum ParsingModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multimodal = "MULTIMODAL"
        public var description: String { return self.rawValue }
    }

    public enum ParsingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockDataAutomation = "BEDROCK_DATA_AUTOMATION"
        case bedrockFoundationModel = "BEDROCK_FOUNDATION_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum PromptState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PromptTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chat = "CHAT"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case memorySummarization = "MEMORY_SUMMARIZATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum QueryEngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case redshift = "REDSHIFT"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftProvisionedAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case username = "USERNAME"
        case usernamePassword = "USERNAME_PASSWORD"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftQueryEngineStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsDataCatalog = "AWS_DATA_CATALOG"
        case redshift = "REDSHIFT"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftQueryEngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provisioned = "PROVISIONED"
        case serverless = "SERVERLESS"
        public var description: String { return self.rawValue }
    }

    public enum RedshiftServerlessAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case usernamePassword = "USERNAME_PASSWORD"
        public var description: String { return self.rawValue }
    }

    public enum RelayConversationHistory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case toCollaborator = "TO_COLLABORATOR"
        public var description: String { return self.rawValue }
    }

    public enum RequireConfirmation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum SharePointAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oauth2ClientCredentials = "OAUTH2_CLIENT_CREDENTIALS"
        case oauth2SharepointAppOnlyClientCredentials = "OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum SharePointHostType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case online = "ONLINE"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum StepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case postChunking = "POST_CHUNKING"
        public var description: String { return self.rawValue }
    }

    public enum SupplementalDataStorageLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum WebScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hostOnly = "HOST_ONLY"
        case subdomains = "SUBDOMAINS"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum APISchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case payload(String)
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see Action group OpenAPI schemas.
        case s3(S3Identifier)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .payload:
                let value = try container.decode(String.self, forKey: .payload)
                self = .payload(value)
            case .s3:
                let value = try container.decode(S3Identifier.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .payload(let value):
                try container.encode(value, forKey: .payload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case s3 = "s3"
        }
    }

    public enum ActionGroupExecutor: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// To return the action group invocation results directly in the InvokeAgent response, specify RETURN_CONTROL.
        case customControl(CustomControlMethod)
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customControl:
                let value = try container.decode(CustomControlMethod.self, forKey: .customControl)
                self = .customControl(value)
            case .lambda:
                let value = try container.decode(String.self, forKey: .lambda)
                self = .lambda(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customControl(let value):
                try container.encode(value, forKey: .customControl)
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try self.validate(value, name: "lambda", parent: name, max: 2048)
                try self.validate(value, name: "lambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customControl = "customControl"
            case lambda = "lambda"
        }
    }

    public enum ContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Creates a cache checkpoint within a message.
        case cachePoint(CachePointBlock)
        /// The text in the message.
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cachePoint:
                let value = try container.decode(CachePointBlock.self, forKey: .cachePoint)
                self = .cachePoint(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case text = "text"
        }
    }

    public enum FlowConnectionConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration of a connection originating from a Condition node.
        case conditional(FlowConditionalConnectionConfiguration)
        /// The configuration of a connection originating from a node that isn't a Condition node.
        case data(FlowDataConnectionConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditional:
                let value = try container.decode(FlowConditionalConnectionConfiguration.self, forKey: .conditional)
                self = .conditional(value)
            case .data:
                let value = try container.decode(FlowDataConnectionConfiguration.self, forKey: .data)
                self = .data(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conditional(let value):
                try container.encode(value, forKey: .conditional)
            case .data(let value):
                try container.encode(value, forKey: .data)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .conditional(let value):
                try value.validate(name: "\(name).conditional")
            case .data(let value):
                try value.validate(name: "\(name).data")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditional = "conditional"
            case data = "data"
        }
    }

    public enum FlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response.
        case agent(AgentFlowNodeConfiguration)
        /// Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs.
        case collector(CollectorFlowNodeConfiguration)
        /// Contains configurations for a Condition node in your flow. Defines conditions that lead to different branches of the flow.
        case condition(ConditionFlowNodeConfiguration)
        /// Contains configurations for an input flow node in your flow. The first node in the flow. inputs can't be specified for this node.
        case input(InputFlowNodeConfiguration)
        /// Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
        case iterator(IteratorFlowNodeConfiguration)
        /// Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response.
        case knowledgeBase(KnowledgeBaseFlowNodeConfiguration)
        /// Contains configurations for a Lambda function node in your flow. Invokes an Lambda function.
        case lambdaFunction(LambdaFunctionFlowNodeConfiguration)
        /// Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.
        case lex(LexFlowNodeConfiguration)
        /// Contains configurations for an output flow node in your flow. The last node in the flow. outputs can't be specified for this node.
        case output(OutputFlowNodeConfiguration)
        /// Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.
        case prompt(PromptFlowNodeConfiguration)
        /// Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output.
        case retrieval(RetrievalFlowNodeConfiguration)
        /// Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location.
        case storage(StorageFlowNodeConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .agent:
                let value = try container.decode(AgentFlowNodeConfiguration.self, forKey: .agent)
                self = .agent(value)
            case .collector:
                let value = try container.decode(CollectorFlowNodeConfiguration.self, forKey: .collector)
                self = .collector(value)
            case .condition:
                let value = try container.decode(ConditionFlowNodeConfiguration.self, forKey: .condition)
                self = .condition(value)
            case .input:
                let value = try container.decode(InputFlowNodeConfiguration.self, forKey: .input)
                self = .input(value)
            case .iterator:
                let value = try container.decode(IteratorFlowNodeConfiguration.self, forKey: .iterator)
                self = .iterator(value)
            case .knowledgeBase:
                let value = try container.decode(KnowledgeBaseFlowNodeConfiguration.self, forKey: .knowledgeBase)
                self = .knowledgeBase(value)
            case .lambdaFunction:
                let value = try container.decode(LambdaFunctionFlowNodeConfiguration.self, forKey: .lambdaFunction)
                self = .lambdaFunction(value)
            case .lex:
                let value = try container.decode(LexFlowNodeConfiguration.self, forKey: .lex)
                self = .lex(value)
            case .output:
                let value = try container.decode(OutputFlowNodeConfiguration.self, forKey: .output)
                self = .output(value)
            case .prompt:
                let value = try container.decode(PromptFlowNodeConfiguration.self, forKey: .prompt)
                self = .prompt(value)
            case .retrieval:
                let value = try container.decode(RetrievalFlowNodeConfiguration.self, forKey: .retrieval)
                self = .retrieval(value)
            case .storage:
                let value = try container.decode(StorageFlowNodeConfiguration.self, forKey: .storage)
                self = .storage(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .agent(let value):
                try container.encode(value, forKey: .agent)
            case .collector(let value):
                try container.encode(value, forKey: .collector)
            case .condition(let value):
                try container.encode(value, forKey: .condition)
            case .input(let value):
                try container.encode(value, forKey: .input)
            case .iterator(let value):
                try container.encode(value, forKey: .iterator)
            case .knowledgeBase(let value):
                try container.encode(value, forKey: .knowledgeBase)
            case .lambdaFunction(let value):
                try container.encode(value, forKey: .lambdaFunction)
            case .lex(let value):
                try container.encode(value, forKey: .lex)
            case .output(let value):
                try container.encode(value, forKey: .output)
            case .prompt(let value):
                try container.encode(value, forKey: .prompt)
            case .retrieval(let value):
                try container.encode(value, forKey: .retrieval)
            case .storage(let value):
                try container.encode(value, forKey: .storage)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .agent(let value):
                try value.validate(name: "\(name).agent")
            case .condition(let value):
                try value.validate(name: "\(name).condition")
            case .knowledgeBase(let value):
                try value.validate(name: "\(name).knowledgeBase")
            case .lambdaFunction(let value):
                try value.validate(name: "\(name).lambdaFunction")
            case .lex(let value):
                try value.validate(name: "\(name).lex")
            case .prompt(let value):
                try value.validate(name: "\(name).prompt")
            case .retrieval(let value):
                try value.validate(name: "\(name).retrieval")
            case .storage(let value):
                try value.validate(name: "\(name).storage")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
            case collector = "collector"
            case condition = "condition"
            case input = "input"
            case iterator = "iterator"
            case knowledgeBase = "knowledgeBase"
            case lambdaFunction = "lambdaFunction"
            case lex = "lex"
            case output = "output"
            case prompt = "prompt"
            case retrieval = "retrieval"
            case storage = "storage"
        }
    }

    public enum FlowValidationDetails: AWSDecodableShape, Sendable {
        /// Details about a cyclic connection in the flow.
        case cyclicConnection(CyclicConnectionFlowValidationDetails)
        /// Details about duplicate condition expressions in a node.
        case duplicateConditionExpression(DuplicateConditionExpressionFlowValidationDetails)
        /// Details about duplicate connections between nodes.
        case duplicateConnections(DuplicateConnectionsFlowValidationDetails)
        /// Details about incompatible data types in a connection.
        case incompatibleConnectionDataType(IncompatibleConnectionDataTypeFlowValidationDetails)
        /// Details about a malformed condition expression in a node.
        case malformedConditionExpression(MalformedConditionExpressionFlowValidationDetails)
        /// Details about a malformed input expression in a node.
        case malformedNodeInputExpression(MalformedNodeInputExpressionFlowValidationDetails)
        /// Details about mismatched input data types in a node.
        case mismatchedNodeInputType(MismatchedNodeInputTypeFlowValidationDetails)
        /// Details about mismatched output data types in a node.
        case mismatchedNodeOutputType(MismatchedNodeOutputTypeFlowValidationDetails)
        /// Details about missing configuration for a connection.
        case missingConnectionConfiguration(MissingConnectionConfigurationFlowValidationDetails)
        /// Details about a missing default condition in a conditional node.
        case missingDefaultCondition(MissingDefaultConditionFlowValidationDetails)
        /// Details about missing ending nodes in the flow.
        case missingEndingNodes(MissingEndingNodesFlowValidationDetails)
        /// Details about missing configuration for a node.
        case missingNodeConfiguration(MissingNodeConfigurationFlowValidationDetails)
        /// Details about a missing required input in a node.
        case missingNodeInput(MissingNodeInputFlowValidationDetails)
        /// Details about a missing required output in a node.
        case missingNodeOutput(MissingNodeOutputFlowValidationDetails)
        /// Details about missing starting nodes in the flow.
        case missingStartingNodes(MissingStartingNodesFlowValidationDetails)
        /// Details about multiple connections to a single node input.
        case multipleNodeInputConnections(MultipleNodeInputConnectionsFlowValidationDetails)
        /// Details about an unfulfilled node input with no valid connections.
        case unfulfilledNodeInput(UnfulfilledNodeInputFlowValidationDetails)
        /// Details about an unknown condition for a connection.
        case unknownConnectionCondition(UnknownConnectionConditionFlowValidationDetails)
        /// Details about an unknown source node for a connection.
        case unknownConnectionSource(UnknownConnectionSourceFlowValidationDetails)
        /// Details about an unknown source output for a connection.
        case unknownConnectionSourceOutput(UnknownConnectionSourceOutputFlowValidationDetails)
        /// Details about an unknown target node for a connection.
        case unknownConnectionTarget(UnknownConnectionTargetFlowValidationDetails)
        /// Details about an unknown target input for a connection.
        case unknownConnectionTargetInput(UnknownConnectionTargetInputFlowValidationDetails)
        /// Details about an unknown input for a node.
        case unknownNodeInput(UnknownNodeInputFlowValidationDetails)
        /// Details about an unknown output for a node.
        case unknownNodeOutput(UnknownNodeOutputFlowValidationDetails)
        /// Details about an unreachable node in the flow.
        case unreachableNode(UnreachableNodeFlowValidationDetails)
        /// Details about unsatisfied conditions for a connection.
        case unsatisfiedConnectionConditions(UnsatisfiedConnectionConditionsFlowValidationDetails)
        /// Details about an unspecified validation.
        case unspecified(UnspecifiedFlowValidationDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cyclicConnection:
                let value = try container.decode(CyclicConnectionFlowValidationDetails.self, forKey: .cyclicConnection)
                self = .cyclicConnection(value)
            case .duplicateConditionExpression:
                let value = try container.decode(DuplicateConditionExpressionFlowValidationDetails.self, forKey: .duplicateConditionExpression)
                self = .duplicateConditionExpression(value)
            case .duplicateConnections:
                let value = try container.decode(DuplicateConnectionsFlowValidationDetails.self, forKey: .duplicateConnections)
                self = .duplicateConnections(value)
            case .incompatibleConnectionDataType:
                let value = try container.decode(IncompatibleConnectionDataTypeFlowValidationDetails.self, forKey: .incompatibleConnectionDataType)
                self = .incompatibleConnectionDataType(value)
            case .malformedConditionExpression:
                let value = try container.decode(MalformedConditionExpressionFlowValidationDetails.self, forKey: .malformedConditionExpression)
                self = .malformedConditionExpression(value)
            case .malformedNodeInputExpression:
                let value = try container.decode(MalformedNodeInputExpressionFlowValidationDetails.self, forKey: .malformedNodeInputExpression)
                self = .malformedNodeInputExpression(value)
            case .mismatchedNodeInputType:
                let value = try container.decode(MismatchedNodeInputTypeFlowValidationDetails.self, forKey: .mismatchedNodeInputType)
                self = .mismatchedNodeInputType(value)
            case .mismatchedNodeOutputType:
                let value = try container.decode(MismatchedNodeOutputTypeFlowValidationDetails.self, forKey: .mismatchedNodeOutputType)
                self = .mismatchedNodeOutputType(value)
            case .missingConnectionConfiguration:
                let value = try container.decode(MissingConnectionConfigurationFlowValidationDetails.self, forKey: .missingConnectionConfiguration)
                self = .missingConnectionConfiguration(value)
            case .missingDefaultCondition:
                let value = try container.decode(MissingDefaultConditionFlowValidationDetails.self, forKey: .missingDefaultCondition)
                self = .missingDefaultCondition(value)
            case .missingEndingNodes:
                let value = try container.decode(MissingEndingNodesFlowValidationDetails.self, forKey: .missingEndingNodes)
                self = .missingEndingNodes(value)
            case .missingNodeConfiguration:
                let value = try container.decode(MissingNodeConfigurationFlowValidationDetails.self, forKey: .missingNodeConfiguration)
                self = .missingNodeConfiguration(value)
            case .missingNodeInput:
                let value = try container.decode(MissingNodeInputFlowValidationDetails.self, forKey: .missingNodeInput)
                self = .missingNodeInput(value)
            case .missingNodeOutput:
                let value = try container.decode(MissingNodeOutputFlowValidationDetails.self, forKey: .missingNodeOutput)
                self = .missingNodeOutput(value)
            case .missingStartingNodes:
                let value = try container.decode(MissingStartingNodesFlowValidationDetails.self, forKey: .missingStartingNodes)
                self = .missingStartingNodes(value)
            case .multipleNodeInputConnections:
                let value = try container.decode(MultipleNodeInputConnectionsFlowValidationDetails.self, forKey: .multipleNodeInputConnections)
                self = .multipleNodeInputConnections(value)
            case .unfulfilledNodeInput:
                let value = try container.decode(UnfulfilledNodeInputFlowValidationDetails.self, forKey: .unfulfilledNodeInput)
                self = .unfulfilledNodeInput(value)
            case .unknownConnectionCondition:
                let value = try container.decode(UnknownConnectionConditionFlowValidationDetails.self, forKey: .unknownConnectionCondition)
                self = .unknownConnectionCondition(value)
            case .unknownConnectionSource:
                let value = try container.decode(UnknownConnectionSourceFlowValidationDetails.self, forKey: .unknownConnectionSource)
                self = .unknownConnectionSource(value)
            case .unknownConnectionSourceOutput:
                let value = try container.decode(UnknownConnectionSourceOutputFlowValidationDetails.self, forKey: .unknownConnectionSourceOutput)
                self = .unknownConnectionSourceOutput(value)
            case .unknownConnectionTarget:
                let value = try container.decode(UnknownConnectionTargetFlowValidationDetails.self, forKey: .unknownConnectionTarget)
                self = .unknownConnectionTarget(value)
            case .unknownConnectionTargetInput:
                let value = try container.decode(UnknownConnectionTargetInputFlowValidationDetails.self, forKey: .unknownConnectionTargetInput)
                self = .unknownConnectionTargetInput(value)
            case .unknownNodeInput:
                let value = try container.decode(UnknownNodeInputFlowValidationDetails.self, forKey: .unknownNodeInput)
                self = .unknownNodeInput(value)
            case .unknownNodeOutput:
                let value = try container.decode(UnknownNodeOutputFlowValidationDetails.self, forKey: .unknownNodeOutput)
                self = .unknownNodeOutput(value)
            case .unreachableNode:
                let value = try container.decode(UnreachableNodeFlowValidationDetails.self, forKey: .unreachableNode)
                self = .unreachableNode(value)
            case .unsatisfiedConnectionConditions:
                let value = try container.decode(UnsatisfiedConnectionConditionsFlowValidationDetails.self, forKey: .unsatisfiedConnectionConditions)
                self = .unsatisfiedConnectionConditions(value)
            case .unspecified:
                let value = try container.decode(UnspecifiedFlowValidationDetails.self, forKey: .unspecified)
                self = .unspecified(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cyclicConnection = "cyclicConnection"
            case duplicateConditionExpression = "duplicateConditionExpression"
            case duplicateConnections = "duplicateConnections"
            case incompatibleConnectionDataType = "incompatibleConnectionDataType"
            case malformedConditionExpression = "malformedConditionExpression"
            case malformedNodeInputExpression = "malformedNodeInputExpression"
            case mismatchedNodeInputType = "mismatchedNodeInputType"
            case mismatchedNodeOutputType = "mismatchedNodeOutputType"
            case missingConnectionConfiguration = "missingConnectionConfiguration"
            case missingDefaultCondition = "missingDefaultCondition"
            case missingEndingNodes = "missingEndingNodes"
            case missingNodeConfiguration = "missingNodeConfiguration"
            case missingNodeInput = "missingNodeInput"
            case missingNodeOutput = "missingNodeOutput"
            case missingStartingNodes = "missingStartingNodes"
            case multipleNodeInputConnections = "multipleNodeInputConnections"
            case unfulfilledNodeInput = "unfulfilledNodeInput"
            case unknownConnectionCondition = "unknownConnectionCondition"
            case unknownConnectionSource = "unknownConnectionSource"
            case unknownConnectionSourceOutput = "unknownConnectionSourceOutput"
            case unknownConnectionTarget = "unknownConnectionTarget"
            case unknownConnectionTargetInput = "unknownConnectionTargetInput"
            case unknownNodeInput = "unknownNodeInput"
            case unknownNodeOutput = "unknownNodeOutput"
            case unreachableNode = "unreachableNode"
            case unsatisfiedConnectionConditions = "unsatisfiedConnectionConditions"
            case unspecified = "unspecified"
        }
    }

    public enum PromptFlowNodeSourceConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configurations for a prompt that is defined inline
        case inline(PromptFlowNodeInlineConfiguration)
        /// Contains configurations for a prompt from Prompt management.
        case resource(PromptFlowNodeResourceConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inline:
                let value = try container.decode(PromptFlowNodeInlineConfiguration.self, forKey: .inline)
                self = .inline(value)
            case .resource:
                let value = try container.decode(PromptFlowNodeResourceConfiguration.self, forKey: .resource)
                self = .resource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inline(let value):
                try container.encode(value, forKey: .inline)
            case .resource(let value):
                try container.encode(value, forKey: .resource)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .inline(let value):
                try value.validate(name: "\(name).inline")
            case .resource(let value):
                try value.validate(name: "\(name).resource")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inline = "inline"
            case resource = "resource"
        }
    }

    public enum PromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configurations to use the prompt in a conversational format.
        case chat(ChatPromptTemplateConfiguration)
        /// Contains configurations for the text in a message for a prompt.
        case text(TextPromptTemplateConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .chat:
                let value = try container.decode(ChatPromptTemplateConfiguration.self, forKey: .chat)
                self = .chat(value)
            case .text:
                let value = try container.decode(TextPromptTemplateConfiguration.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .chat(let value):
                try container.encode(value, forKey: .chat)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .chat(let value):
                try value.validate(name: "\(name).chat")
            case .text(let value):
                try value.validate(name: "\(name).text")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case chat = "chat"
            case text = "text"
        }
    }

    public enum SystemContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Creates a cache checkpoint within a tool designation
        case cachePoint(CachePointBlock)
        /// The text in the system prompt.
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cachePoint:
                let value = try container.decode(CachePointBlock.self, forKey: .cachePoint)
                self = .cachePoint(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .text(let value):
                try self.validate(value, name: "text", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case text = "text"
        }
    }

    public enum Tool: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Creates a cache checkpoint within a tool designation
        case cachePoint(CachePointBlock)
        /// The specification for the tool.
        case toolSpec(ToolSpecification)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cachePoint:
                let value = try container.decode(CachePointBlock.self, forKey: .cachePoint)
                self = .cachePoint(value)
            case .toolSpec:
                let value = try container.decode(ToolSpecification.self, forKey: .toolSpec)
                self = .toolSpec(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .toolSpec(let value):
                try container.encode(value, forKey: .toolSpec)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .toolSpec(let value):
                try value.validate(name: "\(name).toolSpec")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case toolSpec = "toolSpec"
        }
    }

    public enum ToolChoice: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response.
        case any(AnyToolChoice)
        /// Defines tools. The model automatically decides whether to call a tool or to generate text instead.
        case auto(AutoToolChoice)
        /// Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response.
        case tool(SpecificToolChoice)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .any:
                let value = try container.decode(AnyToolChoice.self, forKey: .any)
                self = .any(value)
            case .auto:
                let value = try container.decode(AutoToolChoice.self, forKey: .auto)
                self = .auto(value)
            case .tool:
                let value = try container.decode(SpecificToolChoice.self, forKey: .tool)
                self = .tool(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .any(let value):
                try container.encode(value, forKey: .any)
            case .auto(let value):
                try container.encode(value, forKey: .auto)
            case .tool(let value):
                try container.encode(value, forKey: .tool)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .tool(let value):
                try value.validate(name: "\(name).tool")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case any = "any"
            case auto = "auto"
            case tool = "tool"
        }
    }

    // MARK: Shapes

    public struct ActionGroupSummary: AWSDecodableShape {
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The description of the action group.
        public let description: String?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, description: String? = nil, updatedAt: Date) {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case description = "description"
            case updatedAt = "updatedAt"
        }
    }

    public struct Agent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent.
        public let agentArn: String
        /// The agent's collaboration settings.
        public let agentCollaboration: AgentCollaboration?
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The status of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent is being created.   PREPARING – The agent is being prepared.   PREPARED – The agent is prepared and ready to be invoked.   NOT_PREPARED – The agent has been created but not yet prepared.   FAILED – The agent API operation failed.   UPDATING – The agent is being updated.   DELETING – The agent is being deleted.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        ///  Contains custom orchestration configurations for the agent.
        public let customOrchestration: CustomOrchestration?
        /// The description of the agent.
        public let description: String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public let failureReasons: [String]?
        /// The foundation model used for orchestration by the agent.
        public let foundationModel: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Contains memory configuration for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        ///  Specifies the orchestration strategy for the agent.
        public let orchestrationType: OrchestrationType?
        /// The time at which the agent was last prepared.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var preparedAt: Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public let recommendedActions: [String]?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentArn: String, agentCollaboration: AgentCollaboration? = nil, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, agentVersion: String, clientToken: String? = nil, createdAt: Date, customerEncryptionKeyArn: String? = nil, customOrchestration: CustomOrchestration? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, orchestrationType: OrchestrationType? = nil, preparedAt: Date? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date) {
            self.agentArn = agentArn
            self.agentCollaboration = agentCollaboration
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.customOrchestration = customOrchestration
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.orchestrationType = orchestrationType
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentCollaboration = "agentCollaboration"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case customOrchestration = "customOrchestration"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case orchestrationType = "orchestrationType"
            case preparedAt = "preparedAt"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentActionGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// The name of the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState
        /// The unique identifier of the agent to which the action group belongs.
        public let agentId: String
        /// The version of the agent to which the action group belongs.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the action group was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the action group.
        public let description: String?
        /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        public let functionSchema: FunctionSchema?
        /// The configuration settings for a computer use action.   Computer use is a new Anthropic Claude model capability (in beta) available with Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.
        public let parentActionGroupSignatureParams: [String: String]?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionSignature: ActionGroupSignature?
        /// The time at which the action group was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = nil, createdAt: Date, description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignatureParams: [String: String]? = nil, parentActionSignature: ActionGroupSignature? = nil, updatedAt: Date) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignatureParams = parentActionGroupSignatureParams
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupId = "actionGroupId"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignatureParams = "parentActionGroupSignatureParams"
            case parentActionSignature = "parentActionSignature"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAlias: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias of the agent.
        public let agentAliasArn: String
        /// Contains details about the history of the alias.
        public let agentAliasHistoryEvents: [AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String
        /// The name of the alias of the agent.
        public let agentAliasName: String
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:   CREATING – The agent alias is being created.   PREPARED – The agent alias is finished being created or updated and is ready to be invoked.   FAILED – The agent alias API operation failed.   UPDATING – The agent alias is being updated.   DELETING – The agent alias is being deleted.   DISSOCIATED - The agent alias has no version associated with it.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias of the agent.
        public let description: String?
        /// Information on the failure of Provisioned Throughput assigned to an agent alias.
        public let failureReasons: [String]?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentAliasArn: String, agentAliasHistoryEvents: [AgentAliasHistoryEvent]? = nil, agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, agentId: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, failureReasons: [String]? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
            case agentAliasHistoryEvents = "agentAliasHistoryEvents"
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case failureReasons = "failureReasons"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentAliasHistoryEvent: AWSDecodableShape {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?

        @inlinable
        public init(endDate: Date? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, startDate: Date? = nil) {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case routingConfiguration = "routingConfiguration"
            case startDate = "startDate"
        }
    }

    public struct AgentAliasRoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The version of the agent with which the alias is associated.
        public let agentVersion: String?
        /// Information on the Provisioned Throughput assigned to an agent alias.
        public let provisionedThroughput: String?

        @inlinable
        public init(agentVersion: String? = nil, provisionedThroughput: String? = nil) {
            self.agentVersion = agentVersion
            self.provisionedThroughput = provisionedThroughput
        }

        public func validate(name: String) throws {
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, max: 2048)
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, min: 1)
            try self.validate(self.provisionedThroughput, name: "provisionedThroughput", parent: name, pattern: "^((([0-9a-zA-Z][_-]?){1,63})|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
            case provisionedThroughput = "provisionedThroughput"
        }
    }

    public struct AgentAliasSummary: AWSDecodableShape {
        /// Contains details about
        public let agentAliasId: String
        /// The name of the alias.
        public let agentAliasName: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The time at which the alias of the agent was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias.
        public let description: String?
        /// Contains details about the version of the agent with which the alias is associated.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentAliasId: String, agentAliasName: String, agentAliasStatus: AgentAliasStatus, createdAt: Date, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, updatedAt: Date) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasName = "agentAliasName"
            case agentAliasStatus = "agentAliasStatus"
            case createdAt = "createdAt"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentCollaborator: AWSDecodableShape {
        /// The collaborator's agent descriptor.
        public let agentDescriptor: AgentDescriptor
        /// The collaborator's agent ID.
        public let agentId: String
        /// The collaborator's agent version.
        public let agentVersion: String
        /// The collaborator's client token.
        public let clientToken: String?
        /// The collaborator's instructions.
        public let collaborationInstruction: String
        /// The collaborator's collaborator ID.
        public let collaboratorId: String
        /// The collaborator's collaborator name.
        public let collaboratorName: String
        /// When the collaborator was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// When the collaborator was updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The collaborator's relay conversation history.
        public let relayConversationHistory: RelayConversationHistory?

        @inlinable
        public init(agentDescriptor: AgentDescriptor, agentId: String, agentVersion: String, clientToken: String? = nil, collaborationInstruction: String, collaboratorId: String, collaboratorName: String, createdAt: Date, lastUpdatedAt: Date, relayConversationHistory: RelayConversationHistory? = nil) {
            self.agentDescriptor = agentDescriptor
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.collaborationInstruction = collaborationInstruction
            self.collaboratorId = collaboratorId
            self.collaboratorName = collaboratorName
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.relayConversationHistory = relayConversationHistory
        }

        private enum CodingKeys: String, CodingKey {
            case agentDescriptor = "agentDescriptor"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case clientToken = "clientToken"
            case collaborationInstruction = "collaborationInstruction"
            case collaboratorId = "collaboratorId"
            case collaboratorName = "collaboratorName"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case relayConversationHistory = "relayConversationHistory"
        }
    }

    public struct AgentCollaboratorSummary: AWSDecodableShape {
        /// The collaborator's agent descriptor.
        public let agentDescriptor: AgentDescriptor
        /// The collaborator's agent ID.
        public let agentId: String
        /// The collaborator's agent version.
        public let agentVersion: String
        /// The collaborator's collaboration instruction.
        public let collaborationInstruction: String
        /// The collaborator's ID.
        public let collaboratorId: String
        /// The collaborator's name.
        public let collaboratorName: String
        /// When the collaborator was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// When the collaborator was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The collaborator's relay conversation history.
        public let relayConversationHistory: RelayConversationHistory

        @inlinable
        public init(agentDescriptor: AgentDescriptor, agentId: String, agentVersion: String, collaborationInstruction: String, collaboratorId: String, collaboratorName: String, createdAt: Date, lastUpdatedAt: Date, relayConversationHistory: RelayConversationHistory) {
            self.agentDescriptor = agentDescriptor
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.collaborationInstruction = collaborationInstruction
            self.collaboratorId = collaboratorId
            self.collaboratorName = collaboratorName
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.relayConversationHistory = relayConversationHistory
        }

        private enum CodingKeys: String, CodingKey {
            case agentDescriptor = "agentDescriptor"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case collaborationInstruction = "collaborationInstruction"
            case collaboratorId = "collaboratorId"
            case collaboratorName = "collaboratorName"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case relayConversationHistory = "relayConversationHistory"
        }
    }

    public struct AgentDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The agent's alias ARN.
        public let aliasArn: String?

        @inlinable
        public init(aliasArn: String? = nil) {
            self.aliasArn = aliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, max: 2048)
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, pattern: "^arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:agent-alias/[0-9a-zA-Z]{10}/[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case aliasArn = "aliasArn"
        }
    }

    public struct AgentFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        public let agentAliasArn: String

        @inlinable
        public init(agentAliasArn: String) {
            self.agentAliasArn = agentAliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasArn, name: "agentAliasArn", parent: name, max: 2048)
            try self.validate(self.agentAliasArn, name: "agentAliasArn", parent: name, pattern: "^arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:agent-alias/[0-9a-zA-Z]{10}/[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
        }
    }

    public struct AgentKnowledgeBase: AWSDecodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The time at which the association between the agent and the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the association between the agent and the knowledge base.
        public let description: String
        /// The unique identifier of the association between the agent and the knowledge base.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the association between the agent and the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentId: String, agentVersion: String, createdAt: Date, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentKnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState
        /// The time at which the knowledge base associated with an agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentSummary: AWSDecodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The name of the agent.
        public let agentName: String
        /// The status of the agent.
        public let agentStatus: AgentStatus
        /// The description of the agent.
        public let description: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The latest version of the agent.
        public let latestAgentVersion: String?
        /// The time at which the agent was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentId: String, agentName: String, agentStatus: AgentStatus, description: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, latestAgentVersion: String? = nil, updatedAt: Date) {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case description = "description"
            case guardrailConfiguration = "guardrailConfiguration"
            case latestAgentVersion = "latestAgentVersion"
            case updatedAt = "updatedAt"
        }
    }

    public struct AgentVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent that the version belongs to.
        public let agentArn: String
        /// The agent's collaboration settings.
        public let agentCollaboration: AgentCollaboration?
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The name of the agent that the version belongs to.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The status of the agent that the version belongs to.
        public let agentStatus: AgentStatus
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public let customerEncryptionKeyArn: String?
        /// The description of the version.
        public let description: String?
        /// A list of reasons that the API operation on the version failed.
        public let failureReasons: [String]?
        /// The foundation model that the version invokes.
        public let foundationModel: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int
        /// The instructions provided to the agent.
        public let instruction: String?
        ///  Contains details of the memory configuration on the version of the agent.
        public let memoryConfiguration: MemoryConfiguration?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public let recommendedActions: [String]?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version number.
        public let version: String

        @inlinable
        public init(agentArn: String, agentCollaboration: AgentCollaboration? = nil, agentId: String, agentName: String, agentResourceRoleArn: String, agentStatus: AgentStatus, createdAt: Date, customerEncryptionKeyArn: String? = nil, description: String? = nil, failureReasons: [String]? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, recommendedActions: [String]? = nil, updatedAt: Date, version: String) {
            self.agentArn = agentArn
            self.agentCollaboration = agentCollaboration
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case agentArn = "agentArn"
            case agentCollaboration = "agentCollaboration"
            case agentId = "agentId"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case agentStatus = "agentStatus"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case description = "description"
            case failureReasons = "failureReasons"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case recommendedActions = "recommendedActions"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct AgentVersionSummary: AWSDecodableShape {
        /// The name of the agent to which the version belongs.
        public let agentName: String
        /// The status of the agent to which the version belongs.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the version of the agent.
        public let description: String?
        /// Details about the guardrail associated with the agent.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The time at which the version was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(agentName: String, agentStatus: AgentStatus, agentVersion: String, createdAt: Date, description: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, updatedAt: Date) {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentName = "agentName"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case createdAt = "createdAt"
            case description = "description"
            case guardrailConfiguration = "guardrailConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct AnyToolChoice: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AssociateAgentCollaboratorRequest: AWSEncodableShape {
        /// The alias of the collaborator agent.
        public let agentDescriptor: AgentDescriptor
        /// The agent's ID.
        public let agentId: String
        /// An agent version.
        public let agentVersion: String
        /// A client token.
        public let clientToken: String?
        /// Instruction for the collaborator.
        public let collaborationInstruction: String
        /// A name for the collaborator.
        public let collaboratorName: String
        /// A relay conversation history for the collaborator.
        public let relayConversationHistory: RelayConversationHistory?

        @inlinable
        public init(agentDescriptor: AgentDescriptor, agentId: String, agentVersion: String, clientToken: String? = AssociateAgentCollaboratorRequest.idempotencyToken(), collaborationInstruction: String, collaboratorName: String, relayConversationHistory: RelayConversationHistory? = nil) {
            self.agentDescriptor = agentDescriptor
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.collaborationInstruction = collaborationInstruction
            self.collaboratorName = collaboratorName
            self.relayConversationHistory = relayConversationHistory
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentDescriptor, forKey: .agentDescriptor)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.collaborationInstruction, forKey: .collaborationInstruction)
            try container.encode(self.collaboratorName, forKey: .collaboratorName)
            try container.encodeIfPresent(self.relayConversationHistory, forKey: .relayConversationHistory)
        }

        public func validate(name: String) throws {
            try self.agentDescriptor.validate(name: "\(name).agentDescriptor")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.collaborationInstruction, name: "collaborationInstruction", parent: name, max: 4000)
            try self.validate(self.collaborationInstruction, name: "collaborationInstruction", parent: name, min: 1)
            try self.validate(self.collaboratorName, name: "collaboratorName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentDescriptor = "agentDescriptor"
            case clientToken = "clientToken"
            case collaborationInstruction = "collaborationInstruction"
            case collaboratorName = "collaboratorName"
            case relayConversationHistory = "relayConversationHistory"
        }
    }

    public struct AssociateAgentCollaboratorResponse: AWSDecodableShape {
        /// Details about the collaborator.
        public let agentCollaborator: AgentCollaborator

        @inlinable
        public init(agentCollaborator: AgentCollaborator) {
            self.agentCollaborator = agentCollaborator
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaborator = "agentCollaborator"
        }
    }

    public struct AssociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which you want to associate the knowledge base.
        public let agentId: String
        /// The version of the agent with which you want to associate the knowledge base.
        public let agentVersion: String
        /// A description of what the agent should use the knowledge base for.
        public let description: String
        /// The unique identifier of the knowledge base to associate with the agent.
        public let knowledgeBaseId: String
        /// Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        @inlinable
        public init(agentId: String, agentVersion: String, description: String, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encode(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseId, forKey: .knowledgeBaseId)
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct AssociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with the agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct AutoToolChoice: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct BedrockDataAutomationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to enable parsing of multimodal data, including both text and/or images.
        public let parsingModality: ParsingModality?

        @inlinable
        public init(parsingModality: ParsingModality? = nil) {
            self.parsingModality = parsingModality
        }

        private enum CodingKeys: String, CodingKey {
            case parsingModality = "parsingModality"
        }
    }

    public struct BedrockEmbeddingModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dimensions details for the vector configuration used on the Bedrock embeddings model.
        public let dimensions: Int?
        /// The data type for the vectors when using a model to convert text into vector  embeddings. The model must support the specified data type for vector embeddings.  Floating-point (float32) is the default data type, and is supported by most models  for vector embeddings. See Supported embeddings  models for information on the available models and their vector data types.
        public let embeddingDataType: EmbeddingDataType?

        @inlinable
        public init(dimensions: Int? = nil, embeddingDataType: EmbeddingDataType? = nil) {
            self.dimensions = dimensions
            self.embeddingDataType = embeddingDataType
        }

        public func validate(name: String) throws {
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 4096)
            try self.validate(self.dimensions, name: "dimensions", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "dimensions"
            case embeddingDataType = "embeddingDataType"
        }
    }

    public struct BedrockFoundationModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the foundation model to use for parsing.
        public let modelArn: String
        /// Specifies whether to enable parsing of multimodal data, including both text and/or images.
        public let parsingModality: ParsingModality?
        /// Instructions for interpreting the contents of a document.
        public let parsingPrompt: ParsingPrompt?

        @inlinable
        public init(modelArn: String, parsingModality: ParsingModality? = nil, parsingPrompt: ParsingPrompt? = nil) {
            self.modelArn = modelArn
            self.parsingModality = parsingModality
            self.parsingPrompt = parsingPrompt
        }

        public func validate(name: String) throws {
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.parsingPrompt?.validate(name: "\(name).parsingPrompt")
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
            case parsingModality = "parsingModality"
            case parsingPrompt = "parsingPrompt"
        }
    }

    public struct BedrockFoundationModelContextEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        public let enrichmentStrategyConfiguration: EnrichmentStrategyConfiguration
        /// The Amazon Resource Name (ARN) of the foundation model used for context enrichment.
        public let modelArn: String

        @inlinable
        public init(enrichmentStrategyConfiguration: EnrichmentStrategyConfiguration, modelArn: String) {
            self.enrichmentStrategyConfiguration = enrichmentStrategyConfiguration
            self.modelArn = modelArn
        }

        public func validate(name: String) throws {
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case enrichmentStrategyConfiguration = "enrichmentStrategyConfiguration"
            case modelArn = "modelArn"
        }
    }

    public struct ByteContentDoc: AWSEncodableShape {
        /// The base64-encoded string of the content.
        public let data: AWSBase64Data
        /// The MIME type of the content. For a list of MIME types, see Media Types. The following MIME types are supported:   text/plain   text/html   text/csv   text/vtt   message/rfc822   application/xhtml+xml   application/pdf   application/msword   application/vnd.ms-word.document.macroenabled.12   application/vnd.ms-word.template.macroenabled.12   application/vnd.ms-excel   application/vnd.ms-excel.addin.macroenabled.12   application/vnd.ms-excel.sheet.macroenabled.12   application/vnd.ms-excel.template.macroenabled.12   application/vnd.ms-excel.sheet.binary.macroenabled.12   application/vnd.ms-spreadsheetml   application/vnd.openxmlformats-officedocument.spreadsheetml.sheet   application/vnd.openxmlformats-officedocument.spreadsheetml.template   application/vnd.openxmlformats-officedocument.wordprocessingml.document   application/vnd.openxmlformats-officedocument.wordprocessingml.template
        public let mimeType: String

        @inlinable
        public init(data: AWSBase64Data, mimeType: String) {
            self.data = data
            self.mimeType = mimeType
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 5242880)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case mimeType = "mimeType"
        }
    }

    public struct CachePointBlock: AWSEncodableShape & AWSDecodableShape {
        /// Indicates that the CachePointBlock is of the default type
        public let type: CachePointType

        @inlinable
        public init(type: CachePointType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ChatPromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of the variables in the prompt template.
        public let inputVariables: [PromptInputVariable]?
        /// Contains messages in the chat for the prompt.
        public let messages: [Message]
        /// Contains system prompts to provide context to the model or to describe how it should behave.
        public let system: [SystemContentBlock]?
        /// Configuration information for the tools that the model can use when generating a response.
        public let toolConfiguration: ToolConfiguration?

        @inlinable
        public init(inputVariables: [PromptInputVariable]? = nil, messages: [Message], system: [SystemContentBlock]? = nil, toolConfiguration: ToolConfiguration? = nil) {
            self.inputVariables = inputVariables
            self.messages = messages
            self.system = system
            self.toolConfiguration = toolConfiguration
        }

        public func validate(name: String) throws {
            try self.inputVariables?.forEach {
                try $0.validate(name: "\(name).inputVariables[]")
            }
            try self.validate(self.inputVariables, name: "inputVariables", parent: name, max: 20)
            try self.system?.forEach {
                try $0.validate(name: "\(name).system[]")
            }
            try self.toolConfiguration?.validate(name: "\(name).toolConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case inputVariables = "inputVariables"
            case messages = "messages"
            case system = "system"
            case toolConfiguration = "toolConfiguration"
        }
    }

    public struct ChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.    FIXED_SIZE – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.    HIERARCHICAL – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.    SEMANTIC – Split documents into chunks based on groups of similar content derived with natural language processing.    NONE – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        public let chunkingStrategy: ChunkingStrategy
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public let fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public let hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        public let semanticChunkingConfiguration: SemanticChunkingConfiguration?

        @inlinable
        public init(chunkingStrategy: ChunkingStrategy, fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration? = nil, hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration? = nil, semanticChunkingConfiguration: SemanticChunkingConfiguration? = nil) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }

        public func validate(name: String) throws {
            try self.hierarchicalChunkingConfiguration?.validate(name: "\(name).hierarchicalChunkingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingStrategy = "chunkingStrategy"
            case fixedSizeChunkingConfiguration = "fixedSizeChunkingConfiguration"
            case hierarchicalChunkingConfiguration = "hierarchicalChunkingConfiguration"
            case semanticChunkingConfiguration = "semanticChunkingConfiguration"
        }
    }

    public struct CollectorFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct ConditionFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of conditions. Each member contains the name of a condition and an expression that defines the condition.
        public let conditions: [FlowCondition]

        @inlinable
        public init(conditions: [FlowCondition]) {
            self.conditions = conditions
        }

        public func validate(name: String) throws {
            try self.conditions.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, max: 5)
            try self.validate(self.conditions, name: "conditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "conditions"
        }
    }

    public struct ConfluenceCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the Confluence content. For example, configuring  regular expression patterns to include or exclude certain content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct ConfluenceDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Confluence content. For example, configuring  specific types of Confluence content.
        public let crawlerConfiguration: ConfluenceCrawlerConfiguration?
        /// The endpoint information to connect to your Confluence data source.
        public let sourceConfiguration: ConfluenceSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: ConfluenceCrawlerConfiguration? = nil, sourceConfiguration: ConfluenceSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct ConfluenceSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect to your  Confluence instance.
        public let authType: ConfluenceAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your Confluence instance URL.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  Confluence connection configuration.
        public let credentialsSecretArn: String
        /// The supported host type, whether online/cloud or server/on-premises.
        public let hostType: ConfluenceHostType
        /// The Confluence host URL or instance URL.
        public let hostUrl: String

        @inlinable
        public init(authType: ConfluenceAuthType, credentialsSecretArn: String, hostType: ConfluenceHostType, hostUrl: String) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostType = hostType
            self.hostUrl = hostUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.hostUrl, name: "hostUrl", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case hostType = "hostType"
            case hostUrl = "hostUrl"
        }
    }

    public struct ContextEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Amazon Bedrock foundation model used for context enrichment.
        public let bedrockFoundationModelConfiguration: BedrockFoundationModelContextEnrichmentConfiguration?
        /// The method used for context enrichment. It must be Amazon Bedrock foundation models.
        public let type: ContextEnrichmentType

        @inlinable
        public init(bedrockFoundationModelConfiguration: BedrockFoundationModelContextEnrichmentConfiguration? = nil, type: ContextEnrichmentType) {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.bedrockFoundationModelConfiguration?.validate(name: "\(name).bedrockFoundationModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockFoundationModelConfiguration = "bedrockFoundationModelConfiguration"
            case type = "type"
        }
    }

    public struct CrawlFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering certain objects or content types of the data source.
        public let patternObjectFilter: PatternObjectFilterConfiguration?
        /// The type of filtering that you want to apply to certain objects or content of the  data source. For example, the PATTERN type is regular expression patterns  you can apply to filter your content.
        public let type: CrawlFilterConfigurationType

        @inlinable
        public init(patternObjectFilter: PatternObjectFilterConfiguration? = nil, type: CrawlFilterConfigurationType) {
            self.patternObjectFilter = patternObjectFilter
            self.type = type
        }

        public func validate(name: String) throws {
            try self.patternObjectFilter?.validate(name: "\(name).patternObjectFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case patternObjectFilter = "patternObjectFilter"
            case type = "type"
        }
    }

    public struct CreateAgentActionGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The name to give the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to create the action group.
        public let agentId: String
        /// The version of the agent for which to create the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the action group.
        public let description: String?
        /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let functionSchema: FunctionSchema?
        /// Specify a built-in or computer use action for this action group. If you specify a value, you must leave the description, apiSchema, and actionGroupExecutor fields empty for this action group.    To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.    To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter.   To allow your agent to use an Anthropic computer use tool, specify one of the following values.    Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only.           When operating computer use functionality, we recommend taking additional security precautions, such as executing computer actions in virtual environments with restricted data access and limited internet connectivity.  For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.      ANTHROPIC.Computer - Gives the agent permission to use the mouse and keyboard and take screenshots.    ANTHROPIC.TextEditor - Gives the agent permission to view, create and edit files.    ANTHROPIC.Bash - Gives the agent permission to run commands in a bash shell.
        public let parentActionGroupSignature: ActionGroupSignature?
        /// The configuration settings for a computer use action.   Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.
        public let parentActionGroupSignatureParams: [String: String]?

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, clientToken: String? = CreateAgentActionGroupRequest.idempotencyToken(), description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignature: ActionGroupSignature? = nil, parentActionGroupSignatureParams: [String: String]? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
            self.parentActionGroupSignatureParams = parentActionGroupSignatureParams
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.functionSchema, forKey: .functionSchema)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
            try container.encodeIfPresent(self.parentActionGroupSignatureParams, forKey: .parentActionGroupSignatureParams)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.functionSchema?.validate(name: "\(name).functionSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case clientToken = "clientToken"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignature = "parentActionGroupSignature"
            case parentActionGroupSignatureParams = "parentActionGroupSignatureParams"
        }
    }

    public struct CreateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was created.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct CreateAgentAliasRequest: AWSEncodableShape {
        /// The name of the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the alias of the agent.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?
        /// Any tags that you want to attach to the alias of the agent.
        public let tags: [String: String]?

        @inlinable
        public init(agentAliasName: String, agentId: String, clientToken: String? = CreateAgentAliasRequest.idempotencyToken(), description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil, tags: [String: String]? = nil) {
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.clientToken = clientToken
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case clientToken = "clientToken"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was created.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct CreateAgentRequest: AWSEncodableShape {
        /// The agent's collaboration role.
        public let agentCollaboration: AgentCollaboration?
        /// A name for the agent that you create.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        ///  Contains details of the custom orchestration configured for the agent.
        public let customOrchestration: CustomOrchestration?
        /// A description of the agent.
        public let description: String?
        /// The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
        public let foundationModel: String?
        /// The unique Guardrail configuration assigned to the agent when it is created.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        ///  Contains the details of the memory configured for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        ///  Specifies the type of orchestration strategy for the agent. This is set to DEFAULT orchestration type, by default.
        public let orchestrationType: OrchestrationType?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        /// Any tags that you want to attach to the agent.
        public let tags: [String: String]?

        @inlinable
        public init(agentCollaboration: AgentCollaboration? = nil, agentName: String, agentResourceRoleArn: String? = nil, clientToken: String? = CreateAgentRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, customOrchestration: CustomOrchestration? = nil, description: String? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, orchestrationType: OrchestrationType? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, tags: [String: String]? = nil) {
            self.agentCollaboration = agentCollaboration
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.customOrchestration = customOrchestration
            self.description = description
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.orchestrationType = orchestrationType
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.customOrchestration?.validate(name: "\(name).customOrchestration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 4000)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.memoryConfiguration?.validate(name: "\(name).memoryConfiguration")
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaboration = "agentCollaboration"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case customOrchestration = "customOrchestration"
            case description = "description"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case orchestrationType = "orchestrationType"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent created.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The data deletion policy for the data source. You can set the data deletion policy to:   DELETE: Deletes all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted,  only the data. This flag is ignored if an Amazon Web Services account is deleted.   RETAIN: Retains all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted  if you delete a knowledge base or data source resource.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// A description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which to add the data source.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the server-side encryption for the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(clientToken: String? = CreateDataSourceRequest.idempotencyToken(), dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.clientToken = clientToken
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.dataDeletionPolicy, forKey: .dataDeletionPolicy)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateFlowAliasRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description for the alias.
        public let description: String?
        /// The unique identifier of the flow for which to create an alias.
        public let flowIdentifier: String
        /// A name for the alias.
        public let name: String
        /// Contains information about the version to which to map the alias.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// Any tags that you want to attach to the alias of the flow. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFlowAliasRequest.idempotencyToken(), description: String? = nil, flowIdentifier: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.flowIdentifier = flowIdentifier
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.routingConfiguration, forKey: .routingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.routingConfiguration.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let arn: String
        /// The time at which the alias was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the alias.
        public let description: String?
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the alias.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias of the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateFlowRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// A description for the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// A name for the flow.
        public let name: String
        /// Any tags that you want to attach to the flow. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFlowRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the flow with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If creation fails, the status becomes Failed.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the flow. When you create a flow, the version created is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct CreateFlowVersionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the version of the flow.
        public let description: String?
        /// The unique identifier of the flow that you want to create a version of.
        public let flowIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateFlowVersionRequest.idempotencyToken(), description: String? = nil, flowIdentifier: String) {
            self.clientToken = clientToken
            self.description = description
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct CreateFlowVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The KMS key that the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and connections in the flow.
        public let definition: FlowDefinition?
        /// The description of the version.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the version.
        public let name: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow that was created. Versions are numbered incrementally, starting from 1.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case version = "version"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description of the knowledge base.
        public let description: String?
        /// Contains details about the embeddings model used for the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// A name for the knowledge base.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// Contains details about the configuration of the vector database used for the knowledge base.
        public let storageConfiguration: StorageConfiguration?
        /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, name: String, roleArn: String, storageConfiguration: StorageConfiguration? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration?.validate(name: "\(name).storageConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct CreatePromptRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the prompt.
        public let description: String?
        /// A name for the prompt.
        public let name: String
        /// Any tags that you want to attach to the prompt. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?

        @inlinable
        public init(clientToken: String? = CreatePromptRequest.idempotencyToken(), customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, name: String, tags: [String: String]? = nil, variants: [PromptVariant]? = nil) {
            self.clientToken = clientToken
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.name = name
            self.tags = tags
            self.variants = variants
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.defaultVariant, name: "defaultVariant", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.variants?.forEach {
                try $0.validate(name: "\(name).variants[]")
            }
            try self.validate(self.variants, name: "variants", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case variants = "variants"
        }
    }

    public struct CreatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the prompt with.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for your prompt.
        public let defaultVariant: String?
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt. When you create a prompt, the version created is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct CreatePromptVersionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// A description for the version of the prompt.
        public let description: String?
        /// The unique identifier of the prompt that you want to create a version of.
        public let promptIdentifier: String
        /// Any tags that you want to attach to the version of the prompt. For more information, see Tagging resources in Amazon Bedrock.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreatePromptVersionRequest.idempotencyToken(), description: String? = nil, promptIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.promptIdentifier = promptIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case tags = "tags"
        }
    }

    public struct CreatePromptVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the version of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the version of the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the version.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt that was created. Versions are numbered incrementally, starting from 1.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct CuratedQuery: AWSEncodableShape & AWSDecodableShape {
        /// An example natural language query.
        public let naturalLanguage: String
        /// The SQL equivalent of the natural language query.
        public let sql: String

        @inlinable
        public init(naturalLanguage: String, sql: String) {
            self.naturalLanguage = naturalLanguage
            self.sql = sql
        }

        public func validate(name: String) throws {
            try self.validate(self.naturalLanguage, name: "naturalLanguage", parent: name, max: 1000)
            try self.validate(self.naturalLanguage, name: "naturalLanguage", parent: name, min: 1)
            try self.validate(self.sql, name: "sql", parent: name, max: 1000)
            try self.validate(self.sql, name: "sql", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case naturalLanguage = "naturalLanguage"
            case sql = "sql"
        }
    }

    public struct CustomContent: AWSEncodableShape {
        /// A unique identifier for the document.
        public let customDocumentIdentifier: CustomDocumentIdentifier
        /// Contains information about content defined inline to ingest into a knowledge base.
        public let inlineContent: InlineContent?
        /// Contains information about the Amazon S3 location of the file from which to ingest data.
        public let s3Location: CustomS3Location?
        /// The source of the data to ingest.
        public let sourceType: CustomSourceType

        @inlinable
        public init(customDocumentIdentifier: CustomDocumentIdentifier, inlineContent: InlineContent? = nil, s3Location: CustomS3Location? = nil, sourceType: CustomSourceType) {
            self.customDocumentIdentifier = customDocumentIdentifier
            self.inlineContent = inlineContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.inlineContent?.validate(name: "\(name).inlineContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case customDocumentIdentifier = "customDocumentIdentifier"
            case inlineContent = "inlineContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct CustomDocumentIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the document to ingest into a custom data source.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CustomOrchestration: AWSEncodableShape & AWSDecodableShape {
        ///  The structure of the executor invoking the actions in custom orchestration.
        public let executor: OrchestrationExecutor?

        @inlinable
        public init(executor: OrchestrationExecutor? = nil) {
            self.executor = executor
        }

        public func validate(name: String) throws {
            try self.executor?.validate(name: "\(name).executor")
        }

        private enum CodingKeys: String, CodingKey {
            case executor = "executor"
        }
    }

    public struct CustomS3Location: AWSEncodableShape {
        /// The identifier of the Amazon Web Services account that owns the S3 bucket containing the content to ingest.
        public let bucketOwnerAccountId: String?
        /// The S3 URI of the file containing the content to ingest.
        public let uri: String

        @inlinable
        public init(bucketOwnerAccountId: String? = nil, uri: String) {
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, max: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, min: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case uri = "uri"
        }
    }

    public struct CustomTransformationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An S3 bucket path for input and output objects.
        public let intermediateStorage: IntermediateStorage
        /// A Lambda function that processes documents.
        public let transformations: [Transformation]

        @inlinable
        public init(intermediateStorage: IntermediateStorage, transformations: [Transformation]) {
            self.intermediateStorage = intermediateStorage
            self.transformations = transformations
        }

        public func validate(name: String) throws {
            try self.intermediateStorage.validate(name: "\(name).intermediateStorage")
            try self.transformations.forEach {
                try $0.validate(name: "\(name).transformations[]")
            }
            try self.validate(self.transformations, name: "transformations", parent: name, max: 1)
            try self.validate(self.transformations, name: "transformations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateStorage = "intermediateStorage"
            case transformations = "transformations"
        }
    }

    public struct CyclicConnectionFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection that causes the cycle in the flow.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The time at which the data source was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The data deletion policy for the data source.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The detailed reasons on the failure to delete a data source.
        public let failureReasons: [String]?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// Contains details about the configuration of the server-side encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:   Available – The data source has been created and is ready for ingestion into the knowledge base.   Deleting – The data source is being deleted.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(createdAt: Date, dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, failureReasons: [String]? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: DataSourceStatus, updatedAt: Date, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.createdAt = createdAt
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case failureReasons = "failureReasons"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case updatedAt = "updatedAt"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information to connect to Confluence as your data source.  Confluence data source connector is in preview release and is subject to change.
        public let confluenceConfiguration: ConfluenceDataSourceConfiguration?
        /// The configuration information to connect to Amazon S3 as your data source.
        public let s3Configuration: S3DataSourceConfiguration?
        /// The configuration information to connect to Salesforce as your data source.  Salesforce data source connector is in preview release and is subject to change.
        public let salesforceConfiguration: SalesforceDataSourceConfiguration?
        /// The configuration information to connect to SharePoint as your data source.  SharePoint data source connector is in preview release and is subject to change.
        public let sharePointConfiguration: SharePointDataSourceConfiguration?
        /// The type of data source.
        public let type: DataSourceType
        /// The configuration of web URLs to crawl for your data source.  You should be authorized to crawl the URLs.  Crawling web URLs as your data source is in preview release  and is subject to change.
        public let webConfiguration: WebDataSourceConfiguration?

        @inlinable
        public init(confluenceConfiguration: ConfluenceDataSourceConfiguration? = nil, s3Configuration: S3DataSourceConfiguration? = nil, salesforceConfiguration: SalesforceDataSourceConfiguration? = nil, sharePointConfiguration: SharePointDataSourceConfiguration? = nil, type: DataSourceType, webConfiguration: WebDataSourceConfiguration? = nil) {
            self.confluenceConfiguration = confluenceConfiguration
            self.s3Configuration = s3Configuration
            self.salesforceConfiguration = salesforceConfiguration
            self.sharePointConfiguration = sharePointConfiguration
            self.type = type
            self.webConfiguration = webConfiguration
        }

        public func validate(name: String) throws {
            try self.confluenceConfiguration?.validate(name: "\(name).confluenceConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
            try self.salesforceConfiguration?.validate(name: "\(name).salesforceConfiguration")
            try self.sharePointConfiguration?.validate(name: "\(name).sharePointConfiguration")
            try self.webConfiguration?.validate(name: "\(name).webConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case confluenceConfiguration = "confluenceConfiguration"
            case s3Configuration = "s3Configuration"
            case salesforceConfiguration = "salesforceConfiguration"
            case sharePointConfiguration = "sharePointConfiguration"
            case type = "type"
            case webConfiguration = "webConfiguration"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The description of the data source.
        public let description: String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        public let knowledgeBaseId: String
        /// The name of the data source.
        public let name: String
        /// The status of the data source.
        public let status: DataSourceStatus
        /// The time at which the data source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, status: DataSourceStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group to delete.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(actionGroupId: String, agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentActionGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias to delete.
        public let agentAliasId: String
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentAliasResponse: AWSDecodableShape {
        /// The unique identifier of the alias that was deleted.
        public let agentAliasId: String
        /// The status of the alias.
        public let agentAliasStatus: AgentAliasStatus
        /// The unique identifier of the agent that the alias belongs to.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentAliasStatus: AgentAliasStatus, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentAliasStatus = "agentAliasStatus"
            case agentId = "agentId"
        }
    }

    public struct DeleteAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent to delete.
        public let agentId: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(agentId: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent that was deleted.
        public let agentId: String
        /// The status of the agent.
        public let agentStatus: AgentStatus

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus) {
            self.agentId = agentId
            self.agentStatus = agentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
        }
    }

    public struct DeleteAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The version of the agent to delete.
        public let agentVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(agentId: String, agentVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentVersionResponse: AWSDecodableShape {
        /// The unique identifier of the agent that the version belongs to.
        public let agentId: String
        /// The status of the agent version.
        public let agentStatus: AgentStatus
        /// The version that was deleted.
        public let agentVersion: String

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source to delete.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base from which to delete the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        /// The unique identifier of the data source that was deleted.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
        public let knowledgeBaseId: String
        /// The status of the data source.
        public let status: DataSourceStatus

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String, status: DataSourceStatus) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DeleteFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias to be deleted.
        public let aliasIdentifier: String
        /// The unique identifier of the flow that the alias belongs to.
        public let flowIdentifier: String

        @inlinable
        public init(aliasIdentifier: String, flowIdentifier: String) {
            self.aliasIdentifier = aliasIdentifier
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowAliasResponse: AWSDecodableShape {
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the flow.
        public let id: String

        @inlinable
        public init(flowId: String, id: String) {
            self.flowId = flowId
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "flowId"
            case id = "id"
        }
    }

    public struct DeleteFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(flowIdentifier: String, skipResourceInUseCheck: Bool? = nil) {
            self.flowIdentifier = flowIdentifier
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteFlowVersionRequest: AWSEncodableShape {
        /// The unique identifier of the flow whose version that you want to delete
        public let flowIdentifier: String
        /// The version of the flow that you want to delete.
        public let flowVersion: String
        /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(flowIdentifier: String, flowVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.flowIdentifier = flowIdentifier
            self.flowVersion = flowVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodePath(self.flowVersion, key: "flowVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFlowVersionResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String
        /// The version of the flow being deleted.
        public let version: String

        @inlinable
        public init(id: String, version: String) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case version = "version"
        }
    }

    public struct DeleteKnowledgeBaseDocumentsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The unique identifier of the data source that contains the documents.
        public let dataSourceId: String
        /// A list of objects, each of which contains information to identify a document to delete.
        public let documentIdentifiers: [DocumentIdentifier]
        /// The unique identifier of the knowledge base that is connected to the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(clientToken: String? = DeleteKnowledgeBaseDocumentsRequest.idempotencyToken(), dataSourceId: String, documentIdentifiers: [DocumentIdentifier], knowledgeBaseId: String) {
            self.clientToken = clientToken
            self.dataSourceId = dataSourceId
            self.documentIdentifiers = documentIdentifiers
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encode(self.documentIdentifiers, forKey: .documentIdentifiers)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.documentIdentifiers.forEach {
                try $0.validate(name: "\(name).documentIdentifiers[]")
            }
            try self.validate(self.documentIdentifiers, name: "documentIdentifiers", parent: name, max: 10)
            try self.validate(self.documentIdentifiers, name: "documentIdentifiers", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case documentIdentifiers = "documentIdentifiers"
        }
    }

    public struct DeleteKnowledgeBaseDocumentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about the documents that were deleted.
        public let documentDetails: [KnowledgeBaseDocumentDetail]?

        @inlinable
        public init(documentDetails: [KnowledgeBaseDocumentDetail]? = nil) {
            self.documentDetails = documentDetails
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetails = "documentDetails"
        }
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base to delete.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        /// The unique identifier of the knowledge base that was deleted.
        public let knowledgeBaseId: String
        /// The status of the knowledge base and whether it has been successfully deleted.
        public let status: KnowledgeBaseStatus

        @inlinable
        public init(knowledgeBaseId: String, status: KnowledgeBaseStatus) {
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
        }
    }

    public struct DeletePromptRequest: AWSEncodableShape {
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// The version of the prompt to delete. To delete the prompt, omit this field.
        public let promptVersion: String?

        @inlinable
        public init(promptIdentifier: String, promptVersion: String? = nil) {
            self.promptIdentifier = promptIdentifier
            self.promptVersion = promptVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            request.encodeQuery(self.promptVersion, key: "promptVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePromptResponse: AWSDecodableShape {
        /// The unique identifier of the prompt that was deleted.
        public let id: String
        /// The version of the prompt that was deleted.
        public let version: String?

        @inlinable
        public init(id: String, version: String? = nil) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case version = "version"
        }
    }

    public struct DisassociateAgentCollaboratorRequest: AWSEncodableShape {
        /// An agent ID.
        public let agentId: String
        /// The agent's version.
        public let agentVersion: String
        /// The collaborator's ID.
        public let collaboratorId: String

        @inlinable
        public init(agentId: String, agentVersion: String, collaboratorId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.collaboratorId = collaboratorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.collaboratorId, key: "collaboratorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.collaboratorId, name: "collaboratorId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateAgentCollaboratorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent from which to disassociate the knowledge base.
        public let agentId: String
        /// The version of the agent from which to disassociate the knowledge base.
        public let agentVersion: String
        /// The unique identifier of the knowledge base to disassociate.
        public let knowledgeBaseId: String

        @inlinable
        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateAgentKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DocumentContent: AWSEncodableShape {
        /// Contains information about the content to ingest into a knowledge base connected to a custom data source.
        public let custom: CustomContent?
        /// The type of data source that is connected to the knowledge base to which to ingest this document.
        public let dataSourceType: ContentDataSourceType
        /// Contains information about the content to ingest into a knowledge base connected to an Amazon S3 data source
        public let s3: S3Content?

        @inlinable
        public init(custom: CustomContent? = nil, dataSourceType: ContentDataSourceType, s3: S3Content? = nil) {
            self.custom = custom
            self.dataSourceType = dataSourceType
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.custom?.validate(name: "\(name).custom")
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case custom = "custom"
            case dataSourceType = "dataSourceType"
            case s3 = "s3"
        }
    }

    public struct DocumentIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// Contains information that identifies the document in a custom data source.
        public let custom: CustomDocumentIdentifier?
        /// The type of data source connected to the knowledge base that contains the document.
        public let dataSourceType: ContentDataSourceType
        /// Contains information that identifies the document in an S3 data source.
        public let s3: S3Location?

        @inlinable
        public init(custom: CustomDocumentIdentifier? = nil, dataSourceType: ContentDataSourceType, s3: S3Location? = nil) {
            self.custom = custom
            self.dataSourceType = dataSourceType
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case custom = "custom"
            case dataSourceType = "dataSourceType"
            case s3 = "s3"
        }
    }

    public struct DocumentMetadata: AWSEncodableShape {
        /// An array of objects, each of which defines a metadata attribute to associate with the content to ingest. You define the attributes inline.
        public let inlineAttributes: [MetadataAttribute]?
        /// The Amazon S3 location of the file containing metadata to associate with the content to ingest.
        public let s3Location: CustomS3Location?
        /// The type of the source source from which to add metadata.
        public let type: MetadataSourceType

        @inlinable
        public init(inlineAttributes: [MetadataAttribute]? = nil, s3Location: CustomS3Location? = nil, type: MetadataSourceType) {
            self.inlineAttributes = inlineAttributes
            self.s3Location = s3Location
            self.type = type
        }

        public func validate(name: String) throws {
            try self.inlineAttributes?.forEach {
                try $0.validate(name: "\(name).inlineAttributes[]")
            }
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case inlineAttributes = "inlineAttributes"
            case s3Location = "s3Location"
            case type = "type"
        }
    }

    public struct DuplicateConditionExpressionFlowValidationDetails: AWSDecodableShape {
        /// The duplicated condition expression.
        public let expression: String
        /// The name of the node containing the duplicate condition expressions.
        public let node: String

        @inlinable
        public init(expression: String, node: String) {
            self.expression = expression
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case node = "node"
        }
    }

    public struct DuplicateConnectionsFlowValidationDetails: AWSDecodableShape {
        /// The name of the source node where the duplicate connection starts.
        public let source: String
        /// The name of the target node where the duplicate connection ends.
        public let target: String

        @inlinable
        public init(source: String, target: String) {
            self.source = source
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case target = "target"
        }
    }

    public struct EmbeddingModelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The vector configuration details on the Bedrock embeddings model.
        public let bedrockEmbeddingModelConfiguration: BedrockEmbeddingModelConfiguration?

        @inlinable
        public init(bedrockEmbeddingModelConfiguration: BedrockEmbeddingModelConfiguration? = nil) {
            self.bedrockEmbeddingModelConfiguration = bedrockEmbeddingModelConfiguration
        }

        public func validate(name: String) throws {
            try self.bedrockEmbeddingModelConfiguration?.validate(name: "\(name).bedrockEmbeddingModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockEmbeddingModelConfiguration = "bedrockEmbeddingModelConfiguration"
        }
    }

    public struct EnrichmentStrategyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The method used for the context enrichment strategy.
        public let method: EnrichmentStrategyMethod

        @inlinable
        public init(method: EnrichmentStrategyMethod) {
            self.method = method
        }

        private enum CodingKeys: String, CodingKey {
            case method = "method"
        }
    }

    public struct FixedSizeChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to include in a chunk.
        public let maxTokens: Int
        /// The percentage of overlap between adjacent chunks of a data source.
        public let overlapPercentage: Int

        @inlinable
        public init(maxTokens: Int, overlapPercentage: Int) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case overlapPercentage = "overlapPercentage"
        }
    }

    public struct FlowAliasRoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The version that the alias maps to.
        public let flowVersion: String?

        @inlinable
        public init(flowVersion: String? = nil) {
            self.flowVersion = flowVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, max: 5)
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, min: 1)
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowVersion = "flowVersion"
        }
    }

    public struct FlowAliasSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let arn: String
        /// The time at which the alias was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the alias.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowId: String
        /// The unique identifier of the alias of the flow.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// A list of configurations about the versions that the alias maps to. Currently, you can only specify one.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct FlowCondition: AWSEncodableShape & AWSDecodableShape {
        /// Defines the condition. You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in Node types in prompt flows.
        public let expression: String?
        /// A name for the condition that you can reference.
        public let name: String

        @inlinable
        public init(expression: String? = nil, name: String) {
            self.expression = expression
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 64)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case name = "name"
        }
    }

    public struct FlowConditionalConnectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The condition that triggers this connection. For more information about how to write conditions, see the Condition node type in the Node types topic in the Amazon Bedrock User Guide.
        public let condition: String

        @inlinable
        public init(condition: String) {
            self.condition = condition
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
        }
    }

    public struct FlowConnection: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the connection.
        public let configuration: FlowConnectionConfiguration?
        /// A name for the connection that you can reference.
        public let name: String
        /// The node that the connection starts at.
        public let source: String
        /// The node that the connection ends at.
        public let target: String
        /// Whether the source node that the connection begins from is a condition node (Conditional) or not (Data).
        public let type: FlowConnectionType

        @inlinable
        public init(configuration: FlowConnectionConfiguration? = nil, name: String, source: String, target: String, type: FlowConnectionType) {
            self.configuration = configuration
            self.name = name
            self.source = source
            self.target = target
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,100}$")
            try self.validate(self.source, name: "source", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.validate(self.target, name: "target", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case name = "name"
            case source = "source"
            case target = "target"
            case type = "type"
        }
    }

    public struct FlowDataConnectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the output in the source node that the connection begins from.
        public let sourceOutput: String
        /// The name of the input in the target node that the connection ends at.
        public let targetInput: String

        @inlinable
        public init(sourceOutput: String, targetInput: String) {
            self.sourceOutput = sourceOutput
            self.targetInput = targetInput
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceOutput, name: "sourceOutput", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.validate(self.targetInput, name: "targetInput", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceOutput = "sourceOutput"
            case targetInput = "targetInput"
        }
    }

    public struct FlowDefinition: AWSEncodableShape & AWSDecodableShape {
        /// An array of connection definitions in the flow.
        public let connections: [FlowConnection]?
        /// An array of node definitions in the flow.
        public let nodes: [FlowNode]?

        @inlinable
        public init(connections: [FlowConnection]? = nil, nodes: [FlowNode]? = nil) {
            self.connections = connections
            self.nodes = nodes
        }

        public func validate(name: String) throws {
            try self.connections?.forEach {
                try $0.validate(name: "\(name).connections[]")
            }
            try self.validate(self.connections, name: "connections", parent: name, max: 20)
            try self.nodes?.forEach {
                try $0.validate(name: "\(name).nodes[]")
            }
            try self.validate(self.nodes, name: "nodes", parent: name, max: 40)
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
            case nodes = "nodes"
        }
    }

    public struct FlowNode: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the node.
        public let configuration: FlowNodeConfiguration?
        /// An array of objects, each of which contains information about an input into the node.
        public let inputs: [FlowNodeInput]?
        /// A name for the node.
        public let name: String
        /// A list of objects, each of which contains information about an output from the node.
        public let outputs: [FlowNodeOutput]?
        /// The type of node. This value must match the name of the key that you provide in the configuration you provide in the FlowNodeConfiguration field.
        public let type: FlowNodeType

        @inlinable
        public init(configuration: FlowNodeConfiguration? = nil, inputs: [FlowNodeInput]? = nil, name: String, outputs: [FlowNodeOutput]? = nil, type: FlowNodeType) {
            self.configuration = configuration
            self.inputs = inputs
            self.name = name
            self.outputs = outputs
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.inputs?.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 20)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case inputs = "inputs"
            case name = "name"
            case outputs = "outputs"
            case type = "type"
        }
    }

    public struct FlowNodeInput: AWSEncodableShape & AWSDecodableShape {
        /// An expression that formats the input for the node. For an explanation of how to create expressions, see Expressions in Prompt flows in Amazon Bedrock.
        public let expression: String
        /// A name for the input that you can reference.
        public let name: String
        /// The data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        public let type: FlowNodeIODataType

        @inlinable
        public init(expression: String, name: String, type: FlowNodeIODataType) {
            self.expression = expression
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 64)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case name = "name"
            case type = "type"
        }
    }

    public struct FlowNodeOutput: AWSEncodableShape & AWSDecodableShape {
        /// A name for the output that you can reference.
        public let name: String
        /// The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        public let type: FlowNodeIODataType

        @inlinable
        public init(name: String, type: FlowNodeIODataType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct FlowSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the flow.
        public let description: String?
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. The following statuses are possible:   NotPrepared – The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a PrepareFlow request to package the latest changes into the DRAFT version.   Preparing – The flow is being prepared so that the DRAFT version contains the latest changes for testing.   Prepared – The flow is prepared and the DRAFT version contains the latest changes for testing.   Failed – The last API operation that you invoked on the flow failed. Send a GetFlow request and check the error message in the validations field.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The latest version of the flow.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct FlowValidation: AWSDecodableShape {
        /// Specific details about the validation issue encountered in the flow.
        public let details: FlowValidationDetails?
        /// A message describing the validation error.
        public let message: String
        /// The severity of the issue described in the message.
        public let severity: FlowValidationSeverity
        /// The type of validation issue encountered in the flow.
        public let type: FlowValidationType?

        @inlinable
        public init(details: FlowValidationDetails? = nil, message: String, severity: FlowValidationSeverity, type: FlowValidationType? = nil) {
            self.details = details
            self.message = message
            self.severity = severity
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case message = "message"
            case severity = "severity"
            case type = "type"
        }
    }

    public struct FlowVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow that the version belongs to.
        public let arn: String
        /// The time at the version was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the flow.
        public let id: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, id: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case version = "version"
        }
    }

    public struct Function: AWSEncodableShape & AWSDecodableShape {
        /// A description of the function and its purpose.
        public let description: String?
        /// A name for the function.
        public let name: String
        /// The parameters that the agent elicits from the user to fulfill the function.
        public let parameters: [String: ParameterDetail]?
        /// Contains information if user confirmation is required to invoke the function.
        public let requireConfirmation: RequireConfirmation?

        @inlinable
        public init(description: String? = nil, name: String, parameters: [String: ParameterDetail]? = nil, requireConfirmation: RequireConfirmation? = nil) {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.requireConfirmation = requireConfirmation
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
            case requireConfirmation = "requireConfirmation"
        }
    }

    public struct GetAgentActionGroupRequest: AWSEncodableShape {
        /// The unique identifier of the action group for which to get information.
        public let actionGroupId: String
        /// The unique identifier of the agent that the action group belongs to.
        public let agentId: String
        /// The version of the agent that the action group belongs to.
        public let agentVersion: String

        @inlinable
        public init(actionGroupId: String, agentId: String, agentVersion: String) {
            self.actionGroupId = actionGroupId
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct GetAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias for which to get information.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias to get information belongs.
        public let agentId: String

        @inlinable
        public init(agentAliasId: String, agentId: String) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentAliasResponse: AWSDecodableShape {
        /// Contains information about the alias.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct GetAgentCollaboratorRequest: AWSEncodableShape {
        /// The agent's ID.
        public let agentId: String
        /// The agent's version.
        public let agentVersion: String
        /// The collaborator's ID.
        public let collaboratorId: String

        @inlinable
        public init(agentId: String, agentVersion: String, collaboratorId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.collaboratorId = collaboratorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.collaboratorId, key: "collaboratorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.collaboratorId, name: "collaboratorId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentCollaboratorResponse: AWSDecodableShape {
        /// Details about the collaborator.
        public let agentCollaborator: AgentCollaborator

        @inlinable
        public init(agentCollaborator: AgentCollaborator) {
            self.agentCollaborator = agentCollaborator
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaborator = "agentCollaborator"
        }
    }

    public struct GetAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent with which the knowledge base is associated.
        public let agentId: String
        /// The version of the agent with which the knowledge base is associated.
        public let agentVersion: String
        /// The unique identifier of the knowledge base associated with the agent.
        public let knowledgeBaseId: String

        @inlinable
        public init(agentId: String, agentVersion: String, knowledgeBaseId: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about a knowledge base attached to an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct GetAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentResponse: AWSDecodableShape {
        /// Contains details about the agent.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct GetAgentVersionRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String

        @inlinable
        public init(agentId: String, agentVersion: String) {
            self.agentId = agentId
            self.agentVersion = agentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentVersionResponse: AWSDecodableShape {
        /// Contains details about the version of the agent.
        public let agentVersion: AgentVersion

        @inlinable
        public init(agentVersion: AgentVersion) {
            self.agentVersion = agentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersion = "agentVersion"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base for the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias for which to retrieve information.
        public let aliasIdentifier: String
        /// The unique identifier of the flow that the alias belongs to.
        public let flowIdentifier: String

        @inlinable
        public init(aliasIdentifier: String, flowIdentifier: String) {
            self.aliasIdentifier = aliasIdentifier
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the flow.
        public let description: String?
        /// The unique identifier of the flow that the alias belongs to.
        public let flowId: String
        /// The unique identifier of the alias of the flow.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String

        @inlinable
        public init(flowIdentifier: String) {
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The definition of the nodes and connections between the nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow.  For more information, see Create a service row for flows in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. The following statuses are possible:   NotPrepared – The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a PrepareFlow request to package the latest changes into the DRAFT version.   Preparing – The flow is being prepared so that the DRAFT version contains the latest changes for testing.   Prepared – The flow is prepared and the DRAFT version contains the latest changes for testing.   Failed – The last API operation that you invoked on the flow failed. Send a GetFlow request and check the error message in the validations field.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of validation error messages related to the last failed operation on the flow.
        public let validations: [FlowValidation]?
        /// The version of the flow for which information was retrieved.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, validations: [FlowValidation]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.validations = validations
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case validations = "validations"
            case version = "version"
        }
    }

    public struct GetFlowVersionRequest: AWSEncodableShape {
        /// The unique identifier of the flow for which to get information.
        public let flowIdentifier: String
        /// The version of the flow for which to get information.
        public let flowVersion: String

        @inlinable
        public init(flowIdentifier: String, flowVersion: String) {
            self.flowIdentifier = flowIdentifier
            self.flowVersion = flowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodePath(self.flowVersion, key: "flowVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.flowVersion, name: "flowVersion", parent: name, pattern: "^[0-9]{1,5}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the version of the flow is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The definition of the nodes and connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the version.
        public let name: String
        /// The status of the flow.
        public let status: FlowStatus
        /// The version of the flow for which information was retrieved.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case version = "version"
        }
    }

    public struct GetIngestionJobRequest: AWSEncodableShape {
        /// The unique identifier of the data source for the data ingestion job you want to get information on.
        public let dataSourceId: String
        /// The unique identifier of the data ingestion job you want to get information on.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base for the data ingestion job you want to get information on.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, ingestionJobId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.ingestionJobId, key: "ingestionJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.ingestionJobId, name: "ingestionJobId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIngestionJobResponse: AWSDecodableShape {
        /// Contains details about the data ingestion job.
        public let ingestionJob: IngestionJob

        @inlinable
        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct GetKnowledgeBaseDocumentsRequest: AWSEncodableShape {
        /// The unique identifier of the data source that contains the documents.
        public let dataSourceId: String
        /// A list of objects, each of which contains information to identify a document for which to retrieve information.
        public let documentIdentifiers: [DocumentIdentifier]
        /// The unique identifier of the knowledge base that is connected to the data source.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, documentIdentifiers: [DocumentIdentifier], knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.documentIdentifiers = documentIdentifiers
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encode(self.documentIdentifiers, forKey: .documentIdentifiers)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.documentIdentifiers.forEach {
                try $0.validate(name: "\(name).documentIdentifiers[]")
            }
            try self.validate(self.documentIdentifiers, name: "documentIdentifiers", parent: name, max: 10)
            try self.validate(self.documentIdentifiers, name: "documentIdentifiers", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentIdentifiers = "documentIdentifiers"
        }
    }

    public struct GetKnowledgeBaseDocumentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about the documents that were retrieved.
        public let documentDetails: [KnowledgeBaseDocumentDetail]?

        @inlinable
        public init(documentDetails: [KnowledgeBaseDocumentDetail]? = nil) {
            self.documentDetails = documentDetails
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetails = "documentDetails"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base you want to get information on.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct GetPromptRequest: AWSEncodableShape {
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// The version of the prompt about which you want to retrieve information. Omit this field to return information about the working draft of the prompt.
        public let promptVersion: String?

        @inlinable
        public init(promptIdentifier: String, promptVersion: String? = nil) {
            self.promptIdentifier = promptIdentifier
            self.promptVersion = promptVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            request.encodeQuery(self.promptVersion, key: "promptVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, max: 5)
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, min: 1)
            try self.validate(self.promptVersion, name: "promptVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the prompt is encrypted with.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// The descriptino of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the guardrail.
        public let guardrailIdentifier: String?
        /// The version of the guardrail.
        public let guardrailVersion: String?

        @inlinable
        public init(guardrailIdentifier: String? = nil, guardrailVersion: String? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([0-9]{1,8})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailIdentifier = "guardrailIdentifier"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct HierarchicalChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Token settings for each layer.
        public let levelConfigurations: [HierarchicalChunkingLevelConfiguration]
        /// The number of tokens to repeat across chunks in the same layer.
        public let overlapTokens: Int

        @inlinable
        public init(levelConfigurations: [HierarchicalChunkingLevelConfiguration], overlapTokens: Int) {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, max: 2)
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case levelConfigurations = "levelConfigurations"
            case overlapTokens = "overlapTokens"
        }
    }

    public struct HierarchicalChunkingLevelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens that a chunk can contain in this layer.
        public let maxTokens: Int

        @inlinable
        public init(maxTokens: Int) {
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
        }
    }

    public struct IncompatibleConnectionDataTypeFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with incompatible data types.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to allow in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        @inlinable
        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topK, name: "topK", parent: name, max: 500)
            try self.validate(self.topK, name: "topK", parent: name, min: 0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct IngestKnowledgeBaseDocumentsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The unique identifier of the data source connected to the knowledge base that you're adding documents to.
        public let dataSourceId: String
        /// A list of objects, each of which contains information about the documents to add.
        public let documents: [KnowledgeBaseDocument]
        /// The unique identifier of the knowledge base to ingest the documents into.
        public let knowledgeBaseId: String

        @inlinable
        public init(clientToken: String? = IngestKnowledgeBaseDocumentsRequest.idempotencyToken(), dataSourceId: String, documents: [KnowledgeBaseDocument], knowledgeBaseId: String) {
            self.clientToken = clientToken
            self.dataSourceId = dataSourceId
            self.documents = documents
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.documents, name: "documents", parent: name, max: 10)
            try self.validate(self.documents, name: "documents", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case documents = "documents"
        }
    }

    public struct IngestKnowledgeBaseDocumentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about the documents that were ingested.
        public let documentDetails: [KnowledgeBaseDocumentDetail]?

        @inlinable
        public init(documentDetails: [KnowledgeBaseDocumentDetail]? = nil) {
            self.documentDetails = documentDetails
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetails = "documentDetails"
        }
    }

    public struct IngestionJob: AWSDecodableShape {
        /// The unique identifier of the data source for the data ingestion job.
        public let dataSourceId: String
        /// The description of the data ingestion job.
        public let description: String?
        /// A list of reasons that the data ingestion job failed.
        public let failureReasons: [String]?
        /// The unique identifier of the data ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge for the data ingestion job.
        public let knowledgeBaseId: String
        /// The time the data ingestion job started. If you stop a data ingestion job, the startedAt time is the time the job was started before the job was stopped.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics about the data ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the data ingestion job.
        public let status: IngestionJobStatus
        /// The time the data ingestion job was last updated. If you stop a data ingestion job, the updatedAt time is the time the job was stopped.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, failureReasons: [String]? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case failureReasons = "failureReasons"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct IngestionJobFilter: AWSEncodableShape {
        /// The name of field or attribute to apply the filter.
        public let attribute: IngestionJobFilterAttribute
        /// The operation to apply to the field or attribute.
        public let `operator`: IngestionJobFilterOperator
        /// A list of values that belong to the field or attribute.
        public let values: [String]

        @inlinable
        public init(attribute: IngestionJobFilterAttribute, operator: IngestionJobFilterOperator, values: [String]) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct IngestionJobSortBy: AWSEncodableShape {
        /// The name of field or attribute to apply sorting of data.
        public let attribute: IngestionJobSortByAttribute
        /// The order for sorting the data.
        public let order: SortOrder

        @inlinable
        public init(attribute: IngestionJobSortByAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct IngestionJobStatistics: AWSDecodableShape {
        /// The number of source documents that were deleted.
        public let numberOfDocumentsDeleted: Int64?
        /// The number of source documents that failed to be ingested.
        public let numberOfDocumentsFailed: Int64?
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public let numberOfDocumentsScanned: Int64?
        /// The number of metadata files that were updated or deleted.
        public let numberOfMetadataDocumentsModified: Int64?
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public let numberOfMetadataDocumentsScanned: Int64?
        /// The number of modified source documents in the data source that were successfully indexed.
        public let numberOfModifiedDocumentsIndexed: Int64?
        /// The number of new source documents in the data source that were successfully indexed.
        public let numberOfNewDocumentsIndexed: Int64?

        @inlinable
        public init(numberOfDocumentsDeleted: Int64? = nil, numberOfDocumentsFailed: Int64? = nil, numberOfDocumentsScanned: Int64? = nil, numberOfMetadataDocumentsModified: Int64? = nil, numberOfMetadataDocumentsScanned: Int64? = nil, numberOfModifiedDocumentsIndexed: Int64? = nil, numberOfNewDocumentsIndexed: Int64? = nil) {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDocumentsDeleted = "numberOfDocumentsDeleted"
            case numberOfDocumentsFailed = "numberOfDocumentsFailed"
            case numberOfDocumentsScanned = "numberOfDocumentsScanned"
            case numberOfMetadataDocumentsModified = "numberOfMetadataDocumentsModified"
            case numberOfMetadataDocumentsScanned = "numberOfMetadataDocumentsScanned"
            case numberOfModifiedDocumentsIndexed = "numberOfModifiedDocumentsIndexed"
            case numberOfNewDocumentsIndexed = "numberOfNewDocumentsIndexed"
        }
    }

    public struct IngestionJobSummary: AWSDecodableShape {
        /// The unique identifier of the data source for the data ingestion job.
        public let dataSourceId: String
        /// The description of the data ingestion job.
        public let description: String?
        /// The unique identifier of the data ingestion job.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base for the data ingestion job.
        public let knowledgeBaseId: String
        /// The time the data ingestion job started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Contains statistics for the data ingestion job.
        public let statistics: IngestionJobStatistics?
        /// The status of the data ingestion job.
        public let status: IngestionJobStatus
        /// The time the data ingestion job was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(dataSourceId: String, description: String? = nil, ingestionJobId: String, knowledgeBaseId: String, startedAt: Date, statistics: IngestionJobStatistics? = nil, status: IngestionJobStatus, updatedAt: Date) {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case description = "description"
            case ingestionJobId = "ingestionJobId"
            case knowledgeBaseId = "knowledgeBaseId"
            case startedAt = "startedAt"
            case statistics = "statistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct InlineContent: AWSEncodableShape {
        /// Contains information about content defined inline in bytes.
        public let byteContent: ByteContentDoc?
        /// Contains information about content defined inline in text.
        public let textContent: TextContentDoc?
        /// The type of inline content to define.
        public let type: InlineContentType

        @inlinable
        public init(byteContent: ByteContentDoc? = nil, textContent: TextContentDoc? = nil, type: InlineContentType) {
            self.byteContent = byteContent
            self.textContent = textContent
            self.type = type
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.textContent?.validate(name: "\(name).textContent")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case textContent = "textContent"
            case type = "type"
        }
    }

    public struct InputFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct IntermediateStorage: AWSEncodableShape & AWSDecodableShape {
        /// An S3 bucket path.
        public let s3Location: S3Location

        @inlinable
        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct IteratorFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct KendraKnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Amazon Kendra index.
        public let kendraIndexArn: String

        @inlinable
        public init(kendraIndexArn: String) {
            self.kendraIndexArn = kendraIndexArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kendraIndexArn, name: "kendraIndexArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kendra:[a-z0-9-]{1,20}:([0-9]{12}|):index/([a-zA-Z0-9][a-zA-Z0-9-]{35}|[a-zA-Z0-9][a-zA-Z0-9-]{35}-[a-zA-Z0-9][a-zA-Z0-9-]{35})$")
        }

        private enum CodingKeys: String, CodingKey {
            case kendraIndexArn = "kendraIndexArn"
        }
    }

    public struct KnowledgeBase: AWSDecodableShape {
        /// The time the knowledge base was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the knowledge base.
        public let description: String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public let failureReasons: [String]?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// Contains details about the embeddings configuration of the knowledge base.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// The status of the knowledge base. The following statuses are possible:   CREATING – The knowledge base is being created.   ACTIVE – The knowledge base is ready to be queried.   DELETING – The knowledge base is being deleted.   UPDATING – The knowledge base is being updated.   FAILED – The knowledge base API operation failed.
        public let status: KnowledgeBaseStatus
        /// Contains details about the storage configuration of the knowledge base.
        public let storageConfiguration: StorageConfiguration?
        /// The time the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, failureReasons: [String]? = nil, knowledgeBaseArn: String, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, status: KnowledgeBaseStatus, storageConfiguration: StorageConfiguration? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case failureReasons = "failureReasons"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case storageConfiguration = "storageConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct KnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Settings for an Amazon Kendra knowledge base.
        public let kendraKnowledgeBaseConfiguration: KendraKnowledgeBaseConfiguration?
        /// Specifies configurations for a knowledge base connected to an SQL database.
        public let sqlKnowledgeBaseConfiguration: SqlKnowledgeBaseConfiguration?
        /// The type of data that the data source is converted into for the knowledge base.
        public let type: KnowledgeBaseType
        /// Contains details about the model that's used to convert the data source into vector embeddings.
        public let vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration?

        @inlinable
        public init(kendraKnowledgeBaseConfiguration: KendraKnowledgeBaseConfiguration? = nil, sqlKnowledgeBaseConfiguration: SqlKnowledgeBaseConfiguration? = nil, type: KnowledgeBaseType, vectorKnowledgeBaseConfiguration: VectorKnowledgeBaseConfiguration? = nil) {
            self.kendraKnowledgeBaseConfiguration = kendraKnowledgeBaseConfiguration
            self.sqlKnowledgeBaseConfiguration = sqlKnowledgeBaseConfiguration
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }

        public func validate(name: String) throws {
            try self.kendraKnowledgeBaseConfiguration?.validate(name: "\(name).kendraKnowledgeBaseConfiguration")
            try self.sqlKnowledgeBaseConfiguration?.validate(name: "\(name).sqlKnowledgeBaseConfiguration")
            try self.vectorKnowledgeBaseConfiguration?.validate(name: "\(name).vectorKnowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case kendraKnowledgeBaseConfiguration = "kendraKnowledgeBaseConfiguration"
            case sqlKnowledgeBaseConfiguration = "sqlKnowledgeBaseConfiguration"
            case type = "type"
            case vectorKnowledgeBaseConfiguration = "vectorKnowledgeBaseConfiguration"
        }
    }

    public struct KnowledgeBaseDocument: AWSEncodableShape {
        /// Contains the content of the document.
        public let content: DocumentContent
        /// Contains the metadata to associate with the document.
        public let metadata: DocumentMetadata?

        @inlinable
        public init(content: DocumentContent, metadata: DocumentMetadata? = nil) {
            self.content = content
            self.metadata = metadata
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.metadata?.validate(name: "\(name).metadata")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case metadata = "metadata"
        }
    }

    public struct KnowledgeBaseDocumentDetail: AWSDecodableShape {
        /// The identifier of the data source connected to the knowledge base that the document was ingested into or deleted from.
        public let dataSourceId: String
        /// Contains information that identifies the document.
        public let identifier: DocumentIdentifier
        /// The identifier of the knowledge base that the document was ingested into or deleted from.
        public let knowledgeBaseId: String
        /// The ingestion status of the document. The following statuses are possible:   STARTED – You submitted the ingestion job containing the document.   PENDING – The document is waiting to be ingested.   IN_PROGRESS – The document is being ingested.   INDEXED – The document was successfully indexed.   PARTIALLY_INDEXED – The document was partially indexed.   METADATA_PARTIALLY_INDEXED – You submitted metadata for an existing document and it was partially indexed.   METADATA_UPDATE_FAILED – You submitted a metadata update for an existing document but it failed.   FAILED – The document failed to be ingested.   NOT_FOUND – The document wasn't found.   IGNORED – The document was ignored during ingestion.   DELETING – You submitted the delete job containing the document.   DELETE_IN_PROGRESS – The document is being deleted.
        public let status: DocumentStatus
        /// The reason for the status. Appears alongside the status IGNORED.
        public let statusReason: String?
        /// The date and time at which the document was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(dataSourceId: String, identifier: DocumentIdentifier, knowledgeBaseId: String, status: DocumentStatus, statusReason: String? = nil, updatedAt: Date? = nil) {
            self.dataSourceId = dataSourceId
            self.identifier = identifier
            self.knowledgeBaseId = knowledgeBaseId
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case identifier = "identifier"
            case knowledgeBaseId = "knowledgeBaseId"
            case status = "status"
            case statusReason = "statusReason"
            case updatedAt = "updatedAt"
        }
    }

    public struct KnowledgeBaseFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The unique identifier of the knowledge base to query.
        public let knowledgeBaseId: String
        /// The unique identifier of the model or inference profile to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.
        public let modelId: String?

        @inlinable
        public init(guardrailConfiguration: GuardrailConfiguration? = nil, knowledgeBaseId: String, modelId: String? = nil) {
            self.guardrailConfiguration = guardrailConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailConfiguration = "guardrailConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case modelId = "modelId"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The name of the knowledge base.
        public let name: String
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The time the knowledge base was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(description: String? = nil, knowledgeBaseId: String, name: String, status: KnowledgeBaseStatus, updatedAt: Date) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct LambdaFunctionFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function to invoke.
        public let lambdaArn: String

        @inlinable
        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
        }
    }

    public struct LexFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        public let botAliasArn: String
        /// The Region to invoke the Amazon Lex bot in.
        public let localeId: String

        @inlinable
        public init(botAliasArn: String, localeId: String) {
            self.botAliasArn = botAliasArn
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasArn, name: "botAliasArn", parent: name, max: 78)
            try self.validate(self.botAliasArn, name: "botAliasArn", parent: name, pattern: "^arn:aws(|-us-gov):lex:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:bot-alias/[0-9a-zA-Z]+/[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, max: 10)
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasArn = "botAliasArn"
            case localeId = "localeId"
        }
    }

    public struct ListAgentActionGroupsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The version of the agent.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentActionGroupsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an action group.
        public let actionGroupSummaries: [ActionGroupSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(actionGroupSummaries: [ActionGroupSummary], nextToken: String? = nil) {
            self.actionGroupSummaries = actionGroupSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupSummaries = "actionGroupSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentAliasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an alias of the agent.
        public let agentAliasSummaries: [AgentAliasSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentAliasSummaries: [AgentAliasSummary], nextToken: String? = nil) {
            self.agentAliasSummaries = agentAliasSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasSummaries = "agentAliasSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentCollaboratorsRequest: AWSEncodableShape {
        /// The agent's ID.
        public let agentId: String
        /// The agent's version.
        public let agentVersion: String
        /// The maximum number of agent collaborators to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentCollaboratorsResponse: AWSDecodableShape {
        /// A list of collaborator summaries.
        public let agentCollaboratorSummaries: [AgentCollaboratorSummary]
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentCollaboratorSummaries: [AgentCollaboratorSummary], nextToken: String? = nil) {
            self.agentCollaboratorSummaries = agentCollaboratorSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaboratorSummaries = "agentCollaboratorSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
        public let agentId: String
        /// The version of the agent for which to return information about knowledge bases associated with it.
        public let agentVersion: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, agentVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(DRAFT|[0-9]{0,4}[1-9][0-9]{0,4})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a knowledge base associated with the agent.
        public let agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentKnowledgeBaseSummaries: [AgentKnowledgeBaseSummary], nextToken: String? = nil) {
            self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBaseSummaries = "agentKnowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the agent.
        public let agentId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentId = agentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentVersionsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a version of the agent.
        public let agentVersionSummaries: [AgentVersionSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentVersionSummaries: [AgentVersionSummary], nextToken: String? = nil) {
            self.agentVersionSummaries = agentVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentVersionSummaries = "agentVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about an agent.
        public let agentSummaries: [AgentSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentSummaries: [AgentSummary], nextToken: String? = nil) {
            self.agentSummaries = agentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentSummaries = "agentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base for which to return a list of information.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a data source.
        public let dataSourceSummaries: [DataSourceSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(dataSourceSummaries: [DataSourceSummary], nextToken: String? = nil) {
            self.dataSourceSummaries = dataSourceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSummaries = "dataSourceSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowAliasesRequest: AWSEncodableShape {
        /// The unique identifier of the flow for which aliases are being returned.
        public let flowIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowIdentifier = flowIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowAliasesResponse: AWSDecodableShape {
        /// A list, each member of which contains information about an alias.
        public let flowAliasSummaries: [FlowAliasSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowAliasSummaries: [FlowAliasSummary], nextToken: String? = nil) {
            self.flowAliasSummaries = flowAliasSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowAliasSummaries = "flowAliasSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowIdentifier = flowIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowVersionsResponse: AWSDecodableShape {
        /// A list, each member of which contains information about a flow.
        public let flowVersionSummaries: [FlowVersionSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowVersionSummaries: [FlowVersionSummary], nextToken: String? = nil) {
            self.flowVersionSummaries = flowVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowVersionSummaries = "flowVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowsResponse: AWSDecodableShape {
        /// A list, each member of which contains information about a flow.
        public let flowSummaries: [FlowSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(flowSummaries: [FlowSummary], nextToken: String? = nil) {
            self.flowSummaries = flowSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowSummaries = "flowSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestionJobsRequest: AWSEncodableShape {
        /// The unique identifier of the data source for the list of data ingestion jobs.
        public let dataSourceId: String
        /// Contains information about the filters for filtering the data.
        public let filters: [IngestionJobFilter]?
        /// The unique identifier of the knowledge base for the list of data ingestion jobs.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// Contains details about how to sort the data.
        public let sortBy: IngestionJobSortBy?

        @inlinable
        public init(dataSourceId: String, filters: [IngestionJobFilter]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: IngestionJobSortBy? = nil) {
            self.dataSourceId = dataSourceId
            self.filters = filters
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListIngestionJobsResponse: AWSDecodableShape {
        /// A list of data ingestion jobs with information about each job.
        public let ingestionJobSummaries: [IngestionJobSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(ingestionJobSummaries: [IngestionJobSummary], nextToken: String? = nil) {
            self.ingestionJobSummaries = ingestionJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJobSummaries = "ingestionJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBaseDocumentsRequest: AWSEncodableShape {
        /// The unique identifier of the data source that contains the documents.
        public let dataSourceId: String
        /// The unique identifier of the knowledge base that is connected to the data source.
        public let knowledgeBaseId: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(dataSourceId: String, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataSourceId = dataSourceId
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBaseDocumentsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about the documents that were retrieved.
        public let documentDetails: [KnowledgeBaseDocumentDetail]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(documentDetails: [KnowledgeBaseDocumentDetail], nextToken: String? = nil) {
            self.documentDetails = documentDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetails = "documentDetails"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// A list of knowledge bases with information about each knowledge base.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPromptsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The unique identifier of the prompt for whose versions you want to return information. Omit this field to list information about all prompts in an account.
        public let promptIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, promptIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.promptIdentifier = promptIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.promptIdentifier, key: "promptIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPromptsResponse: AWSDecodableShape {
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?
        /// A list, each member of which contains information about a prompt using Prompt management.
        public let promptSummaries: [PromptSummary]

        @inlinable
        public init(nextToken: String? = nil, promptSummaries: [PromptSummary]) {
            self.nextToken = nextToken
            self.promptSummaries = promptSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case promptSummaries = "promptSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pairs for the tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MalformedConditionExpressionFlowValidationDetails: AWSDecodableShape {
        /// The error message describing why the condition expression is malformed.
        public let cause: String
        /// The name of the malformed condition.
        public let condition: String
        /// The name of the node containing the malformed condition expression.
        public let node: String

        @inlinable
        public init(cause: String, condition: String, node: String) {
            self.cause = cause
            self.condition = condition
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case condition = "condition"
            case node = "node"
        }
    }

    public struct MalformedNodeInputExpressionFlowValidationDetails: AWSDecodableShape {
        /// The error message describing why the input expression is malformed.
        public let cause: String
        /// The name of the input with the malformed expression.
        public let input: String
        /// The name of the node containing the malformed input expression.
        public let node: String

        @inlinable
        public init(cause: String, input: String, node: String) {
            self.cause = cause
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case input = "input"
            case node = "node"
        }
    }

    public struct MemoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of memory that is stored.
        public let enabledMemoryTypes: [MemoryType]
        /// Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        public let sessionSummaryConfiguration: SessionSummaryConfiguration?
        /// The number of days the agent is configured to retain the conversational context.
        public let storageDays: Int?

        @inlinable
        public init(enabledMemoryTypes: [MemoryType], sessionSummaryConfiguration: SessionSummaryConfiguration? = nil, storageDays: Int? = nil) {
            self.enabledMemoryTypes = enabledMemoryTypes
            self.sessionSummaryConfiguration = sessionSummaryConfiguration
            self.storageDays = storageDays
        }

        public func validate(name: String) throws {
            try self.validate(self.enabledMemoryTypes, name: "enabledMemoryTypes", parent: name, max: 1)
            try self.validate(self.enabledMemoryTypes, name: "enabledMemoryTypes", parent: name, min: 1)
            try self.sessionSummaryConfiguration?.validate(name: "\(name).sessionSummaryConfiguration")
            try self.validate(self.storageDays, name: "storageDays", parent: name, max: 365)
            try self.validate(self.storageDays, name: "storageDays", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabledMemoryTypes = "enabledMemoryTypes"
            case sessionSummaryConfiguration = "sessionSummaryConfiguration"
            case storageDays = "storageDays"
        }
    }

    public struct Message: AWSEncodableShape & AWSDecodableShape {
        /// The content in the message.
        public let content: [ContentBlock]
        /// The role that the message belongs to.
        public let role: ConversationRole

        @inlinable
        public init(content: [ContentBlock], role: ConversationRole) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case role = "role"
        }
    }

    public struct MetadataAttribute: AWSEncodableShape {
        /// The key of the metadata attribute.
        public let key: String
        /// Contains the value of the metadata attribute.
        public let value: MetadataAttributeValue

        @inlinable
        public init(key: String, value: MetadataAttributeValue) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 200)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct MetadataAttributeValue: AWSEncodableShape {
        /// The value of the Boolean metadata attribute.
        public let booleanValue: Bool?
        /// The value of the numeric metadata attribute.
        public let numberValue: Double?
        /// An array of strings that define the value of the metadata attribute.
        public let stringListValue: [String]?
        /// The value of the string metadata attribute.
        public let stringValue: String?
        /// The type of the metadata attribute.
        public let type: MetadataValueType

        @inlinable
        public init(booleanValue: Bool? = nil, numberValue: Double? = nil, stringListValue: [String]? = nil, stringValue: String? = nil, type: MetadataValueType) {
            self.booleanValue = booleanValue
            self.numberValue = numberValue
            self.stringListValue = stringListValue
            self.stringValue = stringValue
            self.type = type
        }

        public func validate(name: String) throws {
            try self.stringListValue?.forEach {
                try validate($0, name: "stringListValue[]", parent: name, max: 2048)
                try validate($0, name: "stringListValue[]", parent: name, min: 1)
            }
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 2048)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case numberValue = "numberValue"
            case stringListValue = "stringListValue"
            case stringValue = "stringValue"
            case type = "type"
        }
    }

    public struct MismatchedNodeInputTypeFlowValidationDetails: AWSDecodableShape {
        /// The expected data type for the node input.
        public let expectedType: FlowNodeIODataType
        /// The name of the input with the mismatched data type.
        public let input: String
        /// The name of the node containing the input with the mismatched data type.
        public let node: String

        @inlinable
        public init(expectedType: FlowNodeIODataType, input: String, node: String) {
            self.expectedType = expectedType
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case expectedType = "expectedType"
            case input = "input"
            case node = "node"
        }
    }

    public struct MismatchedNodeOutputTypeFlowValidationDetails: AWSDecodableShape {
        /// The expected data type for the node output.
        public let expectedType: FlowNodeIODataType
        /// The name of the node containing the output with the mismatched data type.
        public let node: String
        /// The name of the output with the mismatched data type.
        public let output: String

        @inlinable
        public init(expectedType: FlowNodeIODataType, node: String, output: String) {
            self.expectedType = expectedType
            self.node = node
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case expectedType = "expectedType"
            case node = "node"
            case output = "output"
        }
    }

    public struct MissingConnectionConfigurationFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection missing configuration.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct MissingDefaultConditionFlowValidationDetails: AWSDecodableShape {
        /// The name of the node missing the default condition.
        public let node: String

        @inlinable
        public init(node: String) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "node"
        }
    }

    public struct MissingEndingNodesFlowValidationDetails: AWSDecodableShape {
        public init() {}
    }

    public struct MissingNodeConfigurationFlowValidationDetails: AWSDecodableShape {
        /// The name of the node missing configuration.
        public let node: String

        @inlinable
        public init(node: String) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "node"
        }
    }

    public struct MissingNodeInputFlowValidationDetails: AWSDecodableShape {
        /// The name of the missing input.
        public let input: String
        /// The name of the node missing the required input.
        public let node: String

        @inlinable
        public init(input: String, node: String) {
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case node = "node"
        }
    }

    public struct MissingNodeOutputFlowValidationDetails: AWSDecodableShape {
        /// The name of the node missing the required output.
        public let node: String
        /// The name of the missing output.
        public let output: String

        @inlinable
        public init(node: String, output: String) {
            self.node = node
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case node = "node"
            case output = "output"
        }
    }

    public struct MissingStartingNodesFlowValidationDetails: AWSDecodableShape {
        public init() {}
    }

    public struct MongoDbAtlasConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The collection name of the knowledge base in MongoDB Atlas.
        public let collectionName: String
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
        public let credentialsSecretArn: String
        /// The database name in your MongoDB Atlas cluster for your knowledge base.
        public let databaseName: String
        /// The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
        public let endpoint: String
        /// The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
        public let endpointServiceName: String?
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: MongoDbAtlasFieldMapping
        /// The name of the MongoDB Atlas vector search index.
        public let vectorIndexName: String

        @inlinable
        public init(collectionName: String, credentialsSecretArn: String, databaseName: String, endpoint: String, endpointServiceName: String? = nil, fieldMapping: MongoDbAtlasFieldMapping, vectorIndexName: String) {
            self.collectionName = collectionName
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.endpoint = endpoint
            self.endpointServiceName = endpointServiceName
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 63)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^.*$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^.*$")
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 2048)
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^.*$")
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, max: 255)
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, min: 1)
            try self.validate(self.endpointServiceName, name: "endpointServiceName", parent: name, pattern: "^(?:arn:aws(?:-us-gov|-cn|-iso|-iso-[a-z])*:.+:.*:\\d+:.+/.+$|[a-zA-Z0-9*]+[a-zA-Z0-9._-]*)$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "collectionName"
            case credentialsSecretArn = "credentialsSecretArn"
            case databaseName = "databaseName"
            case endpoint = "endpoint"
            case endpointServiceName = "endpointServiceName"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct MongoDbAtlasFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct MultipleNodeInputConnectionsFlowValidationDetails: AWSDecodableShape {
        /// The name of the input with multiple connections to it.
        public let input: String
        /// The name of the node containing the input with multiple connections.
        public let node: String

        @inlinable
        public init(input: String, node: String) {
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case node = "node"
        }
    }

    public struct NeptuneAnalyticsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: NeptuneAnalyticsFieldMapping
        /// The Amazon Resource Name (ARN) of the Neptune Analytics vector store.
        public let graphArn: String

        @inlinable
        public init(fieldMapping: NeptuneAnalyticsFieldMapping, graphArn: String) {
            self.fieldMapping = fieldMapping
            self.graphArn = graphArn
        }

        public func validate(name: String) throws {
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.graphArn, name: "graphArn", parent: name, max: 255)
            try self.validate(self.graphArn, name: "graphArn", parent: name, min: 1)
            try self.validate(self.graphArn, name: "graphArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):neptune-graph:[a-zA-Z0-9-]*:[0-9]{12}:graph/g-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldMapping = "fieldMapping"
            case graphArn = "graphArn"
        }
    }

    public struct NeptuneAnalyticsFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String

        @inlinable
        public init(metadataField: String, textField: String) {
            self.metadataField = metadataField
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
        }
    }

    public struct OpenSearchServerlessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
        public let collectionArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: OpenSearchServerlessFieldMapping
        /// The name of the vector store.
        public let vectorIndexName: String

        @inlinable
        public init(collectionArn: String, fieldMapping: OpenSearchServerlessFieldMapping, vectorIndexName: String) {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, max: 2048)
            try self.validate(self.collectionArn, name: "collectionArn", parent: name, pattern: "^arn:aws:aoss:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:collection/[a-z0-9-]{3,32}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "collectionArn"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct OpenSearchServerlessFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct OutputFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct ParameterDetail: AWSEncodableShape & AWSDecodableShape {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public let description: String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public let required: Bool?
        /// The data type of the parameter.
        public let type: `Type`

        @inlinable
        public init(description: String? = nil, required: Bool? = nil, type: `Type`) {
            self.description = description
            self.required = required
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case required = "required"
            case type = "type"
        }
    }

    public struct ParsingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// If you specify BEDROCK_DATA_AUTOMATION as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        public let bedrockDataAutomationConfiguration: BedrockDataAutomationConfiguration?
        /// If you specify BEDROCK_FOUNDATION_MODEL as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        public let bedrockFoundationModelConfiguration: BedrockFoundationModelConfiguration?
        /// The parsing strategy for the data source.
        public let parsingStrategy: ParsingStrategy

        @inlinable
        public init(bedrockDataAutomationConfiguration: BedrockDataAutomationConfiguration? = nil, bedrockFoundationModelConfiguration: BedrockFoundationModelConfiguration? = nil, parsingStrategy: ParsingStrategy) {
            self.bedrockDataAutomationConfiguration = bedrockDataAutomationConfiguration
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }

        public func validate(name: String) throws {
            try self.bedrockFoundationModelConfiguration?.validate(name: "\(name).bedrockFoundationModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockDataAutomationConfiguration = "bedrockDataAutomationConfiguration"
            case bedrockFoundationModelConfiguration = "bedrockFoundationModelConfiguration"
            case parsingStrategy = "parsingStrategy"
        }
    }

    public struct ParsingPrompt: AWSEncodableShape & AWSDecodableShape {
        /// Instructions for interpreting the contents of a document.
        public let parsingPromptText: String

        @inlinable
        public init(parsingPromptText: String) {
            self.parsingPromptText = parsingPromptText
        }

        public func validate(name: String) throws {
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, max: 10000)
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parsingPromptText = "parsingPromptText"
        }
    }

    public struct PatternObjectFilter: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more exclusion regular expression patterns to exclude certain  object types that adhere to the pattern. If you specify an inclusion and exclusion  filter/pattern and both match a document, the exclusion filter takes precedence  and the document isn’t crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include certain  object types that adhere to the pattern. If you specify an inclusion and exclusion  filter/pattern and both match a document, the exclusion filter takes precedence  and the document isn’t crawled.
        public let inclusionFilters: [String]?
        /// The supported object type or content type of the data source.
        public let objectType: String

        @inlinable
        public init(exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, objectType: String) {
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.objectType = objectType
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
            try self.validate(self.objectType, name: "objectType", parent: name, max: 50)
            try self.validate(self.objectType, name: "objectType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case objectType = "objectType"
        }
    }

    public struct PatternObjectFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of specific filters applied to your data source content. You can  filter out or include certain content.
        public let filters: [PatternObjectFilter]

        @inlinable
        public init(filters: [PatternObjectFilter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct PineconeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint URL for your index management page.
        public let connectionString: String
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        public let credentialsSecretArn: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: PineconeFieldMapping
        /// The namespace to be used to write new data to your database.
        public let namespace: String?

        @inlinable
        public init(connectionString: String, credentialsSecretArn: String, fieldMapping: PineconeFieldMapping, namespace: String? = nil) {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionString, name: "connectionString", parent: name, max: 2048)
            try self.validate(self.connectionString, name: "connectionString", parent: name, pattern: "^.*$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 2048)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionString = "connectionString"
            case credentialsSecretArn = "credentialsSecretArn"
            case fieldMapping = "fieldMapping"
            case namespace = "namespace"
        }
    }

    public struct PineconeFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String

        @inlinable
        public init(metadataField: String, textField: String) {
            self.metadataField = metadataField
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
        }
    }

    public struct PrepareAgentRequest: AWSEncodableShape {
        /// The unique identifier of the agent for which to create a DRAFT version.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PrepareAgentResponse: AWSDecodableShape {
        /// The unique identifier of the agent for which the DRAFT version was created.
        public let agentId: String
        /// The status of the DRAFT version and whether it is ready for use.
        public let agentStatus: AgentStatus
        /// The version of the agent.
        public let agentVersion: String
        /// The time at which the DRAFT version of the agent was last prepared.
        @CustomCoding<ISO8601DateCoder>
        public var preparedAt: Date

        @inlinable
        public init(agentId: String, agentStatus: AgentStatus, agentVersion: String, preparedAt: Date) {
            self.agentId = agentId
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.preparedAt = preparedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentStatus = "agentStatus"
            case agentVersion = "agentVersion"
            case preparedAt = "preparedAt"
        }
    }

    public struct PrepareFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow.
        public let flowIdentifier: String

        @inlinable
        public init(flowIdentifier: String) {
            self.flowIdentifier = flowIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PrepareFlowResponse: AWSDecodableShape {
        /// The unique identifier of the flow.
        public let id: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If preparation succeeds, the status becomes Prepared. If it fails, the status becomes FAILED.
        public let status: FlowStatus

        @inlinable
        public init(id: String, status: FlowStatus) {
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case status = "status"
        }
    }

    public struct PromptAgentResource: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the agent with which to use the prompt.
        public let agentIdentifier: String

        @inlinable
        public init(agentIdentifier: String) {
            self.agentIdentifier = agentIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.agentIdentifier, name: "agentIdentifier", parent: name, max: 2048)
            try self.validate(self.agentIdentifier, name: "agentIdentifier", parent: name, pattern: "^arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:agent-alias/[0-9a-zA-Z]{10}/[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentIdentifier = "agentIdentifier"
        }
    }

    public struct PromptConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// If the Converse or ConverseStream operations support the model, additionalModelRequestFields contains additional inference parameters, beyond the base set of inference parameters in the inferenceConfiguration field.  For more information, see Inference request parameters and response fields for foundation models in the Amazon Bedrock user guide.
        public let additionalModelRequestFields: AWSDocument?
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see Prompt template placeholder variables. For more information, see Configure the prompt templates.
        public let basePromptTemplate: String?
        /// The agent's foundation model.
        public let foundationModel: String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDDEN, the overrideLambda field in the PromptOverrideConfiguration must be specified with the ARN of a Lambda function.
        public let parserMode: CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public let promptCreationMode: CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.    PRE_PROCESSING – ENABLED     ORCHESTRATION – ENABLED     KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED     POST_PROCESSING – DISABLED
        public let promptState: PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public let promptType: PromptType?

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, basePromptTemplate: String? = nil, foundationModel: String? = nil, inferenceConfiguration: InferenceConfiguration? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, promptState: PromptState? = nil, promptType: PromptType? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.basePromptTemplate = basePromptTemplate
            self.foundationModel = foundationModel
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }

        public func validate(name: String) throws {
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, max: 100000)
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case basePromptTemplate = "basePromptTemplate"
            case foundationModel = "foundationModel"
            case inferenceConfiguration = "inferenceConfiguration"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case promptState = "promptState"
            case promptType = "promptType"
        }
    }

    public struct PromptFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// Specifies whether the prompt is from Prompt management or defined inline.
        public let sourceConfiguration: PromptFlowNodeSourceConfiguration

        @inlinable
        public init(guardrailConfiguration: GuardrailConfiguration? = nil, sourceConfiguration: PromptFlowNodeSourceConfiguration) {
            self.guardrailConfiguration = guardrailConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailConfiguration = "guardrailConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct PromptFlowNodeInlineConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Additional fields to be included in the model request for the Prompt node.
        public let additionalModelRequestFields: AWSDocument?
        /// Contains inference configurations for the prompt.
        public let inferenceConfiguration: PromptInferenceConfiguration?
        /// The unique identifier of the model or inference profile to run inference with.
        public let modelId: String
        /// Contains a prompt and variables in the prompt that can be replaced with values at runtime.
        public let templateConfiguration: PromptTemplateConfiguration
        /// The type of prompt template.
        public let templateType: PromptTemplateType

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, inferenceConfiguration: PromptInferenceConfiguration? = nil, modelId: String, templateConfiguration: PromptTemplateConfiguration, templateType: PromptTemplateType) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.inferenceConfiguration = inferenceConfiguration
            self.modelId = modelId
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.templateConfiguration.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case inferenceConfiguration = "inferenceConfiguration"
            case modelId = "modelId"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
        }
    }

    public struct PromptFlowNodeResourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt from Prompt management.
        public let promptArn: String

        @inlinable
        public init(promptArn: String) {
            self.promptArn = promptArn
        }

        public func validate(name: String) throws {
            try self.validate(self.promptArn, name: "promptArn", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case promptArn = "promptArn"
        }
    }

    public struct PromptInputVariable: AWSEncodableShape & AWSDecodableShape {
        /// The name of the variable.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct PromptMetadataEntry: AWSEncodableShape & AWSDecodableShape {
        /// The key of a metadata tag for a prompt variant.
        public let key: String
        /// The value of a metadata tag for a prompt variant.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct PromptModelInferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to return in the response.
        public let maxTokens: Int?
        /// A list of strings that define sequences after which the model will stop generating.
        public let stopSequences: [String]?
        /// Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        public let temperature: Float?
        /// The percentage of most-likely candidates that the model considers for the next token.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct PromptOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN. For more information, see Parser Lambda function in Amazon Bedrock Agents.
        public let overrideLambda: String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see Advanced prompts.
        public let promptConfigurations: [PromptConfiguration]

        @inlinable
        public init(overrideLambda: String? = nil, promptConfigurations: [PromptConfiguration]) {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, max: 2048)
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.promptConfigurations.forEach {
                try $0.validate(name: "\(name).promptConfigurations[]")
            }
            try self.validate(self.promptConfigurations, name: "promptConfigurations", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case overrideLambda = "overrideLambda"
            case promptConfigurations = "promptConfigurations"
        }
    }

    public struct PromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the prompt that this summary applies to.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, id: String, name: String, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct PromptVariant: AWSEncodableShape & AWSDecodableShape {
        /// Contains model-specific inference configurations that aren't in the inferenceConfiguration field. To see model-specific inference parameters, see Inference request parameters and response fields for foundation models.
        public let additionalModelRequestFields: AWSDocument?
        /// Specifies a generative AI resource with which to use the prompt.
        public let genAiResource: PromptGenAiResource?
        /// Contains inference configurations for the prompt variant.
        public let inferenceConfiguration: PromptInferenceConfiguration?
        /// An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        public let metadata: [PromptMetadataEntry]?
        /// The unique identifier of the model or inference profile with which to run inference on the prompt.
        public let modelId: String?
        /// The name of the prompt variant.
        public let name: String
        /// Contains configurations for the prompt template.
        public let templateConfiguration: PromptTemplateConfiguration
        /// The type of prompt template to use.
        public let templateType: PromptTemplateType

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, genAiResource: PromptGenAiResource? = nil, inferenceConfiguration: PromptInferenceConfiguration? = nil, metadata: [PromptMetadataEntry]? = nil, modelId: String? = nil, name: String, templateConfiguration: PromptTemplateConfiguration, templateType: PromptTemplateType) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.genAiResource = genAiResource
            self.inferenceConfiguration = inferenceConfiguration
            self.metadata = metadata
            self.modelId = modelId
            self.name = name
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.genAiResource?.validate(name: "\(name).genAiResource")
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 50)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.templateConfiguration.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case genAiResource = "genAiResource"
            case inferenceConfiguration = "inferenceConfiguration"
            case metadata = "metadata"
            case modelId = "modelId"
            case name = "name"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
        }
    }

    public struct QueryGenerationColumn: AWSEncodableShape & AWSDecodableShape {
        /// A description of the column that helps the query engine understand the contents of the column.
        public let description: String?
        /// Specifies whether to include or exclude the column during query generation. If you specify EXCLUDE, the column will be ignored. If you specify INCLUDE, all other columns in the table will be ignored.
        public let inclusion: IncludeExclude?
        /// The name of the column for which the other fields in this object apply.
        public let name: String?

        @inlinable
        public init(description: String? = nil, inclusion: IncludeExclude? = nil, name: String? = nil) {
            self.description = description
            self.inclusion = inclusion
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inclusion = "inclusion"
            case name = "name"
        }
    }

    public struct QueryGenerationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The time after which query generation will time out.
        public let executionTimeoutSeconds: Int?
        /// Specifies configurations for context to use during query generation.
        public let generationContext: QueryGenerationContext?

        @inlinable
        public init(executionTimeoutSeconds: Int? = nil, generationContext: QueryGenerationContext? = nil) {
            self.executionTimeoutSeconds = executionTimeoutSeconds
            self.generationContext = generationContext
        }

        public func validate(name: String) throws {
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, max: 200)
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, min: 1)
            try self.generationContext?.validate(name: "\(name).generationContext")
        }

        private enum CodingKeys: String, CodingKey {
            case executionTimeoutSeconds = "executionTimeoutSeconds"
            case generationContext = "generationContext"
        }
    }

    public struct QueryGenerationContext: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        public let curatedQueries: [CuratedQuery]?
        /// An array of objects, each of which defines information about a table in the database.
        public let tables: [QueryGenerationTable]?

        @inlinable
        public init(curatedQueries: [CuratedQuery]? = nil, tables: [QueryGenerationTable]? = nil) {
            self.curatedQueries = curatedQueries
            self.tables = tables
        }

        public func validate(name: String) throws {
            try self.curatedQueries?.forEach {
                try $0.validate(name: "\(name).curatedQueries[]")
            }
            try self.validate(self.curatedQueries, name: "curatedQueries", parent: name, max: 10)
            try self.tables?.forEach {
                try $0.validate(name: "\(name).tables[]")
            }
            try self.validate(self.tables, name: "tables", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case curatedQueries = "curatedQueries"
            case tables = "tables"
        }
    }

    public struct QueryGenerationTable: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects, each of which defines information about a column in the table.
        public let columns: [QueryGenerationColumn]?
        /// A description of the table that helps the query engine understand the contents of the table.
        public let description: String?
        /// Specifies whether to include or exclude the table during query generation. If you specify EXCLUDE, the table will be ignored. If you specify INCLUDE, all other tables will be ignored.
        public let inclusion: IncludeExclude?
        /// The name of the table for which the other fields in this object apply.
        public let name: String

        @inlinable
        public init(columns: [QueryGenerationColumn]? = nil, description: String? = nil, inclusion: IncludeExclude? = nil, name: String) {
            self.columns = columns
            self.description = description
            self.inclusion = inclusion
            self.name = name
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*\\..*\\..*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
            case description = "description"
            case inclusion = "inclusion"
            case name = "name"
        }
    }

    public struct RdsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        public let credentialsSecretArn: String
        /// The name of your Amazon RDS database.
        public let databaseName: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RdsFieldMapping
        /// The Amazon Resource Name (ARN) of the vector store.
        public let resourceArn: String
        /// The name of the table in the database.
        public let tableName: String

        @inlinable
        public init(credentialsSecretArn: String, databaseName: String, fieldMapping: RdsFieldMapping, resourceArn: String, tableName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):rds:[a-zA-Z0-9-]*:[0-9]{12}:cluster:[a-zA-Z0-9-]{1,63}$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 63)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_\\.\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case databaseName = "databaseName"
            case fieldMapping = "fieldMapping"
            case resourceArn = "resourceArn"
            case tableName = "tableName"
        }
    }

    public struct RdsFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        public let primaryKeyField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, primaryKeyField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 63)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, max: 63)
            try self.validate(self.primaryKeyField, name: "primaryKeyField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.textField, name: "textField", parent: name, max: 63)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 63)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^[a-zA-Z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case primaryKeyField = "primaryKeyField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct RedisEnterpriseCloudConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        public let credentialsSecretArn: String
        /// The endpoint URL of the Redis Enterprise Cloud database.
        public let endpoint: String
        /// Contains the names of the fields to which to map information about the vector store.
        public let fieldMapping: RedisEnterpriseCloudFieldMapping
        /// The name of the vector index.
        public let vectorIndexName: String

        @inlinable
        public init(credentialsSecretArn: String, endpoint: String, fieldMapping: RedisEnterpriseCloudFieldMapping, vectorIndexName: String) {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 2048)
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^.*$")
            try self.fieldMapping.validate(name: "\(name).fieldMapping")
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, max: 2048)
            try self.validate(self.vectorIndexName, name: "vectorIndexName", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsSecretArn = "credentialsSecretArn"
            case endpoint = "endpoint"
            case fieldMapping = "fieldMapping"
            case vectorIndexName = "vectorIndexName"
        }
    }

    public struct RedisEnterpriseCloudFieldMapping: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        public let metadataField: String
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        public let textField: String
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        public let vectorField: String

        @inlinable
        public init(metadataField: String, textField: String, vectorField: String) {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataField, name: "metadataField", parent: name, max: 2048)
            try self.validate(self.metadataField, name: "metadataField", parent: name, pattern: "^.*$")
            try self.validate(self.textField, name: "textField", parent: name, max: 2048)
            try self.validate(self.textField, name: "textField", parent: name, pattern: "^.*$")
            try self.validate(self.vectorField, name: "vectorField", parent: name, max: 2048)
            try self.validate(self.vectorField, name: "vectorField", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataField = "metadataField"
            case textField = "textField"
            case vectorField = "vectorField"
        }
    }

    public struct RedshiftConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for an Amazon Redshift query engine.
        public let queryEngineConfiguration: RedshiftQueryEngineConfiguration
        /// Specifies configurations for generating queries.
        public let queryGenerationConfiguration: QueryGenerationConfiguration?
        /// Specifies configurations for Amazon Redshift database storage.
        public let storageConfigurations: [RedshiftQueryEngineStorageConfiguration]

        @inlinable
        public init(queryEngineConfiguration: RedshiftQueryEngineConfiguration, queryGenerationConfiguration: QueryGenerationConfiguration? = nil, storageConfigurations: [RedshiftQueryEngineStorageConfiguration]) {
            self.queryEngineConfiguration = queryEngineConfiguration
            self.queryGenerationConfiguration = queryGenerationConfiguration
            self.storageConfigurations = storageConfigurations
        }

        public func validate(name: String) throws {
            try self.queryEngineConfiguration.validate(name: "\(name).queryEngineConfiguration")
            try self.queryGenerationConfiguration?.validate(name: "\(name).queryGenerationConfiguration")
            try self.storageConfigurations.forEach {
                try $0.validate(name: "\(name).storageConfigurations[]")
            }
            try self.validate(self.storageConfigurations, name: "storageConfigurations", parent: name, max: 1)
            try self.validate(self.storageConfigurations, name: "storageConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queryEngineConfiguration = "queryEngineConfiguration"
            case queryGenerationConfiguration = "queryGenerationConfiguration"
            case storageConfigurations = "storageConfigurations"
        }
    }

    public struct RedshiftProvisionedAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The database username for authentication to an Amazon Redshift provisioned data warehouse.
        public let databaseUser: String?
        /// The type of authentication to use.
        public let type: RedshiftProvisionedAuthType
        /// The ARN of an Secrets Manager secret for authentication.
        public let usernamePasswordSecretArn: String?

        @inlinable
        public init(databaseUser: String? = nil, type: RedshiftProvisionedAuthType, usernamePasswordSecretArn: String? = nil) {
            self.databaseUser = databaseUser
            self.type = type
            self.usernamePasswordSecretArn = usernamePasswordSecretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.usernamePasswordSecretArn, name: "usernamePasswordSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseUser = "databaseUser"
            case type = "type"
            case usernamePasswordSecretArn = "usernamePasswordSecretArn"
        }
    }

    public struct RedshiftProvisionedConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for authentication to Amazon Redshift.
        public let authConfiguration: RedshiftProvisionedAuthConfiguration
        /// The ID of the Amazon Redshift cluster.
        public let clusterIdentifier: String

        @inlinable
        public init(authConfiguration: RedshiftProvisionedAuthConfiguration, clusterIdentifier: String) {
            self.authConfiguration = authConfiguration
            self.clusterIdentifier = clusterIdentifier
        }

        public func validate(name: String) throws {
            try self.authConfiguration.validate(name: "\(name).authConfiguration")
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, max: 63)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case clusterIdentifier = "clusterIdentifier"
        }
    }

    public struct RedshiftQueryEngineAwsDataCatalogStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of names of the tables to use.
        public let tableNames: [String]

        @inlinable
        public init(tableNames: [String]) {
            self.tableNames = tableNames
        }

        public func validate(name: String) throws {
            try self.tableNames.forEach {
                try validate($0, name: "tableNames[]", parent: name, max: 200)
                try validate($0, name: "tableNames[]", parent: name, min: 1)
                try validate($0, name: "tableNames[]", parent: name, pattern: "^.*\\.*$")
            }
            try self.validate(self.tableNames, name: "tableNames", parent: name, max: 1000)
            try self.validate(self.tableNames, name: "tableNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tableNames = "tableNames"
        }
    }

    public struct RedshiftQueryEngineConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for a provisioned Amazon Redshift query engine.
        public let provisionedConfiguration: RedshiftProvisionedConfiguration?
        /// Specifies configurations for a serverless Amazon Redshift query engine.
        public let serverlessConfiguration: RedshiftServerlessConfiguration?
        /// The type of query engine.
        public let type: RedshiftQueryEngineType

        @inlinable
        public init(provisionedConfiguration: RedshiftProvisionedConfiguration? = nil, serverlessConfiguration: RedshiftServerlessConfiguration? = nil, type: RedshiftQueryEngineType) {
            self.provisionedConfiguration = provisionedConfiguration
            self.serverlessConfiguration = serverlessConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.provisionedConfiguration?.validate(name: "\(name).provisionedConfiguration")
            try self.serverlessConfiguration?.validate(name: "\(name).serverlessConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedConfiguration = "provisionedConfiguration"
            case serverlessConfiguration = "serverlessConfiguration"
            case type = "type"
        }
    }

    public struct RedshiftQueryEngineRedshiftStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon Redshift database.
        public let databaseName: String

        @inlinable
        public init(databaseName: String) {
            self.databaseName = databaseName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 200)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
        }
    }

    public struct RedshiftQueryEngineStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for storage in Glue Data Catalog.
        public let awsDataCatalogConfiguration: RedshiftQueryEngineAwsDataCatalogStorageConfiguration?
        /// Specifies configurations for storage in Amazon Redshift.
        public let redshiftConfiguration: RedshiftQueryEngineRedshiftStorageConfiguration?
        /// The data storage service to use.
        public let type: RedshiftQueryEngineStorageType

        @inlinable
        public init(awsDataCatalogConfiguration: RedshiftQueryEngineAwsDataCatalogStorageConfiguration? = nil, redshiftConfiguration: RedshiftQueryEngineRedshiftStorageConfiguration? = nil, type: RedshiftQueryEngineStorageType) {
            self.awsDataCatalogConfiguration = awsDataCatalogConfiguration
            self.redshiftConfiguration = redshiftConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.awsDataCatalogConfiguration?.validate(name: "\(name).awsDataCatalogConfiguration")
            try self.redshiftConfiguration?.validate(name: "\(name).redshiftConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case awsDataCatalogConfiguration = "awsDataCatalogConfiguration"
            case redshiftConfiguration = "redshiftConfiguration"
            case type = "type"
        }
    }

    public struct RedshiftServerlessAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of authentication to use.
        public let type: RedshiftServerlessAuthType
        /// The ARN of an Secrets Manager secret for authentication.
        public let usernamePasswordSecretArn: String?

        @inlinable
        public init(type: RedshiftServerlessAuthType, usernamePasswordSecretArn: String? = nil) {
            self.type = type
            self.usernamePasswordSecretArn = usernamePasswordSecretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.usernamePasswordSecretArn, name: "usernamePasswordSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case usernamePasswordSecretArn = "usernamePasswordSecretArn"
        }
    }

    public struct RedshiftServerlessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        public let authConfiguration: RedshiftServerlessAuthConfiguration
        /// The ARN of the Amazon Redshift workgroup.
        public let workgroupArn: String

        @inlinable
        public init(authConfiguration: RedshiftServerlessAuthConfiguration, workgroupArn: String) {
            self.authConfiguration = authConfiguration
            self.workgroupArn = workgroupArn
        }

        public func validate(name: String) throws {
            try self.authConfiguration.validate(name: "\(name).authConfiguration")
            try self.validate(self.workgroupArn, name: "workgroupArn", parent: name, pattern: "^(arn:(aws(-[a-z]+)*):redshift-serverless:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:workgroup/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case workgroupArn = "workgroupArn"
        }
    }

    public struct RetrievalFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the service to use for retrieving data to return as the output from the node.
        public let serviceConfiguration: RetrievalFlowNodeServiceConfiguration

        @inlinable
        public init(serviceConfiguration: RetrievalFlowNodeServiceConfiguration) {
            self.serviceConfiguration = serviceConfiguration
        }

        public func validate(name: String) throws {
            try self.serviceConfiguration.validate(name: "\(name).serviceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceConfiguration = "serviceConfiguration"
        }
    }

    public struct RetrievalFlowNodeS3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket from which to retrieve data.
        public let bucketName: String

        @inlinable
        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct S3Content: AWSEncodableShape {
        /// The S3 location of the file containing the content to ingest.
        public let s3Location: S3Location

        @inlinable
        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct S3DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket that contains your data.
        public let bucketArn: String
        /// The account ID for the owner of the S3 bucket.
        public let bucketOwnerAccountId: String?
        /// A list of S3 prefixes to include certain files or content. For more information,  see Organizing objects using prefixes.
        public let inclusionPrefixes: [String]?

        @inlinable
        public init(bucketArn: String, bucketOwnerAccountId: String? = nil, inclusionPrefixes: [String]? = nil) {
            self.bucketArn = bucketArn
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.inclusionPrefixes = inclusionPrefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 2048)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, min: 1)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):s3:::[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$")
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, max: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, min: 12)
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.inclusionPrefixes?.forEach {
                try validate($0, name: "inclusionPrefixes[]", parent: name, max: 300)
                try validate($0, name: "inclusionPrefixes[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, max: 1)
            try self.validate(self.inclusionPrefixes, name: "inclusionPrefixes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case inclusionPrefixes = "inclusionPrefixes"
        }
    }

    public struct S3Identifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket.
        public let s3BucketName: String?
        /// The S3 object key for the S3 resource.
        public let s3ObjectKey: String?

        @inlinable
        public init(s3BucketName: String? = nil, s3ObjectKey: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, max: 1024)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, min: 1)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The location's URI. For example, s3://my-bucket/chunk-processor/.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 2048)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://.{1,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct SalesforceCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the Salesforce content. For example,  configuring regular expression patterns to include or exclude certain  content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct SalesforceDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Salesforce content. For example, configuring  specific types of Salesforce content.
        public let crawlerConfiguration: SalesforceCrawlerConfiguration?
        /// The endpoint information to connect to your Salesforce data source.
        public let sourceConfiguration: SalesforceSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: SalesforceCrawlerConfiguration? = nil, sourceConfiguration: SalesforceSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct SalesforceSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect to your  Salesforce instance.
        public let authType: SalesforceAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your Salesforce instance URL.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  Salesforce connection configuration.
        public let credentialsSecretArn: String
        /// The Salesforce host URL or instance URL.
        public let hostUrl: String

        @inlinable
        public init(authType: SalesforceAuthType, credentialsSecretArn: String, hostUrl: String) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostUrl = hostUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.hostUrl, name: "hostUrl", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case hostUrl = "hostUrl"
        }
    }

    public struct SeedUrl: AWSEncodableShape & AWSDecodableShape {
        /// A seed or starting point URL.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.url, name: "url", parent: name, pattern: "^https?://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct SemanticChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dissimilarity threshold for splitting chunks.
        public let breakpointPercentileThreshold: Int
        /// The buffer size.
        public let bufferSize: Int
        /// The maximum number of tokens that a chunk can contain.
        public let maxTokens: Int

        @inlinable
        public init(breakpointPercentileThreshold: Int, bufferSize: Int, maxTokens: Int) {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case breakpointPercentileThreshold = "breakpointPercentileThreshold"
            case bufferSize = "bufferSize"
            case maxTokens = "maxTokens"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the resource.
        public let kmsKeyArn: String?

        @inlinable
        public init(kmsKeyArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct SessionSummaryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of recent session summaries to include in the agent's prompt context.
        public let maxRecentSessions: Int?

        @inlinable
        public init(maxRecentSessions: Int? = nil) {
            self.maxRecentSessions = maxRecentSessions
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRecentSessions, name: "maxRecentSessions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecentSessions = "maxRecentSessions"
        }
    }

    public struct SharePointCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of filtering the SharePoint content. For example,  configuring regular expression patterns to include or exclude certain content.
        public let filterConfiguration: CrawlFilterConfiguration?

        @inlinable
        public init(filterConfiguration: CrawlFilterConfiguration? = nil) {
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct SharePointDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the SharePoint content. For example, configuring  specific types of SharePoint content.
        public let crawlerConfiguration: SharePointCrawlerConfiguration?
        /// The endpoint information to connect to your SharePoint data source.
        public let sourceConfiguration: SharePointSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: SharePointCrawlerConfiguration? = nil, sourceConfiguration: SharePointSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct SharePointSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The supported authentication type to authenticate and connect  to your SharePoint site/sites.
        public let authType: SharePointAuthType
        /// The Amazon Resource Name of an Secrets Manager secret that  stores your authentication credentials for your SharePoint site/sites.  For more information on the key-value pairs that must be included in  your secret, depending on your authentication type, see  SharePoint connection configuration.
        public let credentialsSecretArn: String
        /// The domain of your SharePoint instance or site URL/URLs.
        public let domain: String
        /// The supported host type, whether online/cloud or server/on-premises.
        public let hostType: SharePointHostType
        /// A list of one or more SharePoint site URLs.
        public let siteUrls: [String]
        /// The identifier of your Microsoft 365 tenant.
        public let tenantId: String?

        @inlinable
        public init(authType: SharePointAuthType, credentialsSecretArn: String, domain: String, hostType: SharePointHostType, siteUrls: [String], tenantId: String? = nil) {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.domain = domain
            self.hostType = hostType
            self.siteUrls = siteUrls
            self.tenantId = tenantId
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
            try self.siteUrls.forEach {
                try validate($0, name: "siteUrls[]", parent: name, pattern: "^https://[A-Za-z0-9][^\\s]*$")
            }
            try self.validate(self.siteUrls, name: "siteUrls", parent: name, max: 100)
            try self.validate(self.siteUrls, name: "siteUrls", parent: name, min: 1)
            try self.validate(self.tenantId, name: "tenantId", parent: name, max: 36)
            try self.validate(self.tenantId, name: "tenantId", parent: name, min: 36)
            try self.validate(self.tenantId, name: "tenantId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case credentialsSecretArn = "credentialsSecretArn"
            case domain = "domain"
            case hostType = "hostType"
            case siteUrls = "siteUrls"
            case tenantId = "tenantId"
        }
    }

    public struct SpecificToolChoice: AWSEncodableShape & AWSDecodableShape {
        /// The name of the tool.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct SqlKnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        public let redshiftConfiguration: RedshiftConfiguration?
        /// The type of SQL database to connect to the knowledge base.
        public let type: QueryEngineType

        @inlinable
        public init(redshiftConfiguration: RedshiftConfiguration? = nil, type: QueryEngineType) {
            self.redshiftConfiguration = redshiftConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.redshiftConfiguration?.validate(name: "\(name).redshiftConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case redshiftConfiguration = "redshiftConfiguration"
            case type = "type"
        }
    }

    public struct StartIngestionJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The unique identifier of the data source you want to ingest into your knowledge base.
        public let dataSourceId: String
        /// A description of the data ingestion job.
        public let description: String?
        /// The unique identifier of the knowledge base for the data ingestion job.
        public let knowledgeBaseId: String

        @inlinable
        public init(clientToken: String? = StartIngestionJobRequest.idempotencyToken(), dataSourceId: String, description: String? = nil, knowledgeBaseId: String) {
            self.clientToken = clientToken
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct StartIngestionJobResponse: AWSDecodableShape {
        /// Contains information about the data ingestion job.
        public let ingestionJob: IngestionJob

        @inlinable
        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct StopIngestionJobRequest: AWSEncodableShape {
        /// The unique identifier of the data source for the data ingestion job you want to stop.
        public let dataSourceId: String
        /// The unique identifier of the data ingestion job you want to stop.
        public let ingestionJobId: String
        /// The unique identifier of the knowledge base for the data ingestion job you want to stop.
        public let knowledgeBaseId: String

        @inlinable
        public init(dataSourceId: String, ingestionJobId: String, knowledgeBaseId: String) {
            self.dataSourceId = dataSourceId
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.ingestionJobId, key: "ingestionJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.ingestionJobId, name: "ingestionJobId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopIngestionJobResponse: AWSDecodableShape {
        /// Contains information about the stopped data ingestion job.
        public let ingestionJob: IngestionJob

        @inlinable
        public init(ingestionJob: IngestionJob) {
            self.ingestionJob = ingestionJob
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionJob = "ingestionJob"
        }
    }

    public struct StorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the storage configuration of the knowledge base in MongoDB Atlas.
        public let mongoDbAtlasConfiguration: MongoDbAtlasConfiguration?
        /// Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information,  see Create a vector index in Amazon Neptune Analytics..
        public let neptuneAnalyticsConfiguration: NeptuneAnalyticsConfiguration?
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public let opensearchServerlessConfiguration: OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public let pineconeConfiguration: PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        public let rdsConfiguration: RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public let redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        public let type: KnowledgeBaseStorageType

        @inlinable
        public init(mongoDbAtlasConfiguration: MongoDbAtlasConfiguration? = nil, neptuneAnalyticsConfiguration: NeptuneAnalyticsConfiguration? = nil, opensearchServerlessConfiguration: OpenSearchServerlessConfiguration? = nil, pineconeConfiguration: PineconeConfiguration? = nil, rdsConfiguration: RdsConfiguration? = nil, redisEnterpriseCloudConfiguration: RedisEnterpriseCloudConfiguration? = nil, type: KnowledgeBaseStorageType) {
            self.mongoDbAtlasConfiguration = mongoDbAtlasConfiguration
            self.neptuneAnalyticsConfiguration = neptuneAnalyticsConfiguration
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.mongoDbAtlasConfiguration?.validate(name: "\(name).mongoDbAtlasConfiguration")
            try self.neptuneAnalyticsConfiguration?.validate(name: "\(name).neptuneAnalyticsConfiguration")
            try self.opensearchServerlessConfiguration?.validate(name: "\(name).opensearchServerlessConfiguration")
            try self.pineconeConfiguration?.validate(name: "\(name).pineconeConfiguration")
            try self.rdsConfiguration?.validate(name: "\(name).rdsConfiguration")
            try self.redisEnterpriseCloudConfiguration?.validate(name: "\(name).redisEnterpriseCloudConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case mongoDbAtlasConfiguration = "mongoDbAtlasConfiguration"
            case neptuneAnalyticsConfiguration = "neptuneAnalyticsConfiguration"
            case opensearchServerlessConfiguration = "opensearchServerlessConfiguration"
            case pineconeConfiguration = "pineconeConfiguration"
            case rdsConfiguration = "rdsConfiguration"
            case redisEnterpriseCloudConfiguration = "redisEnterpriseCloudConfiguration"
            case type = "type"
        }
    }

    public struct StorageFlowNodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the service to use for storing the input into the node.
        public let serviceConfiguration: StorageFlowNodeServiceConfiguration

        @inlinable
        public init(serviceConfiguration: StorageFlowNodeServiceConfiguration) {
            self.serviceConfiguration = serviceConfiguration
        }

        public func validate(name: String) throws {
            try self.serviceConfiguration.validate(name: "\(name).serviceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceConfiguration = "serviceConfiguration"
        }
    }

    public struct StorageFlowNodeS3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket in which to store the input into the node.
        public let bucketName: String

        @inlinable
        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct SupplementalDataStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of objects specifying storage locations for images extracted from multimodal documents in your data source.
        public let storageLocations: [SupplementalDataStorageLocation]

        @inlinable
        public init(storageLocations: [SupplementalDataStorageLocation]) {
            self.storageLocations = storageLocations
        }

        public func validate(name: String) throws {
            try self.storageLocations.forEach {
                try $0.validate(name: "\(name).storageLocations[]")
            }
            try self.validate(self.storageLocations, name: "storageLocations", parent: name, max: 1)
            try self.validate(self.storageLocations, name: "storageLocations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case storageLocations = "storageLocations"
        }
    }

    public struct SupplementalDataStorageLocation: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about the Amazon S3 location for the extracted images.
        public let s3Location: S3Location?
        /// Specifies the storage service used for this location.
        public let type: SupplementalDataStorageLocationType

        @inlinable
        public init(s3Location: S3Location? = nil, type: SupplementalDataStorageLocationType) {
            self.s3Location = s3Location
            self.type = type
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
            case type = "type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// An object containing key-value pairs that define the tags to attach to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextContentDoc: AWSEncodableShape {
        /// The text of the content.
        public let data: String

        @inlinable
        public init(data: String) {
            self.data = data
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 5242880)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
        }
    }

    public struct TextPromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A cache checkpoint within a template configuration.
        public let cachePoint: CachePointBlock?
        /// An array of the variables in the prompt template.
        public let inputVariables: [PromptInputVariable]?
        /// The message for the prompt.
        public let text: String

        @inlinable
        public init(cachePoint: CachePointBlock? = nil, inputVariables: [PromptInputVariable]? = nil, text: String) {
            self.cachePoint = cachePoint
            self.inputVariables = inputVariables
            self.text = text
        }

        public func validate(name: String) throws {
            try self.inputVariables?.forEach {
                try $0.validate(name: "\(name).inputVariables[]")
            }
            try self.validate(self.inputVariables, name: "inputVariables", parent: name, max: 20)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case inputVariables = "inputVariables"
            case text = "text"
        }
    }

    public struct ToolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines which tools the model should request when invoked.
        public let toolChoice: ToolChoice?
        /// An array of tools to pass to a model.
        public let tools: [Tool]

        @inlinable
        public init(toolChoice: ToolChoice? = nil, tools: [Tool]) {
            self.toolChoice = toolChoice
            self.tools = tools
        }

        public func validate(name: String) throws {
            try self.toolChoice?.validate(name: "\(name).toolChoice")
            try self.tools.forEach {
                try $0.validate(name: "\(name).tools[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case toolChoice = "toolChoice"
            case tools = "tools"
        }
    }

    public struct ToolSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The description of the tool.
        public let description: String?
        /// The input schema for the tool.
        public let inputSchema: ToolInputSchema
        /// The name of the tool.
        public let name: String

        @inlinable
        public init(description: String? = nil, inputSchema: ToolInputSchema, name: String) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputSchema = "inputSchema"
            case name = "name"
        }
    }

    public struct Transformation: AWSEncodableShape & AWSDecodableShape {
        /// When the service applies the transformation.
        public let stepToApply: StepType
        /// A Lambda function that processes documents.
        public let transformationFunction: TransformationFunction

        @inlinable
        public init(stepToApply: StepType, transformationFunction: TransformationFunction) {
            self.stepToApply = stepToApply
            self.transformationFunction = transformationFunction
        }

        public func validate(name: String) throws {
            try self.transformationFunction.validate(name: "\(name).transformationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case stepToApply = "stepToApply"
            case transformationFunction = "transformationFunction"
        }
    }

    public struct TransformationFunction: AWSEncodableShape & AWSDecodableShape {
        /// The Lambda function.
        public let transformationLambdaConfiguration: TransformationLambdaConfiguration

        @inlinable
        public init(transformationLambdaConfiguration: TransformationLambdaConfiguration) {
            self.transformationLambdaConfiguration = transformationLambdaConfiguration
        }

        public func validate(name: String) throws {
            try self.transformationLambdaConfiguration.validate(name: "\(name).transformationLambdaConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case transformationLambdaConfiguration = "transformationLambdaConfiguration"
        }
    }

    public struct TransformationLambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The function's ARN identifier.
        public let lambdaArn: String

        @inlinable
        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
        }
    }

    public struct UnfulfilledNodeInputFlowValidationDetails: AWSDecodableShape {
        /// The name of the unfulfilled input. An input is unfulfilled if there are no data connections to it.
        public let input: String
        /// The name of the node containing the unfulfilled input.
        public let node: String

        @inlinable
        public init(input: String, node: String) {
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case node = "node"
        }
    }

    public struct UnknownConnectionConditionFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with the unknown condition.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnknownConnectionSourceFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with the unknown source.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnknownConnectionSourceOutputFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with the unknown source output.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnknownConnectionTargetFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with the unknown target.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnknownConnectionTargetInputFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with the unknown target input.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnknownNodeInputFlowValidationDetails: AWSDecodableShape {
        /// The name of the node with the unknown input.
        public let input: String
        /// The name of the unknown input.
        public let node: String

        @inlinable
        public init(input: String, node: String) {
            self.input = input
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case node = "node"
        }
    }

    public struct UnknownNodeOutputFlowValidationDetails: AWSDecodableShape {
        /// The name of the node with the unknown output.
        public let node: String
        /// The name of the unknown output.
        public let output: String

        @inlinable
        public init(node: String, output: String) {
            self.node = node
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case node = "node"
            case output = "output"
        }
    }

    public struct UnreachableNodeFlowValidationDetails: AWSDecodableShape {
        /// The name of the unreachable node.
        public let node: String

        @inlinable
        public init(node: String) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "node"
        }
    }

    public struct UnsatisfiedConnectionConditionsFlowValidationDetails: AWSDecodableShape {
        /// The name of the connection with unsatisfied conditions.
        public let connection: String

        @inlinable
        public init(connection: String) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct UnspecifiedFlowValidationDetails: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
        public let resourceArn: String
        /// A list of keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:(agent|agent-alias|knowledge-base|flow|prompt)/[A-Z0-9]{10}(?:/[A-Z0-9]{10})?$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:flow/([A-Z0-9]{10})/alias/([A-Z0-9]{10})$|^arn:aws:bedrock:[a-zA-Z0-9-]+:/d{12}:prompt/([A-Z0-9]{10})?(?::/d+)?$)")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentActionGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let actionGroupExecutor: ActionGroupExecutor?
        /// The unique identifier of the action group.
        public let actionGroupId: String
        /// Specifies a new name for the action group.
        public let actionGroupName: String
        /// Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
        public let actionGroupState: ActionGroupState?
        /// The unique identifier of the agent for which to update the action group.
        public let agentId: String
        /// The unique identifier of the agent version for which to update the action group.
        public let agentVersion: String
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        /// Specifies a new name for the action group.
        public let description: String?
        /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let functionSchema: FunctionSchema?
        /// Update the built-in or computer use action for this action group. If you specify a value, you must leave the description, apiSchema, and actionGroupExecutor fields empty for this action group.    To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.    To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter.   To allow your agent to use an Anthropic computer use tool, specify one of the following values.    Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only.           When operating computer use functionality, we recommend taking additional security precautions, such as executing computer actions in virtual environments with restricted data access and limited internet connectivity.  For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.      ANTHROPIC.Computer - Gives the agent permission to use the mouse and keyboard and take screenshots.    ANTHROPIC.TextEditor - Gives the agent permission to view, create and edit files.    ANTHROPIC.Bash - Gives the agent permission to run commands in a bash shell.     During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?
        /// The configuration settings for a computer use action.   Computer use is a new Anthropic Claude model capability (in beta) available with Claude 3.7 and Claude 3.5 Sonnet v2 only. For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.
        public let parentActionGroupSignatureParams: [String: String]?

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupId: String, actionGroupName: String, actionGroupState: ActionGroupState? = nil, agentId: String, agentVersion: String, apiSchema: APISchema? = nil, description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignature: ActionGroupSignature? = nil, parentActionGroupSignatureParams: [String: String]? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
            self.parentActionGroupSignatureParams = parentActionGroupSignatureParams
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroupExecutor, forKey: .actionGroupExecutor)
            request.encodePath(self.actionGroupId, key: "actionGroupId")
            try container.encode(self.actionGroupName, forKey: .actionGroupName)
            try container.encodeIfPresent(self.actionGroupState, forKey: .actionGroupState)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.apiSchema, forKey: .apiSchema)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.functionSchema, forKey: .functionSchema)
            try container.encodeIfPresent(self.parentActionGroupSignature, forKey: .parentActionGroupSignature)
            try container.encodeIfPresent(self.parentActionGroupSignatureParams, forKey: .parentActionGroupSignatureParams)
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupId, name: "actionGroupId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.functionSchema?.validate(name: "\(name).functionSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case actionGroupState = "actionGroupState"
            case apiSchema = "apiSchema"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignature = "parentActionGroupSignature"
            case parentActionGroupSignatureParams = "parentActionGroupSignatureParams"
        }
    }

    public struct UpdateAgentActionGroupResponse: AWSDecodableShape {
        /// Contains details about the action group that was updated.
        public let agentActionGroup: AgentActionGroup

        @inlinable
        public init(agentActionGroup: AgentActionGroup) {
            self.agentActionGroup = agentActionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case agentActionGroup = "agentActionGroup"
        }
    }

    public struct UpdateAgentAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias.
        public let agentAliasId: String
        /// Specifies a new name for the alias.
        public let agentAliasName: String
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new description for the alias.
        public let description: String?
        /// Contains details about the routing configuration of the alias.
        public let routingConfiguration: [AgentAliasRoutingConfigurationListItem]?

        @inlinable
        public init(agentAliasId: String, agentAliasName: String, agentId: String, description: String? = nil, routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil) {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentId = agentId
            self.description = description
            self.routingConfiguration = routingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            try container.encode(self.agentAliasName, forKey: .agentAliasName)
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routingConfiguration, forKey: .routingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, min: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.agentAliasName, name: "agentAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasName = "agentAliasName"
            case description = "description"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct UpdateAgentAliasResponse: AWSDecodableShape {
        /// Contains details about the alias that was updated.
        public let agentAlias: AgentAlias

        @inlinable
        public init(agentAlias: AgentAlias) {
            self.agentAlias = agentAlias
        }

        private enum CodingKeys: String, CodingKey {
            case agentAlias = "agentAlias"
        }
    }

    public struct UpdateAgentCollaboratorRequest: AWSEncodableShape {
        /// An agent descriptor for the agent collaborator.
        public let agentDescriptor: AgentDescriptor
        /// The agent's ID.
        public let agentId: String
        /// The agent's version.
        public let agentVersion: String
        /// Instruction for the collaborator.
        public let collaborationInstruction: String
        /// The collaborator's ID.
        public let collaboratorId: String
        /// The collaborator's name.
        public let collaboratorName: String
        /// A relay conversation history for the collaborator.
        public let relayConversationHistory: RelayConversationHistory?

        @inlinable
        public init(agentDescriptor: AgentDescriptor, agentId: String, agentVersion: String, collaborationInstruction: String, collaboratorId: String, collaboratorName: String, relayConversationHistory: RelayConversationHistory? = nil) {
            self.agentDescriptor = agentDescriptor
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.collaborationInstruction = collaborationInstruction
            self.collaboratorId = collaboratorId
            self.collaboratorName = collaboratorName
            self.relayConversationHistory = relayConversationHistory
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentDescriptor, forKey: .agentDescriptor)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encode(self.collaborationInstruction, forKey: .collaborationInstruction)
            request.encodePath(self.collaboratorId, key: "collaboratorId")
            try container.encode(self.collaboratorName, forKey: .collaboratorName)
            try container.encodeIfPresent(self.relayConversationHistory, forKey: .relayConversationHistory)
        }

        public func validate(name: String) throws {
            try self.agentDescriptor.validate(name: "\(name).agentDescriptor")
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.collaborationInstruction, name: "collaborationInstruction", parent: name, max: 4000)
            try self.validate(self.collaborationInstruction, name: "collaborationInstruction", parent: name, min: 1)
            try self.validate(self.collaboratorId, name: "collaboratorId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.collaboratorName, name: "collaboratorName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentDescriptor = "agentDescriptor"
            case collaborationInstruction = "collaborationInstruction"
            case collaboratorName = "collaboratorName"
            case relayConversationHistory = "relayConversationHistory"
        }
    }

    public struct UpdateAgentCollaboratorResponse: AWSDecodableShape {
        /// Details about the collaborator.
        public let agentCollaborator: AgentCollaborator

        @inlinable
        public init(agentCollaborator: AgentCollaborator) {
            self.agentCollaborator = agentCollaborator
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaborator = "agentCollaborator"
        }
    }

    public struct UpdateAgentKnowledgeBaseRequest: AWSEncodableShape {
        /// The unique identifier of the agent associated with the knowledge base that you want to update.
        public let agentId: String
        /// The version of the agent associated with the knowledge base that you want to update.
        public let agentVersion: String
        /// Specifies a new description for the knowledge base associated with an agent.
        public let description: String?
        /// The unique identifier of the knowledge base that has been associated with an agent.
        public let knowledgeBaseId: String
        /// Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
        public let knowledgeBaseState: KnowledgeBaseState?

        @inlinable
        public init(agentId: String, agentVersion: String, description: String? = nil, knowledgeBaseId: String, knowledgeBaseState: KnowledgeBaseState? = nil) {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            request.encodePath(self.agentVersion, key: "agentVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.knowledgeBaseState, forKey: .knowledgeBaseState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 5)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseState = "knowledgeBaseState"
        }
    }

    public struct UpdateAgentKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base that has been associated with an agent.
        public let agentKnowledgeBase: AgentKnowledgeBase

        @inlinable
        public init(agentKnowledgeBase: AgentKnowledgeBase) {
            self.agentKnowledgeBase = agentKnowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case agentKnowledgeBase = "agentKnowledgeBase"
        }
    }

    public struct UpdateAgentRequest: AWSEncodableShape {
        /// The agent's collaboration role.
        public let agentCollaboration: AgentCollaboration?
        /// The unique identifier of the agent.
        public let agentId: String
        /// Specifies a new name for the agent.
        public let agentName: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        public let agentResourceRoleArn: String
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
        public let customerEncryptionKeyArn: String?
        ///  Contains details of the custom orchestration configured for the agent.
        public let customOrchestration: CustomOrchestration?
        /// Specifies a new description of the agent.
        public let description: String?
        /// The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
        public let foundationModel: String?
        /// The unique Guardrail configuration assigned to the agent when it is updated.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public let idleSessionTTLInSeconds: Int?
        /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
        public let instruction: String?
        /// Specifies the new memory configuration for the agent.
        public let memoryConfiguration: MemoryConfiguration?
        ///  Specifies the type of orchestration strategy for the agent. This is set to DEFAULT orchestration type, by default.
        public let orchestrationType: OrchestrationType?
        /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?

        @inlinable
        public init(agentCollaboration: AgentCollaboration? = nil, agentId: String, agentName: String, agentResourceRoleArn: String, customerEncryptionKeyArn: String? = nil, customOrchestration: CustomOrchestration? = nil, description: String? = nil, foundationModel: String? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, idleSessionTTLInSeconds: Int? = nil, instruction: String? = nil, memoryConfiguration: MemoryConfiguration? = nil, orchestrationType: OrchestrationType? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil) {
            self.agentCollaboration = agentCollaboration
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.customOrchestration = customOrchestration
            self.description = description
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.orchestrationType = orchestrationType
            self.promptOverrideConfiguration = promptOverrideConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.agentCollaboration, forKey: .agentCollaboration)
            request.encodePath(self.agentId, key: "agentId")
            try container.encode(self.agentName, forKey: .agentName)
            try container.encode(self.agentResourceRoleArn, forKey: .agentResourceRoleArn)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.customOrchestration, forKey: .customOrchestration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.foundationModel, forKey: .foundationModel)
            try container.encodeIfPresent(self.guardrailConfiguration, forKey: .guardrailConfiguration)
            try container.encodeIfPresent(self.idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
            try container.encodeIfPresent(self.instruction, forKey: .instruction)
            try container.encodeIfPresent(self.memoryConfiguration, forKey: .memoryConfiguration)
            try container.encodeIfPresent(self.orchestrationType, forKey: .orchestrationType)
            try container.encodeIfPresent(self.promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.agentName, name: "agentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, max: 2048)
            try self.validate(self.agentResourceRoleArn, name: "agentResourceRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.customOrchestration?.validate(name: "\(name).customOrchestration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.instruction, name: "instruction", parent: name, max: 4000)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.memoryConfiguration?.validate(name: "\(name).memoryConfiguration")
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaboration = "agentCollaboration"
            case agentName = "agentName"
            case agentResourceRoleArn = "agentResourceRoleArn"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case customOrchestration = "customOrchestration"
            case description = "description"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case instruction = "instruction"
            case memoryConfiguration = "memoryConfiguration"
            case orchestrationType = "orchestrationType"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
        }
    }

    public struct UpdateAgentResponse: AWSDecodableShape {
        /// Contains details about the agent that was updated.
        public let agent: Agent

        @inlinable
        public init(agent: Agent) {
            self.agent = agent
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// The data deletion policy for the data source that you want to update.
        public let dataDeletionPolicy: DataDeletionPolicy?
        /// The connection configuration for the data source that you want to update.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The unique identifier of the data source.
        public let dataSourceId: String
        /// Specifies a new description for the data source.
        public let description: String?
        /// The unique identifier of the knowledge base for the data source.
        public let knowledgeBaseId: String
        /// Specifies a new name for the data source.
        public let name: String
        /// Contains details about server-side encryption of the data source.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Contains details about how to ingest the documents in the data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(dataDeletionPolicy: DataDeletionPolicy? = nil, dataSourceConfiguration: DataSourceConfiguration, dataSourceId: String, description: String? = nil, knowledgeBaseId: String, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataDeletionPolicy, forKey: .dataDeletionPolicy)
            try container.encode(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
            try container.encodeIfPresent(self.vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }

        public func validate(name: String) throws {
            try self.dataSourceConfiguration.validate(name: "\(name).dataSourceConfiguration")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataDeletionPolicy = "dataDeletionPolicy"
            case dataSourceConfiguration = "dataSourceConfiguration"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// Contains details about the data source.
        public let dataSource: DataSource

        @inlinable
        public init(dataSource: DataSource) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct UpdateFlowAliasRequest: AWSEncodableShape {
        /// The unique identifier of the alias.
        public let aliasIdentifier: String
        /// A description for the alias.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version to which to map the alias.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]

        @inlinable
        public init(aliasIdentifier: String, description: String? = nil, flowIdentifier: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem]) {
            self.aliasIdentifier = aliasIdentifier
            self.description = description
            self.flowIdentifier = flowIdentifier
            self.name = name
            self.routingConfiguration = routingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasIdentifier, key: "aliasIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.routingConfiguration, forKey: .routingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasIdentifier, name: "aliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(TSTALIASID|[0-9a-zA-Z]{10})$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.routingConfiguration.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 1)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct UpdateFlowAliasResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the flow.
        public let description: String?
        /// The unique identifier of the flow.
        public let flowId: String
        /// The unique identifier of the alias.
        public let id: String
        /// The name of the alias.
        public let name: String
        /// Contains information about the version that the alias is mapped to.
        public let routingConfiguration: [FlowAliasRoutingConfigurationListItem]
        /// The time at which the alias was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, flowId: String, id: String, name: String, routingConfiguration: [FlowAliasRoutingConfigurationListItem], updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case flowId = "flowId"
            case id = "id"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateFlowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and the connections between the nodes in the flow.
        public let definition: FlowDefinition?
        /// A description for the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// A name for the flow.
        public let name: String

        @inlinable
        public init(customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, flowIdentifier: String, name: String) {
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.flowIdentifier = flowIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.executionRoleArn, forKey: .executionRoleArn)
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?.+$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
        }
    }

    public struct UpdateFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String
        /// The time at which the flow was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key that the flow was encrypted with.
        public let customerEncryptionKeyArn: String?
        /// A definition of the nodes and the connections between nodes in the flow.
        public let definition: FlowDefinition?
        /// The description of the flow.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let executionRoleArn: String
        /// The unique identifier of the flow.
        public let id: String
        /// The name of the flow.
        public let name: String
        /// The status of the flow. When you submit this request, the status will be NotPrepared. If updating fails, the status becomes Failed.
        public let status: FlowStatus
        /// The time at which the flow was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the flow. When you update a flow, the version updated is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, definition: FlowDefinition? = nil, description: String? = nil, executionRoleArn: String, id: String, name: String, status: FlowStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.definition = definition
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case definition = "definition"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct UpdateKnowledgeBaseRequest: AWSEncodableShape {
        /// Specifies a new description for the knowledge base.
        public let description: String?
        /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let knowledgeBaseConfiguration: KnowledgeBaseConfiguration
        /// The unique identifier of the knowledge base to update.
        public let knowledgeBaseId: String
        /// Specifies a new name for the knowledge base.
        public let name: String
        /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        public let roleArn: String
        /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
        public let storageConfiguration: StorageConfiguration?

        @inlinable
        public init(description: String? = nil, knowledgeBaseConfiguration: KnowledgeBaseConfiguration, knowledgeBaseId: String, name: String, roleArn: String, storageConfiguration: StorageConfiguration? = nil) {
            self.description = description
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.storageConfiguration = storageConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.storageConfiguration, forKey: .storageConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.knowledgeBaseConfiguration.validate(name: "\(name).knowledgeBaseConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.storageConfiguration?.validate(name: "\(name).storageConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct UpdateKnowledgeBaseResponse: AWSDecodableShape {
        /// Contains details about the knowledge base.
        public let knowledgeBase: KnowledgeBase

        @inlinable
        public init(knowledgeBase: KnowledgeBase) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct UpdatePromptRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// A description for the prompt.
        public let description: String?
        /// A name for the prompt.
        public let name: String
        /// The unique identifier of the prompt.
        public let promptIdentifier: String
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?

        @inlinable
        public init(customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, name: String, promptIdentifier: String, variants: [PromptVariant]? = nil) {
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.name = name
            self.promptIdentifier = promptIdentifier
            self.variants = variants
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.defaultVariant, forKey: .defaultVariant)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.promptIdentifier, key: "promptIdentifier")
            try container.encodeIfPresent(self.variants, forKey: .variants)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.defaultVariant, name: "defaultVariant", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.promptIdentifier, name: "promptIdentifier", parent: name, pattern: "^([0-9a-zA-Z]{10})|(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10})(?::[0-9]{1,5})?$")
            try self.variants?.forEach {
                try $0.validate(name: "\(name).variants[]")
            }
            try self.validate(self.variants, name: "variants", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case name = "name"
            case variants = "variants"
        }
    }

    public struct UpdatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String
        /// The time at which the prompt was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
        public let customerEncryptionKeyArn: String?
        /// The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
        public let defaultVariant: String?
        /// The description of the prompt.
        public let description: String?
        /// The unique identifier of the prompt.
        public let id: String
        /// The name of the prompt.
        public let name: String
        /// The time at which the prompt was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// A list of objects, each containing details about a variant of the prompt.
        public let variants: [PromptVariant]?
        /// The version of the prompt. When you update a prompt, the version updated is the DRAFT version.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, customerEncryptionKeyArn: String? = nil, defaultVariant: String? = nil, description: String? = nil, id: String, name: String, updatedAt: Date, variants: [PromptVariant]? = nil, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.defaultVariant = defaultVariant
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.variants = variants
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case defaultVariant = "defaultVariant"
            case description = "description"
            case id = "id"
            case name = "name"
            case updatedAt = "updatedAt"
            case variants = "variants"
            case version = "version"
        }
    }

    public struct UrlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// One or more seed or starting point URLs.
        public let seedUrls: [SeedUrl]?

        @inlinable
        public init(seedUrls: [SeedUrl]? = nil) {
            self.seedUrls = seedUrls
        }

        public func validate(name: String) throws {
            try self.seedUrls?.forEach {
                try $0.validate(name: "\(name).seedUrls[]")
            }
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, max: 100)
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case seedUrls = "seedUrls"
        }
    }

    public struct ValidateFlowDefinitionRequest: AWSEncodableShape {
        /// The definition of a flow to validate.
        public let definition: FlowDefinition

        @inlinable
        public init(definition: FlowDefinition) {
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
        }
    }

    public struct ValidateFlowDefinitionResponse: AWSDecodableShape {
        /// Contains an array of objects, each of which contains an error identified by validation.
        public let validations: [FlowValidation]

        @inlinable
        public init(validations: [FlowValidation]) {
            self.validations = validations
        }

        private enum CodingKeys: String, CodingKey {
            case validations = "validations"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A list of objects containing fields that caused validation errors and their corresponding validation error messages.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil) {
            self.fieldList = fieldList
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VectorIngestionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public let chunkingConfiguration: ChunkingConfiguration?
        /// The context enrichment configuration used for ingestion of the data into the vector store.
        public let contextEnrichmentConfiguration: ContextEnrichmentConfiguration?
        /// A custom document transformer for parsed data source documents.
        public let customTransformationConfiguration: CustomTransformationConfiguration?
        /// Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        public let parsingConfiguration: ParsingConfiguration?

        @inlinable
        public init(chunkingConfiguration: ChunkingConfiguration? = nil, contextEnrichmentConfiguration: ContextEnrichmentConfiguration? = nil, customTransformationConfiguration: CustomTransformationConfiguration? = nil, parsingConfiguration: ParsingConfiguration? = nil) {
            self.chunkingConfiguration = chunkingConfiguration
            self.contextEnrichmentConfiguration = contextEnrichmentConfiguration
            self.customTransformationConfiguration = customTransformationConfiguration
            self.parsingConfiguration = parsingConfiguration
        }

        public func validate(name: String) throws {
            try self.chunkingConfiguration?.validate(name: "\(name).chunkingConfiguration")
            try self.contextEnrichmentConfiguration?.validate(name: "\(name).contextEnrichmentConfiguration")
            try self.customTransformationConfiguration?.validate(name: "\(name).customTransformationConfiguration")
            try self.parsingConfiguration?.validate(name: "\(name).parsingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingConfiguration = "chunkingConfiguration"
            case contextEnrichmentConfiguration = "contextEnrichmentConfiguration"
            case customTransformationConfiguration = "customTransformationConfiguration"
            case parsingConfiguration = "parsingConfiguration"
        }
    }

    public struct VectorKnowledgeBaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        public let embeddingModelArn: String
        /// The embeddings model configuration details for the vector model used in Knowledge Base.
        public let embeddingModelConfiguration: EmbeddingModelConfiguration?
        /// If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using RetrieveAndGenerate.
        public let supplementalDataStorageConfiguration: SupplementalDataStorageConfiguration?

        @inlinable
        public init(embeddingModelArn: String, embeddingModelConfiguration: EmbeddingModelConfiguration? = nil, supplementalDataStorageConfiguration: SupplementalDataStorageConfiguration? = nil) {
            self.embeddingModelArn = embeddingModelArn
            self.embeddingModelConfiguration = embeddingModelConfiguration
            self.supplementalDataStorageConfiguration = supplementalDataStorageConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, max: 2048)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, min: 20)
            try self.validate(self.embeddingModelArn, name: "embeddingModelArn", parent: name, pattern: "^(arn:aws(-[^:]{1,12})?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-zA-Z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.embeddingModelConfiguration?.validate(name: "\(name).embeddingModelConfiguration")
            try self.supplementalDataStorageConfiguration?.validate(name: "\(name).supplementalDataStorageConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case embeddingModelArn = "embeddingModelArn"
            case embeddingModelConfiguration = "embeddingModelConfiguration"
            case supplementalDataStorageConfiguration = "supplementalDataStorageConfiguration"
        }
    }

    public struct WebCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of crawl limits for the web URLs.
        public let crawlerLimits: WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude  certain URLs. If you specify an inclusion and exclusion filter/pattern  and both match a URL, the exclusion filter takes precedence and the web  content of the URL isn’t crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include  certain URLs. If you specify an inclusion and exclusion filter/pattern  and both match a URL, the exclusion filter takes precedence and the web  content of the URL isn’t crawled.
        public let inclusionFilters: [String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary  domain. For example, only web pages that contain the seed URL  "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains.  You can choose to include sub domains in addition to the host or primary domain.  For example, web pages that contain "aws.amazon.com" can also include sub domain  "docs.aws.amazon.com".
        public let scope: WebScopeType?
        /// Returns the user agent suffix for your web crawler.
        public let userAgent: String?
        /// A string used for identifying the crawler or bot when it accesses a web server. The user agent header value consists of the bedrockbot, UUID, and a user agent suffix for your crawler (if one is provided). By default, it is set to bedrockbot_UUID. You can optionally append a custom  suffix to bedrockbot_UUID to allowlist a specific user agent permitted to access your source URLs.
        public let userAgentHeader: String?

        @inlinable
        public init(crawlerLimits: WebCrawlerLimits? = nil, exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, scope: WebScopeType? = nil, userAgent: String? = nil, userAgentHeader: String? = nil) {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
            self.userAgent = userAgent
            self.userAgentHeader = userAgentHeader
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
            try self.validate(self.userAgent, name: "userAgent", parent: name, max: 40)
            try self.validate(self.userAgent, name: "userAgent", parent: name, min: 15)
            try self.validate(self.userAgentHeader, name: "userAgentHeader", parent: name, max: 86)
            try self.validate(self.userAgentHeader, name: "userAgentHeader", parent: name, min: 61)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLimits = "crawlerLimits"
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case scope = "scope"
            case userAgent = "userAgent"
            case userAgentHeader = "userAgentHeader"
        }
    }

    public struct WebCrawlerLimits: AWSEncodableShape & AWSDecodableShape {
        ///  The max number of web pages crawled from your source URLs, up to 25,000 pages.  If  the web pages exceed this limit, the data source sync will fail and no web pages will be ingested.
        public let maxPages: Int?
        /// The max rate at which pages are crawled, up to 300 per minute per host.
        public let rateLimit: Int?

        @inlinable
        public init(maxPages: Int? = nil, rateLimit: Int? = nil) {
            self.maxPages = maxPages
            self.rateLimit = rateLimit
        }

        private enum CodingKeys: String, CodingKey {
            case maxPages = "maxPages"
            case rateLimit = "rateLimit"
        }
    }

    public struct WebDataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Web Crawler configuration details for the web data source.
        public let crawlerConfiguration: WebCrawlerConfiguration?
        /// The source configuration details for the web data source.
        public let sourceConfiguration: WebSourceConfiguration

        @inlinable
        public init(crawlerConfiguration: WebCrawlerConfiguration? = nil, sourceConfiguration: WebSourceConfiguration) {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.crawlerConfiguration?.validate(name: "\(name).crawlerConfiguration")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerConfiguration = "crawlerConfiguration"
            case sourceConfiguration = "sourceConfiguration"
        }
    }

    public struct WebSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the URL/URLs.
        public let urlConfiguration: UrlConfiguration

        @inlinable
        public init(urlConfiguration: UrlConfiguration) {
            self.urlConfiguration = urlConfiguration
        }

        public func validate(name: String) throws {
            try self.urlConfiguration.validate(name: "\(name).urlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case urlConfiguration = "urlConfiguration"
        }
    }

    public struct FunctionSchema: AWSEncodableShape & AWSDecodableShape {
        /// A list of functions that each define an action in the action group.
        public let functions: [Function]?

        @inlinable
        public init(functions: [Function]? = nil) {
            self.functions = functions
        }

        public func validate(name: String) throws {
            try self.functions?.forEach {
                try $0.validate(name: "\(name).functions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
        }
    }

    public struct OrchestrationExecutor: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        public let lambda: String?

        @inlinable
        public init(lambda: String? = nil) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.validate(self.lambda, name: "lambda", parent: name, max: 2048)
            try self.validate(self.lambda, name: "lambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
        }
    }

    public struct PromptGenAiResource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an Amazon Bedrock agent with which to use the prompt.
        public let agent: PromptAgentResource?

        @inlinable
        public init(agent: PromptAgentResource? = nil) {
            self.agent = agent
        }

        public func validate(name: String) throws {
            try self.agent?.validate(name: "\(name).agent")
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
        }
    }

    public struct PromptInferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains inference configurations for a text prompt.
        public let text: PromptModelInferenceConfiguration?

        @inlinable
        public init(text: PromptModelInferenceConfiguration? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.text?.validate(name: "\(name).text")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrievalFlowNodeServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.
        public let s3: RetrievalFlowNodeS3Configuration?

        @inlinable
        public init(s3: RetrievalFlowNodeS3Configuration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct StorageFlowNodeServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations for the Amazon S3 location in which to store the input into the node.
        public let s3: StorageFlowNodeS3Configuration?

        @inlinable
        public init(s3: StorageFlowNodeS3Configuration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct ToolInputSchema: AWSEncodableShape & AWSDecodableShape {
        /// A JSON object defining the input schema for the tool.
        public let json: AWSDocument?

        @inlinable
        public init(json: AWSDocument? = nil) {
            self.json = json
        }

        private enum CodingKeys: String, CodingKey {
            case json = "json"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgent
public struct BedrockAgentErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgent
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgent.ValidationException.self
    ]
}

extension BedrockAgentErrorType: Equatable {
    public static func == (lhs: BedrockAgentErrorType, rhs: BedrockAgentErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
