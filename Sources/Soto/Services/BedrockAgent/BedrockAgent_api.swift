//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS BedrockAgent service.
///
/// Describes the API operations for creating and managing Amazon Bedrock agents.
public struct BedrockAgent: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the BedrockAgent client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "BedrockAgent",
            serviceIdentifier: "bedrock-agent",
            signingName: "bedrock",
            serviceProtocol: .restjson,
            apiVersion: "2023-06-05",
            endpoint: endpoint,
            errorType: BedrockAgentErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Makes an agent a collaborator for another agent.
    @Sendable
    @inlinable
    public func associateAgentCollaborator(_ input: AssociateAgentCollaboratorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateAgentCollaboratorResponse {
        try await self.client.execute(
            operation: "AssociateAgentCollaborator", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/agentcollaborators/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes an agent a collaborator for another agent.
    ///
    /// Parameters:
    ///   - agentDescriptor: The alias of the collaborator agent.
    ///   - agentId: The agent's ID.
    ///   - agentVersion: An agent version.
    ///   - clientToken: A client token.
    ///   - collaborationInstruction: Instruction for the collaborator.
    ///   - collaboratorName: A name for the collaborator.
    ///   - relayConversationHistory: A relay conversation history for the collaborator.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateAgentCollaborator(
        agentDescriptor: AgentDescriptor,
        agentId: String,
        agentVersion: String,
        clientToken: String? = AssociateAgentCollaboratorRequest.idempotencyToken(),
        collaborationInstruction: String,
        collaboratorName: String,
        relayConversationHistory: RelayConversationHistory? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateAgentCollaboratorResponse {
        let input = AssociateAgentCollaboratorRequest(
            agentDescriptor: agentDescriptor, 
            agentId: agentId, 
            agentVersion: agentVersion, 
            clientToken: clientToken, 
            collaborationInstruction: collaborationInstruction, 
            collaboratorName: collaboratorName, 
            relayConversationHistory: relayConversationHistory
        )
        return try await self.associateAgentCollaborator(input, logger: logger)
    }

    /// Associates a knowledge base with an agent. If a knowledge base is associated and its indexState is set to Enabled, the agent queries the knowledge base for information to augment its response to the user.
    @Sendable
    @inlinable
    public func associateAgentKnowledgeBase(_ input: AssociateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateAgentKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "AssociateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a knowledge base with an agent. If a knowledge base is associated and its indexState is set to Enabled, the agent queries the knowledge base for information to augment its response to the user.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent with which you want to associate the knowledge base.
    ///   - agentVersion: The version of the agent with which you want to associate the knowledge base.
    ///   - description: A description of what the agent should use the knowledge base for.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to associate with the agent.
    ///   - knowledgeBaseState: Specifies whether to use the knowledge base or not when sending an InvokeAgent request.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateAgentKnowledgeBase(
        agentId: String,
        agentVersion: String,
        description: String,
        knowledgeBaseId: String,
        knowledgeBaseState: KnowledgeBaseState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateAgentKnowledgeBaseResponse {
        let input = AssociateAgentKnowledgeBaseRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            description: description, 
            knowledgeBaseId: knowledgeBaseId, 
            knowledgeBaseState: knowledgeBaseState
        )
        return try await self.associateAgentKnowledgeBase(input, logger: logger)
    }

    /// Creates an agent that orchestrates interactions between foundation models, data sources, software applications, user conversations, and APIs to carry out tasks to help customers.   Specify the following fields for security purposes.    agentResourceRoleArn – The Amazon Resource Name (ARN) of the role with permissions to invoke API operations on an agent.   (Optional) customerEncryptionKeyArn – The Amazon Resource Name (ARN) of a KMS key to encrypt the creation of the agent.   (Optional) idleSessionTTLinSeconds – Specify the number of seconds for which the agent should maintain session information. After this time expires, the subsequent InvokeAgent request begins a new session.     To enable your agent to retain conversational context across multiple sessions, include a memoryConfiguration object.  For more information, see Configure memory.   To override the default prompt behavior for agent orchestration and to use advanced prompts, include a promptOverrideConfiguration object.  For more information, see Advanced prompts.   If your agent fails to be created, the response returns a list of failureReasons alongside a list of recommendedActions for you to troubleshoot.   The agent instructions will not be honored if your agent has only one knowledge base, uses default prompts, has no action group, and user input is disabled.
    @Sendable
    @inlinable
    public func createAgent(_ input: CreateAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentResponse {
        try await self.client.execute(
            operation: "CreateAgent", 
            path: "/agents/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an agent that orchestrates interactions between foundation models, data sources, software applications, user conversations, and APIs to carry out tasks to help customers.   Specify the following fields for security purposes.    agentResourceRoleArn – The Amazon Resource Name (ARN) of the role with permissions to invoke API operations on an agent.   (Optional) customerEncryptionKeyArn – The Amazon Resource Name (ARN) of a KMS key to encrypt the creation of the agent.   (Optional) idleSessionTTLinSeconds – Specify the number of seconds for which the agent should maintain session information. After this time expires, the subsequent InvokeAgent request begins a new session.     To enable your agent to retain conversational context across multiple sessions, include a memoryConfiguration object.  For more information, see Configure memory.   To override the default prompt behavior for agent orchestration and to use advanced prompts, include a promptOverrideConfiguration object.  For more information, see Advanced prompts.   If your agent fails to be created, the response returns a list of failureReasons alongside a list of recommendedActions for you to troubleshoot.   The agent instructions will not be honored if your agent has only one knowledge base, uses default prompts, has no action group, and user input is disabled.
    ///
    /// Parameters:
    ///   - agentCollaboration: The agent's collaboration role.
    ///   - agentName: A name for the agent that you create.
    ///   - agentResourceRoleArn: The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    ///   - customOrchestration:  Contains details of the custom orchestration configured for the agent.
    ///   - description: A description of the agent.
    ///   - foundationModel: The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
    ///   - guardrailConfiguration: The unique Guardrail configuration assigned to the agent when it is created.
    ///   - idleSessionTTLInSeconds: The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    ///   - instruction: Instructions that tell the agent what it should do and how it should interact with users.
    ///   - memoryConfiguration:  Contains the details of the memory configured for the agent.
    ///   - orchestrationType:  Specifies the type of orchestration strategy for the agent. This is set to DEFAULT orchestration type, by default.
    ///   - promptOverrideConfiguration: Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
    ///   - tags: Any tags that you want to attach to the agent.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAgent(
        agentCollaboration: AgentCollaboration? = nil,
        agentName: String,
        agentResourceRoleArn: String? = nil,
        clientToken: String? = CreateAgentRequest.idempotencyToken(),
        customerEncryptionKeyArn: String? = nil,
        customOrchestration: CustomOrchestration? = nil,
        description: String? = nil,
        foundationModel: String? = nil,
        guardrailConfiguration: GuardrailConfiguration? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        instruction: String? = nil,
        memoryConfiguration: MemoryConfiguration? = nil,
        orchestrationType: OrchestrationType? = nil,
        promptOverrideConfiguration: PromptOverrideConfiguration? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAgentResponse {
        let input = CreateAgentRequest(
            agentCollaboration: agentCollaboration, 
            agentName: agentName, 
            agentResourceRoleArn: agentResourceRoleArn, 
            clientToken: clientToken, 
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            customOrchestration: customOrchestration, 
            description: description, 
            foundationModel: foundationModel, 
            guardrailConfiguration: guardrailConfiguration, 
            idleSessionTTLInSeconds: idleSessionTTLInSeconds, 
            instruction: instruction, 
            memoryConfiguration: memoryConfiguration, 
            orchestrationType: orchestrationType, 
            promptOverrideConfiguration: promptOverrideConfiguration, 
            tags: tags
        )
        return try await self.createAgent(input, logger: logger)
    }

    /// Creates an action group for an agent. An action group represents the actions that an agent can carry out for the customer by defining the APIs that an agent can call and the logic for calling them. To allow your agent to request the user for additional information when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.UserInput.  To allow your agent to generate, run, and troubleshoot code when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.CodeInterpreter.  You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
    @Sendable
    @inlinable
    public func createAgentActionGroup(_ input: CreateAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentActionGroupResponse {
        try await self.client.execute(
            operation: "CreateAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an action group for an agent. An action group represents the actions that an agent can carry out for the customer by defining the APIs that an agent can call and the logic for calling them. To allow your agent to request the user for additional information when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.UserInput.  To allow your agent to generate, run, and troubleshoot code when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.CodeInterpreter.  You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
    ///
    /// Parameters:
    ///   - actionGroupExecutor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    ///   - actionGroupName: The name to give the action group.
    ///   - actionGroupState: Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
    ///   - agentId: The unique identifier of the agent for which to create the action group.
    ///   - agentVersion: The version of the agent for which to create the action group.
    ///   - apiSchema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description of the action group.
    ///   - functionSchema: Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    ///   - parentActionGroupSignature: Specify a built-in or computer use action for this action group. If you specify a value, you must leave the description, apiSchema, and actionGroupExecutor fields empty for this action group.    To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.    To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter.   To allow your agent to use an Anthropic computer use tool, specify one of the following values.    Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only.           When operating computer use functionality, we recommend taking additional security precautions, such as executing computer actions in virtual environments with restricted data access and limited internet connectivity.  For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.      ANTHROPIC.Computer - Gives the agent permission to use the mouse and keyboard and take screenshots.    ANTHROPIC.TextEditor - Gives the agent permission to view, create and edit files.    ANTHROPIC.Bash - Gives the agent permission to run commands in a bash shell.
    ///   - parentActionGroupSignatureParams: The configuration settings for a computer use action.   Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAgentActionGroup(
        actionGroupExecutor: ActionGroupExecutor? = nil,
        actionGroupName: String,
        actionGroupState: ActionGroupState? = nil,
        agentId: String,
        agentVersion: String,
        apiSchema: APISchema? = nil,
        clientToken: String? = CreateAgentActionGroupRequest.idempotencyToken(),
        description: String? = nil,
        functionSchema: FunctionSchema? = nil,
        parentActionGroupSignature: ActionGroupSignature? = nil,
        parentActionGroupSignatureParams: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAgentActionGroupResponse {
        let input = CreateAgentActionGroupRequest(
            actionGroupExecutor: actionGroupExecutor, 
            actionGroupName: actionGroupName, 
            actionGroupState: actionGroupState, 
            agentId: agentId, 
            agentVersion: agentVersion, 
            apiSchema: apiSchema, 
            clientToken: clientToken, 
            description: description, 
            functionSchema: functionSchema, 
            parentActionGroupSignature: parentActionGroupSignature, 
            parentActionGroupSignatureParams: parentActionGroupSignatureParams
        )
        return try await self.createAgentActionGroup(input, logger: logger)
    }

    /// Creates an alias of an agent that can be used to deploy the agent.
    @Sendable
    @inlinable
    public func createAgentAlias(_ input: CreateAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentAliasResponse {
        try await self.client.execute(
            operation: "CreateAgentAlias", 
            path: "/agents/{agentId}/agentaliases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an alias of an agent that can be used to deploy the agent.
    ///
    /// Parameters:
    ///   - agentAliasName: The name of the alias.
    ///   - agentId: The unique identifier of the agent.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description of the alias of the agent.
    ///   - routingConfiguration: Contains details about the routing configuration of the alias.
    ///   - tags: Any tags that you want to attach to the alias of the agent.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAgentAlias(
        agentAliasName: String,
        agentId: String,
        clientToken: String? = CreateAgentAliasRequest.idempotencyToken(),
        description: String? = nil,
        routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAgentAliasResponse {
        let input = CreateAgentAliasRequest(
            agentAliasName: agentAliasName, 
            agentId: agentId, 
            clientToken: clientToken, 
            description: description, 
            routingConfiguration: routingConfiguration, 
            tags: tags
        )
        return try await self.createAgentAlias(input, logger: logger)
    }

    /// Connects a knowledge base to a data source. You specify the configuration for the specific data source service in the dataSourceConfiguration field.  You can't change the chunkingConfiguration after you create the data source connector.
    @Sendable
    @inlinable
    public func createDataSource(_ input: CreateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataSourceResponse {
        try await self.client.execute(
            operation: "CreateDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Connects a knowledge base to a data source. You specify the configuration for the specific data source service in the dataSourceConfiguration field.  You can't change the chunkingConfiguration after you create the data source connector.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - dataDeletionPolicy: The data deletion policy for the data source. You can set the data deletion policy to:   DELETE: Deletes all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted,  only the data. This flag is ignored if an Amazon Web Services account is deleted.   RETAIN: Retains all data from your data source that’s converted  into vector embeddings upon deletion of a knowledge base or data source resource.  Note that the vector store itself is not deleted  if you delete a knowledge base or data source resource.
    ///   - dataSourceConfiguration: The connection configuration for the data source.
    ///   - description: A description of the data source.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to which to add the data source.
    ///   - name: The name of the data source.
    ///   - serverSideEncryptionConfiguration: Contains details about the server-side encryption for the data source.
    ///   - vectorIngestionConfiguration: Contains details about how to ingest the documents in the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataSource(
        clientToken: String? = CreateDataSourceRequest.idempotencyToken(),
        dataDeletionPolicy: DataDeletionPolicy? = nil,
        dataSourceConfiguration: DataSourceConfiguration,
        description: String? = nil,
        knowledgeBaseId: String,
        name: String,
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: VectorIngestionConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDataSourceResponse {
        let input = CreateDataSourceRequest(
            clientToken: clientToken, 
            dataDeletionPolicy: dataDeletionPolicy, 
            dataSourceConfiguration: dataSourceConfiguration, 
            description: description, 
            knowledgeBaseId: knowledgeBaseId, 
            name: name, 
            serverSideEncryptionConfiguration: serverSideEncryptionConfiguration, 
            vectorIngestionConfiguration: vectorIngestionConfiguration
        )
        return try await self.createDataSource(input, logger: logger)
    }

    /// Creates a prompt flow that you can use to send an input through various steps to yield an output. Configure nodes, each of which corresponds to a step of the flow, and create connections between the nodes to create paths to different outputs. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func createFlow(_ input: CreateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowResponse {
        try await self.client.execute(
            operation: "CreateFlow", 
            path: "/flows/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a prompt flow that you can use to send an input through various steps to yield an output. Configure nodes, each of which corresponds to a step of the flow, and create connections between the nodes to create paths to different outputs. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
    ///   - definition: A definition of the nodes and connections between nodes in the flow.
    ///   - description: A description for the flow.
    ///   - executionRoleArn: The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///   - name: A name for the flow.
    ///   - tags: Any tags that you want to attach to the flow. For more information, see Tagging resources in Amazon Bedrock.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFlow(
        clientToken: String? = CreateFlowRequest.idempotencyToken(),
        customerEncryptionKeyArn: String? = nil,
        definition: FlowDefinition? = nil,
        description: String? = nil,
        executionRoleArn: String,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFlowResponse {
        let input = CreateFlowRequest(
            clientToken: clientToken, 
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            definition: definition, 
            description: description, 
            executionRoleArn: executionRoleArn, 
            name: name, 
            tags: tags
        )
        return try await self.createFlow(input, logger: logger)
    }

    /// Creates an alias of a flow for deployment. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func createFlowAlias(_ input: CreateFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowAliasResponse {
        try await self.client.execute(
            operation: "CreateFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an alias of a flow for deployment. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description for the alias.
    ///   - flowIdentifier: The unique identifier of the flow for which to create an alias.
    ///   - name: A name for the alias.
    ///   - routingConfiguration: Contains information about the version to which to map the alias.
    ///   - tags: Any tags that you want to attach to the alias of the flow. For more information, see Tagging resources in Amazon Bedrock.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFlowAlias(
        clientToken: String? = CreateFlowAliasRequest.idempotencyToken(),
        description: String? = nil,
        flowIdentifier: String,
        name: String,
        routingConfiguration: [FlowAliasRoutingConfigurationListItem],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFlowAliasResponse {
        let input = CreateFlowAliasRequest(
            clientToken: clientToken, 
            description: description, 
            flowIdentifier: flowIdentifier, 
            name: name, 
            routingConfiguration: routingConfiguration, 
            tags: tags
        )
        return try await self.createFlowAlias(input, logger: logger)
    }

    /// Creates a version of the flow that you can deploy. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func createFlowVersion(_ input: CreateFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowVersionResponse {
        try await self.client.execute(
            operation: "CreateFlowVersion", 
            path: "/flows/{flowIdentifier}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a version of the flow that you can deploy. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description of the version of the flow.
    ///   - flowIdentifier: The unique identifier of the flow that you want to create a version of.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFlowVersion(
        clientToken: String? = CreateFlowVersionRequest.idempotencyToken(),
        description: String? = nil,
        flowIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFlowVersionResponse {
        let input = CreateFlowVersionRequest(
            clientToken: clientToken, 
            description: description, 
            flowIdentifier: flowIdentifier
        )
        return try await self.createFlowVersion(input, logger: logger)
    }

    /// Creates a knowledge base. A knowledge base contains your data sources so that Large Language Models (LLMs) can use your data. To create a knowledge base, you must first set up your data sources and configure a supported vector store. For more information, see Set up a knowledge base.  If you prefer to let Amazon Bedrock create and manage a vector store for you in Amazon OpenSearch Service, use the console. For more information, see Create a knowledge base.    Provide the name and an optional description.   Provide the Amazon Resource Name (ARN) with permissions to create a knowledge base in the roleArn field.   Provide the embedding model to use in the embeddingModelArn field in the knowledgeBaseConfiguration object.   Provide the configuration for your vector store in the storageConfiguration object.   For an Amazon OpenSearch Service database, use the opensearchServerlessConfiguration object. For more information, see Create a vector store in Amazon OpenSearch Service.   For an Amazon Aurora database, use the RdsConfiguration object. For more information, see Create a vector store in Amazon Aurora.   For a Pinecone database, use the pineconeConfiguration object. For more information, see Create a vector store in Pinecone.   For a Redis Enterprise Cloud database, use the redisEnterpriseCloudConfiguration object. For more information, see Create a vector store in Redis Enterprise Cloud.
    @Sendable
    @inlinable
    public func createKnowledgeBase(_ input: CreateKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "CreateKnowledgeBase", 
            path: "/knowledgebases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a knowledge base. A knowledge base contains your data sources so that Large Language Models (LLMs) can use your data. To create a knowledge base, you must first set up your data sources and configure a supported vector store. For more information, see Set up a knowledge base.  If you prefer to let Amazon Bedrock create and manage a vector store for you in Amazon OpenSearch Service, use the console. For more information, see Create a knowledge base.    Provide the name and an optional description.   Provide the Amazon Resource Name (ARN) with permissions to create a knowledge base in the roleArn field.   Provide the embedding model to use in the embeddingModelArn field in the knowledgeBaseConfiguration object.   Provide the configuration for your vector store in the storageConfiguration object.   For an Amazon OpenSearch Service database, use the opensearchServerlessConfiguration object. For more information, see Create a vector store in Amazon OpenSearch Service.   For an Amazon Aurora database, use the RdsConfiguration object. For more information, see Create a vector store in Amazon Aurora.   For a Pinecone database, use the pineconeConfiguration object. For more information, see Create a vector store in Pinecone.   For a Redis Enterprise Cloud database, use the redisEnterpriseCloudConfiguration object. For more information, see Create a vector store in Redis Enterprise Cloud.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description of the knowledge base.
    ///   - knowledgeBaseConfiguration: Contains details about the embeddings model used for the knowledge base.
    ///   - name: A name for the knowledge base.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    ///   - storageConfiguration: Contains details about the configuration of the vector database used for the knowledge base.
    ///   - tags: Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKnowledgeBase(
        clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(),
        description: String? = nil,
        knowledgeBaseConfiguration: KnowledgeBaseConfiguration,
        name: String,
        roleArn: String,
        storageConfiguration: StorageConfiguration? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKnowledgeBaseResponse {
        let input = CreateKnowledgeBaseRequest(
            clientToken: clientToken, 
            description: description, 
            knowledgeBaseConfiguration: knowledgeBaseConfiguration, 
            name: name, 
            roleArn: roleArn, 
            storageConfiguration: storageConfiguration, 
            tags: tags
        )
        return try await self.createKnowledgeBase(input, logger: logger)
    }

    /// Creates a prompt in your prompt library that you can add to a flow. For more information, see Prompt management in Amazon Bedrock, Create a prompt using Prompt management and Prompt flows in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func createPrompt(_ input: CreatePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePromptResponse {
        try await self.client.execute(
            operation: "CreatePrompt", 
            path: "/prompts/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a prompt in your prompt library that you can add to a flow. For more information, see Prompt management in Amazon Bedrock, Create a prompt using Prompt management and Prompt flows in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
    ///   - defaultVariant: The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
    ///   - description: A description for the prompt.
    ///   - name: A name for the prompt.
    ///   - tags: Any tags that you want to attach to the prompt. For more information, see Tagging resources in Amazon Bedrock.
    ///   - variants: A list of objects, each containing details about a variant of the prompt.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPrompt(
        clientToken: String? = CreatePromptRequest.idempotencyToken(),
        customerEncryptionKeyArn: String? = nil,
        defaultVariant: String? = nil,
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        variants: [PromptVariant]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePromptResponse {
        let input = CreatePromptRequest(
            clientToken: clientToken, 
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            defaultVariant: defaultVariant, 
            description: description, 
            name: name, 
            tags: tags, 
            variants: variants
        )
        return try await self.createPrompt(input, logger: logger)
    }

    /// Creates a static snapshot of your prompt that can be deployed to production. For more information, see Deploy prompts using Prompt management by creating versions in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func createPromptVersion(_ input: CreatePromptVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePromptVersionResponse {
        try await self.client.execute(
            operation: "CreatePromptVersion", 
            path: "/prompts/{promptIdentifier}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a static snapshot of your prompt that can be deployed to production. For more information, see Deploy prompts using Prompt management by creating versions in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - description: A description for the version of the prompt.
    ///   - promptIdentifier: The unique identifier of the prompt that you want to create a version of.
    ///   - tags: Any tags that you want to attach to the version of the prompt. For more information, see Tagging resources in Amazon Bedrock.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPromptVersion(
        clientToken: String? = CreatePromptVersionRequest.idempotencyToken(),
        description: String? = nil,
        promptIdentifier: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePromptVersionResponse {
        let input = CreatePromptVersionRequest(
            clientToken: clientToken, 
            description: description, 
            promptIdentifier: promptIdentifier, 
            tags: tags
        )
        return try await self.createPromptVersion(input, logger: logger)
    }

    /// Deletes an agent.
    @Sendable
    @inlinable
    public func deleteAgent(_ input: DeleteAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentResponse {
        try await self.client.execute(
            operation: "DeleteAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent to delete.
    ///   - skipResourceInUseCheck: By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgent(
        agentId: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentResponse {
        let input = DeleteAgentRequest(
            agentId: agentId, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteAgent(input, logger: logger)
    }

    /// Deletes an action group in an agent.
    @Sendable
    @inlinable
    public func deleteAgentActionGroup(_ input: DeleteAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentActionGroupResponse {
        try await self.client.execute(
            operation: "DeleteAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an action group in an agent.
    ///
    /// Parameters:
    ///   - actionGroupId: The unique identifier of the action group to delete.
    ///   - agentId: The unique identifier of the agent that the action group belongs to.
    ///   - agentVersion: The version of the agent that the action group belongs to.
    ///   - skipResourceInUseCheck: By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgentActionGroup(
        actionGroupId: String,
        agentId: String,
        agentVersion: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentActionGroupResponse {
        let input = DeleteAgentActionGroupRequest(
            actionGroupId: actionGroupId, 
            agentId: agentId, 
            agentVersion: agentVersion, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteAgentActionGroup(input, logger: logger)
    }

    /// Deletes an alias of an agent.
    @Sendable
    @inlinable
    public func deleteAgentAlias(_ input: DeleteAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentAliasResponse {
        try await self.client.execute(
            operation: "DeleteAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an alias of an agent.
    ///
    /// Parameters:
    ///   - agentAliasId: The unique identifier of the alias to delete.
    ///   - agentId: The unique identifier of the agent that the alias belongs to.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgentAlias(
        agentAliasId: String,
        agentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentAliasResponse {
        let input = DeleteAgentAliasRequest(
            agentAliasId: agentAliasId, 
            agentId: agentId
        )
        return try await self.deleteAgentAlias(input, logger: logger)
    }

    /// Deletes a version of an agent.
    @Sendable
    @inlinable
    public func deleteAgentVersion(_ input: DeleteAgentVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentVersionResponse {
        try await self.client.execute(
            operation: "DeleteAgentVersion", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a version of an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent that the version belongs to.
    ///   - agentVersion: The version of the agent to delete.
    ///   - skipResourceInUseCheck: By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgentVersion(
        agentId: String,
        agentVersion: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentVersionResponse {
        let input = DeleteAgentVersionRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteAgentVersion(input, logger: logger)
    }

    /// Deletes a data source from a knowledge base.
    @Sendable
    @inlinable
    public func deleteDataSource(_ input: DeleteDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataSourceResponse {
        try await self.client.execute(
            operation: "DeleteDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a data source from a knowledge base.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source to delete.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base from which to delete the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataSource(
        dataSourceId: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDataSourceResponse {
        let input = DeleteDataSourceRequest(
            dataSourceId: dataSourceId, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.deleteDataSource(input, logger: logger)
    }

    /// Deletes a flow.
    @Sendable
    @inlinable
    public func deleteFlow(_ input: DeleteFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowResponse {
        try await self.client.execute(
            operation: "DeleteFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a flow.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - skipResourceInUseCheck: By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFlow(
        flowIdentifier: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFlowResponse {
        let input = DeleteFlowRequest(
            flowIdentifier: flowIdentifier, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteFlow(input, logger: logger)
    }

    /// Deletes an alias of a flow.
    @Sendable
    @inlinable
    public func deleteFlowAlias(_ input: DeleteFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowAliasResponse {
        try await self.client.execute(
            operation: "DeleteFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an alias of a flow.
    ///
    /// Parameters:
    ///   - aliasIdentifier: The unique identifier of the alias to be deleted.
    ///   - flowIdentifier: The unique identifier of the flow that the alias belongs to.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFlowAlias(
        aliasIdentifier: String,
        flowIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFlowAliasResponse {
        let input = DeleteFlowAliasRequest(
            aliasIdentifier: aliasIdentifier, 
            flowIdentifier: flowIdentifier
        )
        return try await self.deleteFlowAlias(input, logger: logger)
    }

    /// Deletes a version of a flow.
    @Sendable
    @inlinable
    public func deleteFlowVersion(_ input: DeleteFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowVersionResponse {
        try await self.client.execute(
            operation: "DeleteFlowVersion", 
            path: "/flows/{flowIdentifier}/versions/{flowVersion}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a version of a flow.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow whose version that you want to delete
    ///   - flowVersion: The version of the flow that you want to delete.
    ///   - skipResourceInUseCheck: By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFlowVersion(
        flowIdentifier: String,
        flowVersion: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFlowVersionResponse {
        let input = DeleteFlowVersionRequest(
            flowIdentifier: flowIdentifier, 
            flowVersion: flowVersion, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteFlowVersion(input, logger: logger)
    }

    /// Deletes a knowledge base. Before deleting a knowledge base, you should disassociate the knowledge base from any agents that it is associated with by making a DisassociateAgentKnowledgeBase request.
    @Sendable
    @inlinable
    public func deleteKnowledgeBase(_ input: DeleteKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "DeleteKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a knowledge base. Before deleting a knowledge base, you should disassociate the knowledge base from any agents that it is associated with by making a DisassociateAgentKnowledgeBase request.
    ///
    /// Parameters:
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKnowledgeBase(
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKnowledgeBaseResponse {
        let input = DeleteKnowledgeBaseRequest(
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.deleteKnowledgeBase(input, logger: logger)
    }

    /// Deletes documents from a data source and syncs the changes to the knowledge base that is connected to it. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func deleteKnowledgeBaseDocuments(_ input: DeleteKnowledgeBaseDocumentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKnowledgeBaseDocumentsResponse {
        try await self.client.execute(
            operation: "DeleteKnowledgeBaseDocuments", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/documents/deleteDocuments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes documents from a data source and syncs the changes to the knowledge base that is connected to it. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - dataSourceId: The unique identifier of the data source that contains the documents.
    ///   - documentIdentifiers: A list of objects, each of which contains information to identify a document to delete.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base that is connected to the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKnowledgeBaseDocuments(
        clientToken: String? = DeleteKnowledgeBaseDocumentsRequest.idempotencyToken(),
        dataSourceId: String,
        documentIdentifiers: [DocumentIdentifier],
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKnowledgeBaseDocumentsResponse {
        let input = DeleteKnowledgeBaseDocumentsRequest(
            clientToken: clientToken, 
            dataSourceId: dataSourceId, 
            documentIdentifiers: documentIdentifiers, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.deleteKnowledgeBaseDocuments(input, logger: logger)
    }

    /// Deletes a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see Delete prompts from the Prompt management tool and Delete a version of a prompt from the Prompt management tool in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func deletePrompt(_ input: DeletePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePromptResponse {
        try await self.client.execute(
            operation: "DeletePrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see Delete prompts from the Prompt management tool and Delete a version of a prompt from the Prompt management tool in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - promptIdentifier: The unique identifier of the prompt.
    ///   - promptVersion: The version of the prompt to delete. To delete the prompt, omit this field.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePrompt(
        promptIdentifier: String,
        promptVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePromptResponse {
        let input = DeletePromptRequest(
            promptIdentifier: promptIdentifier, 
            promptVersion: promptVersion
        )
        return try await self.deletePrompt(input, logger: logger)
    }

    /// Disassociates an agent collaborator.
    @Sendable
    @inlinable
    public func disassociateAgentCollaborator(_ input: DisassociateAgentCollaboratorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateAgentCollaboratorResponse {
        try await self.client.execute(
            operation: "DisassociateAgentCollaborator", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/agentcollaborators/{collaboratorId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates an agent collaborator.
    ///
    /// Parameters:
    ///   - agentId: An agent ID.
    ///   - agentVersion: The agent's version.
    ///   - collaboratorId: The collaborator's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateAgentCollaborator(
        agentId: String,
        agentVersion: String,
        collaboratorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateAgentCollaboratorResponse {
        let input = DisassociateAgentCollaboratorRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            collaboratorId: collaboratorId
        )
        return try await self.disassociateAgentCollaborator(input, logger: logger)
    }

    /// Disassociates a knowledge base from an agent.
    @Sendable
    @inlinable
    public func disassociateAgentKnowledgeBase(_ input: DisassociateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateAgentKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "DisassociateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates a knowledge base from an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent from which to disassociate the knowledge base.
    ///   - agentVersion: The version of the agent from which to disassociate the knowledge base.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to disassociate.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateAgentKnowledgeBase(
        agentId: String,
        agentVersion: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateAgentKnowledgeBaseResponse {
        let input = DisassociateAgentKnowledgeBaseRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.disassociateAgentKnowledgeBase(input, logger: logger)
    }

    /// Gets information about an agent.
    @Sendable
    @inlinable
    public func getAgent(_ input: GetAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentResponse {
        try await self.client.execute(
            operation: "GetAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgent(
        agentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentResponse {
        let input = GetAgentRequest(
            agentId: agentId
        )
        return try await self.getAgent(input, logger: logger)
    }

    /// Gets information about an action group for an agent.
    @Sendable
    @inlinable
    public func getAgentActionGroup(_ input: GetAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentActionGroupResponse {
        try await self.client.execute(
            operation: "GetAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an action group for an agent.
    ///
    /// Parameters:
    ///   - actionGroupId: The unique identifier of the action group for which to get information.
    ///   - agentId: The unique identifier of the agent that the action group belongs to.
    ///   - agentVersion: The version of the agent that the action group belongs to.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentActionGroup(
        actionGroupId: String,
        agentId: String,
        agentVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentActionGroupResponse {
        let input = GetAgentActionGroupRequest(
            actionGroupId: actionGroupId, 
            agentId: agentId, 
            agentVersion: agentVersion
        )
        return try await self.getAgentActionGroup(input, logger: logger)
    }

    /// Gets information about an alias of an agent.
    @Sendable
    @inlinable
    public func getAgentAlias(_ input: GetAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentAliasResponse {
        try await self.client.execute(
            operation: "GetAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an alias of an agent.
    ///
    /// Parameters:
    ///   - agentAliasId: The unique identifier of the alias for which to get information.
    ///   - agentId: The unique identifier of the agent to which the alias to get information belongs.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentAlias(
        agentAliasId: String,
        agentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentAliasResponse {
        let input = GetAgentAliasRequest(
            agentAliasId: agentAliasId, 
            agentId: agentId
        )
        return try await self.getAgentAlias(input, logger: logger)
    }

    /// Retrieves information about an agent's collaborator.
    @Sendable
    @inlinable
    public func getAgentCollaborator(_ input: GetAgentCollaboratorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentCollaboratorResponse {
        try await self.client.execute(
            operation: "GetAgentCollaborator", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/agentcollaborators/{collaboratorId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an agent's collaborator.
    ///
    /// Parameters:
    ///   - agentId: The agent's ID.
    ///   - agentVersion: The agent's version.
    ///   - collaboratorId: The collaborator's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentCollaborator(
        agentId: String,
        agentVersion: String,
        collaboratorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentCollaboratorResponse {
        let input = GetAgentCollaboratorRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            collaboratorId: collaboratorId
        )
        return try await self.getAgentCollaborator(input, logger: logger)
    }

    /// Gets information about a knowledge base associated with an agent.
    @Sendable
    @inlinable
    public func getAgentKnowledgeBase(_ input: GetAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "GetAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a knowledge base associated with an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent with which the knowledge base is associated.
    ///   - agentVersion: The version of the agent with which the knowledge base is associated.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base associated with the agent.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentKnowledgeBase(
        agentId: String,
        agentVersion: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentKnowledgeBaseResponse {
        let input = GetAgentKnowledgeBaseRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.getAgentKnowledgeBase(input, logger: logger)
    }

    /// Gets details about a version of an agent.
    @Sendable
    @inlinable
    public func getAgentVersion(_ input: GetAgentVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentVersionResponse {
        try await self.client.execute(
            operation: "GetAgentVersion", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details about a version of an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - agentVersion: The version of the agent.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentVersion(
        agentId: String,
        agentVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentVersionResponse {
        let input = GetAgentVersionRequest(
            agentId: agentId, 
            agentVersion: agentVersion
        )
        return try await self.getAgentVersion(input, logger: logger)
    }

    /// Gets information about a data source.
    @Sendable
    @inlinable
    public func getDataSource(_ input: GetDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataSourceResponse {
        try await self.client.execute(
            operation: "GetDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a data source.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataSource(
        dataSourceId: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataSourceResponse {
        let input = GetDataSourceRequest(
            dataSourceId: dataSourceId, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.getDataSource(input, logger: logger)
    }

    /// Retrieves information about a flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func getFlow(_ input: GetFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowResponse {
        try await self.client.execute(
            operation: "GetFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFlow(
        flowIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFlowResponse {
        let input = GetFlowRequest(
            flowIdentifier: flowIdentifier
        )
        return try await self.getFlow(input, logger: logger)
    }

    /// Retrieves information about a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func getFlowAlias(_ input: GetFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowAliasResponse {
        try await self.client.execute(
            operation: "GetFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - aliasIdentifier: The unique identifier of the alias for which to retrieve information.
    ///   - flowIdentifier: The unique identifier of the flow that the alias belongs to.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFlowAlias(
        aliasIdentifier: String,
        flowIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFlowAliasResponse {
        let input = GetFlowAliasRequest(
            aliasIdentifier: aliasIdentifier, 
            flowIdentifier: flowIdentifier
        )
        return try await self.getFlowAlias(input, logger: logger)
    }

    /// Retrieves information about a version of a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func getFlowVersion(_ input: GetFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowVersionResponse {
        try await self.client.execute(
            operation: "GetFlowVersion", 
            path: "/flows/{flowIdentifier}/versions/{flowVersion}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a version of a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow for which to get information.
    ///   - flowVersion: The version of the flow for which to get information.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFlowVersion(
        flowIdentifier: String,
        flowVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFlowVersionResponse {
        let input = GetFlowVersionRequest(
            flowIdentifier: flowIdentifier, 
            flowVersion: flowVersion
        )
        return try await self.getFlowVersion(input, logger: logger)
    }

    /// Gets information about a data ingestion job. Data sources are ingested into your knowledge base so that Large Language Models (LLMs) can use your data.
    @Sendable
    @inlinable
    public func getIngestionJob(_ input: GetIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIngestionJobResponse {
        try await self.client.execute(
            operation: "GetIngestionJob", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/{ingestionJobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a data ingestion job. Data sources are ingested into your knowledge base so that Large Language Models (LLMs) can use your data.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source for the data ingestion job you want to get information on.
    ///   - ingestionJobId: The unique identifier of the data ingestion job you want to get information on.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the data ingestion job you want to get information on.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIngestionJob(
        dataSourceId: String,
        ingestionJobId: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIngestionJobResponse {
        let input = GetIngestionJobRequest(
            dataSourceId: dataSourceId, 
            ingestionJobId: ingestionJobId, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.getIngestionJob(input, logger: logger)
    }

    /// Gets information about a knoweldge base.
    @Sendable
    @inlinable
    public func getKnowledgeBase(_ input: GetKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "GetKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a knoweldge base.
    ///
    /// Parameters:
    ///   - knowledgeBaseId: The unique identifier of the knowledge base you want to get information on.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKnowledgeBase(
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKnowledgeBaseResponse {
        let input = GetKnowledgeBaseRequest(
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.getKnowledgeBase(input, logger: logger)
    }

    /// Retrieves specific documents from a data source that is connected to a knowledge base. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func getKnowledgeBaseDocuments(_ input: GetKnowledgeBaseDocumentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKnowledgeBaseDocumentsResponse {
        try await self.client.execute(
            operation: "GetKnowledgeBaseDocuments", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/documents/getDocuments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves specific documents from a data source that is connected to a knowledge base. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source that contains the documents.
    ///   - documentIdentifiers: A list of objects, each of which contains information to identify a document for which to retrieve information.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base that is connected to the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKnowledgeBaseDocuments(
        dataSourceId: String,
        documentIdentifiers: [DocumentIdentifier],
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKnowledgeBaseDocumentsResponse {
        let input = GetKnowledgeBaseDocumentsRequest(
            dataSourceId: dataSourceId, 
            documentIdentifiers: documentIdentifiers, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.getKnowledgeBaseDocuments(input, logger: logger)
    }

    /// Retrieves information about the working draft (DRAFT version) of a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see View information about prompts using Prompt management and View information about a version of your prompt in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func getPrompt(_ input: GetPromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPromptResponse {
        try await self.client.execute(
            operation: "GetPrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the working draft (DRAFT version) of a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see View information about prompts using Prompt management and View information about a version of your prompt in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - promptIdentifier: The unique identifier of the prompt.
    ///   - promptVersion: The version of the prompt about which you want to retrieve information. Omit this field to return information about the working draft of the prompt.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPrompt(
        promptIdentifier: String,
        promptVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPromptResponse {
        let input = GetPromptRequest(
            promptIdentifier: promptIdentifier, 
            promptVersion: promptVersion
        )
        return try await self.getPrompt(input, logger: logger)
    }

    /// Ingests documents directly into the knowledge base that is connected to the data source. The dataSourceType specified in the content for each document must match the type of the data source that you specify in the header. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func ingestKnowledgeBaseDocuments(_ input: IngestKnowledgeBaseDocumentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> IngestKnowledgeBaseDocumentsResponse {
        try await self.client.execute(
            operation: "IngestKnowledgeBaseDocuments", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/documents", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Ingests documents directly into the knowledge base that is connected to the data source. The dataSourceType specified in the content for each document must match the type of the data source that you specify in the header. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - dataSourceId: The unique identifier of the data source connected to the knowledge base that you're adding documents to.
    ///   - documents: A list of objects, each of which contains information about the documents to add.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to ingest the documents into.
    ///   - logger: Logger use during operation
    @inlinable
    public func ingestKnowledgeBaseDocuments(
        clientToken: String? = IngestKnowledgeBaseDocumentsRequest.idempotencyToken(),
        dataSourceId: String,
        documents: [KnowledgeBaseDocument],
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> IngestKnowledgeBaseDocumentsResponse {
        let input = IngestKnowledgeBaseDocumentsRequest(
            clientToken: clientToken, 
            dataSourceId: dataSourceId, 
            documents: documents, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.ingestKnowledgeBaseDocuments(input, logger: logger)
    }

    /// Lists the action groups for an agent and information about each one.
    @Sendable
    @inlinable
    public func listAgentActionGroups(_ input: ListAgentActionGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentActionGroupsResponse {
        try await self.client.execute(
            operation: "ListAgentActionGroups", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the action groups for an agent and information about each one.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - agentVersion: The version of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentActionGroups(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentActionGroupsResponse {
        let input = ListAgentActionGroupsRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentActionGroups(input, logger: logger)
    }

    /// Lists the aliases of an agent and information about each one.
    @Sendable
    @inlinable
    public func listAgentAliases(_ input: ListAgentAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentAliasesResponse {
        try await self.client.execute(
            operation: "ListAgentAliases", 
            path: "/agents/{agentId}/agentaliases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the aliases of an agent and information about each one.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentAliases(
        agentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentAliasesResponse {
        let input = ListAgentAliasesRequest(
            agentId: agentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentAliases(input, logger: logger)
    }

    /// Retrieve a list of an agent's collaborators.
    @Sendable
    @inlinable
    public func listAgentCollaborators(_ input: ListAgentCollaboratorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentCollaboratorsResponse {
        try await self.client.execute(
            operation: "ListAgentCollaborators", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/agentcollaborators/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a list of an agent's collaborators.
    ///
    /// Parameters:
    ///   - agentId: The agent's ID.
    ///   - agentVersion: The agent's version.
    ///   - maxResults: The maximum number of agent collaborators to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentCollaborators(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentCollaboratorsResponse {
        let input = ListAgentCollaboratorsRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentCollaborators(input, logger: logger)
    }

    /// Lists knowledge bases associated with an agent and information about each one.
    @Sendable
    @inlinable
    public func listAgentKnowledgeBases(_ input: ListAgentKnowledgeBasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentKnowledgeBasesResponse {
        try await self.client.execute(
            operation: "ListAgentKnowledgeBases", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists knowledge bases associated with an agent and information about each one.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent for which to return information about knowledge bases associated with it.
    ///   - agentVersion: The version of the agent for which to return information about knowledge bases associated with it.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentKnowledgeBases(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentKnowledgeBasesResponse {
        let input = ListAgentKnowledgeBasesRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentKnowledgeBases(input, logger: logger)
    }

    /// Lists the versions of an agent and information about each version.
    @Sendable
    @inlinable
    public func listAgentVersions(_ input: ListAgentVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentVersionsResponse {
        try await self.client.execute(
            operation: "ListAgentVersions", 
            path: "/agents/{agentId}/agentversions/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the versions of an agent and information about each version.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentVersions(
        agentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentVersionsResponse {
        let input = ListAgentVersionsRequest(
            agentId: agentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentVersions(input, logger: logger)
    }

    /// Lists the agents belonging to an account and information about each agent.
    @Sendable
    @inlinable
    public func listAgents(_ input: ListAgentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentsResponse {
        try await self.client.execute(
            operation: "ListAgents", 
            path: "/agents/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the agents belonging to an account and information about each agent.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgents(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentsResponse {
        let input = ListAgentsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgents(input, logger: logger)
    }

    /// Lists the data sources in a knowledge base and information about each one.
    @Sendable
    @inlinable
    public func listDataSources(_ input: ListDataSourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataSourcesResponse {
        try await self.client.execute(
            operation: "ListDataSources", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the data sources in a knowledge base and information about each one.
    ///
    /// Parameters:
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for which to return a list of information.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataSources(
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataSourcesResponse {
        let input = ListDataSourcesRequest(
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataSources(input, logger: logger)
    }

    /// Returns a list of aliases for a flow.
    @Sendable
    @inlinable
    public func listFlowAliases(_ input: ListFlowAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowAliasesResponse {
        try await self.client.execute(
            operation: "ListFlowAliases", 
            path: "/flows/{flowIdentifier}/aliases", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of aliases for a flow.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow for which aliases are being returned.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFlowAliases(
        flowIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFlowAliasesResponse {
        let input = ListFlowAliasesRequest(
            flowIdentifier: flowIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFlowAliases(input, logger: logger)
    }

    /// Returns a list of information about each flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func listFlowVersions(_ input: ListFlowVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowVersionsResponse {
        try await self.client.execute(
            operation: "ListFlowVersions", 
            path: "/flows/{flowIdentifier}/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of information about each flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFlowVersions(
        flowIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFlowVersionsResponse {
        let input = ListFlowVersionsRequest(
            flowIdentifier: flowIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFlowVersions(input, logger: logger)
    }

    /// Returns a list of flows and information about each flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func listFlows(_ input: ListFlowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowsResponse {
        try await self.client.execute(
            operation: "ListFlows", 
            path: "/flows/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of flows and information about each flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFlows(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFlowsResponse {
        let input = ListFlowsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFlows(input, logger: logger)
    }

    /// Lists the data ingestion jobs for a data source. The list also includes information about each job.
    @Sendable
    @inlinable
    public func listIngestionJobs(_ input: ListIngestionJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIngestionJobsResponse {
        try await self.client.execute(
            operation: "ListIngestionJobs", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the data ingestion jobs for a data source. The list also includes information about each job.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source for the list of data ingestion jobs.
    ///   - filters: Contains information about the filters for filtering the data.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the list of data ingestion jobs.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - sortBy: Contains details about how to sort the data.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIngestionJobs(
        dataSourceId: String,
        filters: [IngestionJobFilter]? = nil,
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: IngestionJobSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIngestionJobsResponse {
        let input = ListIngestionJobsRequest(
            dataSourceId: dataSourceId, 
            filters: filters, 
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listIngestionJobs(input, logger: logger)
    }

    /// Retrieves all the documents contained in a data source that is connected to a knowledge base. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func listKnowledgeBaseDocuments(_ input: ListKnowledgeBaseDocumentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKnowledgeBaseDocumentsResponse {
        try await self.client.execute(
            operation: "ListKnowledgeBaseDocuments", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/documents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all the documents contained in a data source that is connected to a knowledge base. For more information, see Ingest changes directly into a knowledge base in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source that contains the documents.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base that is connected to the data source.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKnowledgeBaseDocuments(
        dataSourceId: String,
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKnowledgeBaseDocumentsResponse {
        let input = ListKnowledgeBaseDocumentsRequest(
            dataSourceId: dataSourceId, 
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKnowledgeBaseDocuments(input, logger: logger)
    }

    /// Lists the knowledge bases in an account. The list also includesinformation about each knowledge base.
    @Sendable
    @inlinable
    public func listKnowledgeBases(_ input: ListKnowledgeBasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKnowledgeBasesResponse {
        try await self.client.execute(
            operation: "ListKnowledgeBases", 
            path: "/knowledgebases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the knowledge bases in an account. The list also includesinformation about each knowledge base.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKnowledgeBases(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKnowledgeBasesResponse {
        let input = ListKnowledgeBasesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKnowledgeBases(input, logger: logger)
    }

    /// Returns either information about the working draft (DRAFT version) of each prompt in an account, or information about of all versions of a prompt, depending on whether you include the promptIdentifier field or not. For more information, see View information about prompts using Prompt management in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func listPrompts(_ input: ListPromptsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPromptsResponse {
        try await self.client.execute(
            operation: "ListPrompts", 
            path: "/prompts/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns either information about the working draft (DRAFT version) of each prompt in an account, or information about of all versions of a prompt, depending on whether you include the promptIdentifier field or not. For more information, see View information about prompts using Prompt management in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - promptIdentifier: The unique identifier of the prompt for whose versions you want to return information. Omit this field to list information about all prompts in an account.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrompts(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        promptIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPromptsResponse {
        let input = ListPromptsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            promptIdentifier: promptIdentifier
        )
        return try await self.listPrompts(input, logger: logger)
    }

    /// List all the tags for the resource you specify.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all the tags for the resource you specify.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to list tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Creates a DRAFT version of the agent that can be used for internal testing.
    @Sendable
    @inlinable
    public func prepareAgent(_ input: PrepareAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PrepareAgentResponse {
        try await self.client.execute(
            operation: "PrepareAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a DRAFT version of the agent that can be used for internal testing.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent for which to create a DRAFT version.
    ///   - logger: Logger use during operation
    @inlinable
    public func prepareAgent(
        agentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PrepareAgentResponse {
        let input = PrepareAgentRequest(
            agentId: agentId
        )
        return try await self.prepareAgent(input, logger: logger)
    }

    /// Prepares the DRAFT version of a flow so that it can be invoked. For more information, see Test a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func prepareFlow(_ input: PrepareFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PrepareFlowResponse {
        try await self.client.execute(
            operation: "PrepareFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Prepares the DRAFT version of a flow so that it can be invoked. For more information, see Test a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func prepareFlow(
        flowIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PrepareFlowResponse {
        let input = PrepareFlowRequest(
            flowIdentifier: flowIdentifier
        )
        return try await self.prepareFlow(input, logger: logger)
    }

    /// Begins a data ingestion job. Data sources are ingested into your knowledge base so that Large Language Models (LLMs) can use your data.
    @Sendable
    @inlinable
    public func startIngestionJob(_ input: StartIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartIngestionJobResponse {
        try await self.client.execute(
            operation: "StartIngestionJob", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Begins a data ingestion job. Data sources are ingested into your knowledge base so that Large Language Models (LLMs) can use your data.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
    ///   - dataSourceId: The unique identifier of the data source you want to ingest into your knowledge base.
    ///   - description: A description of the data ingestion job.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the data ingestion job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startIngestionJob(
        clientToken: String? = StartIngestionJobRequest.idempotencyToken(),
        dataSourceId: String,
        description: String? = nil,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartIngestionJobResponse {
        let input = StartIngestionJobRequest(
            clientToken: clientToken, 
            dataSourceId: dataSourceId, 
            description: description, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.startIngestionJob(input, logger: logger)
    }

    /// Stops a currently running data ingestion job. You can send a StartIngestionJob request again to ingest the rest of your data when you are ready.
    @Sendable
    @inlinable
    public func stopIngestionJob(_ input: StopIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopIngestionJobResponse {
        try await self.client.execute(
            operation: "StopIngestionJob", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/{ingestionJobId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a currently running data ingestion job. You can send a StartIngestionJob request again to ingest the rest of your data when you are ready.
    ///
    /// Parameters:
    ///   - dataSourceId: The unique identifier of the data source for the data ingestion job you want to stop.
    ///   - ingestionJobId: The unique identifier of the data ingestion job you want to stop.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the data ingestion job you want to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopIngestionJob(
        dataSourceId: String,
        ingestionJobId: String,
        knowledgeBaseId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopIngestionJobResponse {
        let input = StopIngestionJobRequest(
            dataSourceId: dataSourceId, 
            ingestionJobId: ingestionJobId, 
            knowledgeBaseId: knowledgeBaseId
        )
        return try await self.stopIngestionJob(input, logger: logger)
    }

    /// Associate tags with a resource. For more information, see  Tagging resources in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate tags with a resource. For more information, see  Tagging resources in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to tag.
    ///   - tags: An object containing key-value pairs that define the tags to attach to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Remove tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource from which to remove tags.
    ///   - tagKeys: A list of keys of the tags to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of an agent.
    @Sendable
    @inlinable
    public func updateAgent(_ input: UpdateAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentResponse {
        try await self.client.execute(
            operation: "UpdateAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an agent.
    ///
    /// Parameters:
    ///   - agentCollaboration: The agent's collaboration role.
    ///   - agentId: The unique identifier of the agent.
    ///   - agentName: Specifies a new name for the agent.
    ///   - agentResourceRoleArn: The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    ///   - customOrchestration:  Contains details of the custom orchestration configured for the agent.
    ///   - description: Specifies a new description of the agent.
    ///   - foundationModel: The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
    ///   - guardrailConfiguration: The unique Guardrail configuration assigned to the agent when it is updated.
    ///   - idleSessionTTLInSeconds: The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    ///   - instruction: Specifies new instructions that tell the agent what it should do and how it should interact with users.
    ///   - memoryConfiguration: Specifies the new memory configuration for the agent.
    ///   - orchestrationType:  Specifies the type of orchestration strategy for the agent. This is set to DEFAULT orchestration type, by default.
    ///   - promptOverrideConfiguration: Contains configurations to override prompts in different parts of an agent sequence. For more information, see Advanced prompts.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgent(
        agentCollaboration: AgentCollaboration? = nil,
        agentId: String,
        agentName: String,
        agentResourceRoleArn: String,
        customerEncryptionKeyArn: String? = nil,
        customOrchestration: CustomOrchestration? = nil,
        description: String? = nil,
        foundationModel: String? = nil,
        guardrailConfiguration: GuardrailConfiguration? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        instruction: String? = nil,
        memoryConfiguration: MemoryConfiguration? = nil,
        orchestrationType: OrchestrationType? = nil,
        promptOverrideConfiguration: PromptOverrideConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentResponse {
        let input = UpdateAgentRequest(
            agentCollaboration: agentCollaboration, 
            agentId: agentId, 
            agentName: agentName, 
            agentResourceRoleArn: agentResourceRoleArn, 
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            customOrchestration: customOrchestration, 
            description: description, 
            foundationModel: foundationModel, 
            guardrailConfiguration: guardrailConfiguration, 
            idleSessionTTLInSeconds: idleSessionTTLInSeconds, 
            instruction: instruction, 
            memoryConfiguration: memoryConfiguration, 
            orchestrationType: orchestrationType, 
            promptOverrideConfiguration: promptOverrideConfiguration
        )
        return try await self.updateAgent(input, logger: logger)
    }

    /// Updates the configuration for an action group for an agent.
    @Sendable
    @inlinable
    public func updateAgentActionGroup(_ input: UpdateAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentActionGroupResponse {
        try await self.client.execute(
            operation: "UpdateAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration for an action group for an agent.
    ///
    /// Parameters:
    ///   - actionGroupExecutor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
    ///   - actionGroupId: The unique identifier of the action group.
    ///   - actionGroupName: Specifies a new name for the action group.
    ///   - actionGroupState: Specifies whether the action group is available for the agent to invoke or not when sending an InvokeAgent request.
    ///   - agentId: The unique identifier of the agent for which to update the action group.
    ///   - agentVersion: The unique identifier of the agent version for which to update the action group.
    ///   - apiSchema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see Action group OpenAPI schemas.
    ///   - description: Specifies a new name for the action group.
    ///   - functionSchema: Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    ///   - parentActionGroupSignature: Update the built-in or computer use action for this action group. If you specify a value, you must leave the description, apiSchema, and actionGroupExecutor fields empty for this action group.    To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.    To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter.   To allow your agent to use an Anthropic computer use tool, specify one of the following values.    Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only.           When operating computer use functionality, we recommend taking additional security precautions, such as executing computer actions in virtual environments with restricted data access and limited internet connectivity.  For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.      ANTHROPIC.Computer - Gives the agent permission to use the mouse and keyboard and take screenshots.    ANTHROPIC.TextEditor - Gives the agent permission to view, create and edit files.    ANTHROPIC.Bash - Gives the agent permission to run commands in a bash shell.     During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
    ///   - parentActionGroupSignatureParams: The configuration settings for a computer use action.   Computer use is a new Anthropic Claude model capability (in beta) available with Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. For more information, see Configure an Amazon Bedrock Agent to complete tasks with computer use tools.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentActionGroup(
        actionGroupExecutor: ActionGroupExecutor? = nil,
        actionGroupId: String,
        actionGroupName: String,
        actionGroupState: ActionGroupState? = nil,
        agentId: String,
        agentVersion: String,
        apiSchema: APISchema? = nil,
        description: String? = nil,
        functionSchema: FunctionSchema? = nil,
        parentActionGroupSignature: ActionGroupSignature? = nil,
        parentActionGroupSignatureParams: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentActionGroupResponse {
        let input = UpdateAgentActionGroupRequest(
            actionGroupExecutor: actionGroupExecutor, 
            actionGroupId: actionGroupId, 
            actionGroupName: actionGroupName, 
            actionGroupState: actionGroupState, 
            agentId: agentId, 
            agentVersion: agentVersion, 
            apiSchema: apiSchema, 
            description: description, 
            functionSchema: functionSchema, 
            parentActionGroupSignature: parentActionGroupSignature, 
            parentActionGroupSignatureParams: parentActionGroupSignatureParams
        )
        return try await self.updateAgentActionGroup(input, logger: logger)
    }

    /// Updates configurations for an alias of an agent.
    @Sendable
    @inlinable
    public func updateAgentAlias(_ input: UpdateAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentAliasResponse {
        try await self.client.execute(
            operation: "UpdateAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates configurations for an alias of an agent.
    ///
    /// Parameters:
    ///   - agentAliasId: The unique identifier of the alias.
    ///   - agentAliasName: Specifies a new name for the alias.
    ///   - agentId: The unique identifier of the agent.
    ///   - description: Specifies a new description for the alias.
    ///   - routingConfiguration: Contains details about the routing configuration of the alias.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentAlias(
        agentAliasId: String,
        agentAliasName: String,
        agentId: String,
        description: String? = nil,
        routingConfiguration: [AgentAliasRoutingConfigurationListItem]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentAliasResponse {
        let input = UpdateAgentAliasRequest(
            agentAliasId: agentAliasId, 
            agentAliasName: agentAliasName, 
            agentId: agentId, 
            description: description, 
            routingConfiguration: routingConfiguration
        )
        return try await self.updateAgentAlias(input, logger: logger)
    }

    /// Updates an agent's collaborator.
    @Sendable
    @inlinable
    public func updateAgentCollaborator(_ input: UpdateAgentCollaboratorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentCollaboratorResponse {
        try await self.client.execute(
            operation: "UpdateAgentCollaborator", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/agentcollaborators/{collaboratorId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an agent's collaborator.
    ///
    /// Parameters:
    ///   - agentDescriptor: An agent descriptor for the agent collaborator.
    ///   - agentId: The agent's ID.
    ///   - agentVersion: The agent's version.
    ///   - collaborationInstruction: Instruction for the collaborator.
    ///   - collaboratorId: The collaborator's ID.
    ///   - collaboratorName: The collaborator's name.
    ///   - relayConversationHistory: A relay conversation history for the collaborator.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentCollaborator(
        agentDescriptor: AgentDescriptor,
        agentId: String,
        agentVersion: String,
        collaborationInstruction: String,
        collaboratorId: String,
        collaboratorName: String,
        relayConversationHistory: RelayConversationHistory? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentCollaboratorResponse {
        let input = UpdateAgentCollaboratorRequest(
            agentDescriptor: agentDescriptor, 
            agentId: agentId, 
            agentVersion: agentVersion, 
            collaborationInstruction: collaborationInstruction, 
            collaboratorId: collaboratorId, 
            collaboratorName: collaboratorName, 
            relayConversationHistory: relayConversationHistory
        )
        return try await self.updateAgentCollaborator(input, logger: logger)
    }

    /// Updates the configuration for a knowledge base that has been associated with an agent.
    @Sendable
    @inlinable
    public func updateAgentKnowledgeBase(_ input: UpdateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "UpdateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration for a knowledge base that has been associated with an agent.
    ///
    /// Parameters:
    ///   - agentId: The unique identifier of the agent associated with the knowledge base that you want to update.
    ///   - agentVersion: The version of the agent associated with the knowledge base that you want to update.
    ///   - description: Specifies a new description for the knowledge base associated with an agent.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base that has been associated with an agent.
    ///   - knowledgeBaseState: Specifies whether the agent uses the knowledge base or not when sending an InvokeAgent request.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentKnowledgeBase(
        agentId: String,
        agentVersion: String,
        description: String? = nil,
        knowledgeBaseId: String,
        knowledgeBaseState: KnowledgeBaseState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentKnowledgeBaseResponse {
        let input = UpdateAgentKnowledgeBaseRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            description: description, 
            knowledgeBaseId: knowledgeBaseId, 
            knowledgeBaseState: knowledgeBaseState
        )
        return try await self.updateAgentKnowledgeBase(input, logger: logger)
    }

    /// Updates the configurations for a data source connector.  You can't change the chunkingConfiguration after you create the data source connector. Specify the existing chunkingConfiguration.
    @Sendable
    @inlinable
    public func updateDataSource(_ input: UpdateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDataSourceResponse {
        try await self.client.execute(
            operation: "UpdateDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configurations for a data source connector.  You can't change the chunkingConfiguration after you create the data source connector. Specify the existing chunkingConfiguration.
    ///
    /// Parameters:
    ///   - dataDeletionPolicy: The data deletion policy for the data source that you want to update.
    ///   - dataSourceConfiguration: The connection configuration for the data source that you want to update.
    ///   - dataSourceId: The unique identifier of the data source.
    ///   - description: Specifies a new description for the data source.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the data source.
    ///   - name: Specifies a new name for the data source.
    ///   - serverSideEncryptionConfiguration: Contains details about server-side encryption of the data source.
    ///   - vectorIngestionConfiguration: Contains details about how to ingest the documents in the data source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataSource(
        dataDeletionPolicy: DataDeletionPolicy? = nil,
        dataSourceConfiguration: DataSourceConfiguration,
        dataSourceId: String,
        description: String? = nil,
        knowledgeBaseId: String,
        name: String,
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: VectorIngestionConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDataSourceResponse {
        let input = UpdateDataSourceRequest(
            dataDeletionPolicy: dataDeletionPolicy, 
            dataSourceConfiguration: dataSourceConfiguration, 
            dataSourceId: dataSourceId, 
            description: description, 
            knowledgeBaseId: knowledgeBaseId, 
            name: name, 
            serverSideEncryptionConfiguration: serverSideEncryptionConfiguration, 
            vectorIngestionConfiguration: vectorIngestionConfiguration
        )
        return try await self.updateDataSource(input, logger: logger)
    }

    /// Modifies a flow. Include both fields that you want to keep and fields that you want to change. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func updateFlow(_ input: UpdateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFlowResponse {
        try await self.client.execute(
            operation: "UpdateFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies a flow. Include both fields that you want to keep and fields that you want to change. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
    ///   - definition: A definition of the nodes and the connections between the nodes in the flow.
    ///   - description: A description for the flow.
    ///   - executionRoleArn: The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see Create a service role for flows in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - name: A name for the flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFlow(
        customerEncryptionKeyArn: String? = nil,
        definition: FlowDefinition? = nil,
        description: String? = nil,
        executionRoleArn: String,
        flowIdentifier: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFlowResponse {
        let input = UpdateFlowRequest(
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            definition: definition, 
            description: description, 
            executionRoleArn: executionRoleArn, 
            flowIdentifier: flowIdentifier, 
            name: name
        )
        return try await self.updateFlow(input, logger: logger)
    }

    /// Modifies the alias of a flow. Include both fields that you want to keep and ones that you want to change. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func updateFlowAlias(_ input: UpdateFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFlowAliasResponse {
        try await self.client.execute(
            operation: "UpdateFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the alias of a flow. Include both fields that you want to keep and ones that you want to change. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - aliasIdentifier: The unique identifier of the alias.
    ///   - description: A description for the alias.
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - name: The name of the alias.
    ///   - routingConfiguration: Contains information about the version to which to map the alias.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFlowAlias(
        aliasIdentifier: String,
        description: String? = nil,
        flowIdentifier: String,
        name: String,
        routingConfiguration: [FlowAliasRoutingConfigurationListItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFlowAliasResponse {
        let input = UpdateFlowAliasRequest(
            aliasIdentifier: aliasIdentifier, 
            description: description, 
            flowIdentifier: flowIdentifier, 
            name: name, 
            routingConfiguration: routingConfiguration
        )
        return try await self.updateFlowAlias(input, logger: logger)
    }

    /// Updates the configuration of a knowledge base with the fields that you specify. Because all fields will be overwritten, you must include the same values for fields that you want to keep the same. You can change the following fields:    name     description     roleArn    You can't change the knowledgeBaseConfiguration or storageConfiguration fields, so you must specify the same configurations as when you created the knowledge base. You can send a GetKnowledgeBase request and copy the same configurations.
    @Sendable
    @inlinable
    public func updateKnowledgeBase(_ input: UpdateKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKnowledgeBaseResponse {
        try await self.client.execute(
            operation: "UpdateKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a knowledge base with the fields that you specify. Because all fields will be overwritten, you must include the same values for fields that you want to keep the same. You can change the following fields:    name     description     roleArn    You can't change the knowledgeBaseConfiguration or storageConfiguration fields, so you must specify the same configurations as when you created the knowledge base. You can send a GetKnowledgeBase request and copy the same configurations.
    ///
    /// Parameters:
    ///   - description: Specifies a new description for the knowledge base.
    ///   - knowledgeBaseConfiguration: Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base to update.
    ///   - name: Specifies a new name for the knowledge base.
    ///   - roleArn: Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    ///   - storageConfiguration: Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKnowledgeBase(
        description: String? = nil,
        knowledgeBaseConfiguration: KnowledgeBaseConfiguration,
        knowledgeBaseId: String,
        name: String,
        roleArn: String,
        storageConfiguration: StorageConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKnowledgeBaseResponse {
        let input = UpdateKnowledgeBaseRequest(
            description: description, 
            knowledgeBaseConfiguration: knowledgeBaseConfiguration, 
            knowledgeBaseId: knowledgeBaseId, 
            name: name, 
            roleArn: roleArn, 
            storageConfiguration: storageConfiguration
        )
        return try await self.updateKnowledgeBase(input, logger: logger)
    }

    /// Modifies a prompt in your prompt library. Include both fields that you want to keep and fields that you want to replace. For more information, see Prompt management in Amazon Bedrock and Edit prompts in your prompt library in the Amazon Bedrock User Guide.
    @Sendable
    @inlinable
    public func updatePrompt(_ input: UpdatePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePromptResponse {
        try await self.client.execute(
            operation: "UpdatePrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies a prompt in your prompt library. Include both fields that you want to keep and fields that you want to replace. For more information, see Prompt management in Amazon Bedrock and Edit prompts in your prompt library in the Amazon Bedrock User Guide.
    ///
    /// Parameters:
    ///   - customerEncryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
    ///   - defaultVariant: The name of the default variant for the prompt. This value must match the name field in the relevant PromptVariant object.
    ///   - description: A description for the prompt.
    ///   - name: A name for the prompt.
    ///   - promptIdentifier: The unique identifier of the prompt.
    ///   - variants: A list of objects, each containing details about a variant of the prompt.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePrompt(
        customerEncryptionKeyArn: String? = nil,
        defaultVariant: String? = nil,
        description: String? = nil,
        name: String,
        promptIdentifier: String,
        variants: [PromptVariant]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePromptResponse {
        let input = UpdatePromptRequest(
            customerEncryptionKeyArn: customerEncryptionKeyArn, 
            defaultVariant: defaultVariant, 
            description: description, 
            name: name, 
            promptIdentifier: promptIdentifier, 
            variants: variants
        )
        return try await self.updatePrompt(input, logger: logger)
    }

    /// Validates the definition of a flow.
    @Sendable
    @inlinable
    public func validateFlowDefinition(_ input: ValidateFlowDefinitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ValidateFlowDefinitionResponse {
        try await self.client.execute(
            operation: "ValidateFlowDefinition", 
            path: "/flows/validate-definition", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Validates the definition of a flow.
    ///
    /// Parameters:
    ///   - definition: The definition of a flow to validate.
    ///   - logger: Logger use during operation
    @inlinable
    public func validateFlowDefinition(
        definition: FlowDefinition,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ValidateFlowDefinitionResponse {
        let input = ValidateFlowDefinitionRequest(
            definition: definition
        )
        return try await self.validateFlowDefinition(input, logger: logger)
    }
}

extension BedrockAgent {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: BedrockAgent, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BedrockAgent {
    /// Return PaginatorSequence for operation ``listAgentActionGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentActionGroupsPaginator(
        _ input: ListAgentActionGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentActionGroupsRequest, ListAgentActionGroupsResponse> {
        return .init(
            input: input,
            command: self.listAgentActionGroups,
            inputKey: \ListAgentActionGroupsRequest.nextToken,
            outputKey: \ListAgentActionGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentActionGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - agentVersion: The version of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentActionGroupsPaginator(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentActionGroupsRequest, ListAgentActionGroupsResponse> {
        let input = ListAgentActionGroupsRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults
        )
        return self.listAgentActionGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentAliasesPaginator(
        _ input: ListAgentAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentAliasesRequest, ListAgentAliasesResponse> {
        return .init(
            input: input,
            command: self.listAgentAliases,
            inputKey: \ListAgentAliasesRequest.nextToken,
            outputKey: \ListAgentAliasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentAliasesPaginator(
        agentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentAliasesRequest, ListAgentAliasesResponse> {
        let input = ListAgentAliasesRequest(
            agentId: agentId, 
            maxResults: maxResults
        )
        return self.listAgentAliasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentCollaborators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentCollaboratorsPaginator(
        _ input: ListAgentCollaboratorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentCollaboratorsRequest, ListAgentCollaboratorsResponse> {
        return .init(
            input: input,
            command: self.listAgentCollaborators,
            inputKey: \ListAgentCollaboratorsRequest.nextToken,
            outputKey: \ListAgentCollaboratorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentCollaborators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentId: The agent's ID.
    ///   - agentVersion: The agent's version.
    ///   - maxResults: The maximum number of agent collaborators to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentCollaboratorsPaginator(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentCollaboratorsRequest, ListAgentCollaboratorsResponse> {
        let input = ListAgentCollaboratorsRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults
        )
        return self.listAgentCollaboratorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentKnowledgeBases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentKnowledgeBasesPaginator(
        _ input: ListAgentKnowledgeBasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentKnowledgeBasesRequest, ListAgentKnowledgeBasesResponse> {
        return .init(
            input: input,
            command: self.listAgentKnowledgeBases,
            inputKey: \ListAgentKnowledgeBasesRequest.nextToken,
            outputKey: \ListAgentKnowledgeBasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentKnowledgeBases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentId: The unique identifier of the agent for which to return information about knowledge bases associated with it.
    ///   - agentVersion: The version of the agent for which to return information about knowledge bases associated with it.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentKnowledgeBasesPaginator(
        agentId: String,
        agentVersion: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentKnowledgeBasesRequest, ListAgentKnowledgeBasesResponse> {
        let input = ListAgentKnowledgeBasesRequest(
            agentId: agentId, 
            agentVersion: agentVersion, 
            maxResults: maxResults
        )
        return self.listAgentKnowledgeBasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentVersionsPaginator(
        _ input: ListAgentVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentVersionsRequest, ListAgentVersionsResponse> {
        return .init(
            input: input,
            command: self.listAgentVersions,
            inputKey: \ListAgentVersionsRequest.nextToken,
            outputKey: \ListAgentVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentId: The unique identifier of the agent.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentVersionsPaginator(
        agentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentVersionsRequest, ListAgentVersionsResponse> {
        let input = ListAgentVersionsRequest(
            agentId: agentId, 
            maxResults: maxResults
        )
        return self.listAgentVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentsPaginator(
        _ input: ListAgentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentsRequest, ListAgentsResponse> {
        return .init(
            input: input,
            command: self.listAgents,
            inputKey: \ListAgentsRequest.nextToken,
            outputKey: \ListAgentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentsRequest, ListAgentsResponse> {
        let input = ListAgentsRequest(
            maxResults: maxResults
        )
        return self.listAgentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSourcesPaginator(
        _ input: ListDataSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataSourcesRequest, ListDataSourcesResponse> {
        return .init(
            input: input,
            command: self.listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for which to return a list of information.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSourcesPaginator(
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataSourcesRequest, ListDataSourcesResponse> {
        let input = ListDataSourcesRequest(
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults
        )
        return self.listDataSourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFlowAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowAliasesPaginator(
        _ input: ListFlowAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowAliasesRequest, ListFlowAliasesResponse> {
        return .init(
            input: input,
            command: self.listFlowAliases,
            inputKey: \ListFlowAliasesRequest.nextToken,
            outputKey: \ListFlowAliasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFlowAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - flowIdentifier: The unique identifier of the flow for which aliases are being returned.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowAliasesPaginator(
        flowIdentifier: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFlowAliasesRequest, ListFlowAliasesResponse> {
        let input = ListFlowAliasesRequest(
            flowIdentifier: flowIdentifier, 
            maxResults: maxResults
        )
        return self.listFlowAliasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFlowVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowVersionsPaginator(
        _ input: ListFlowVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowVersionsRequest, ListFlowVersionsResponse> {
        return .init(
            input: input,
            command: self.listFlowVersions,
            inputKey: \ListFlowVersionsRequest.nextToken,
            outputKey: \ListFlowVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFlowVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - flowIdentifier: The unique identifier of the flow.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowVersionsPaginator(
        flowIdentifier: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFlowVersionsRequest, ListFlowVersionsResponse> {
        let input = ListFlowVersionsRequest(
            flowIdentifier: flowIdentifier, 
            maxResults: maxResults
        )
        return self.listFlowVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowsPaginator(
        _ input: ListFlowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowsRequest, ListFlowsResponse> {
        return .init(
            input: input,
            command: self.listFlows,
            inputKey: \ListFlowsRequest.nextToken,
            outputKey: \ListFlowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFlowsRequest, ListFlowsResponse> {
        let input = ListFlowsRequest(
            maxResults: maxResults
        )
        return self.listFlowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIngestionJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngestionJobsPaginator(
        _ input: ListIngestionJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIngestionJobsRequest, ListIngestionJobsResponse> {
        return .init(
            input: input,
            command: self.listIngestionJobs,
            inputKey: \ListIngestionJobsRequest.nextToken,
            outputKey: \ListIngestionJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIngestionJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dataSourceId: The unique identifier of the data source for the list of data ingestion jobs.
    ///   - filters: Contains information about the filters for filtering the data.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base for the list of data ingestion jobs.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - sortBy: Contains details about how to sort the data.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngestionJobsPaginator(
        dataSourceId: String,
        filters: [IngestionJobFilter]? = nil,
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        sortBy: IngestionJobSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIngestionJobsRequest, ListIngestionJobsResponse> {
        let input = ListIngestionJobsRequest(
            dataSourceId: dataSourceId, 
            filters: filters, 
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listIngestionJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKnowledgeBaseDocuments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKnowledgeBaseDocumentsPaginator(
        _ input: ListKnowledgeBaseDocumentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKnowledgeBaseDocumentsRequest, ListKnowledgeBaseDocumentsResponse> {
        return .init(
            input: input,
            command: self.listKnowledgeBaseDocuments,
            inputKey: \ListKnowledgeBaseDocumentsRequest.nextToken,
            outputKey: \ListKnowledgeBaseDocumentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKnowledgeBaseDocuments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dataSourceId: The unique identifier of the data source that contains the documents.
    ///   - knowledgeBaseId: The unique identifier of the knowledge base that is connected to the data source.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKnowledgeBaseDocumentsPaginator(
        dataSourceId: String,
        knowledgeBaseId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKnowledgeBaseDocumentsRequest, ListKnowledgeBaseDocumentsResponse> {
        let input = ListKnowledgeBaseDocumentsRequest(
            dataSourceId: dataSourceId, 
            knowledgeBaseId: knowledgeBaseId, 
            maxResults: maxResults
        )
        return self.listKnowledgeBaseDocumentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKnowledgeBases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKnowledgeBasesPaginator(
        _ input: ListKnowledgeBasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKnowledgeBasesRequest, ListKnowledgeBasesResponse> {
        return .init(
            input: input,
            command: self.listKnowledgeBases,
            inputKey: \ListKnowledgeBasesRequest.nextToken,
            outputKey: \ListKnowledgeBasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKnowledgeBases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKnowledgeBasesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKnowledgeBasesRequest, ListKnowledgeBasesResponse> {
        let input = ListKnowledgeBasesRequest(
            maxResults: maxResults
        )
        return self.listKnowledgeBasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrompts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPromptsPaginator(
        _ input: ListPromptsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPromptsRequest, ListPromptsResponse> {
        return .init(
            input: input,
            command: self.listPrompts,
            inputKey: \ListPromptsRequest.nextToken,
            outputKey: \ListPromptsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrompts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - promptIdentifier: The unique identifier of the prompt for whose versions you want to return information. Omit this field to list information about all prompts in an account.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPromptsPaginator(
        maxResults: Int? = nil,
        promptIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPromptsRequest, ListPromptsResponse> {
        let input = ListPromptsRequest(
            maxResults: maxResults, 
            promptIdentifier: promptIdentifier
        )
        return self.listPromptsPaginator(input, logger: logger)
    }
}

extension BedrockAgent.ListAgentActionGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentActionGroupsRequest {
        return .init(
            agentId: self.agentId,
            agentVersion: self.agentVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentAliasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentAliasesRequest {
        return .init(
            agentId: self.agentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentCollaboratorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentCollaboratorsRequest {
        return .init(
            agentId: self.agentId,
            agentVersion: self.agentVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentKnowledgeBasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentKnowledgeBasesRequest {
        return .init(
            agentId: self.agentId,
            agentVersion: self.agentVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentVersionsRequest {
        return .init(
            agentId: self.agentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListDataSourcesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListDataSourcesRequest {
        return .init(
            knowledgeBaseId: self.knowledgeBaseId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowAliasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowAliasesRequest {
        return .init(
            flowIdentifier: self.flowIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowVersionsRequest {
        return .init(
            flowIdentifier: self.flowIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListIngestionJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListIngestionJobsRequest {
        return .init(
            dataSourceId: self.dataSourceId,
            filters: self.filters,
            knowledgeBaseId: self.knowledgeBaseId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension BedrockAgent.ListKnowledgeBaseDocumentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListKnowledgeBaseDocumentsRequest {
        return .init(
            dataSourceId: self.dataSourceId,
            knowledgeBaseId: self.knowledgeBaseId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListKnowledgeBasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListKnowledgeBasesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListPromptsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListPromptsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            promptIdentifier: self.promptIdentifier
        )
    }
}
