//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS BedrockAgent service.
///
/// Describes the API operations for creating and managing Amazon Bedrock agents.
public struct BedrockAgent: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the BedrockAgent client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "BedrockAgent",
            serviceIdentifier: "bedrock-agent",
            signingName: "bedrock",
            serviceProtocol: .restjson,
            apiVersion: "2023-06-05",
            endpoint: endpoint,
            errorType: BedrockAgentErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Associates a knowledge base with an agent. If a knowledge base is associated and its indexState is set to Enabled, the agent queries the knowledge base for information to augment its response to the user.
    @Sendable
    public func associateAgentKnowledgeBase(_ input: AssociateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateAgentKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "AssociateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an agent that orchestrates interactions between foundation models, data sources, software applications, user conversations, and APIs to carry out tasks to help customers.   Specify the following fields for security purposes.    agentResourceRoleArn – The Amazon Resource Name (ARN) of the role with permissions to invoke API operations on an agent.   (Optional) customerEncryptionKeyArn – The Amazon Resource Name (ARN) of a KMS key to encrypt the creation of the agent.   (Optional) idleSessionTTLinSeconds – Specify the number of seconds for which the agent should maintain session information. After this time expires, the subsequent InvokeAgent request begins a new session.     To enable your agent to retain conversational context across multiple sessions, include a memoryConfiguration object.  For more information, see Configure memory.   To override the default prompt behavior for agent orchestration and to use advanced prompts, include a promptOverrideConfiguration object.  For more information, see Advanced prompts.   If your agent fails to be created, the response returns a list of failureReasons alongside a list of recommendedActions for you to troubleshoot.   The agent instructions will not be honored if your agent has only one knowledge base, uses default prompts, has no action group, and user input is disabled.
    @Sendable
    public func createAgent(_ input: CreateAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentResponse {
        return try await self.client.execute(
            operation: "CreateAgent", 
            path: "/agents/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an action group for an agent. An action group represents the actions that an agent can carry out for the customer by defining the APIs that an agent can call and the logic for calling them. To allow your agent to request the user for additional information when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.UserInput.  To allow your agent to generate, run, and troubleshoot code when trying to complete a task,  add an action group with the parentActionGroupSignature field set to AMAZON.CodeInterpreter.  You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
    @Sendable
    public func createAgentActionGroup(_ input: CreateAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentActionGroupResponse {
        return try await self.client.execute(
            operation: "CreateAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an alias of an agent that can be used to deploy the agent.
    @Sendable
    public func createAgentAlias(_ input: CreateAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentAliasResponse {
        return try await self.client.execute(
            operation: "CreateAgentAlias", 
            path: "/agents/{agentId}/agentaliases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a data source connector for a knowledge base.  You can't change the chunkingConfiguration after you create the data source connector.
    @Sendable
    public func createDataSource(_ input: CreateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataSourceResponse {
        return try await self.client.execute(
            operation: "CreateDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a prompt flow that you can use to send an input through various steps to yield an output. Configure nodes, each of which corresponds to a step of the flow, and create connections between the nodes to create paths to different outputs. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func createFlow(_ input: CreateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowResponse {
        return try await self.client.execute(
            operation: "CreateFlow", 
            path: "/flows/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an alias of a flow for deployment. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func createFlowAlias(_ input: CreateFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowAliasResponse {
        return try await self.client.execute(
            operation: "CreateFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a version of the flow that you can deploy. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func createFlowVersion(_ input: CreateFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowVersionResponse {
        return try await self.client.execute(
            operation: "CreateFlowVersion", 
            path: "/flows/{flowIdentifier}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a knowledge base that contains data sources from which information can be queried and used by LLMs. To create a knowledge base, you must first set up your data sources and configure a supported vector store. For more information, see Set up your data for ingestion.  If you prefer to let Amazon Bedrock create and manage a vector store for you in Amazon OpenSearch Service, use the console. For more information, see Create a knowledge base.    Provide the name and an optional description.   Provide the Amazon Resource Name (ARN) with permissions to create a knowledge base in the roleArn field.   Provide the embedding model to use in the embeddingModelArn field in the knowledgeBaseConfiguration object.   Provide the configuration for your vector store in the storageConfiguration object.   For an Amazon OpenSearch Service database, use the opensearchServerlessConfiguration object. For more information, see Create a vector store in Amazon OpenSearch Service.   For an Amazon Aurora database, use the RdsConfiguration object. For more information, see Create a vector store in Amazon Aurora.   For a Pinecone database, use the pineconeConfiguration object. For more information, see Create a vector store in Pinecone.   For a Redis Enterprise Cloud database, use the redisEnterpriseCloudConfiguration object. For more information, see Create a vector store in Redis Enterprise Cloud.
    @Sendable
    public func createKnowledgeBase(_ input: CreateKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "CreateKnowledgeBase", 
            path: "/knowledgebases/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a prompt in your prompt library that you can add to a flow. For more information, see Prompt management in Amazon Bedrock, Create a prompt using Prompt management and Prompt flows in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func createPrompt(_ input: CreatePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePromptResponse {
        return try await self.client.execute(
            operation: "CreatePrompt", 
            path: "/prompts/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a static snapshot of your prompt that can be deployed to production. For more information, see Deploy prompts using Prompt management by creating versions in the Amazon Bedrock User Guide.
    @Sendable
    public func createPromptVersion(_ input: CreatePromptVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePromptVersionResponse {
        return try await self.client.execute(
            operation: "CreatePromptVersion", 
            path: "/prompts/{promptIdentifier}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an agent.
    @Sendable
    public func deleteAgent(_ input: DeleteAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentResponse {
        return try await self.client.execute(
            operation: "DeleteAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an action group in an agent.
    @Sendable
    public func deleteAgentActionGroup(_ input: DeleteAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentActionGroupResponse {
        return try await self.client.execute(
            operation: "DeleteAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an alias of an agent.
    @Sendable
    public func deleteAgentAlias(_ input: DeleteAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentAliasResponse {
        return try await self.client.execute(
            operation: "DeleteAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a version of an agent.
    @Sendable
    public func deleteAgentVersion(_ input: DeleteAgentVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentVersionResponse {
        return try await self.client.execute(
            operation: "DeleteAgentVersion", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a data source from a knowledge base.
    @Sendable
    public func deleteDataSource(_ input: DeleteDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataSourceResponse {
        return try await self.client.execute(
            operation: "DeleteDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a flow.
    @Sendable
    public func deleteFlow(_ input: DeleteFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowResponse {
        return try await self.client.execute(
            operation: "DeleteFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an alias of a flow.
    @Sendable
    public func deleteFlowAlias(_ input: DeleteFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowAliasResponse {
        return try await self.client.execute(
            operation: "DeleteFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a version of a flow.
    @Sendable
    public func deleteFlowVersion(_ input: DeleteFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowVersionResponse {
        return try await self.client.execute(
            operation: "DeleteFlowVersion", 
            path: "/flows/{flowIdentifier}/versions/{flowVersion}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a knowledge base. Before deleting a knowledge base, you should disassociate the knowledge base from any agents that it is associated with by making a DisassociateAgentKnowledgeBase request.
    @Sendable
    public func deleteKnowledgeBase(_ input: DeleteKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "DeleteKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see Delete prompts from the Prompt management tool and Delete a version of a prompt from the Prompt management tool in the Amazon Bedrock User Guide.
    @Sendable
    public func deletePrompt(_ input: DeletePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePromptResponse {
        return try await self.client.execute(
            operation: "DeletePrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Disassociates a knowledge base from an agent.
    @Sendable
    public func disassociateAgentKnowledgeBase(_ input: DisassociateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateAgentKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "DisassociateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about an agent.
    @Sendable
    public func getAgent(_ input: GetAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentResponse {
        return try await self.client.execute(
            operation: "GetAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about an action group for an agent.
    @Sendable
    public func getAgentActionGroup(_ input: GetAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentActionGroupResponse {
        return try await self.client.execute(
            operation: "GetAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about an alias of an agent.
    @Sendable
    public func getAgentAlias(_ input: GetAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentAliasResponse {
        return try await self.client.execute(
            operation: "GetAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a knowledge base associated with an agent.
    @Sendable
    public func getAgentKnowledgeBase(_ input: GetAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "GetAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets details about a version of an agent.
    @Sendable
    public func getAgentVersion(_ input: GetAgentVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentVersionResponse {
        return try await self.client.execute(
            operation: "GetAgentVersion", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a data source.
    @Sendable
    public func getDataSource(_ input: GetDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataSourceResponse {
        return try await self.client.execute(
            operation: "GetDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves information about a flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func getFlow(_ input: GetFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowResponse {
        return try await self.client.execute(
            operation: "GetFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves information about a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func getFlowAlias(_ input: GetFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowAliasResponse {
        return try await self.client.execute(
            operation: "GetFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves information about a version of a flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func getFlowVersion(_ input: GetFlowVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFlowVersionResponse {
        return try await self.client.execute(
            operation: "GetFlowVersion", 
            path: "/flows/{flowIdentifier}/versions/{flowVersion}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a ingestion job, in which a data source is added to a knowledge base.
    @Sendable
    public func getIngestionJob(_ input: GetIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIngestionJobResponse {
        return try await self.client.execute(
            operation: "GetIngestionJob", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/{ingestionJobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a knoweldge base.
    @Sendable
    public func getKnowledgeBase(_ input: GetKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "GetKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves information about the working draft (DRAFT version) of a prompt or a version of it, depending on whether you include the promptVersion field or not. For more information, see View information about prompts using Prompt management and View information about a version of your prompt in the Amazon Bedrock User Guide.
    @Sendable
    public func getPrompt(_ input: GetPromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPromptResponse {
        return try await self.client.execute(
            operation: "GetPrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the action groups for an agent and information about each one.
    @Sendable
    public func listAgentActionGroups(_ input: ListAgentActionGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentActionGroupsResponse {
        return try await self.client.execute(
            operation: "ListAgentActionGroups", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the aliases of an agent and information about each one.
    @Sendable
    public func listAgentAliases(_ input: ListAgentAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentAliasesResponse {
        return try await self.client.execute(
            operation: "ListAgentAliases", 
            path: "/agents/{agentId}/agentaliases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists knowledge bases associated with an agent and information about each one.
    @Sendable
    public func listAgentKnowledgeBases(_ input: ListAgentKnowledgeBasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentKnowledgeBasesResponse {
        return try await self.client.execute(
            operation: "ListAgentKnowledgeBases", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the versions of an agent and information about each version.
    @Sendable
    public func listAgentVersions(_ input: ListAgentVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentVersionsResponse {
        return try await self.client.execute(
            operation: "ListAgentVersions", 
            path: "/agents/{agentId}/agentversions/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the agents belonging to an account and information about each agent.
    @Sendable
    public func listAgents(_ input: ListAgentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentsResponse {
        return try await self.client.execute(
            operation: "ListAgents", 
            path: "/agents/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the data sources in a knowledge base and information about each one.
    @Sendable
    public func listDataSources(_ input: ListDataSourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataSourcesResponse {
        return try await self.client.execute(
            operation: "ListDataSources", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of aliases for a flow.
    @Sendable
    public func listFlowAliases(_ input: ListFlowAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowAliasesResponse {
        return try await self.client.execute(
            operation: "ListFlowAliases", 
            path: "/flows/{flowIdentifier}/aliases", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of information about each flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func listFlowVersions(_ input: ListFlowVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowVersionsResponse {
        return try await self.client.execute(
            operation: "ListFlowVersions", 
            path: "/flows/{flowIdentifier}/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of flows and information about each flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func listFlows(_ input: ListFlowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowsResponse {
        return try await self.client.execute(
            operation: "ListFlows", 
            path: "/flows/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the ingestion jobs for a data source and information about each of them.
    @Sendable
    public func listIngestionJobs(_ input: ListIngestionJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIngestionJobsResponse {
        return try await self.client.execute(
            operation: "ListIngestionJobs", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the knowledge bases in an account and information about each of them.
    @Sendable
    public func listKnowledgeBases(_ input: ListKnowledgeBasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKnowledgeBasesResponse {
        return try await self.client.execute(
            operation: "ListKnowledgeBases", 
            path: "/knowledgebases/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns either information about the working draft (DRAFT version) of each prompt in an account, or information about of all versions of a prompt, depending on whether you include the promptIdentifier field or not. For more information, see View information about prompts using Prompt management in the Amazon Bedrock User Guide.
    @Sendable
    public func listPrompts(_ input: ListPromptsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPromptsResponse {
        return try await self.client.execute(
            operation: "ListPrompts", 
            path: "/prompts/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// List all the tags for the resource you specify.
    @Sendable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a DRAFT version of the agent that can be used for internal testing.
    @Sendable
    public func prepareAgent(_ input: PrepareAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PrepareAgentResponse {
        return try await self.client.execute(
            operation: "PrepareAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Prepares the DRAFT version of a flow so that it can be invoked. For more information, see Test a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func prepareFlow(_ input: PrepareFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PrepareFlowResponse {
        return try await self.client.execute(
            operation: "PrepareFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Begins an ingestion job, in which a data source is added to a knowledge base.
    @Sendable
    public func startIngestionJob(_ input: StartIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartIngestionJobResponse {
        return try await self.client.execute(
            operation: "StartIngestionJob", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Associate tags with a resource. For more information, see  Tagging resources in the Amazon Bedrock User Guide.
    @Sendable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        return try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Remove tags from a resource.
    @Sendable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        return try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration of an agent.
    @Sendable
    public func updateAgent(_ input: UpdateAgentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentResponse {
        return try await self.client.execute(
            operation: "UpdateAgent", 
            path: "/agents/{agentId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration for an action group for an agent.
    @Sendable
    public func updateAgentActionGroup(_ input: UpdateAgentActionGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentActionGroupResponse {
        return try await self.client.execute(
            operation: "UpdateAgentActionGroup", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/actiongroups/{actionGroupId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates configurations for an alias of an agent.
    @Sendable
    public func updateAgentAlias(_ input: UpdateAgentAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentAliasResponse {
        return try await self.client.execute(
            operation: "UpdateAgentAlias", 
            path: "/agents/{agentId}/agentaliases/{agentAliasId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration for a knowledge base that has been associated with an agent.
    @Sendable
    public func updateAgentKnowledgeBase(_ input: UpdateAgentKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "UpdateAgentKnowledgeBase", 
            path: "/agents/{agentId}/agentversions/{agentVersion}/knowledgebases/{knowledgeBaseId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configurations for a data source connector.  You can't change the chunkingConfiguration after you create the data source connector. Specify the existing chunkingConfiguration.
    @Sendable
    public func updateDataSource(_ input: UpdateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDataSourceResponse {
        return try await self.client.execute(
            operation: "UpdateDataSource", 
            path: "/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies a flow. Include both fields that you want to keep and fields that you want to change. For more information, see How it works and Create a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func updateFlow(_ input: UpdateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFlowResponse {
        return try await self.client.execute(
            operation: "UpdateFlow", 
            path: "/flows/{flowIdentifier}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the alias of a flow. Include both fields that you want to keep and ones that you want to change. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    @Sendable
    public func updateFlowAlias(_ input: UpdateFlowAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFlowAliasResponse {
        return try await self.client.execute(
            operation: "UpdateFlowAlias", 
            path: "/flows/{flowIdentifier}/aliases/{aliasIdentifier}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration of a knowledge base with the fields that you specify. Because all fields will be overwritten, you must include the same values for fields that you want to keep the same. You can change the following fields:    name     description     roleArn    You can't change the knowledgeBaseConfiguration or storageConfiguration fields, so you must specify the same configurations as when you created the knowledge base. You can send a GetKnowledgeBase request and copy the same configurations.
    @Sendable
    public func updateKnowledgeBase(_ input: UpdateKnowledgeBaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKnowledgeBaseResponse {
        return try await self.client.execute(
            operation: "UpdateKnowledgeBase", 
            path: "/knowledgebases/{knowledgeBaseId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies a prompt in your prompt library. Include both fields that you want to keep and fields that you want to replace. For more information, see Prompt management in Amazon Bedrock and Edit prompts in your prompt library in the Amazon Bedrock User Guide.
    @Sendable
    public func updatePrompt(_ input: UpdatePromptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePromptResponse {
        return try await self.client.execute(
            operation: "UpdatePrompt", 
            path: "/prompts/{promptIdentifier}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
}

extension BedrockAgent {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: BedrockAgent, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BedrockAgent {
    /// Lists the action groups for an agent and information about each one.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAgentActionGroupsPaginator(
        _ input: ListAgentActionGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentActionGroupsRequest, ListAgentActionGroupsResponse> {
        return .init(
            input: input,
            command: self.listAgentActionGroups,
            inputKey: \ListAgentActionGroupsRequest.nextToken,
            outputKey: \ListAgentActionGroupsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the aliases of an agent and information about each one.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAgentAliasesPaginator(
        _ input: ListAgentAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentAliasesRequest, ListAgentAliasesResponse> {
        return .init(
            input: input,
            command: self.listAgentAliases,
            inputKey: \ListAgentAliasesRequest.nextToken,
            outputKey: \ListAgentAliasesResponse.nextToken,
            logger: logger
        )
    }

    /// Lists knowledge bases associated with an agent and information about each one.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAgentKnowledgeBasesPaginator(
        _ input: ListAgentKnowledgeBasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentKnowledgeBasesRequest, ListAgentKnowledgeBasesResponse> {
        return .init(
            input: input,
            command: self.listAgentKnowledgeBases,
            inputKey: \ListAgentKnowledgeBasesRequest.nextToken,
            outputKey: \ListAgentKnowledgeBasesResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the versions of an agent and information about each version.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAgentVersionsPaginator(
        _ input: ListAgentVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentVersionsRequest, ListAgentVersionsResponse> {
        return .init(
            input: input,
            command: self.listAgentVersions,
            inputKey: \ListAgentVersionsRequest.nextToken,
            outputKey: \ListAgentVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the agents belonging to an account and information about each agent.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAgentsPaginator(
        _ input: ListAgentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentsRequest, ListAgentsResponse> {
        return .init(
            input: input,
            command: self.listAgents,
            inputKey: \ListAgentsRequest.nextToken,
            outputKey: \ListAgentsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the data sources in a knowledge base and information about each one.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listDataSourcesPaginator(
        _ input: ListDataSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataSourcesRequest, ListDataSourcesResponse> {
        return .init(
            input: input,
            command: self.listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of aliases for a flow.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listFlowAliasesPaginator(
        _ input: ListFlowAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowAliasesRequest, ListFlowAliasesResponse> {
        return .init(
            input: input,
            command: self.listFlowAliases,
            inputKey: \ListFlowAliasesRequest.nextToken,
            outputKey: \ListFlowAliasesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of information about each flow. For more information, see Deploy a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listFlowVersionsPaginator(
        _ input: ListFlowVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowVersionsRequest, ListFlowVersionsResponse> {
        return .init(
            input: input,
            command: self.listFlowVersions,
            inputKey: \ListFlowVersionsRequest.nextToken,
            outputKey: \ListFlowVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of flows and information about each flow. For more information, see Manage a flow in Amazon Bedrock in the Amazon Bedrock User Guide.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listFlowsPaginator(
        _ input: ListFlowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowsRequest, ListFlowsResponse> {
        return .init(
            input: input,
            command: self.listFlows,
            inputKey: \ListFlowsRequest.nextToken,
            outputKey: \ListFlowsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the ingestion jobs for a data source and information about each of them.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listIngestionJobsPaginator(
        _ input: ListIngestionJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIngestionJobsRequest, ListIngestionJobsResponse> {
        return .init(
            input: input,
            command: self.listIngestionJobs,
            inputKey: \ListIngestionJobsRequest.nextToken,
            outputKey: \ListIngestionJobsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the knowledge bases in an account and information about each of them.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listKnowledgeBasesPaginator(
        _ input: ListKnowledgeBasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKnowledgeBasesRequest, ListKnowledgeBasesResponse> {
        return .init(
            input: input,
            command: self.listKnowledgeBases,
            inputKey: \ListKnowledgeBasesRequest.nextToken,
            outputKey: \ListKnowledgeBasesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns either information about the working draft (DRAFT version) of each prompt in an account, or information about of all versions of a prompt, depending on whether you include the promptIdentifier field or not. For more information, see View information about prompts using Prompt management in the Amazon Bedrock User Guide.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listPromptsPaginator(
        _ input: ListPromptsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPromptsRequest, ListPromptsResponse> {
        return .init(
            input: input,
            command: self.listPrompts,
            inputKey: \ListPromptsRequest.nextToken,
            outputKey: \ListPromptsResponse.nextToken,
            logger: logger
        )
    }
}

extension BedrockAgent.ListAgentActionGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentActionGroupsRequest {
        return .init(
            agentId: self.agentId,
            agentVersion: self.agentVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentAliasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentAliasesRequest {
        return .init(
            agentId: self.agentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentKnowledgeBasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentKnowledgeBasesRequest {
        return .init(
            agentId: self.agentId,
            agentVersion: self.agentVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentVersionsRequest {
        return .init(
            agentId: self.agentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListAgentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListAgentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListDataSourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListDataSourcesRequest {
        return .init(
            knowledgeBaseId: self.knowledgeBaseId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowAliasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowAliasesRequest {
        return .init(
            flowIdentifier: self.flowIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowVersionsRequest {
        return .init(
            flowIdentifier: self.flowIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListFlowsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListFlowsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListIngestionJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListIngestionJobsRequest {
        return .init(
            dataSourceId: self.dataSourceId,
            filters: self.filters,
            knowledgeBaseId: self.knowledgeBaseId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension BedrockAgent.ListKnowledgeBasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListKnowledgeBasesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgent.ListPromptsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> BedrockAgent.ListPromptsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            promptIdentifier: self.promptIdentifier
        )
    }
}
