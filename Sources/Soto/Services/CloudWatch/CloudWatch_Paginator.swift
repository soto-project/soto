//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension CloudWatch {
    ///  Retrieves the history for the specified alarm. You can filter the results by date range or item type.
    ///  			If an alarm name is not specified, the histories for either all metric alarms or all composite alarms are returned.
    ///  		       CloudWatch retains the history of an alarm even if you delete the alarm.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAlarmHistoryPaginator<Result>(
        _ input: DescribeAlarmHistoryInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAlarmHistoryOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAlarmHistory,
            inputKey: \DescribeAlarmHistoryInput.nextToken,
            outputKey: \DescribeAlarmHistoryOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAlarmHistoryPaginator(
        _ input: DescribeAlarmHistoryInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAlarmHistoryOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAlarmHistory,
            inputKey: \DescribeAlarmHistoryInput.nextToken,
            outputKey: \DescribeAlarmHistoryOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the specified alarms. You can filter the results by specifying a prefix for the alarm
    ///  			name, the alarm state, or a prefix for any action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAlarmsPaginator<Result>(
        _ input: DescribeAlarmsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAlarmsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAlarms,
            inputKey: \DescribeAlarmsInput.nextToken,
            outputKey: \DescribeAlarmsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAlarmsPaginator(
        _ input: DescribeAlarmsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAlarmsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAlarms,
            inputKey: \DescribeAlarmsInput.nextToken,
            outputKey: \DescribeAlarmsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of all the Contributor Insights rules in your account.
    ///
    ///  		       For more information about Contributor Insights, see
    ///  		Using Contributor Insights to Analyze High-Cardinality Data.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInsightRulesPaginator<Result>(
        _ input: DescribeInsightRulesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInsightRulesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInsightRules,
            inputKey: \DescribeInsightRulesInput.nextToken,
            outputKey: \DescribeInsightRulesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInsightRulesPaginator(
        _ input: DescribeInsightRulesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInsightRulesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInsightRules,
            inputKey: \DescribeInsightRulesInput.nextToken,
            outputKey: \DescribeInsightRulesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  You can use the GetMetricData API to retrieve as many as 500 different
    ///  			metrics in a single request, with a total of as many as 100,800 data points. You can also
    ///  			optionally perform math expressions on the values of the returned statistics, to create
    ///  			new time series that represent new insights into your data. For example, using Lambda
    ///  			metrics, you could divide the Errors metric by the Invocations metric to get an error
    ///  			rate time series. For more information about metric math expressions, see Metric Math Syntax and Functions in the Amazon CloudWatch User
    ///  				Guide.
    ///
    ///  		       Calls to the GetMetricData API have a different pricing structure than
    ///  			calls to GetMetricStatistics. For more information about pricing, see
    ///  			Amazon CloudWatch Pricing.
    ///  		       Amazon CloudWatch retains metric data as follows:
    ///  		         Data points with a period of less than 60 seconds are available for 3 hours. These data points are high-resolution
    ///  				metrics and are available only for custom metrics that have been defined with a StorageResolution of 1.   Data points with a period of 60 seconds (1-minute) are available for 15 days.   Data points with a period of 300 seconds (5-minute) are available for 63 days.   Data points with a period of 3600 seconds (1 hour) are available for 455 days (15 months).
    ///  		       Data points that are initially published with a shorter period are aggregated together for long-term storage. For example, if you collect
    ///  			data using a period of 1 minute, the data remains available for 15 days with 1-minute resolution. After 15 days, this data is still available,
    ///  			but is aggregated and retrievable only with a resolution of 5 minutes. After 63 days, the data is further aggregated and is available with
    ///  			a resolution of 1 hour.
    ///
    ///  		       If you omit Unit in your request, all data that was collected with any unit is returned, along with the corresponding units that were specified
    ///  			when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified.
    ///  			If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getMetricDataPaginator<Result>(
        _ input: GetMetricDataInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetMetricDataOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getMetricData,
            inputKey: \GetMetricDataInput.nextToken,
            outputKey: \GetMetricDataOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getMetricDataPaginator(
        _ input: GetMetricDataInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetMetricDataOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getMetricData,
            inputKey: \GetMetricDataInput.nextToken,
            outputKey: \GetMetricDataOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of the dashboards for your account. If you include DashboardNamePrefix, only
    ///  			those dashboards with names starting with the prefix are listed. Otherwise, all dashboards in your account are
    ///  			listed.
    ///
    ///  		        ListDashboards returns up to 1000 results on one page. If there
    ///  			are more than 1000 dashboards, you can call ListDashboards again and
    ///  		include the value you received for NextToken in the first call, to receive
    ///  		the next 1000 results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDashboardsPaginator<Result>(
        _ input: ListDashboardsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDashboardsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDashboards,
            inputKey: \ListDashboardsInput.nextToken,
            outputKey: \ListDashboardsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDashboardsPaginator(
        _ input: ListDashboardsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDashboardsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDashboards,
            inputKey: \ListDashboardsInput.nextToken,
            outputKey: \ListDashboardsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of metric streams in this account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMetricStreamsPaginator<Result>(
        _ input: ListMetricStreamsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMetricStreamsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listMetricStreams,
            inputKey: \ListMetricStreamsInput.nextToken,
            outputKey: \ListMetricStreamsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMetricStreamsPaginator(
        _ input: ListMetricStreamsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMetricStreamsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listMetricStreams,
            inputKey: \ListMetricStreamsInput.nextToken,
            outputKey: \ListMetricStreamsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the specified metrics. You can use the returned metrics with
    ///  			GetMetricData or
    ///  			GetMetricStatistics to obtain statistical data.
    ///  		       Up to 500 results are returned for any one call. To retrieve additional results,
    ///  			use the returned token with subsequent calls.
    ///  		       After you create a metric, allow up to 15 minutes before the metric appears.
    ///  			You can see statistics about the metric sooner by using GetMetricData or
    ///  			GetMetricStatistics.
    ///  	         ListMetrics doesn't return information about metrics if those metrics haven't
    ///  	reported data in the past two weeks. To retrieve those metrics, use
    ///  		GetMetricData or
    ///  		GetMetricStatistics.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMetricsPaginator<Result>(
        _ input: ListMetricsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMetricsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listMetrics,
            inputKey: \ListMetricsInput.nextToken,
            outputKey: \ListMetricsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMetricsPaginator(
        _ input: ListMetricsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMetricsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listMetrics,
            inputKey: \ListMetricsInput.nextToken,
            outputKey: \ListMetricsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension CloudWatch.DescribeAlarmHistoryInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.DescribeAlarmHistoryInput {
        return .init(
            alarmName: self.alarmName,
            alarmTypes: self.alarmTypes,
            endDate: self.endDate,
            historyItemType: self.historyItemType,
            maxRecords: self.maxRecords,
            nextToken: token,
            scanBy: self.scanBy,
            startDate: self.startDate
        )
    }
}

extension CloudWatch.DescribeAlarmsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.DescribeAlarmsInput {
        return .init(
            actionPrefix: self.actionPrefix,
            alarmNamePrefix: self.alarmNamePrefix,
            alarmNames: self.alarmNames,
            alarmTypes: self.alarmTypes,
            childrenOfAlarmName: self.childrenOfAlarmName,
            maxRecords: self.maxRecords,
            nextToken: token,
            parentsOfAlarmName: self.parentsOfAlarmName,
            stateValue: self.stateValue
        )
    }
}

extension CloudWatch.DescribeInsightRulesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.DescribeInsightRulesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CloudWatch.GetMetricDataInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.GetMetricDataInput {
        return .init(
            endTime: self.endTime,
            labelOptions: self.labelOptions,
            maxDatapoints: self.maxDatapoints,
            metricDataQueries: self.metricDataQueries,
            nextToken: token,
            scanBy: self.scanBy,
            startTime: self.startTime
        )
    }
}

extension CloudWatch.ListDashboardsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.ListDashboardsInput {
        return .init(
            dashboardNamePrefix: self.dashboardNamePrefix,
            nextToken: token
        )
    }
}

extension CloudWatch.ListMetricStreamsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.ListMetricStreamsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CloudWatch.ListMetricsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CloudWatch.ListMetricsInput {
        return .init(
            dimensions: self.dimensions,
            metricName: self.metricName,
            namespace: self.namespace,
            nextToken: token,
            recentlyActive: self.recentlyActive
        )
    }
}
