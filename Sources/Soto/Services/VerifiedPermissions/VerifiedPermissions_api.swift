//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS VerifiedPermissions service.
///
/// Amazon Verified Permissions is a permissions management service from Amazon Web Services. You can use Verified Permissions to manage permissions for your application, and authorize user access based on those permissions. Using Verified Permissions, application developers can grant access based on information about the users, resources, and requested actions. You can also evaluate additional information like group membership, attributes of the resources, and session context, such as time of request and IP addresses. Verified Permissions manages these permissions by letting you create and store authorization policies for your applications, such as consumer-facing web sites and enterprise business systems. Verified Permissions uses Cedar as the policy language to express your permission requirements. Cedar supports both role-based access control (RBAC) and attribute-based access control (ABAC) authorization models. For more information about configuring, administering, and using Amazon Verified Permissions in your applications, see the Amazon Verified Permissions User Guide. For more information about the Cedar policy language, see the Cedar Policy Language Guide.  When you write Cedar policies that reference principals, resources and actions, you can define the unique identifiers used for each of those elements. We strongly recommend that you follow these best practices:    Use values like universally unique identifiers (UUIDs) for all principal and resource identifiers.  For example, if user jane leaves the company, and you later let someone else use the name jane, then that new user automatically gets access to everything granted by policies that still reference User::"jane". Cedar can’t distinguish between the new user and the old. This applies to both principal and resource identifiers. Always use identifiers that are guaranteed unique and never reused to ensure that you don’t unintentionally grant access because of the presence of an old identifier in a policy. Where you use a UUID for an entity, we recommend that you follow it with the // comment specifier and the ‘friendly’ name of your entity. This helps to make your policies easier to understand. For example: principal == User::"a1b2c3d4-e5f6-a1b2-c3d4-EXAMPLE11111", // alice    Do not include personally identifying, confidential, or sensitive information as part of the unique identifier for your principals or resources. These identifiers are included in log entries shared in CloudTrail trails.    Several operations return structures that appear similar, but have different purposes. As new functionality is added to the product, the structure used in a parameter of one operation might need to change in a way that wouldn't make sense for the same parameter in a different operation. To help you understand the purpose of each, the following naming convention is used for the structures:   Parameter type structures that end in Detail are used in Get operations.   Parameter type structures that end in Item are used in List operations.   Parameter type structures that use neither suffix are used in the mutating (create and update) operations.
public struct VerifiedPermissions: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the VerifiedPermissions client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "VerifiedPermissions",
            serviceName: "VerifiedPermissions",
            serviceIdentifier: "verifiedpermissions",
            serviceProtocol: .json(version: "1.0"),
            apiVersion: "2021-12-01",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: VerifiedPermissionsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "verifiedpermissions-fips.ca-central-1.amazonaws.com",
            "ca-west-1": "verifiedpermissions-fips.ca-west-1.amazonaws.com",
            "us-east-1": "verifiedpermissions-fips.us-east-1.amazonaws.com",
            "us-east-2": "verifiedpermissions-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "verifiedpermissions-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "verifiedpermissions-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "verifiedpermissions-fips.us-west-1.amazonaws.com",
            "us-west-2": "verifiedpermissions-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Retrieves information about a group (batch) of policies.  The BatchGetPolicy operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:GetPolicy in their IAM policies.
    @Sendable
    @inlinable
    public func batchGetPolicy(_ input: BatchGetPolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetPolicyOutput {
        try await self.client.execute(
            operation: "BatchGetPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a group (batch) of policies.  The BatchGetPolicy operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:GetPolicy in their IAM policies.
    ///
    /// Parameters:
    ///   - requests: An array of up to 100 policies you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetPolicy(
        requests: [BatchGetPolicyInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetPolicyOutput {
        let input = BatchGetPolicyInput(
            requests: requests
        )
        return try await self.batchGetPolicy(input, logger: logger)
    }

    /// Makes a series of decisions about multiple authorization requests for one principal or resource. Each request contains the equivalent content of an IsAuthorized request: principal, action, resource, and context. Either the principal or the resource parameter must be identical across all requests. For example, Verified Permissions won't evaluate a pair of requests where bob views photo1 and alice views photo2. Authorization of bob to view photo1 and photo2, or bob and alice to view photo1, are valid batches.  The request is evaluated against all policies in the specified policy store that match the entities that you declare. The result of the decisions is a series of Allow or Deny responses, along with the IDs of the policies that produced each decision. The entities of a BatchIsAuthorized API request can contain up to 100 principals and up to 100 resources. The requests of a BatchIsAuthorized API request can contain up to 30 requests.  The BatchIsAuthorized operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:IsAuthorized in their IAM policies.
    @Sendable
    @inlinable
    public func batchIsAuthorized(_ input: BatchIsAuthorizedInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchIsAuthorizedOutput {
        try await self.client.execute(
            operation: "BatchIsAuthorized", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes a series of decisions about multiple authorization requests for one principal or resource. Each request contains the equivalent content of an IsAuthorized request: principal, action, resource, and context. Either the principal or the resource parameter must be identical across all requests. For example, Verified Permissions won't evaluate a pair of requests where bob views photo1 and alice views photo2. Authorization of bob to view photo1 and photo2, or bob and alice to view photo1, are valid batches.  The request is evaluated against all policies in the specified policy store that match the entities that you declare. The result of the decisions is a series of Allow or Deny responses, along with the IDs of the policies that produced each decision. The entities of a BatchIsAuthorized API request can contain up to 100 principals and up to 100 resources. The requests of a BatchIsAuthorized API request can contain up to 30 requests.  The BatchIsAuthorized operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:IsAuthorized in their IAM policies.
    ///
    /// Parameters:
    ///   - entities: Specifies the list of resources and principals and their associated attributes that Verified Permissions can examine when evaluating the policies.   You can include only principal and resource entities in this parameter; you can't include actions. You must specify actions in the schema.
    ///   - policyStoreId: Specifies the ID of the policy store. Policies in this policy store will be used to make the authorization decisions for the input.
    ///   - requests: An array of up to 30 requests that you want Verified Permissions to evaluate.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchIsAuthorized(
        entities: EntitiesDefinition? = nil,
        policyStoreId: String,
        requests: [BatchIsAuthorizedInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchIsAuthorizedOutput {
        let input = BatchIsAuthorizedInput(
            entities: entities, 
            policyStoreId: policyStoreId, 
            requests: requests
        )
        return try await self.batchIsAuthorized(input, logger: logger)
    }

    /// Makes a series of decisions about multiple authorization requests for one token. The principal in this request comes from an external identity source in the form of an identity or access token, formatted as a JSON web token (JWT). The information in the parameters can also define additional context that Verified Permissions can include in the evaluations. The request is evaluated against all policies in the specified policy store that match the entities that you provide in the entities declaration and in the token. The result of the decisions is a series of Allow or Deny responses, along with the IDs of the policies that produced each decision. The entities of a BatchIsAuthorizedWithToken API request can contain up to 100 resources and up to 99 user groups. The requests of a BatchIsAuthorizedWithToken API request can contain up to 30 requests.  The BatchIsAuthorizedWithToken operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:IsAuthorizedWithToken in their IAM policies.
    @Sendable
    @inlinable
    public func batchIsAuthorizedWithToken(_ input: BatchIsAuthorizedWithTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchIsAuthorizedWithTokenOutput {
        try await self.client.execute(
            operation: "BatchIsAuthorizedWithToken", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes a series of decisions about multiple authorization requests for one token. The principal in this request comes from an external identity source in the form of an identity or access token, formatted as a JSON web token (JWT). The information in the parameters can also define additional context that Verified Permissions can include in the evaluations. The request is evaluated against all policies in the specified policy store that match the entities that you provide in the entities declaration and in the token. The result of the decisions is a series of Allow or Deny responses, along with the IDs of the policies that produced each decision. The entities of a BatchIsAuthorizedWithToken API request can contain up to 100 resources and up to 99 user groups. The requests of a BatchIsAuthorizedWithToken API request can contain up to 30 requests.  The BatchIsAuthorizedWithToken operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals, include the permission verifiedpermissions:IsAuthorizedWithToken in their IAM policies.
    ///
    /// Parameters:
    ///   - accessToken: Specifies an access token for the principal that you want to authorize in each request. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an access token. Verified Permissions returns an error if the token_use claim in the submitted token isn't access.
    ///   - entities: Specifies the list of resources and their associated attributes that Verified Permissions can examine when evaluating the policies.   You can't include principals in this parameter, only resource and action entities. This parameter can't include any entities of a type that matches the user or group entity types that you defined in your identity source.   The BatchIsAuthorizedWithToken operation takes principal attributes from  only  the identityToken or accessToken passed to the operation.   For action entities, you can include only their Identifier and EntityType.
    ///   - identityToken: Specifies an identity (ID) token for the principal that you want to authorize in each request. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an ID token. Verified Permissions returns an error if the token_use claim in the submitted token isn't id.
    ///   - policyStoreId: Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    ///   - requests: An array of up to 30 requests that you want Verified Permissions to evaluate.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchIsAuthorizedWithToken(
        accessToken: String? = nil,
        entities: EntitiesDefinition? = nil,
        identityToken: String? = nil,
        policyStoreId: String,
        requests: [BatchIsAuthorizedWithTokenInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchIsAuthorizedWithTokenOutput {
        let input = BatchIsAuthorizedWithTokenInput(
            accessToken: accessToken, 
            entities: entities, 
            identityToken: identityToken, 
            policyStoreId: policyStoreId, 
            requests: requests
        )
        return try await self.batchIsAuthorizedWithToken(input, logger: logger)
    }

    /// Adds an identity source to a policy store–an Amazon Cognito user pool or OpenID Connect (OIDC) identity provider (IdP).  After you create an identity source, you can use the identities provided by the IdP as proxies for the principal in authorization queries that use the IsAuthorizedWithToken or BatchIsAuthorizedWithToken API operations. These identities take the form of tokens that contain claims about the user, such as IDs, attributes and group memberships. Identity sources provide identity (ID) tokens and access tokens. Verified Permissions derives information about your user and session from token claims. Access tokens provide action context to your policies, and ID tokens provide principal Attributes.  Tokens from an identity source user continue to be usable until they expire.  Token revocation and resource deletion have no effect on the validity of a token in your policy store   To reference a user from this identity source in your Cedar policies, refer to the following syntax examples.   Amazon Cognito user pool: Namespace::[Entity type]::[User pool ID]|[user principal attribute], for example MyCorp::User::us-east-1_EXAMPLE|a1b2c3d4-5678-90ab-cdef-EXAMPLE11111.   OpenID Connect (OIDC) provider: Namespace::[Entity type]::[entityIdPrefix]|[user principal attribute], for example MyCorp::User::MyOIDCProvider|a1b2c3d4-5678-90ab-cdef-EXAMPLE22222.     Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func createIdentitySource(_ input: CreateIdentitySourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIdentitySourceOutput {
        try await self.client.execute(
            operation: "CreateIdentitySource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds an identity source to a policy store–an Amazon Cognito user pool or OpenID Connect (OIDC) identity provider (IdP).  After you create an identity source, you can use the identities provided by the IdP as proxies for the principal in authorization queries that use the IsAuthorizedWithToken or BatchIsAuthorizedWithToken API operations. These identities take the form of tokens that contain claims about the user, such as IDs, attributes and group memberships. Identity sources provide identity (ID) tokens and access tokens. Verified Permissions derives information about your user and session from token claims. Access tokens provide action context to your policies, and ID tokens provide principal Attributes.  Tokens from an identity source user continue to be usable until they expire.  Token revocation and resource deletion have no effect on the validity of a token in your policy store   To reference a user from this identity source in your Cedar policies, refer to the following syntax examples.   Amazon Cognito user pool: Namespace::[Entity type]::[User pool ID]|[user principal attribute], for example MyCorp::User::us-east-1_EXAMPLE|a1b2c3d4-5678-90ab-cdef-EXAMPLE11111.   OpenID Connect (OIDC) provider: Namespace::[Entity type]::[entityIdPrefix]|[user principal attribute], for example MyCorp::User::MyOIDCProvider|a1b2c3d4-5678-90ab-cdef-EXAMPLE22222.     Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of  the value of ClientToken.
    ///   - configuration: Specifies the details required to communicate with the identity provider (IdP) associated with this identity source.
    ///   - policyStoreId: Specifies the ID of the policy store in which you want to store this identity source. Only policies and requests made using this policy store can reference identities from the identity provider configured in the new identity source.
    ///   - principalEntityType: Specifies the namespace and data type of the principals generated for identities authenticated by the new identity source.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIdentitySource(
        clientToken: String? = CreateIdentitySourceInput.idempotencyToken(),
        configuration: Configuration,
        policyStoreId: String,
        principalEntityType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIdentitySourceOutput {
        let input = CreateIdentitySourceInput(
            clientToken: clientToken, 
            configuration: configuration, 
            policyStoreId: policyStoreId, 
            principalEntityType: principalEntityType
        )
        return try await self.createIdentitySource(input, logger: logger)
    }

    /// Creates a Cedar policy and saves it in the specified policy store. You can create either a static policy or a policy linked to a policy template.   To create a static policy, provide the Cedar policy text in the StaticPolicy section of the PolicyDefinition.   To create a policy that is dynamically linked to a policy template, specify the policy template ID and the principal and resource to associate with this policy in the templateLinked section of the PolicyDefinition. If the policy template is ever updated, any policies linked to the policy template automatically use the updated template.    Creating a policy causes it to be validated against the schema in the policy store. If the policy doesn't pass validation, the operation fails and the policy isn't stored.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func createPolicy(_ input: CreatePolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyOutput {
        try await self.client.execute(
            operation: "CreatePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Cedar policy and saves it in the specified policy store. You can create either a static policy or a policy linked to a policy template.   To create a static policy, provide the Cedar policy text in the StaticPolicy section of the PolicyDefinition.   To create a policy that is dynamically linked to a policy template, specify the policy template ID and the principal and resource to associate with this policy in the templateLinked section of the PolicyDefinition. If the policy template is ever updated, any policies linked to the policy template automatically use the updated template.    Creating a policy causes it to be validated against the schema in the policy store. If the policy doesn't pass validation, the operation fails and the policy isn't stored.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of  the value of ClientToken.
    ///   - definition: A structure that specifies the policy type and content to use for the new policy. You must include either a static or a templateLinked element. The policy content must be written in the Cedar policy language.
    ///   - policyStoreId: Specifies the PolicyStoreId of the policy store you want to store the policy in.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicy(
        clientToken: String? = CreatePolicyInput.idempotencyToken(),
        definition: PolicyDefinition,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyOutput {
        let input = CreatePolicyInput(
            clientToken: clientToken, 
            definition: definition, 
            policyStoreId: policyStoreId
        )
        return try await self.createPolicy(input, logger: logger)
    }

    /// Creates a policy store. A policy store is a container for policy resources.  Although Cedar supports multiple namespaces, Verified Permissions currently supports only one namespace per policy store.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func createPolicyStore(_ input: CreatePolicyStoreInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyStoreOutput {
        try await self.client.execute(
            operation: "CreatePolicyStore", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a policy store. A policy store is a container for policy resources.  Although Cedar supports multiple namespaces, Verified Permissions currently supports only one namespace per policy store.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of  the value of ClientToken.
    ///   - deletionProtection: Specifies whether the policy store can be deleted. If enabled, the policy store can't be deleted. The default state is DISABLED.
    ///   - description: Descriptive text that you can provide to help with identification  of the current policy store.
    ///   - validationSettings: Specifies the validation setting for this policy store. Currently, the only valid and required value is Mode.  We recommend that you turn on STRICT mode only after you define a schema. If a schema doesn't exist, then STRICT mode causes any policy to fail validation, and Verified Permissions rejects the policy. You can turn off validation by using the UpdatePolicyStore. Then, when you have a schema defined, use UpdatePolicyStore again to turn validation back on.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicyStore(
        clientToken: String? = CreatePolicyStoreInput.idempotencyToken(),
        deletionProtection: DeletionProtection? = nil,
        description: String? = nil,
        validationSettings: ValidationSettings,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyStoreOutput {
        let input = CreatePolicyStoreInput(
            clientToken: clientToken, 
            deletionProtection: deletionProtection, 
            description: description, 
            validationSettings: validationSettings
        )
        return try await self.createPolicyStore(input, logger: logger)
    }

    /// Creates a policy template. A template can use placeholders for the principal and resource. A template must be instantiated into a policy by associating it with specific principals and resources to use for the placeholders. That instantiated policy can then be considered in authorization decisions. The instantiated policy works identically to any other policy, except that it is dynamically linked to the template. If the template changes, then any policies that are linked to that template are immediately updated as well.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func createPolicyTemplate(_ input: CreatePolicyTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyTemplateOutput {
        try await self.client.execute(
            operation: "CreatePolicyTemplate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a policy template. A template can use placeholders for the principal and resource. A template must be instantiated into a policy by associating it with specific principals and resources to use for the placeholders. That instantiated policy can then be considered in authorization decisions. The instantiated policy works identically to any other policy, except that it is dynamically linked to the template. If the template changes, then any policies that are linked to that template are immediately updated as well.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of  the value of ClientToken.
    ///   - description: Specifies a description for the policy template.
    ///   - policyStoreId: The ID of the policy store in which to create the policy template.
    ///   - statement: Specifies the content that you want to use for the new policy template, written in the Cedar policy language.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicyTemplate(
        clientToken: String? = CreatePolicyTemplateInput.idempotencyToken(),
        description: String? = nil,
        policyStoreId: String,
        statement: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyTemplateOutput {
        let input = CreatePolicyTemplateInput(
            clientToken: clientToken, 
            description: description, 
            policyStoreId: policyStoreId, 
            statement: statement
        )
        return try await self.createPolicyTemplate(input, logger: logger)
    }

    /// Deletes an identity source that references an identity provider (IdP) such as Amazon Cognito. After you delete the identity source, you can no longer use tokens for identities from that identity source to represent principals in authorization queries made using IsAuthorizedWithToken. operations.
    @Sendable
    @inlinable
    public func deleteIdentitySource(_ input: DeleteIdentitySourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIdentitySourceOutput {
        try await self.client.execute(
            operation: "DeleteIdentitySource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an identity source that references an identity provider (IdP) such as Amazon Cognito. After you delete the identity source, you can no longer use tokens for identities from that identity source to represent principals in authorization queries made using IsAuthorizedWithToken. operations.
    ///
    /// Parameters:
    ///   - identitySourceId: Specifies the ID of the identity source that you want to delete.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the identity source that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIdentitySource(
        identitySourceId: String,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIdentitySourceOutput {
        let input = DeleteIdentitySourceInput(
            identitySourceId: identitySourceId, 
            policyStoreId: policyStoreId
        )
        return try await self.deleteIdentitySource(input, logger: logger)
    }

    /// Deletes the specified policy from the policy store. This operation is idempotent; if you specify a policy that doesn't  exist, the request response returns a successful HTTP 200 status code.
    @Sendable
    @inlinable
    public func deletePolicy(_ input: DeletePolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyOutput {
        try await self.client.execute(
            operation: "DeletePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified policy from the policy store. This operation is idempotent; if you specify a policy that doesn't  exist, the request response returns a successful HTTP 200 status code.
    ///
    /// Parameters:
    ///   - policyId: Specifies the ID of the policy that you want to delete.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicy(
        policyId: String,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyOutput {
        let input = DeletePolicyInput(
            policyId: policyId, 
            policyStoreId: policyStoreId
        )
        return try await self.deletePolicy(input, logger: logger)
    }

    /// Deletes the specified policy store. This operation is idempotent. If you specify a policy store that does not exist, the request response will still return a successful HTTP 200 status code.
    @Sendable
    @inlinable
    public func deletePolicyStore(_ input: DeletePolicyStoreInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyStoreOutput {
        try await self.client.execute(
            operation: "DeletePolicyStore", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified policy store. This operation is idempotent. If you specify a policy store that does not exist, the request response will still return a successful HTTP 200 status code.
    ///
    /// Parameters:
    ///   - policyStoreId: Specifies the ID of the policy store that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicyStore(
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyStoreOutput {
        let input = DeletePolicyStoreInput(
            policyStoreId: policyStoreId
        )
        return try await self.deletePolicyStore(input, logger: logger)
    }

    /// Deletes the specified policy template from the policy store.  This operation also deletes any policies that were created from the specified policy template. Those policies are immediately removed from all future API responses, and are asynchronously deleted from the policy store.
    @Sendable
    @inlinable
    public func deletePolicyTemplate(_ input: DeletePolicyTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyTemplateOutput {
        try await self.client.execute(
            operation: "DeletePolicyTemplate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified policy template from the policy store.  This operation also deletes any policies that were created from the specified policy template. Those policies are immediately removed from all future API responses, and are asynchronously deleted from the policy store.
    ///
    /// Parameters:
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy template that you want to delete.
    ///   - policyTemplateId: Specifies the ID of the policy template that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicyTemplate(
        policyStoreId: String,
        policyTemplateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyTemplateOutput {
        let input = DeletePolicyTemplateInput(
            policyStoreId: policyStoreId, 
            policyTemplateId: policyTemplateId
        )
        return try await self.deletePolicyTemplate(input, logger: logger)
    }

    /// Retrieves the details about the specified identity source.
    @Sendable
    @inlinable
    public func getIdentitySource(_ input: GetIdentitySourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIdentitySourceOutput {
        try await self.client.execute(
            operation: "GetIdentitySource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details about the specified identity source.
    ///
    /// Parameters:
    ///   - identitySourceId: Specifies the ID of the identity source you want information about.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the identity source you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIdentitySource(
        identitySourceId: String,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIdentitySourceOutput {
        let input = GetIdentitySourceInput(
            identitySourceId: identitySourceId, 
            policyStoreId: policyStoreId
        )
        return try await self.getIdentitySource(input, logger: logger)
    }

    /// Retrieves information about the specified policy.
    @Sendable
    @inlinable
    public func getPolicy(_ input: GetPolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyOutput {
        try await self.client.execute(
            operation: "GetPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified policy.
    ///
    /// Parameters:
    ///   - policyId: Specifies the ID of the policy you want information about.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy that you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicy(
        policyId: String,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyOutput {
        let input = GetPolicyInput(
            policyId: policyId, 
            policyStoreId: policyStoreId
        )
        return try await self.getPolicy(input, logger: logger)
    }

    /// Retrieves details about a policy store.
    @Sendable
    @inlinable
    public func getPolicyStore(_ input: GetPolicyStoreInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyStoreOutput {
        try await self.client.execute(
            operation: "GetPolicyStore", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves details about a policy store.
    ///
    /// Parameters:
    ///   - policyStoreId: Specifies the ID of the policy store that you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicyStore(
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyStoreOutput {
        let input = GetPolicyStoreInput(
            policyStoreId: policyStoreId
        )
        return try await self.getPolicyStore(input, logger: logger)
    }

    /// Retrieve the details for the specified policy template in the specified policy store.
    @Sendable
    @inlinable
    public func getPolicyTemplate(_ input: GetPolicyTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyTemplateOutput {
        try await self.client.execute(
            operation: "GetPolicyTemplate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the details for the specified policy template in the specified policy store.
    ///
    /// Parameters:
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy template that you want information about.
    ///   - policyTemplateId: Specifies the ID of the policy template that you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicyTemplate(
        policyStoreId: String,
        policyTemplateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyTemplateOutput {
        let input = GetPolicyTemplateInput(
            policyStoreId: policyStoreId, 
            policyTemplateId: policyTemplateId
        )
        return try await self.getPolicyTemplate(input, logger: logger)
    }

    /// Retrieve the details for the specified schema in the specified policy store.
    @Sendable
    @inlinable
    public func getSchema(_ input: GetSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaOutput {
        try await self.client.execute(
            operation: "GetSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the details for the specified schema in the specified policy store.
    ///
    /// Parameters:
    ///   - policyStoreId: Specifies the ID of the policy store that contains the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchema(
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaOutput {
        let input = GetSchemaInput(
            policyStoreId: policyStoreId
        )
        return try await self.getSchema(input, logger: logger)
    }

    /// Makes an authorization decision about a service request described in the parameters. The information in the parameters can also define additional context that Verified Permissions can include in the evaluation. The request is evaluated against all matching policies in the specified policy store. The result of the decision is either Allow or Deny, along with a list of the policies that resulted in the decision.
    @Sendable
    @inlinable
    public func isAuthorized(_ input: IsAuthorizedInput, logger: Logger = AWSClient.loggingDisabled) async throws -> IsAuthorizedOutput {
        try await self.client.execute(
            operation: "IsAuthorized", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes an authorization decision about a service request described in the parameters. The information in the parameters can also define additional context that Verified Permissions can include in the evaluation. The request is evaluated against all matching policies in the specified policy store. The result of the decision is either Allow or Deny, along with a list of the policies that resulted in the decision.
    ///
    /// Parameters:
    ///   - action: Specifies the requested action to be authorized. For example, is the principal authorized to perform this action on the resource?
    ///   - context: Specifies additional context that can be used to make more granular authorization decisions.
    ///   - entities: Specifies the list of resources and principals and their associated attributes that Verified Permissions can examine when evaluating the policies.   You can include only principal and resource entities in this parameter; you can't include actions. You must specify actions in the schema.
    ///   - policyStoreId: Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    ///   - principal: Specifies the principal for which the authorization decision is to be made.
    ///   - resource: Specifies the resource for which the authorization decision is to be made.
    ///   - logger: Logger use during operation
    @inlinable
    public func isAuthorized(
        action: ActionIdentifier? = nil,
        context: ContextDefinition? = nil,
        entities: EntitiesDefinition? = nil,
        policyStoreId: String,
        principal: EntityIdentifier? = nil,
        resource: EntityIdentifier? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> IsAuthorizedOutput {
        let input = IsAuthorizedInput(
            action: action, 
            context: context, 
            entities: entities, 
            policyStoreId: policyStoreId, 
            principal: principal, 
            resource: resource
        )
        return try await self.isAuthorized(input, logger: logger)
    }

    /// Makes an authorization decision about a service request described in the parameters. The principal in this request comes from an external identity source in the form of an identity token formatted as a JSON web token (JWT). The information in the parameters can also define additional context that Verified Permissions can include in the evaluation. The request is evaluated against all matching policies in the specified policy store. The result of the decision is either Allow or Deny, along with a list of the policies that resulted in the decision. Verified Permissions validates each token that is specified in a request by checking its expiration date and its signature.  Tokens from an identity source user continue to be usable until they expire.  Token revocation and resource deletion have no effect on the validity of a token in your policy store
    @Sendable
    @inlinable
    public func isAuthorizedWithToken(_ input: IsAuthorizedWithTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> IsAuthorizedWithTokenOutput {
        try await self.client.execute(
            operation: "IsAuthorizedWithToken", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes an authorization decision about a service request described in the parameters. The principal in this request comes from an external identity source in the form of an identity token formatted as a JSON web token (JWT). The information in the parameters can also define additional context that Verified Permissions can include in the evaluation. The request is evaluated against all matching policies in the specified policy store. The result of the decision is either Allow or Deny, along with a list of the policies that resulted in the decision. Verified Permissions validates each token that is specified in a request by checking its expiration date and its signature.  Tokens from an identity source user continue to be usable until they expire.  Token revocation and resource deletion have no effect on the validity of a token in your policy store
    ///
    /// Parameters:
    ///   - accessToken: Specifies an access token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an access token. Verified Permissions returns an error if the token_use claim in the submitted token isn't access.
    ///   - action: Specifies the requested action to be authorized. Is the specified principal authorized to perform this action on the specified resource.
    ///   - context: Specifies additional context that can be used to make more granular authorization decisions.
    ///   - entities: Specifies the list of resources and their associated attributes that Verified Permissions can examine when evaluating the policies.   You can't include principals in this parameter, only resource and action entities. This parameter can't include any entities of a type that matches the user or group entity types that you defined in your identity source.   The IsAuthorizedWithToken operation takes principal attributes from  only  the identityToken or accessToken passed to the operation.   For action entities, you can include only their Identifier and EntityType.
    ///   - identityToken: Specifies an identity token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an ID token. Verified Permissions returns an error if the token_use claim in the submitted token isn't id.
    ///   - policyStoreId: Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    ///   - resource: Specifies the resource for which the authorization decision is made. For example, is the principal allowed to perform the action on the resource?
    ///   - logger: Logger use during operation
    @inlinable
    public func isAuthorizedWithToken(
        accessToken: String? = nil,
        action: ActionIdentifier? = nil,
        context: ContextDefinition? = nil,
        entities: EntitiesDefinition? = nil,
        identityToken: String? = nil,
        policyStoreId: String,
        resource: EntityIdentifier? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> IsAuthorizedWithTokenOutput {
        let input = IsAuthorizedWithTokenInput(
            accessToken: accessToken, 
            action: action, 
            context: context, 
            entities: entities, 
            identityToken: identityToken, 
            policyStoreId: policyStoreId, 
            resource: resource
        )
        return try await self.isAuthorizedWithToken(input, logger: logger)
    }

    /// Returns a paginated list of all of the identity sources defined in the specified policy store.
    @Sendable
    @inlinable
    public func listIdentitySources(_ input: ListIdentitySourcesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIdentitySourcesOutput {
        try await self.client.execute(
            operation: "ListIdentitySources", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of all of the identity sources defined in the specified policy store.
    ///
    /// Parameters:
    ///   - filters: Specifies characteristics of an identity source that you can use to limit the output to matching identity sources.
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 identity sources per response. You can specify a maximum of 50 identity sources per response.
    ///   - nextToken: Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the identity sources that you want to list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIdentitySources(
        filters: [IdentitySourceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIdentitySourcesOutput {
        let input = ListIdentitySourcesInput(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyStoreId: policyStoreId
        )
        return try await self.listIdentitySources(input, logger: logger)
    }

    /// Returns a paginated list of all policies stored in the specified policy store.
    @Sendable
    @inlinable
    public func listPolicies(_ input: ListPoliciesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPoliciesOutput {
        try await self.client.execute(
            operation: "ListPolicies", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of all policies stored in the specified policy store.
    ///
    /// Parameters:
    ///   - filter: Specifies a filter that limits the response to only policies that match the specified criteria. For example, you list only the policies that reference a specified principal.
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policies per response. You can specify a maximum of 50 policies per response.
    ///   - nextToken: Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
    ///   - policyStoreId: Specifies the ID of the policy store you want to list policies from.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicies(
        filter: PolicyFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPoliciesOutput {
        let input = ListPoliciesInput(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyStoreId: policyStoreId
        )
        return try await self.listPolicies(input, logger: logger)
    }

    /// Returns a paginated list of all policy stores in the calling Amazon Web Services account.
    @Sendable
    @inlinable
    public func listPolicyStores(_ input: ListPolicyStoresInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyStoresOutput {
        try await self.client.execute(
            operation: "ListPolicyStores", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of all policy stores in the calling Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy stores per response. You can specify a maximum of 50 policy stores per response.
    ///   - nextToken: Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyStores(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyStoresOutput {
        let input = ListPolicyStoresInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPolicyStores(input, logger: logger)
    }

    /// Returns a paginated list of all policy templates in the specified policy store.
    @Sendable
    @inlinable
    public func listPolicyTemplates(_ input: ListPolicyTemplatesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyTemplatesOutput {
        try await self.client.execute(
            operation: "ListPolicyTemplates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of all policy templates in the specified policy store.
    ///
    /// Parameters:
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy templates per response. You can specify a maximum of 50 policy templates per response.
    ///   - nextToken: Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy templates you want to list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyTemplatesOutput {
        let input = ListPolicyTemplatesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyStoreId: policyStoreId
        )
        return try await self.listPolicyTemplates(input, logger: logger)
    }

    /// Creates or updates the policy schema in the specified policy store. The schema is used to validate any Cedar policies and policy templates submitted to the policy store. Any changes to the schema validate only policies and templates submitted after the schema change. Existing policies and templates are not re-evaluated against the changed schema. If you later update a policy, then it is evaluated against the new schema at that time.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func putSchema(_ input: PutSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> PutSchemaOutput {
        try await self.client.execute(
            operation: "PutSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the policy schema in the specified policy store. The schema is used to validate any Cedar policies and policy templates submitted to the policy store. Any changes to the schema validate only policies and templates submitted after the schema change. Existing policies and templates are not re-evaluated against the changed schema. If you later update a policy, then it is evaluated against the new schema at that time.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - definition: Specifies the definition of the schema to be stored. The schema definition must be written in Cedar schema JSON.
    ///   - policyStoreId: Specifies the ID of the policy store in which to place the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func putSchema(
        definition: SchemaDefinition,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutSchemaOutput {
        let input = PutSchemaInput(
            definition: definition, 
            policyStoreId: policyStoreId
        )
        return try await self.putSchema(input, logger: logger)
    }

    /// Updates the specified identity source to use a new identity provider (IdP), or to change the mapping of identities from the IdP to a different principal entity type.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func updateIdentitySource(_ input: UpdateIdentitySourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIdentitySourceOutput {
        try await self.client.execute(
            operation: "UpdateIdentitySource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified identity source to use a new identity provider (IdP), or to change the mapping of identities from the IdP to a different principal entity type.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - identitySourceId: Specifies the ID of the identity source that you want to update.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the identity source that you want to update.
    ///   - principalEntityType: Specifies the data type of principals generated for identities authenticated by the identity source.
    ///   - updateConfiguration: Specifies the details required to communicate with the identity provider (IdP) associated with this identity source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIdentitySource(
        identitySourceId: String,
        policyStoreId: String,
        principalEntityType: String? = nil,
        updateConfiguration: UpdateConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIdentitySourceOutput {
        let input = UpdateIdentitySourceInput(
            identitySourceId: identitySourceId, 
            policyStoreId: policyStoreId, 
            principalEntityType: principalEntityType, 
            updateConfiguration: updateConfiguration
        )
        return try await self.updateIdentitySource(input, logger: logger)
    }

    /// Modifies a Cedar static policy in the specified policy store. You can change only certain elements of the UpdatePolicyDefinition parameter. You can directly update only static policies. To change a template-linked policy, you must update the template instead, using UpdatePolicyTemplate.    If policy validation is enabled in the policy store, then updating a static policy causes Verified Permissions to validate the policy against the schema in the policy store. If the updated static policy doesn't pass validation, the operation fails and the update isn't stored.   When you edit a static policy, you can change only certain elements of a static policy:   The action referenced by the policy.    A condition clause, such as when and unless.    You can't change these elements of a static policy:    Changing a policy from a static policy to a template-linked policy.    Changing the effect of a static policy from permit or forbid.    The principal referenced by a static policy.    The resource referenced by a static policy.      To update a template-linked policy, you must update the template instead.      Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func updatePolicy(_ input: UpdatePolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePolicyOutput {
        try await self.client.execute(
            operation: "UpdatePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies a Cedar static policy in the specified policy store. You can change only certain elements of the UpdatePolicyDefinition parameter. You can directly update only static policies. To change a template-linked policy, you must update the template instead, using UpdatePolicyTemplate.    If policy validation is enabled in the policy store, then updating a static policy causes Verified Permissions to validate the policy against the schema in the policy store. If the updated static policy doesn't pass validation, the operation fails and the update isn't stored.   When you edit a static policy, you can change only certain elements of a static policy:   The action referenced by the policy.    A condition clause, such as when and unless.    You can't change these elements of a static policy:    Changing a policy from a static policy to a template-linked policy.    Changing the effect of a static policy from permit or forbid.    The principal referenced by a static policy.    The resource referenced by a static policy.      To update a template-linked policy, you must update the template instead.      Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - definition: Specifies the updated policy content that you want to replace on the specified policy. The content must be valid Cedar policy language text. You can change only the following elements from the policy definition:   The action referenced by the policy.   Any conditional clauses, such as when or unless clauses.   You can't change the following elements:   Changing from static to templateLinked.   Changing the effect of the policy from permit or forbid.   The principal referenced by the policy.   The resource referenced by the policy.
    ///   - policyId: Specifies the ID of the policy that you want to update. To find this value, you can use ListPolicies.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy that you want to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePolicy(
        definition: UpdatePolicyDefinition,
        policyId: String,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePolicyOutput {
        let input = UpdatePolicyInput(
            definition: definition, 
            policyId: policyId, 
            policyStoreId: policyStoreId
        )
        return try await self.updatePolicy(input, logger: logger)
    }

    /// Modifies the validation setting for a policy store.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func updatePolicyStore(_ input: UpdatePolicyStoreInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePolicyStoreOutput {
        try await self.client.execute(
            operation: "UpdatePolicyStore", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the validation setting for a policy store.  Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - deletionProtection: Specifies whether the policy store can be deleted. If enabled, the policy store can't be deleted. When you call UpdatePolicyStore, this parameter is unchanged unless explicitly included in the call.
    ///   - description: Descriptive text that you can provide to help with identification  of the current policy store.
    ///   - policyStoreId: Specifies the ID of the policy store that you want to update
    ///   - validationSettings: A structure that defines the validation settings that want to enable for the policy store.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePolicyStore(
        deletionProtection: DeletionProtection? = nil,
        description: String? = nil,
        policyStoreId: String,
        validationSettings: ValidationSettings,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePolicyStoreOutput {
        let input = UpdatePolicyStoreInput(
            deletionProtection: deletionProtection, 
            description: description, 
            policyStoreId: policyStoreId, 
            validationSettings: validationSettings
        )
        return try await self.updatePolicyStore(input, logger: logger)
    }

    /// Updates the specified policy template. You can update only the description and the some elements of the policyBody.   Changes you make to the policy template content are immediately (within the constraints of eventual consistency) reflected in authorization decisions that involve all template-linked policies instantiated from this template.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    @Sendable
    @inlinable
    public func updatePolicyTemplate(_ input: UpdatePolicyTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePolicyTemplateOutput {
        try await self.client.execute(
            operation: "UpdatePolicyTemplate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified policy template. You can update only the description and the some elements of the policyBody.   Changes you make to the policy template content are immediately (within the constraints of eventual consistency) reflected in authorization decisions that involve all template-linked policies instantiated from this template.   Verified Permissions is  eventually consistent . It can take a few seconds for a new or changed element to propagate through the service and be visible in the results of other Verified Permissions operations.
    ///
    /// Parameters:
    ///   - description: Specifies a new description to apply to the policy template.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy template that you want to update.
    ///   - policyTemplateId: Specifies the ID of the policy template that you want to update.
    ///   - statement: Specifies new statement content written in Cedar policy language to replace the current body of the policy template. You can change only the following elements of the policy body:   The action referenced by the policy template.   Any conditional clauses, such as when or unless clauses.   You can't change the following elements:   The effect (permit or forbid) of the policy template.   The principal referenced by the policy template.   The resource referenced by the policy template.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePolicyTemplate(
        description: String? = nil,
        policyStoreId: String,
        policyTemplateId: String,
        statement: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePolicyTemplateOutput {
        let input = UpdatePolicyTemplateInput(
            description: description, 
            policyStoreId: policyStoreId, 
            policyTemplateId: policyTemplateId, 
            statement: statement
        )
        return try await self.updatePolicyTemplate(input, logger: logger)
    }
}

extension VerifiedPermissions {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: VerifiedPermissions, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension VerifiedPermissions {
    /// Return PaginatorSequence for operation ``listIdentitySources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdentitySourcesPaginator(
        _ input: ListIdentitySourcesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIdentitySourcesInput, ListIdentitySourcesOutput> {
        return .init(
            input: input,
            command: self.listIdentitySources,
            inputKey: \ListIdentitySourcesInput.nextToken,
            outputKey: \ListIdentitySourcesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIdentitySources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Specifies characteristics of an identity source that you can use to limit the output to matching identity sources.
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 identity sources per response. You can specify a maximum of 50 identity sources per response.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the identity sources that you want to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdentitySourcesPaginator(
        filters: [IdentitySourceFilter]? = nil,
        maxResults: Int? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIdentitySourcesInput, ListIdentitySourcesOutput> {
        let input = ListIdentitySourcesInput(
            filters: filters, 
            maxResults: maxResults, 
            policyStoreId: policyStoreId
        )
        return self.listIdentitySourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        _ input: ListPoliciesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput> {
        return .init(
            input: input,
            command: self.listPolicies,
            inputKey: \ListPoliciesInput.nextToken,
            outputKey: \ListPoliciesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: Specifies a filter that limits the response to only policies that match the specified criteria. For example, you list only the policies that reference a specified principal.
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policies per response. You can specify a maximum of 50 policies per response.
    ///   - policyStoreId: Specifies the ID of the policy store you want to list policies from.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        filter: PolicyFilter? = nil,
        maxResults: Int? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput> {
        let input = ListPoliciesInput(
            filter: filter, 
            maxResults: maxResults, 
            policyStoreId: policyStoreId
        )
        return self.listPoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyStoresPaginator(
        _ input: ListPolicyStoresInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyStoresInput, ListPolicyStoresOutput> {
        return .init(
            input: input,
            command: self.listPolicyStores,
            inputKey: \ListPolicyStoresInput.nextToken,
            outputKey: \ListPolicyStoresOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyStores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy stores per response. You can specify a maximum of 50 policy stores per response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyStoresPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyStoresInput, ListPolicyStoresOutput> {
        let input = ListPolicyStoresInput(
            maxResults: maxResults
        )
        return self.listPolicyStoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyTemplatesPaginator(
        _ input: ListPolicyTemplatesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyTemplatesInput, ListPolicyTemplatesOutput> {
        return .init(
            input: input,
            command: self.listPolicyTemplates,
            inputKey: \ListPolicyTemplatesInput.nextToken,
            outputKey: \ListPolicyTemplatesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the  NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check  NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy templates per response. You can specify a maximum of 50 policy templates per response.
    ///   - policyStoreId: Specifies the ID of the policy store that contains the policy templates you want to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyTemplatesPaginator(
        maxResults: Int? = nil,
        policyStoreId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyTemplatesInput, ListPolicyTemplatesOutput> {
        let input = ListPolicyTemplatesInput(
            maxResults: maxResults, 
            policyStoreId: policyStoreId
        )
        return self.listPolicyTemplatesPaginator(input, logger: logger)
    }
}

extension VerifiedPermissions.ListIdentitySourcesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> VerifiedPermissions.ListIdentitySourcesInput {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            policyStoreId: self.policyStoreId
        )
    }
}

extension VerifiedPermissions.ListPoliciesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> VerifiedPermissions.ListPoliciesInput {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            policyStoreId: self.policyStoreId
        )
    }
}

extension VerifiedPermissions.ListPolicyStoresInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> VerifiedPermissions.ListPolicyStoresInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension VerifiedPermissions.ListPolicyTemplatesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> VerifiedPermissions.ListPolicyTemplatesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyStoreId: self.policyStoreId
        )
    }
}
