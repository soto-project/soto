//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension GlueDataBrew {
    // MARK: Enums

    public enum CompressionFormat: String, CustomStringConvertible, Codable {
        case brotli = "BROTLI"
        case bzip2 = "BZIP2"
        case deflate = "DEFLATE"
        case gzip = "GZIP"
        case lz4 = "LZ4"
        case lzo = "LZO"
        case snappy = "SNAPPY"
        case zlib = "ZLIB"
        case zstd = "ZSTD"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMode: String, CustomStringConvertible, Codable {
        case sseKms = "SSE-KMS"
        case sseS3 = "SSE-S3"
        public var description: String { return self.rawValue }
    }

    public enum InputFormat: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case excel = "EXCEL"
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable {
        case profile = "PROFILE"
        case recipe = "RECIPE"
        public var description: String { return self.rawValue }
    }

    public enum LogSubscription: String, CustomStringConvertible, Codable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum OrderedBy: String, CustomStringConvertible, Codable {
        case lastModifiedDate = "LAST_MODIFIED_DATE"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable {
        case avro = "AVRO"
        case csv = "CSV"
        case glueparquet = "GLUEPARQUET"
        case json = "JSON"
        case orc = "ORC"
        case parquet = "PARQUET"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable {
        case datetime = "Datetime"
        case number = "Number"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum SampleMode: String, CustomStringConvertible, Codable {
        case customRows = "CUSTOM_ROWS"
        case fullDataset = "FULL_DATASET"
        public var description: String { return self.rawValue }
    }

    public enum SampleType: String, CustomStringConvertible, Codable {
        case firstN = "FIRST_N"
        case lastN = "LAST_N"
        case random = "RANDOM"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable {
        case assigned = "ASSIGNED"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case provisioning = "PROVISIONING"
        case ready = "READY"
        case recycling = "RECYCLING"
        case rotating = "ROTATING"
        case terminated = "TERMINATED"
        case terminating = "TERMINATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable {
        case dataCatalog = "DATA-CATALOG"
        case database = "DATABASE"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchDeleteRecipeVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the recipe whose versions are to be deleted.
        public let name: String
        /// An array of version identifiers, for the recipe versions to be deleted. You can specify numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
        public let recipeVersions: [String]

        public init(name: String, recipeVersions: [String]) {
            self.name = name
            self.recipeVersions = recipeVersions
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.recipeVersions.forEach {
                try validate($0, name: "recipeVersions[]", parent: name, max: 16)
                try validate($0, name: "recipeVersions[]", parent: name, min: 1)
            }
            try self.validate(self.recipeVersions, name: "recipeVersions", parent: name, max: 50)
            try self.validate(self.recipeVersions, name: "recipeVersions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recipeVersions = "RecipeVersions"
        }
    }

    public struct BatchDeleteRecipeVersionResponse: AWSDecodableShape {
        /// Errors, if any, that occurred while attempting to delete the recipe versions.
        public let errors: [RecipeVersionErrorDetail]?
        /// The name of the recipe that was modified.
        public let name: String

        public init(errors: [RecipeVersionErrorDetail]? = nil, name: String) {
            self.errors = errors
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case name = "Name"
        }
    }

    public struct ConditionExpression: AWSEncodableShape & AWSDecodableShape {
        /// A specific condition to apply to a recipe action. For more information, see Recipe structure in the Glue DataBrew Developer Guide.
        public let condition: String
        /// A column to apply this condition to.
        public let targetColumn: String
        /// A value that the condition must evaluate to for the condition to succeed.
        public let value: String?

        public init(condition: String, targetColumn: String, value: String? = nil) {
            self.condition = condition
            self.targetColumn = targetColumn
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 128)
            try self.validate(self.condition, name: "condition", parent: name, min: 1)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^[A-Z\\_]+$")
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, max: 1024)
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case targetColumn = "TargetColumn"
            case value = "Value"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The name of the dataset to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?
        /// Metadata tags to apply to this dataset.
        public let tags: [String: String]?

        public init(format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, name: String, pathOptions: PathOptions? = nil, tags: [String: String]? = nil) {
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.name = name
            self.pathOptions = pathOptions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.input.validate(name: "\(name).input")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.pathOptions?.validate(name: "\(name).pathOptions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case name = "Name"
            case pathOptions = "PathOptions"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateProfileJobRequest: AWSEncodableShape {
        /// The name of the dataset that this job is to act upon.
        public let datasetName: String
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - SSE-KMS - Server-side encryption with KMS-managed keys.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can use when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        public let outputLocation: S3Location
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// Metadata tags to apply to this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(datasetName: String, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputLocation: S3Location, roleArn: String, tags: [String: String]? = nil, timeout: Int? = nil) {
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputLocation = outputLocation
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputLocation = "OutputLocation"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
        }
    }

    public struct CreateProfileJobResponse: AWSDecodableShape {
        /// The name of the job that was created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// The name of an existing dataset to associate this project with.
        public let datasetName: String
        /// A unique name for the new project. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// The name of an existing recipe to associate with the project.
        public let recipeName: String
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed for this request.
        public let roleArn: String
        public let sample: Sample?
        /// Metadata tags to apply to this project.
        public let tags: [String: String]?

        public init(datasetName: String, name: String, recipeName: String, roleArn: String, sample: Sample? = nil, tags: [String: String]? = nil) {
            self.datasetName = datasetName
            self.name = name
            self.recipeName = recipeName
            self.roleArn = roleArn
            self.sample = sample
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeName, name: "recipeName", parent: name, max: 255)
            try self.validate(self.recipeName, name: "recipeName", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.sample?.validate(name: "\(name).sample")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case datasetName = "DatasetName"
            case name = "Name"
            case recipeName = "RecipeName"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case tags = "Tags"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The name of the project that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateRecipeJobRequest: AWSEncodableShape {
        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset that this job processes.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// A unique name for the job. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// Either the name of an existing project, or a combination of a recipe and a dataset to associate with the recipe.
        public let projectName: String?
        public let recipeReference: RecipeReference?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// Metadata tags to apply to this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, roleArn: String, tags: [String: String]? = nil, timeout: Int? = nil) {
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.dataCatalogOutputs?.forEach {
                try $0.validate(name: "\(name).dataCatalogOutputs[]")
            }
            try self.validate(self.dataCatalogOutputs, name: "dataCatalogOutputs", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.recipeReference?.validate(name: "\(name).recipeReference")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
        }
    }

    public struct CreateRecipeJobResponse: AWSDecodableShape {
        /// The name of the job that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateRecipeRequest: AWSEncodableShape {
        /// A description for the recipe.
        public let description: String?
        /// A unique name for the recipe. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// An array containing the steps to be performed by the recipe. Each recipe step consists of one recipe action and (optionally) an array of condition expressions.
        public let steps: [RecipeStep]
        /// Metadata tags to apply to this recipe.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, steps: [RecipeStep], tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.steps = steps
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.steps.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct CreateRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that you created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateScheduleRequest: AWSEncodableShape {
        /// The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String
        /// The name or names of one or more jobs to be run.
        public let jobNames: [String]?
        /// A unique name for the schedule. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
        public let name: String
        /// Metadata tags to apply to this schedule.
        public let tags: [String: String]?

        public init(cronExpression: String, jobNames: [String]? = nil, name: String, tags: [String: String]? = nil) {
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, max: 512)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, min: 1)
            try self.jobNames?.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 240)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
            }
            try self.validate(self.jobNames, name: "jobNames", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was created.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CsvOptions: AWSEncodableShape & AWSDecodableShape {
        /// A single character that specifies the delimiter being used in the CSV file.
        public let delimiter: String?
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public let headerRow: Bool?

        public init(delimiter: String? = nil, headerRow: Bool? = nil) {
            self.delimiter = delimiter
            self.headerRow = headerRow
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case headerRow = "HeaderRow"
        }
    }

    public struct CsvOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// A single character that specifies the delimiter used to create CSV job output.
        public let delimiter: String?

        public init(delimiter: String? = nil) {
            self.delimiter = delimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
        }
    }

    public struct DataCatalogInputDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the Amazon Web Services account that holds the Data Catalog that stores the data.
        public let catalogId: String?
        /// The name of a database in the Data Catalog.
        public let databaseName: String
        /// The name of a database table in the Data Catalog. This table corresponds to a DataBrew dataset.
        public let tableName: String
        /// Represents an Amazon location where DataBrew can store intermediate results.
        public let tempDirectory: S3Location?

        public init(catalogId: String? = nil, databaseName: String, tableName: String, tempDirectory: S3Location? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct DataCatalogOutput: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the AWS account that holds the Data Catalog that stores the data.
        public let catalogId: String?
        /// The name of a database in the Data Catalog.
        public let databaseName: String
        /// Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        public let databaseOptions: DatabaseTableOutputOptions?
        /// A value that, if true, means that any data in the location specified for output is overwritten with new output. Not supported with DatabaseOptions.
        public let overwrite: Bool?
        /// Represents options that specify how and where DataBrew writes the S3 output generated by recipe jobs.
        public let s3Options: S3TableOutputOptions?
        /// The name of a table in the Data Catalog.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, databaseOptions: DatabaseTableOutputOptions? = nil, overwrite: Bool? = nil, s3Options: S3TableOutputOptions? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.databaseOptions = databaseOptions
            self.overwrite = overwrite
            self.s3Options = s3Options
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.databaseOptions?.validate(name: "\(name).databaseOptions")
            try self.s3Options?.validate(name: "\(name).s3Options")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case databaseOptions = "DatabaseOptions"
            case overwrite = "Overwrite"
            case s3Options = "S3Options"
            case tableName = "TableName"
        }
    }

    public struct DatabaseInputDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The table within the target database.
        public let databaseTableName: String
        /// The Glue Connection that stores the connection information for the target database.
        public let glueConnectionName: String
        public let tempDirectory: S3Location?

        public init(databaseTableName: String, glueConnectionName: String, tempDirectory: S3Location? = nil) {
            self.databaseTableName = databaseTableName
            self.glueConnectionName = glueConnectionName
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseTableName, name: "databaseTableName", parent: name, max: 255)
            try self.validate(self.databaseTableName, name: "databaseTableName", parent: name, min: 1)
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, max: 255)
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseTableName = "DatabaseTableName"
            case glueConnectionName = "GlueConnectionName"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct DatabaseTableOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// A prefix for the name of a table DataBrew will create in the database.
        public let tableName: String
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can store intermediate results.
        public let tempDirectory: S3Location?

        public init(tableName: String, tempDirectory: S3Location? = nil) {
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.tempDirectory?.validate(name: "\(name).tempDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case tableName = "TableName"
            case tempDirectory = "TempDirectory"
        }
    }

    public struct Dataset: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the dataset.
        public let accountId: String?
        /// The date and time that the dataset was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the dataset.
        public let createdBy: String?
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        /// A set of options that define how DataBrew interprets the data in the dataset.
        public let formatOptions: FormatOptions?
        /// Information on how DataBrew can find the dataset, in either the Glue Data Catalog or Amazon S3.
        public let input: Input
        /// The Amazon Resource Name (ARN) of the user who last modified the dataset.
        public let lastModifiedBy: String?
        /// The last modification date and time of the dataset.
        public let lastModifiedDate: Date?
        /// The unique name of the dataset.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?
        /// The unique Amazon Resource Name (ARN) for the dataset.
        public let resourceArn: String?
        /// The location of the data for the dataset, either Amazon S3 or the Glue Data Catalog.
        public let source: Source?
        /// Metadata tags that have been applied to the dataset.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, pathOptions: PathOptions? = nil, resourceArn: String? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.pathOptions = pathOptions
            self.resourceArn = resourceArn
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case pathOptions = "PathOptions"
            case resourceArn = "ResourceArn"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct DatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// Optional boolean value that defines whether the captured value of this parameter should be used to create a new column in a dataset.
        public let createColumn: Bool?
        /// Additional parameter options such as a format and a timezone. Required for datetime parameters.
        public let datetimeOptions: DatetimeOptions?
        /// The optional filter expression structure to apply additional matching criteria to the parameter.
        public let filter: FilterExpression?
        /// The name of the parameter that is used in the dataset's Amazon S3 path.
        public let name: String
        /// The type of the dataset parameter, can be one of a 'String', 'Number' or 'Datetime'.
        public let type: ParameterType

        public init(createColumn: Bool? = nil, datetimeOptions: DatetimeOptions? = nil, filter: FilterExpression? = nil, name: String, type: ParameterType) {
            self.createColumn = createColumn
            self.datetimeOptions = datetimeOptions
            self.filter = filter
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.datetimeOptions?.validate(name: "\(name).datetimeOptions")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case createColumn = "CreateColumn"
            case datetimeOptions = "DatetimeOptions"
            case filter = "Filter"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DatetimeOptions: AWSEncodableShape & AWSDecodableShape {
        /// Required option, that defines the datetime format used for a date parameter in the Amazon S3 path. Should use only supported datetime specifiers and separation characters, all literal a-z or A-Z characters should be escaped with single quotes. E.g. "MM.dd.yyyy-'at'-HH:mm".
        public let format: String
        /// Optional value for a non-US locale code, needed for correct interpretation of some date formats.
        public let localeCode: String?
        /// Optional value for a timezone offset of the datetime parameter value in the Amazon S3 path. Shouldn't be used if Format for this parameter includes timezone fields. If no offset specified, UTC is assumed.
        public let timezoneOffset: String?

        public init(format: String, localeCode: String? = nil, timezoneOffset: String? = nil) {
            self.format = format
            self.localeCode = localeCode
            self.timezoneOffset = timezoneOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.format, name: "format", parent: name, max: 100)
            try self.validate(self.format, name: "format", parent: name, min: 2)
            try self.validate(self.localeCode, name: "localeCode", parent: name, max: 100)
            try self.validate(self.localeCode, name: "localeCode", parent: name, min: 2)
            try self.validate(self.localeCode, name: "localeCode", parent: name, pattern: "^[A-Za-z0-9_\\.#@\\-]+$")
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, max: 6)
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, min: 1)
            try self.validate(self.timezoneOffset, name: "timezoneOffset", parent: name, pattern: "^(Z|[-+](\\d|\\d{2}|\\d{2}:?\\d{2}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case localeCode = "LocaleCode"
            case timezoneOffset = "TimezoneOffset"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the dataset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the job to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        /// The name of the job that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the project to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        /// The name of the project that you deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteRecipeVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "recipeVersion", location: .uri(locationName: "recipeVersion"))
        ]

        /// The name of the recipe.
        public let name: String
        /// The version of the recipe to be deleted. You can specify a numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
        public let recipeVersion: String

        public init(name: String, recipeVersion: String) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRecipeVersionResponse: AWSDecodableShape {
        /// The name of the recipe that was deleted.
        public let name: String
        /// The version of the recipe that was deleted.
        public let recipeVersion: String

        public init(name: String, recipeVersion: String) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct DeleteScheduleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the schedule to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the dataset to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// The date and time that the dataset was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the dataset.
        public let createdBy: String?
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The identifier (user name) of the user who last modified the dataset.
        public let lastModifiedBy: String?
        /// The date and time that the dataset was last modified.
        public let lastModifiedDate: Date?
        /// The name of the dataset.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let resourceArn: String?
        /// The location of the data for this dataset, Amazon S3 or the Glue Data Catalog.
        public let source: Source?
        /// Metadata tags associated with this dataset.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, pathOptions: PathOptions? = nil, resourceArn: String? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.pathOptions = pathOptions
            self.resourceArn = resourceArn
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case pathOptions = "PathOptions"
            case resourceArn = "ResourceArn"
            case source = "Source"
            case tags = "Tags"
        }
    }

    public struct DescribeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the job to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobResponse: AWSDecodableShape {
        /// The date and time that the job was created.
        public let createDate: Date?
        /// The identifier (user name) of the user associated with the creation of the job.
        public let createdBy: String?
        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The dataset that the job acts upon.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed.
        public let jobSample: JobSample?
        /// The identifier (user name) of the user who last modified the job.
        public let lastModifiedBy: String?
        /// The date and time that the job was last modified.
        public let lastModifiedDate: Date?
        /// Indicates whether Amazon CloudWatch logging is enabled for this job.
        public let logSubscription: LogSubscription?
        /// The maximum number of compute nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// The DataBrew project associated with this job.
        public let projectName: String?
        public let recipeReference: RecipeReference?
        /// The Amazon Resource Name (ARN) of the job.
        public let resourceArn: String?
        /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String?
        /// Metadata tags associated with this job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// The job type, which must be one of the following:    PROFILE - The job analyzes the dataset to determine its size, data types, data distribution, and more.    RECIPE - The job applies one or more transformations to a dataset.
        public let type: JobType?

        public init(createDate: Date? = nil, createdBy: String? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, resourceArn: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, type: JobType? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
            case type = "Type"
        }
    }

    public struct DescribeJobRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "runId", location: .uri(locationName: "runId"))
        ]

        /// The name of the job being processed during this run.
        public let name: String
        /// The unique identifier of the job run.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobRunResponse: AWSDecodableShape {
        /// The number of times that DataBrew has attempted to run the job.
        public let attempt: Int?
        /// The date and time when the job completed processing.
        public let completedOn: Date?
        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset for the job to process.
        public let datasetName: String?
        /// A message indicating an error (if any) that was encountered when the job ran.
        public let errorMessage: String?
        /// The amount of time, in seconds, during which the job run consumed resources.
        public let executionTime: Int?
        /// The name of the job being processed during this run.
        public let jobName: String
        /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
        public let logGroupName: String?
        /// The current status of Amazon CloudWatch logging for the job run.
        public let logSubscription: LogSubscription?
        /// One or more output artifacts from a job run.
        public let outputs: [Output]?
        public let recipeReference: RecipeReference?
        /// The unique identifier of the job run.
        public let runId: String?
        /// The Amazon Resource Name (ARN) of the user who started the job run.
        public let startedBy: String?
        /// The date and time when the job run began.
        public let startedOn: Date?
        /// The current state of the job run entity itself.
        public let state: JobRunState?

        public init(attempt: Int? = nil, completedOn: Date? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, errorMessage: String? = nil, executionTime: Int? = nil, jobName: String, jobSample: JobSample? = nil, logGroupName: String? = nil, logSubscription: LogSubscription? = nil, outputs: [Output]? = nil, recipeReference: RecipeReference? = nil, runId: String? = nil, startedBy: String? = nil, startedOn: Date? = nil, state: JobRunState? = nil) {
            self.attempt = attempt
            self.completedOn = completedOn
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.jobName = jobName
            self.jobSample = jobSample
            self.logGroupName = logGroupName
            self.logSubscription = logSubscription
            self.outputs = outputs
            self.recipeReference = recipeReference
            self.runId = runId
            self.startedBy = startedBy
            self.startedOn = startedOn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case jobName = "JobName"
            case jobSample = "JobSample"
            case logGroupName = "LogGroupName"
            case logSubscription = "LogSubscription"
            case outputs = "Outputs"
            case recipeReference = "RecipeReference"
            case runId = "RunId"
            case startedBy = "StartedBy"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the project to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The date and time that the project was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the project.
        public let createdBy: String?
        /// The dataset associated with the project.
        public let datasetName: String?
        /// The identifier (user name) of the user who last modified the project.
        public let lastModifiedBy: String?
        /// The date and time that the project was last modified.
        public let lastModifiedDate: Date?
        /// The name of the project.
        public let name: String
        /// The date and time when the project was opened.
        public let openDate: Date?
        /// The identifier (user name) of the user that opened the project for use.
        public let openedBy: String?
        /// The recipe associated with this job.
        public let recipeName: String?
        /// The Amazon Resource Name (ARN) of the project.
        public let resourceArn: String?
        /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String?
        public let sample: Sample?
        /// Describes the current state of the session:    PROVISIONING - allocating resources for the session.    INITIALIZING - getting the session ready for first use.    ASSIGNED - the session is ready for use.
        public let sessionStatus: SessionStatus?
        /// Metadata tags associated with this project.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, datasetName: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, openDate: Date? = nil, openedBy: String? = nil, recipeName: String? = nil, resourceArn: String? = nil, roleArn: String? = nil, sample: Sample? = nil, sessionStatus: SessionStatus? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.datasetName = datasetName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.openDate = openDate
            self.openedBy = openedBy
            self.recipeName = recipeName
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.sample = sample
            self.sessionStatus = sessionStatus
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case datasetName = "DatasetName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case openDate = "OpenDate"
            case openedBy = "OpenedBy"
            case recipeName = "RecipeName"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case sessionStatus = "SessionStatus"
            case tags = "Tags"
        }
    }

    public struct DescribeRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "recipeVersion", location: .querystring(locationName: "recipeVersion"))
        ]

        /// The name of the recipe to be described.
        public let name: String
        /// The recipe version identifier. If this parameter isn't specified, then the latest published version is returned.
        public let recipeVersion: String?

        public init(name: String, recipeVersion: String? = nil) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRecipeResponse: AWSDecodableShape {
        /// The date and time that the recipe was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the recipe.
        public let createdBy: String?
        /// The description of the recipe.
        public let description: String?
        /// The identifier (user name) of the user who last modified the recipe.
        public let lastModifiedBy: String?
        /// The date and time that the recipe was last modified.
        public let lastModifiedDate: Date?
        /// The name of the recipe.
        public let name: String
        /// The name of the project associated with this recipe.
        public let projectName: String?
        /// The identifier (user name) of the user who last published the recipe.
        public let publishedBy: String?
        /// The date and time when the recipe was last published.
        public let publishedDate: Date?
        /// The recipe version identifier.
        public let recipeVersion: String?
        /// The ARN of the recipe.
        public let resourceArn: String?
        /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
        public let steps: [RecipeStep]?
        /// Metadata tags associated with this project.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, projectName: String? = nil, publishedBy: String? = nil, publishedDate: Date? = nil, recipeVersion: String? = nil, resourceArn: String? = nil, steps: [RecipeStep]? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.projectName = projectName
            self.publishedBy = publishedBy
            self.publishedDate = publishedDate
            self.recipeVersion = recipeVersion
            self.resourceArn = resourceArn
            self.steps = steps
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case projectName = "ProjectName"
            case publishedBy = "PublishedBy"
            case publishedDate = "PublishedDate"
            case recipeVersion = "RecipeVersion"
            case resourceArn = "ResourceArn"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct DescribeScheduleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the schedule to be described.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeScheduleResponse: AWSDecodableShape {
        /// The date and time that the schedule was created.
        public let createDate: Date?
        /// The identifier (user name) of the user who created the schedule.
        public let createdBy: String?
        /// The date or dates and time or times when the jobs are to be run for the schedule. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String?
        /// The name or names of one or more jobs to be run by using the schedule.
        public let jobNames: [String]?
        /// The identifier (user name) of the user who last modified the schedule.
        public let lastModifiedBy: String?
        /// The date and time that the schedule was last modified.
        public let lastModifiedDate: Date?
        /// The name of the schedule.
        public let name: String
        /// The Amazon Resource Name (ARN) of the schedule.
        public let resourceArn: String?
        /// Metadata tags associated with this schedule.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, cronExpression: String? = nil, jobNames: [String]? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct ExcelOptions: AWSEncodableShape & AWSDecodableShape {
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public let headerRow: Bool?
        /// One or more sheet numbers in the Excel file that will be included in the dataset.
        public let sheetIndexes: [Int]?
        /// One or more named sheets in the Excel file that will be included in the dataset.
        public let sheetNames: [String]?

        public init(headerRow: Bool? = nil, sheetIndexes: [Int]? = nil, sheetNames: [String]? = nil) {
            self.headerRow = headerRow
            self.sheetIndexes = sheetIndexes
            self.sheetNames = sheetNames
        }

        public func validate(name: String) throws {
            try self.sheetIndexes?.forEach {
                try validate($0, name: "sheetIndexes[]", parent: name, max: 200)
                try validate($0, name: "sheetIndexes[]", parent: name, min: 0)
            }
            try self.validate(self.sheetIndexes, name: "sheetIndexes", parent: name, max: 1)
            try self.validate(self.sheetIndexes, name: "sheetIndexes", parent: name, min: 1)
            try self.sheetNames?.forEach {
                try validate($0, name: "sheetNames[]", parent: name, max: 31)
                try validate($0, name: "sheetNames[]", parent: name, min: 1)
            }
            try self.validate(self.sheetNames, name: "sheetNames", parent: name, max: 1)
            try self.validate(self.sheetNames, name: "sheetNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headerRow = "HeaderRow"
            case sheetIndexes = "SheetIndexes"
            case sheetNames = "SheetNames"
        }
    }

    public struct FilesLimit: AWSEncodableShape & AWSDecodableShape {
        /// The number of Amazon S3 files to select.
        public let maxFiles: Int
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses DESCENDING order, i.e. most recent files are selected first. Anotherpossible value is ASCENDING.
        public let order: Order?
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses LAST_MODIFIED_DATE as a sorting criteria. Currently it's the only allowed value.
        public let orderedBy: OrderedBy?

        public init(maxFiles: Int, order: Order? = nil, orderedBy: OrderedBy? = nil) {
            self.maxFiles = maxFiles
            self.order = order
            self.orderedBy = orderedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxFiles, name: "maxFiles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxFiles = "MaxFiles"
            case order = "Order"
            case orderedBy = "OrderedBy"
        }
    }

    public struct FilterExpression: AWSEncodableShape & AWSDecodableShape {
        /// The expression which includes condition names followed by substitution variables, possibly grouped and combined with other conditions. For example, "(starts_with :prefix1 or starts_with :prefix2) and (ends_with :suffix1 or ends_with :suffix2)". Substitution variables should start with ':' symbol.
        public let expression: String
        /// The map of substitution variable names to their values used in this filter expression.
        public let valuesMap: [String: String]

        public init(expression: String, valuesMap: [String: String]) {
            self.expression = expression
            self.valuesMap = valuesMap
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 4)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[<>0-9A-Za-z_:)(!= ]+$")
            try self.valuesMap.forEach {
                try validate($0.key, name: "valuesMap.key", parent: name, max: 128)
                try validate($0.key, name: "valuesMap.key", parent: name, min: 2)
                try validate($0.key, name: "valuesMap.key", parent: name, pattern: "^:[A-Za-z0-9_]+$")
                try validate($0.value, name: "valuesMap[\"\($0.key)\"]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case valuesMap = "ValuesMap"
        }
    }

    public struct FormatOptions: AWSEncodableShape & AWSDecodableShape {
        /// Options that define how CSV input is to be interpreted by DataBrew.
        public let csv: CsvOptions?
        /// Options that define how Excel input is to be interpreted by DataBrew.
        public let excel: ExcelOptions?
        /// Options that define how JSON input is to be interpreted by DataBrew.
        public let json: JsonOptions?

        public init(csv: CsvOptions? = nil, excel: ExcelOptions? = nil, json: JsonOptions? = nil) {
            self.csv = csv
            self.excel = excel
            self.json = json
        }

        public func validate(name: String) throws {
            try self.csv?.validate(name: "\(name).csv")
            try self.excel?.validate(name: "\(name).excel")
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "Csv"
            case excel = "Excel"
            case json = "Json"
        }
    }

    public struct Input: AWSEncodableShape & AWSDecodableShape {
        /// Connection information for dataset input files stored in a database.
        public let databaseInputDefinition: DatabaseInputDefinition?
        /// The Glue Data Catalog parameters for the data.
        public let dataCatalogInputDefinition: DataCatalogInputDefinition?
        /// The Amazon S3 location where the data is stored.
        public let s3InputDefinition: S3Location?

        public init(databaseInputDefinition: DatabaseInputDefinition? = nil, dataCatalogInputDefinition: DataCatalogInputDefinition? = nil, s3InputDefinition: S3Location? = nil) {
            self.databaseInputDefinition = databaseInputDefinition
            self.dataCatalogInputDefinition = dataCatalogInputDefinition
            self.s3InputDefinition = s3InputDefinition
        }

        public func validate(name: String) throws {
            try self.databaseInputDefinition?.validate(name: "\(name).databaseInputDefinition")
            try self.dataCatalogInputDefinition?.validate(name: "\(name).dataCatalogInputDefinition")
            try self.s3InputDefinition?.validate(name: "\(name).s3InputDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseInputDefinition = "DatabaseInputDefinition"
            case dataCatalogInputDefinition = "DataCatalogInputDefinition"
            case s3InputDefinition = "S3InputDefinition"
        }
    }

    public struct Job: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the job.
        public let accountId: String?
        /// The date and time that the job was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the job.
        public let createdBy: String?
        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// A dataset that the job is to process.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job output. For more information, see Encrypting data written by DataBrew jobs
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default value is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public let jobSample: JobSample?
        /// The Amazon Resource Name (ARN) of the user who last modified the job.
        public let lastModifiedBy: String?
        /// The modification date and time of the job.
        public let lastModifiedDate: Date?
        /// The current status of Amazon CloudWatch logging for the job.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that can be consumed when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The unique name of the job.
        public let name: String
        /// One or more artifacts that represent output from running the job.
        public let outputs: [Output]?
        /// The name of the project that the job is associated with.
        public let projectName: String?
        /// A set of steps that the job runs.
        public let recipeReference: RecipeReference?
        /// The unique Amazon Resource Name (ARN) for the job.
        public let resourceArn: String?
        /// The Amazon Resource Name (ARN) of the role to be assumed for this job.
        public let roleArn: String?
        /// Metadata tags that have been applied to the job.
        public let tags: [String: String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?
        /// The job type of the job, which must be one of the following:    PROFILE - A job to analyze a dataset, to determine its size, data types, data distribution, and more.    RECIPE - A job to apply one or more transformations to a dataset.
        public let type: JobType?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, projectName: String? = nil, recipeReference: RecipeReference? = nil, resourceArn: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, type: JobType? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case outputs = "Outputs"
            case projectName = "ProjectName"
            case recipeReference = "RecipeReference"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case timeout = "Timeout"
            case type = "Type"
        }
    }

    public struct JobRun: AWSDecodableShape {
        /// The number of times that DataBrew has attempted to run the job.
        public let attempt: Int?
        /// The date and time when the job completed processing.
        public let completedOn: Date?
        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The name of the dataset for the job to process.
        public let datasetName: String?
        /// A message indicating an error (if any) that was encountered when the job ran.
        public let errorMessage: String?
        /// The amount of time, in seconds, during which a job run consumed resources.
        public let executionTime: Int?
        /// The name of the job being processed during this run.
        public let jobName: String?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public let jobSample: JobSample?
        /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
        public let logGroupName: String?
        /// The current status of Amazon CloudWatch logging for the job run.
        public let logSubscription: LogSubscription?
        /// One or more output artifacts from a job run.
        public let outputs: [Output]?
        /// The set of steps processed by the job.
        public let recipeReference: RecipeReference?
        /// The unique identifier of the job run.
        public let runId: String?
        /// The Amazon Resource Name (ARN) of the user who initiated the job run.
        public let startedBy: String?
        /// The date and time when the job run began.
        public let startedOn: Date?
        /// The current state of the job run entity itself.
        public let state: JobRunState?

        public init(attempt: Int? = nil, completedOn: Date? = nil, dataCatalogOutputs: [DataCatalogOutput]? = nil, datasetName: String? = nil, errorMessage: String? = nil, executionTime: Int? = nil, jobName: String? = nil, jobSample: JobSample? = nil, logGroupName: String? = nil, logSubscription: LogSubscription? = nil, outputs: [Output]? = nil, recipeReference: RecipeReference? = nil, runId: String? = nil, startedBy: String? = nil, startedOn: Date? = nil, state: JobRunState? = nil) {
            self.attempt = attempt
            self.completedOn = completedOn
            self.dataCatalogOutputs = dataCatalogOutputs
            self.datasetName = datasetName
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.jobName = jobName
            self.jobSample = jobSample
            self.logGroupName = logGroupName
            self.logSubscription = logSubscription
            self.outputs = outputs
            self.recipeReference = recipeReference
            self.runId = runId
            self.startedBy = startedBy
            self.startedOn = startedOn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case dataCatalogOutputs = "DataCatalogOutputs"
            case datasetName = "DatasetName"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case jobName = "JobName"
            case jobSample = "JobSample"
            case logGroupName = "LogGroupName"
            case logSubscription = "LogSubscription"
            case outputs = "Outputs"
            case recipeReference = "RecipeReference"
            case runId = "RunId"
            case startedBy = "StartedBy"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public struct JobSample: AWSEncodableShape & AWSDecodableShape {
        /// A value that determines whether the profile job is run on the entire dataset or a specified number of rows. This value must be one of the following:   FULL_DATASET - The profile job is run on the entire dataset.   CUSTOM_ROWS - The profile job is run on the number of rows specified in the Size parameter.
        public let mode: SampleMode?
        /// The Size parameter is only required when the mode is CUSTOM_ROWS. The profile job is run on the specified number of rows. The maximum value for size is Long.MAX_VALUE. Long.MAX_VALUE = 9223372036854775807
        public let size: Int64?

        public init(mode: SampleMode? = nil, size: Int64? = nil) {
            self.mode = mode
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
            case size = "Size"
        }
    }

    public struct JsonOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value that specifies whether JSON input contains embedded new line characters.
        public let multiLine: Bool?

        public init(multiLine: Bool? = nil) {
            self.multiLine = multiLine
        }

        private enum CodingKeys: String, CodingKey {
            case multiLine = "MultiLine"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// A list of datasets that are defined.
        public let datasets: [Dataset]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(datasets: [Dataset], nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "Datasets"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobRunsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The name of the job.
        public let name: String
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobRunsResponse: AWSDecodableShape {
        /// A list of job runs that have occurred for the specified job.
        public let jobRuns: [JobRun]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobRuns: [JobRun], nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetName", location: .querystring(locationName: "datasetName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "projectName", location: .querystring(locationName: "projectName"))
        ]

        /// The name of a dataset. Using this parameter indicates to return only those jobs that act on the specified dataset.
        public let datasetName: String?
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token generated by DataBrew that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the NextToken value from the response object of the previous page call.
        public let nextToken: String?
        /// The name of a project. Using this parameter indicates to return only those jobs that are associated with the specified project.
        public let projectName: String?

        public init(datasetName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectName: String? = nil) {
            self.datasetName = datasetName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 255)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// A list of jobs that are defined.
        public let jobs: [Job]
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobs: [Job], nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of projects that are defined .
        public let projects: [Project]

        public init(nextToken: String? = nil, projects: [Project]) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projects = "Projects"
        }
    }

    public struct ListRecipeVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring(locationName: "name")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The name of the recipe for which to return version information.
        public let name: String
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecipeVersionsResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of versions for the specified recipe.
        public let recipes: [Recipe]

        public init(nextToken: String? = nil, recipes: [Recipe]) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recipes = "Recipes"
        }
    }

    public struct ListRecipesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "recipeVersion", location: .querystring(locationName: "recipeVersion"))
        ]

        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// Return only those recipes with a version identifier of LATEST_WORKING or LATEST_PUBLISHED. If RecipeVersion is omitted, ListRecipes returns all of the LATEST_PUBLISHED recipe versions. Valid values: LATEST_WORKING | LATEST_PUBLISHED
        public let recipeVersion: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, recipeVersion: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecipesResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of recipes that are defined.
        public let recipes: [Recipe]

        public init(nextToken: String? = nil, recipes: [Recipe]) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recipes = "Recipes"
        }
    }

    public struct ListSchedulesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobName", location: .querystring(locationName: "jobName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The name of the job that these schedules apply to.
        public let jobName: String?
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(jobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 240)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchedulesResponse: AWSDecodableShape {
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?
        /// A list of schedules that are defined.
        public let schedules: [Schedule]

        public init(nextToken: String? = nil, schedules: [Schedule]) {
            self.nextToken = nextToken
            self.schedules = schedules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schedules = "Schedules"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the DataBrew resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the DataBrew resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Output: AWSEncodableShape & AWSDecodableShape {
        /// The compression algorithm used to compress the output text of the job.
        public let compressionFormat: CompressionFormat?
        /// The data format of the output of the job.
        public let format: OutputFormat?
        /// Represents options that define how DataBrew formats job output files.
        public let formatOptions: OutputFormatOptions?
        /// The location in Amazon S3 where the job writes its output.
        public let location: S3Location
        /// A value that, if true, means that any data in the location specified for output is overwritten with new output.
        public let overwrite: Bool?
        /// The names of one or more partition columns for the output of the job.
        public let partitionColumns: [String]?

        public init(compressionFormat: CompressionFormat? = nil, format: OutputFormat? = nil, formatOptions: OutputFormatOptions? = nil, location: S3Location, overwrite: Bool? = nil, partitionColumns: [String]? = nil) {
            self.compressionFormat = compressionFormat
            self.format = format
            self.formatOptions = formatOptions
            self.location = location
            self.overwrite = overwrite
            self.partitionColumns = partitionColumns
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.location.validate(name: "\(name).location")
            try self.partitionColumns?.forEach {
                try validate($0, name: "partitionColumns[]", parent: name, max: 255)
                try validate($0, name: "partitionColumns[]", parent: name, min: 1)
            }
            try self.validate(self.partitionColumns, name: "partitionColumns", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case compressionFormat = "CompressionFormat"
            case format = "Format"
            case formatOptions = "FormatOptions"
            case location = "Location"
            case overwrite = "Overwrite"
            case partitionColumns = "PartitionColumns"
        }
    }

    public struct OutputFormatOptions: AWSEncodableShape & AWSDecodableShape {
        /// Represents a set of options that define the structure of comma-separated value (CSV) job output.
        public let csv: CsvOutputOptions?

        public init(csv: CsvOutputOptions? = nil) {
            self.csv = csv
        }

        public func validate(name: String) throws {
            try self.csv?.validate(name: "\(name).csv")
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "Csv"
        }
    }

    public struct PathOptions: AWSEncodableShape & AWSDecodableShape {
        /// If provided, this structure imposes a limit on a number of files that should be selected.
        public let filesLimit: FilesLimit?
        /// If provided, this structure defines a date range for matching Amazon S3 objects based on their LastModifiedDate attribute in Amazon S3.
        public let lastModifiedDateCondition: FilterExpression?
        /// A structure that maps names of parameters used in the Amazon S3 path of a dataset to their definitions.
        public let parameters: [String: DatasetParameter]?

        public init(filesLimit: FilesLimit? = nil, lastModifiedDateCondition: FilterExpression? = nil, parameters: [String: DatasetParameter]? = nil) {
            self.filesLimit = filesLimit
            self.lastModifiedDateCondition = lastModifiedDateCondition
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.filesLimit?.validate(name: "\(name).filesLimit")
            try self.lastModifiedDateCondition?.validate(name: "\(name).lastModifiedDateCondition")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filesLimit = "FilesLimit"
            case lastModifiedDateCondition = "LastModifiedDateCondition"
            case parameters = "Parameters"
        }
    }

    public struct Project: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the project.
        public let accountId: String?
        /// The date and time that the project was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who crated the project.
        public let createdBy: String?
        /// The dataset that the project is to act upon.
        public let datasetName: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the project.
        public let lastModifiedBy: String?
        /// The last modification date and time for the project.
        public let lastModifiedDate: Date?
        /// The unique name of a project.
        public let name: String
        /// The date and time when the project was opened.
        public let openDate: Date?
        /// The Amazon Resource Name (ARN) of the user that opened the project for use.
        public let openedBy: String?
        /// The name of a recipe that will be developed during a project session.
        public let recipeName: String
        /// The Amazon Resource Name (ARN) for the project.
        public let resourceArn: String?
        /// The Amazon Resource Name (ARN) of the role that will be assumed for this project.
        public let roleArn: String?
        /// The sample size and sampling type to apply to the data. If this parameter isn't specified, then the sample consists of the first 500 rows from the dataset.
        public let sample: Sample?
        /// Metadata tags that have been applied to the project.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, datasetName: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, openDate: Date? = nil, openedBy: String? = nil, recipeName: String, resourceArn: String? = nil, roleArn: String? = nil, sample: Sample? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.datasetName = datasetName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.openDate = openDate
            self.openedBy = openedBy
            self.recipeName = recipeName
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.sample = sample
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case datasetName = "DatasetName"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case openDate = "OpenDate"
            case openedBy = "OpenedBy"
            case recipeName = "RecipeName"
            case resourceArn = "ResourceArn"
            case roleArn = "RoleArn"
            case sample = "Sample"
            case tags = "Tags"
        }
    }

    public struct PublishRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// A description of the recipe to be published, for this version of the recipe.
        public let description: String?
        /// The name of the recipe to be published.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct PublishRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that you published.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Recipe: AWSDecodableShape {
        /// The date and time that the recipe was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the recipe.
        public let createdBy: String?
        /// The description of the recipe.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the user who last modified the recipe.
        public let lastModifiedBy: String?
        /// The last modification date and time of the recipe.
        public let lastModifiedDate: Date?
        /// The unique name for the recipe.
        public let name: String
        /// The name of the project that the recipe is associated with.
        public let projectName: String?
        /// The Amazon Resource Name (ARN) of the user who published the recipe.
        public let publishedBy: String?
        /// The date and time when the recipe was published.
        public let publishedDate: Date?
        /// The identifier for the version for the recipe. Must be one of the following:   Numeric version (X.Y) - X and Y stand for major and minor version numbers. The maximum length of each is 6 digits, and neither can be negative values. Both X and Y are required, and "0.0" isn't a valid version.    LATEST_WORKING - the most recent valid version being developed in a DataBrew project.    LATEST_PUBLISHED - the most recent published version.
        public let recipeVersion: String?
        /// The Amazon Resource Name (ARN) for the recipe.
        public let resourceArn: String?
        /// A list of steps that are defined by the recipe.
        public let steps: [RecipeStep]?
        /// Metadata tags that have been applied to the recipe.
        public let tags: [String: String]?

        public init(createDate: Date? = nil, createdBy: String? = nil, description: String? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, projectName: String? = nil, publishedBy: String? = nil, publishedDate: Date? = nil, recipeVersion: String? = nil, resourceArn: String? = nil, steps: [RecipeStep]? = nil, tags: [String: String]? = nil) {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.projectName = projectName
            self.publishedBy = publishedBy
            self.publishedDate = publishedDate
            self.recipeVersion = recipeVersion
            self.resourceArn = resourceArn
            self.steps = steps
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case description = "Description"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case projectName = "ProjectName"
            case publishedBy = "PublishedBy"
            case publishedDate = "PublishedDate"
            case recipeVersion = "RecipeVersion"
            case resourceArn = "ResourceArn"
            case steps = "Steps"
            case tags = "Tags"
        }
    }

    public struct RecipeAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of a valid DataBrew transformation to be performed on the data.
        public let operation: String
        /// Contextual parameters for the transformation.
        public let parameters: [String: String]?

        public init(operation: String, parameters: [String: String]? = nil) {
            self.operation = operation
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.operation, name: "operation", parent: name, max: 128)
            try self.validate(self.operation, name: "operation", parent: name, min: 1)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[A-Z\\_]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 128)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[A-Za-z0-9]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 12288)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "Operation"
            case parameters = "Parameters"
        }
    }

    public struct RecipeReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the recipe.
        public let name: String
        /// The identifier for the version for the recipe.
        public let recipeVersion: String?

        public init(name: String, recipeVersion: String? = nil) {
            self.name = name
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct RecipeStep: AWSEncodableShape & AWSDecodableShape {
        /// The particular action to be performed in the recipe step.
        public let action: RecipeAction
        /// One or more conditions that must be met for the recipe step to succeed.  All of the conditions in the array must be met. In other words, all of the conditions must be combined using a logical AND operation.
        public let conditionExpressions: [ConditionExpression]?

        public init(action: RecipeAction, conditionExpressions: [ConditionExpression]? = nil) {
            self.action = action
            self.conditionExpressions = conditionExpressions
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.conditionExpressions?.forEach {
                try $0.validate(name: "\(name).conditionExpressions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case conditionExpressions = "ConditionExpressions"
        }
    }

    public struct RecipeVersionErrorDetail: AWSDecodableShape {
        /// The HTTP status code for the error.
        public let errorCode: String?
        /// The text of the error message.
        public let errorMessage: String?
        /// The identifier for the recipe version associated with this error.
        public let recipeVersion: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, recipeVersion: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.recipeVersion = recipeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucket: String
        /// The unique name of the object in the bucket.
        public let key: String?

        public init(bucket: String, key: String? = nil) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.key, name: "key", parent: name, max: 1280)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct S3TableOutputOptions: AWSEncodableShape & AWSDecodableShape {
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can write output from a job.
        public let location: S3Location

        public init(location: S3Location) {
            self.location = location
        }

        public func validate(name: String) throws {
            try self.location.validate(name: "\(name).location")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
        }
    }

    public struct Sample: AWSEncodableShape & AWSDecodableShape {
        /// The number of rows in the sample.
        public let size: Int?
        /// The way in which DataBrew obtains rows from a dataset.
        public let type: SampleType

        public init(size: Int? = nil, type: SampleType) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 5000)
            try self.validate(self.size, name: "size", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
            case type = "Type"
        }
    }

    public struct Schedule: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the schedule.
        public let accountId: String?
        /// The date and time that the schedule was created.
        public let createDate: Date?
        /// The Amazon Resource Name (ARN) of the user who created the schedule.
        public let createdBy: String?
        /// The dates and times when the job is to run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String?
        /// A list of jobs to be run, according to the schedule.
        public let jobNames: [String]?
        /// The Amazon Resource Name (ARN) of the user who last modified the schedule.
        public let lastModifiedBy: String?
        /// The date and time when the schedule was last modified.
        public let lastModifiedDate: Date?
        /// The name of the schedule.
        public let name: String
        /// The Amazon Resource Name (ARN) of the schedule.
        public let resourceArn: String?
        /// Metadata tags that have been applied to the schedule.
        public let tags: [String: String]?

        public init(accountId: String? = nil, createDate: Date? = nil, createdBy: String? = nil, cronExpression: String? = nil, jobNames: [String]? = nil, lastModifiedBy: String? = nil, lastModifiedDate: Date? = nil, name: String, resourceArn: String? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case createDate = "CreateDate"
            case createdBy = "CreatedBy"
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct SendProjectSessionActionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// A unique identifier for an interactive session that's currently open and ready for work. The action will be performed on this session.
        public let clientSessionId: String?
        /// The name of the project to apply the action to.
        public let name: String
        /// If true, the result of the recipe step will be returned, but not applied.
        public let preview: Bool?
        public let recipeStep: RecipeStep?
        /// The index from which to preview a step. This index is used to preview the result of steps that have already been applied, so that the resulting view frame is from earlier in the view frame stack.
        public let stepIndex: Int?
        public let viewFrame: ViewFrame?

        public init(clientSessionId: String? = nil, name: String, preview: Bool? = nil, recipeStep: RecipeStep? = nil, stepIndex: Int? = nil, viewFrame: ViewFrame? = nil) {
            self.clientSessionId = clientSessionId
            self.name = name
            self.preview = preview
            self.recipeStep = recipeStep
            self.stepIndex = stepIndex
            self.viewFrame = viewFrame
        }

        public func validate(name: String) throws {
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, max: 255)
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, min: 1)
            try self.validate(self.clientSessionId, name: "clientSessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.recipeStep?.validate(name: "\(name).recipeStep")
            try self.validate(self.stepIndex, name: "stepIndex", parent: name, min: 0)
            try self.viewFrame?.validate(name: "\(name).viewFrame")
        }

        private enum CodingKeys: String, CodingKey {
            case clientSessionId = "ClientSessionId"
            case preview = "Preview"
            case recipeStep = "RecipeStep"
            case stepIndex = "StepIndex"
            case viewFrame = "ViewFrame"
        }
    }

    public struct SendProjectSessionActionResponse: AWSDecodableShape {
        /// A unique identifier for the action that was performed.
        public let actionId: Int?
        /// The name of the project that was affected by the action.
        public let name: String
        /// A message indicating the result of performing the action.
        public let result: String?

        public init(actionId: Int? = nil, name: String, result: String? = nil) {
            self.actionId = actionId
            self.name = name
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "ActionId"
            case name = "Name"
            case result = "Result"
        }
    }

    public struct StartJobRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the job to be run.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartJobRunResponse: AWSDecodableShape {
        /// A system-generated identifier for this particular job run.
        public let runId: String

        public init(runId: String) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartProjectSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// A value that, if true, enables you to take control of a session, even if a different client is currently accessing the project.
        public let assumeControl: Bool?
        /// The name of the project to act upon.
        public let name: String

        public init(assumeControl: Bool? = nil, name: String) {
            self.assumeControl = assumeControl
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assumeControl = "AssumeControl"
        }
    }

    public struct StartProjectSessionResponse: AWSDecodableShape {
        /// A system-generated identifier for the session.
        public let clientSessionId: String?
        /// The name of the project to be acted upon.
        public let name: String

        public init(clientSessionId: String? = nil, name: String) {
            self.clientSessionId = clientSessionId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case clientSessionId = "ClientSessionId"
            case name = "Name"
        }
    }

    public struct StopJobRunRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "runId", location: .uri(locationName: "runId"))
        ]

        /// The name of the job to be stopped.
        public let name: String
        /// The ID of the job run to be stopped.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopJobRunResponse: AWSDecodableShape {
        /// The ID of the job run that you stopped.
        public let runId: String

        public init(runId: String) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The DataBrew resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DataBrew, you can tag a dataset, a job, a project, or a recipe.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// A DataBrew resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag keys (names) of one or more tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public let format: InputFormat?
        public let formatOptions: FormatOptions?
        public let input: Input
        /// The name of the dataset to be updated.
        public let name: String
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public let pathOptions: PathOptions?

        public init(format: InputFormat? = nil, formatOptions: FormatOptions? = nil, input: Input, name: String, pathOptions: PathOptions? = nil) {
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.name = name
            self.pathOptions = pathOptions
        }

        public func validate(name: String) throws {
            try self.formatOptions?.validate(name: "\(name).formatOptions")
            try self.input.validate(name: "\(name).input")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.pathOptions?.validate(name: "\(name).pathOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case formatOptions = "FormatOptions"
            case input = "Input"
            case pathOptions = "PathOptions"
        }
    }

    public struct UpdateDatasetResponse: AWSDecodableShape {
        /// The name of the dataset that you updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateProfileJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Sample configuration for Profile Jobs only. Determines the number of rows on which the Profile job will be executed. If a JobSample value is not provided for profile jobs, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
        public let jobSample: JobSample?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of compute nodes that DataBrew can use when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to be updated.
        public let name: String
        public let outputLocation: S3Location
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, jobSample: JobSample? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputLocation: S3Location, roleArn: String, timeout: Int? = nil) {
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputLocation = outputLocation
            self.roleArn = roleArn
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case jobSample = "JobSample"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case outputLocation = "OutputLocation"
            case roleArn = "RoleArn"
            case timeout = "Timeout"
        }
    }

    public struct UpdateProfileJobResponse: AWSDecodableShape {
        /// The name of the job that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The name of the project to be updated.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role to be assumed for this request.
        public let roleArn: String
        public let sample: Sample?

        public init(name: String, roleArn: String, sample: Sample? = nil) {
            self.name = name
            self.roleArn = roleArn
            self.sample = sample
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.sample?.validate(name: "\(name).sample")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case sample = "Sample"
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        /// The date and time that the project was last modified.
        public let lastModifiedDate: Date?
        /// The name of the project that you updated.
        public let name: String

        public init(lastModifiedDate: Date? = nil, name: String) {
            self.lastModifiedDate = lastModifiedDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
        }
    }

    public struct UpdateRecipeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// One or more artifacts that represent the AWS Glue Data Catalog output from running the job.
        public let dataCatalogOutputs: [DataCatalogOutput]?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
        public let encryptionKeyArn: String?
        /// The encryption mode for the job, which can be one of the following:    SSE-KMS - Server-side encryption with keys managed by KMS.    SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public let encryptionMode: EncryptionMode?
        /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
        public let logSubscription: LogSubscription?
        /// The maximum number of nodes that DataBrew can consume when the job processes data.
        public let maxCapacity: Int?
        /// The maximum number of times to retry the job after a job run fails.
        public let maxRetries: Int?
        /// The name of the job to update.
        public let name: String
        /// One or more artifacts that represent the output from running the job.
        public let outputs: [Output]?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
        public let roleArn: String
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public let timeout: Int?

        public init(dataCatalogOutputs: [DataCatalogOutput]? = nil, encryptionKeyArn: String? = nil, encryptionMode: EncryptionMode? = nil, logSubscription: LogSubscription? = nil, maxCapacity: Int? = nil, maxRetries: Int? = nil, name: String, outputs: [Output]? = nil, roleArn: String, timeout: Int? = nil) {
            self.dataCatalogOutputs = dataCatalogOutputs
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.roleArn = roleArn
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.dataCatalogOutputs?.forEach {
                try $0.validate(name: "\(name).dataCatalogOutputs[]")
            }
            try self.validate(self.dataCatalogOutputs, name: "dataCatalogOutputs", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 20)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 240)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.outputs, name: "outputs", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogOutputs = "DataCatalogOutputs"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionMode = "EncryptionMode"
            case logSubscription = "LogSubscription"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case outputs = "Outputs"
            case roleArn = "RoleArn"
            case timeout = "Timeout"
        }
    }

    public struct UpdateRecipeJobResponse: AWSDecodableShape {
        /// The name of the job that you updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// A description of the recipe.
        public let description: String?
        /// The name of the recipe to be updated.
        public let name: String
        /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
        public let steps: [RecipeStep]?

        public init(description: String? = nil, name: String, steps: [RecipeStep]? = nil) {
            self.description = description
            self.name = name
            self.steps = steps
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.steps?.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case steps = "Steps"
        }
    }

    public struct UpdateRecipeResponse: AWSDecodableShape {
        /// The name of the recipe that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateScheduleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The date or dates and time or times when the jobs are to be run. For more information, see Cron expressions in the Glue DataBrew Developer Guide.
        public let cronExpression: String
        /// The name or names of one or more jobs to be run for this schedule.
        public let jobNames: [String]?
        /// The name of the schedule to update.
        public let name: String

        public init(cronExpression: String, jobNames: [String]? = nil, name: String) {
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, max: 512)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, min: 1)
            try self.jobNames?.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 240)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
            }
            try self.validate(self.jobNames, name: "jobNames", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
            case jobNames = "JobNames"
        }
    }

    public struct UpdateScheduleResponse: AWSDecodableShape {
        /// The name of the schedule that was updated.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ViewFrame: AWSEncodableShape {
        /// The number of columns to include in the view frame, beginning with the StartColumnIndex value and ignoring any columns in the HiddenColumns list.
        public let columnRange: Int?
        /// A list of columns to hide in the view frame.
        public let hiddenColumns: [String]?
        /// The starting index for the range of columns to return in the view frame.
        public let startColumnIndex: Int

        public init(columnRange: Int? = nil, hiddenColumns: [String]? = nil, startColumnIndex: Int) {
            self.columnRange = columnRange
            self.hiddenColumns = hiddenColumns
            self.startColumnIndex = startColumnIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.columnRange, name: "columnRange", parent: name, max: 20)
            try self.validate(self.columnRange, name: "columnRange", parent: name, min: 0)
            try self.hiddenColumns?.forEach {
                try validate($0, name: "hiddenColumns[]", parent: name, max: 255)
                try validate($0, name: "hiddenColumns[]", parent: name, min: 1)
            }
            try self.validate(self.startColumnIndex, name: "startColumnIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case columnRange = "ColumnRange"
            case hiddenColumns = "HiddenColumns"
            case startColumnIndex = "StartColumnIndex"
        }
    }
}
