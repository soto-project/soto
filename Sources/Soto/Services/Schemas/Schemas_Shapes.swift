//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Schemas {
    // MARK: Enums

    public enum CodeGenerationStatus: String, CustomStringConvertible, Codable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DiscovererState: String, CustomStringConvertible, Codable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case jsonschemadraft4 = "JSONSchemaDraft4"
        case openapi3 = "OpenApi3"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDiscovererRequest: AWSEncodableShape {
        /// Support discovery of schemas in events sent to the bus from another account. (default: true).
        public let crossAccount: Bool?
        /// A description for the discoverer.
        public let description: String?
        /// The ARN of the event bus.
        public let sourceArn: String
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, sourceArn: String, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.sourceArn = sourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 1600)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case sourceArn = "SourceArn"
            case tags
        }
    }

    public struct CreateDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags
        }
    }

    public struct CreateRegistryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName"))
        ]

        /// A description of the registry to be created.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// Tags to associate with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryName: String, tags: [String: String]? = nil) {
            self.description = description
            self.registryName = registryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case tags
        }
    }

    public struct CreateRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags
        }
    }

    public struct CreateSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName"))
        ]

        /// The source of the schema definition.
        public let content: String
        /// A description of the schema.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Tags associated with the schema.
        public let tags: [String: String]?
        /// The type of schema.
        public let type: `Type`

        public init(content: String, description: String? = nil, registryName: String, schemaName: String, tags: [String: String]? = nil, type: `Type`) {
            self.content = content
            self.description = description
            self.registryName = registryName
            self.schemaName = schemaName
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 100_000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case tags
            case type = "Type"
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }

    public struct DeleteDiscovererRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererId", location: .uri("DiscovererId"))
        ]

        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRegistryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName"))
        ]

        /// The name of the registry.
        public let registryName: String

        public init(registryName: String) {
            self.registryName = registryName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .querystring("registryName"))
        ]

        /// The name of the registry.
        public let registryName: String?

        public init(registryName: String? = nil) {
            self.registryName = registryName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName"))
        ]

        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String

        public init(registryName: String, schemaName: String) {
            self.registryName = registryName
            self.schemaName = schemaName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .uri("SchemaVersion"))
        ]

        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// The version number of the schema
        public let schemaVersion: String

        public init(registryName: String, schemaName: String, schemaVersion: String) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCodeBindingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "language", location: .uri("Language")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .querystring("schemaVersion"))
        ]

        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCodeBindingResponse: AWSDecodableShape {
        /// The time and date that the code binding was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The date and time that code bindings were modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The current status of code binding generation.
        public let status: CodeGenerationStatus?

        public init(creationDate: Date? = nil, lastModified: Date? = nil, schemaVersion: String? = nil, status: CodeGenerationStatus? = nil) {
            self.creationDate = creationDate
            self.lastModified = lastModified
            self.schemaVersion = schemaVersion
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case lastModified = "LastModified"
            case schemaVersion = "SchemaVersion"
            case status = "Status"
        }
    }

    public struct DescribeDiscovererRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererId", location: .uri("DiscovererId"))
        ]

        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags
        }
    }

    public struct DescribeRegistryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName"))
        ]

        /// The name of the registry.
        public let registryName: String

        public init(registryName: String) {
            self.registryName = registryName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags
        }
    }

    public struct DescribeSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .querystring("schemaVersion"))
        ]

        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSchemaResponse: AWSDecodableShape {
        /// The source of the schema definition.
        public let content: String?
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        /// Tags associated with the resource.
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(content: String? = nil, description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.content = content
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }

    public struct DiscovererSummary: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags
        }
    }

    public struct ExportSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .querystring("schemaVersion")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?
        public let type: String

        public init(registryName: String, schemaName: String, schemaVersion: String? = nil, type: String) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportSchemaResponse: AWSDecodableShape {
        public let content: String?
        public let schemaArn: String?
        public let schemaName: String?
        public let schemaVersion: String?
        public let type: String?

        public init(content: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, type: String? = nil) {
            self.content = content
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct GetCodeBindingSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "language", location: .uri("Language")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .querystring("schemaVersion"))
        ]

        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeBindingSourceResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "body"
        public static let _options: AWSShapeOptions = [.rawPayload]
        public static var _encoding = [
            AWSMemberEncoding(label: "body", location: .body("Body"))
        ]

        public let body: AWSPayload?

        public init(body: AWSPayload? = nil) {
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
        }
    }

    public struct GetDiscoveredSchemaRequest: AWSEncodableShape {
        /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
        public let events: [String]
        /// The type of event.
        public let type: `Type`

        public init(events: [String], type: `Type`) {
            self.events = events
            self.type = type
        }

        public func validate(name: String) throws {
            try self.events.forEach {
                try validate($0, name: "events[]", parent: name, max: 100_000)
                try validate($0, name: "events[]", parent: name, min: 1)
            }
            try self.validate(self.events, name: "events", parent: name, max: 10)
            try self.validate(self.events, name: "events", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case type = "Type"
        }
    }

    public struct GetDiscoveredSchemaResponse: AWSDecodableShape {
        /// The source of the schema definition.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .querystring("registryName"))
        ]

        /// The name of the registry.
        public let registryName: String?

        public init(registryName: String? = nil) {
            self.registryName = registryName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// The revision ID.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct ListDiscoverersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererIdPrefix", location: .querystring("discovererIdPrefix")),
            AWSMemberEncoding(label: "limit", location: .querystring("limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "sourceArnPrefix", location: .querystring("sourceArnPrefix"))
        ]

        /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
        public let discovererIdPrefix: String?
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// Specifying this limits the results to only those ARNs that start with the specified prefix.
        public let sourceArnPrefix: String?

        public init(discovererIdPrefix: String? = nil, limit: Int? = nil, nextToken: String? = nil, sourceArnPrefix: String? = nil) {
            self.discovererIdPrefix = discovererIdPrefix
            self.limit = limit
            self.nextToken = nextToken
            self.sourceArnPrefix = sourceArnPrefix
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDiscoverersResponse: AWSDecodableShape {
        /// An array of DiscovererSummary information.
        public let discoverers: [DiscovererSummary]?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?

        public init(discoverers: [DiscovererSummary]? = nil, nextToken: String? = nil) {
            self.discoverers = discoverers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case discoverers = "Discoverers"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegistriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring("limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "registryNamePrefix", location: .querystring("registryNamePrefix")),
            AWSMemberEncoding(label: "scope", location: .querystring("scope"))
        ]

        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// Specifying this limits the results to only those registry names that start with the specified prefix.
        public let registryNamePrefix: String?
        /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
        public let scope: String?

        public init(limit: Int? = nil, nextToken: String? = nil, registryNamePrefix: String? = nil, scope: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryNamePrefix = registryNamePrefix
            self.scope = scope
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRegistriesResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of registry summaries.
        public let registries: [RegistrySummary]?

        public init(nextToken: String? = nil, registries: [RegistrySummary]? = nil) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registries = "Registries"
        }
    }

    public struct ListSchemaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring("limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName"))
        ]

        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String

        public init(limit: Int? = nil, nextToken: String? = nil, registryName: String, schemaName: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
            self.schemaName = schemaName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of schema version summaries.
        public let schemaVersions: [SchemaVersionSummary]?

        public init(nextToken: String? = nil, schemaVersions: [SchemaVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.schemaVersions = schemaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemaVersions = "SchemaVersions"
        }
    }

    public struct ListSchemasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring("limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaNamePrefix", location: .querystring("schemaNamePrefix"))
        ]

        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String
        /// Specifying this limits the results to only those schema names that start with the specified prefix.
        public let schemaNamePrefix: String?

        public init(limit: Int? = nil, nextToken: String? = nil, registryName: String, schemaNamePrefix: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
            self.schemaNamePrefix = schemaNamePrefix
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of schema summaries.
        public let schemas: [SchemaSummary]?

        public init(nextToken: String? = nil, schemas: [SchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct PutCodeBindingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "language", location: .uri("Language")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName")),
            AWSMemberEncoding(label: "schemaVersion", location: .querystring("schemaVersion"))
        ]

        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutCodeBindingResponse: AWSDecodableShape {
        /// The time and date that the code binding was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The date and time that code bindings were modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The current status of code binding generation.
        public let status: CodeGenerationStatus?

        public init(creationDate: Date? = nil, lastModified: Date? = nil, schemaVersion: String? = nil, status: CodeGenerationStatus? = nil) {
            self.creationDate = creationDate
            self.lastModified = lastModified
            self.schemaVersion = schemaVersion
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case lastModified = "LastModified"
            case schemaVersion = "SchemaVersion"
            case status = "Status"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .querystring("registryName"))
        ]

        /// The resource-based policy.
        public let policy: String
        /// The name of the registry.
        public let registryName: String?
        /// The revision ID of the policy.
        public let revisionId: String?

        public init(policy: String, registryName: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.registryName = registryName
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// The revision ID of the policy.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct RegistrySummary: AWSDecodableShape {
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags
        }
    }

    public struct SchemaSummary: AWSDecodableShape {
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// Tags associated with the schema.
        public let tags: [String: String]?
        /// The number of versions available for the schema.
        public let versionCount: Int64?

        public init(lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, tags: [String: String]? = nil, versionCount: Int64? = nil) {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }

        private enum CodingKeys: String, CodingKey {
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case tags
            case versionCount = "VersionCount"
        }
    }

    public struct SchemaVersionSummary: AWSDecodableShape {
        /// The ARN of the schema version.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The type of schema.
        public let type: `Type`?

        public init(schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, type: `Type`? = nil) {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct SearchSchemaSummary: AWSDecodableShape {
        /// The name of the registry.
        public let registryName: String?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// An array of schema version summaries.
        public let schemaVersions: [SearchSchemaVersionSummary]?

        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersions: [SearchSchemaVersionSummary]? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersions = "SchemaVersions"
        }
    }

    public struct SearchSchemaVersionSummary: AWSDecodableShape {
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The version number of the schema
        public let schemaVersion: String?
        /// The type of schema.
        public let type: `Type`?

        public init(createdDate: Date? = nil, schemaVersion: String? = nil, type: `Type`? = nil) {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct SearchSchemasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "keywords", location: .querystring("keywords")),
            AWSMemberEncoding(label: "limit", location: .querystring("limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName"))
        ]

        /// Specifying this limits the results to only schemas that include the provided keywords.
        public let keywords: String
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String

        public init(keywords: String, limit: Int? = nil, nextToken: String? = nil, registryName: String) {
            self.keywords = keywords
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SearchSchemasResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of SearchSchemaSummary information.
        public let schemas: [SearchSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [SearchSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct StartDiscovererRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererId", location: .uri("DiscovererId"))
        ]

        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartDiscovererResponse: AWSDecodableShape {
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The state of the discoverer.
        public let state: DiscovererState?

        public init(discovererId: String? = nil, state: DiscovererState? = nil) {
            self.discovererId = discovererId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case discovererId = "DiscovererId"
            case state = "State"
        }
    }

    public struct StopDiscovererRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererId", location: .uri("DiscovererId"))
        ]

        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopDiscovererResponse: AWSDecodableShape {
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The state of the discoverer.
        public let state: DiscovererState?

        public init(discovererId: String? = nil, state: DiscovererState? = nil) {
            self.discovererId = discovererId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case discovererId = "DiscovererId"
            case state = "State"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        /// Tags associated with the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        /// Keys of key-value pairs.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateDiscovererRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "discovererId", location: .uri("DiscovererId"))
        ]

        /// Support discovery of schemas in events sent to the bus from another account. (default: true)
        public let crossAccount: Bool?
        /// The description of the discoverer to update.
        public let description: String?
        /// The ID of the discoverer.
        public let discovererId: String

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererId: String) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererId = discovererId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
        }
    }

    public struct UpdateDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags
        }
    }

    public struct UpdateRegistryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName"))
        ]

        /// The description of the registry to update.
        public let description: String?
        /// The name of the registry.
        public let registryName: String

        public init(description: String? = nil, registryName: String) {
            self.description = description
            self.registryName = registryName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags
        }
    }

    public struct UpdateSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "registryName", location: .uri("RegistryName")),
            AWSMemberEncoding(label: "schemaName", location: .uri("SchemaName"))
        ]

        /// The ID of the client token.
        public let clientTokenId: String?
        /// The source of the schema definition.
        public let content: String?
        /// The description of the schema.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// The schema type for the events schema.
        public let type: `Type`?

        public init(clientTokenId: String? = UpdateSchemaRequest.idempotencyToken(), content: String? = nil, description: String? = nil, registryName: String, schemaName: String, type: `Type`? = nil) {
            self.clientTokenId = clientTokenId
            self.content = content
            self.description = description
            self.registryName = registryName
            self.schemaName = schemaName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientTokenId, name: "clientTokenId", parent: name, max: 36)
            try self.validate(self.content, name: "content", parent: name, max: 100_000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case clientTokenId = "ClientTokenId"
            case content = "Content"
            case description = "Description"
            case type = "Type"
        }
    }

    public struct UpdateSchemaResponse: AWSDecodableShape {
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }
}
