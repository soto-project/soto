//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Schemas {
    // MARK: Enums

    public enum CodeGenerationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DiscovererState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jsonSchemaDraft4 = "JSONSchemaDraft4"
        case openApi3 = "OpenApi3"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDiscovererRequest: AWSEncodableShape {
        /// Support discovery of schemas in events sent to the bus from another account. (default: true).
        public let crossAccount: Bool?
        /// A description for the discoverer.
        public let description: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, sourceArn: String? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.sourceArn = sourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 1600)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case sourceArn = "SourceArn"
            case tags = "tags"
        }
    }

    public struct CreateDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags = "tags"
        }
    }

    public struct CreateRegistryRequest: AWSEncodableShape {
        /// A description of the registry to be created.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// Tags to associate with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryName: String, tags: [String: String]? = nil) {
            self.description = description
            self.registryName = registryName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.registryName, key: "RegistryName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case tags = "tags"
        }
    }

    public struct CreateRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "tags"
        }
    }

    public struct CreateSchemaRequest: AWSEncodableShape {
        /// The source of the schema definition.
        public let content: String?
        /// A description of the schema.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Tags associated with the schema.
        public let tags: [String: String]?
        /// The type of schema.
        public let type: `Type`?

        public init(content: String? = nil, description: String? = nil, registryName: String, schemaName: String, tags: [String: String]? = nil, type: `Type`? = nil) {
            self.content = content
            self.description = description
            self.registryName = registryName
            self.schemaName = schemaName
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 100000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case tags = "tags"
            case type = "Type"
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags = "tags"
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }

    public struct DeleteDiscovererRequest: AWSEncodableShape {
        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.discovererId, key: "DiscovererId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRegistryRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String

        public init(registryName: String) {
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String?

        public init(registryName: String? = nil) {
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.registryName, key: "registryName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String

        public init(registryName: String, schemaName: String) {
            self.registryName = registryName
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaVersionRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// The version number of the schema
        public let schemaVersion: String

        public init(registryName: String, schemaName: String, schemaVersion: String) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodePath(self.schemaVersion, key: "SchemaVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCodeBindingRequest: AWSEncodableShape {
        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.language, key: "Language")
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodeQuery(self.schemaVersion, key: "schemaVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCodeBindingResponse: AWSDecodableShape {
        /// The time and date that the code binding was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The date and time that code bindings were modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The current status of code binding generation.
        public let status: CodeGenerationStatus?

        public init(creationDate: Date? = nil, lastModified: Date? = nil, schemaVersion: String? = nil, status: CodeGenerationStatus? = nil) {
            self.creationDate = creationDate
            self.lastModified = lastModified
            self.schemaVersion = schemaVersion
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case lastModified = "LastModified"
            case schemaVersion = "SchemaVersion"
            case status = "Status"
        }
    }

    public struct DescribeDiscovererRequest: AWSEncodableShape {
        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.discovererId, key: "DiscovererId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags = "tags"
        }
    }

    public struct DescribeRegistryRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String

        public init(registryName: String) {
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "tags"
        }
    }

    public struct DescribeSchemaRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodeQuery(self.schemaVersion, key: "schemaVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSchemaResponse: AWSDecodableShape {
        /// The source of the schema definition.
        public let content: String?
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        /// Tags associated with the resource.
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(content: String? = nil, description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.content = content
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags = "tags"
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }

    public struct DiscovererSummary: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags = "tags"
        }
    }

    public struct ExportSchemaRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?
        public let type: String?

        public init(registryName: String, schemaName: String, schemaVersion: String? = nil, type: String? = nil) {
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodeQuery(self.schemaVersion, key: "schemaVersion")
            request.encodeQuery(self.type, key: "type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportSchemaResponse: AWSDecodableShape {
        public let content: String?
        public let schemaArn: String?
        public let schemaName: String?
        public let schemaVersion: String?
        public let type: String?

        public init(content: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, type: String? = nil) {
            self.content = content
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct GetCodeBindingSourceRequest: AWSEncodableShape {
        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.language, key: "Language")
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodeQuery(self.schemaVersion, key: "schemaVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeBindingSourceResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        public let body: AWSHTTPBody

        public init(body: AWSHTTPBody) {
            self.body = body
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDiscoveredSchemaRequest: AWSEncodableShape {
        /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
        public let events: [String]?
        /// The type of event.
        public let type: `Type`?

        public init(events: [String]? = nil, type: `Type`? = nil) {
            self.events = events
            self.type = type
        }

        public func validate(name: String) throws {
            try self.events?.forEach {
                try validate($0, name: "events[]", parent: name, max: 100000)
                try validate($0, name: "events[]", parent: name, min: 1)
            }
            try self.validate(self.events, name: "events", parent: name, max: 10)
            try self.validate(self.events, name: "events", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case type = "Type"
        }
    }

    public struct GetDiscoveredSchemaResponse: AWSDecodableShape {
        /// The source of the schema definition.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The name of the registry.
        public let registryName: String?

        public init(registryName: String? = nil) {
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.registryName, key: "registryName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// The revision ID.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct ListDiscoverersRequest: AWSEncodableShape {
        /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
        public let discovererIdPrefix: String?
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// Specifying this limits the results to only those ARNs that start with the specified prefix.
        public let sourceArnPrefix: String?

        public init(discovererIdPrefix: String? = nil, limit: Int? = nil, nextToken: String? = nil, sourceArnPrefix: String? = nil) {
            self.discovererIdPrefix = discovererIdPrefix
            self.limit = limit
            self.nextToken = nextToken
            self.sourceArnPrefix = sourceArnPrefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.discovererIdPrefix, key: "discovererIdPrefix")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sourceArnPrefix, key: "sourceArnPrefix")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDiscoverersResponse: AWSDecodableShape {
        /// An array of DiscovererSummary information.
        public let discoverers: [DiscovererSummary]?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?

        public init(discoverers: [DiscovererSummary]? = nil, nextToken: String? = nil) {
            self.discoverers = discoverers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case discoverers = "Discoverers"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegistriesRequest: AWSEncodableShape {
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// Specifying this limits the results to only those registry names that start with the specified prefix.
        public let registryNamePrefix: String?
        /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
        public let scope: String?

        public init(limit: Int? = nil, nextToken: String? = nil, registryNamePrefix: String? = nil, scope: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryNamePrefix = registryNamePrefix
            self.scope = scope
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registryNamePrefix, key: "registryNamePrefix")
            request.encodeQuery(self.scope, key: "scope")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRegistriesResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of registry summaries.
        public let registries: [RegistrySummary]?

        public init(nextToken: String? = nil, registries: [RegistrySummary]? = nil) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registries = "Registries"
        }
    }

    public struct ListSchemaVersionsRequest: AWSEncodableShape {
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String

        public init(limit: Int? = nil, nextToken: String? = nil, registryName: String, schemaName: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of schema version summaries.
        public let schemaVersions: [SchemaVersionSummary]?

        public init(nextToken: String? = nil, schemaVersions: [SchemaVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.schemaVersions = schemaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemaVersions = "SchemaVersions"
        }
    }

    public struct ListSchemasRequest: AWSEncodableShape {
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String
        /// Specifying this limits the results to only those schema names that start with the specified prefix.
        public let schemaNamePrefix: String?

        public init(limit: Int? = nil, nextToken: String? = nil, registryName: String, schemaNamePrefix: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
            self.schemaNamePrefix = schemaNamePrefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodeQuery(self.schemaNamePrefix, key: "schemaNamePrefix")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of schema summaries.
        public let schemas: [SchemaSummary]?

        public init(nextToken: String? = nil, schemas: [SchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PutCodeBindingRequest: AWSEncodableShape {
        /// The language of the code binding.
        public let language: String
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// Specifying this limits the results to only this schema version.
        public let schemaVersion: String?

        public init(language: String, registryName: String, schemaName: String, schemaVersion: String? = nil) {
            self.language = language
            self.registryName = registryName
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.language, key: "Language")
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            request.encodeQuery(self.schemaVersion, key: "schemaVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutCodeBindingResponse: AWSDecodableShape {
        /// The time and date that the code binding was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The date and time that code bindings were modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The current status of code binding generation.
        public let status: CodeGenerationStatus?

        public init(creationDate: Date? = nil, lastModified: Date? = nil, schemaVersion: String? = nil, status: CodeGenerationStatus? = nil) {
            self.creationDate = creationDate
            self.lastModified = lastModified
            self.schemaVersion = schemaVersion
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case lastModified = "LastModified"
            case schemaVersion = "SchemaVersion"
            case status = "Status"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// The name of the registry.
        public let registryName: String?
        /// The revision ID of the policy.
        public let revisionId: String?

        public init(policy: String? = nil, registryName: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.registryName = registryName
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.policy, forKey: .policy)
            request.encodeQuery(self.registryName, key: "registryName")
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// The revision ID of the policy.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct RegistrySummary: AWSDecodableShape {
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "tags"
        }
    }

    public struct SchemaSummary: AWSDecodableShape {
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// Tags associated with the schema.
        public let tags: [String: String]?
        /// The number of versions available for the schema.
        public let versionCount: Int64?

        public init(lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, tags: [String: String]? = nil, versionCount: Int64? = nil) {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }

        private enum CodingKeys: String, CodingKey {
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case tags = "tags"
            case versionCount = "VersionCount"
        }
    }

    public struct SchemaVersionSummary: AWSDecodableShape {
        /// The ARN of the schema version.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema.
        public let schemaVersion: String?
        /// The type of schema.
        public let type: `Type`?

        public init(schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, type: `Type`? = nil) {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct SearchSchemaSummary: AWSDecodableShape {
        /// The name of the registry.
        public let registryName: String?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// An array of schema version summaries.
        public let schemaVersions: [SearchSchemaVersionSummary]?

        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersions: [SearchSchemaVersionSummary]? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersions = "SchemaVersions"
        }
    }

    public struct SearchSchemaVersionSummary: AWSDecodableShape {
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The version number of the schema
        public let schemaVersion: String?
        /// The type of schema.
        public let type: `Type`?

        public init(createdDate: Date? = nil, schemaVersion: String? = nil, type: `Type`? = nil) {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case schemaVersion = "SchemaVersion"
            case type = "Type"
        }
    }

    public struct SearchSchemasRequest: AWSEncodableShape {
        /// Specifying this limits the results to only schemas that include the provided keywords.
        public let keywords: String?
        public let limit: Int?
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// The name of the registry.
        public let registryName: String

        public init(keywords: String? = nil, limit: Int? = nil, nextToken: String? = nil, registryName: String) {
            self.keywords = keywords
            self.limit = limit
            self.nextToken = nextToken
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.keywords, key: "keywords")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.registryName, key: "RegistryName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SearchSchemasResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
        public let nextToken: String?
        /// An array of SearchSchemaSummary information.
        public let schemas: [SearchSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [SearchSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct StartDiscovererRequest: AWSEncodableShape {
        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.discovererId, key: "DiscovererId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartDiscovererResponse: AWSDecodableShape {
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The state of the discoverer.
        public let state: DiscovererState?

        public init(discovererId: String? = nil, state: DiscovererState? = nil) {
            self.discovererId = discovererId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case discovererId = "DiscovererId"
            case state = "State"
        }
    }

    public struct StopDiscovererRequest: AWSEncodableShape {
        /// The ID of the discoverer.
        public let discovererId: String

        public init(discovererId: String) {
            self.discovererId = discovererId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.discovererId, key: "DiscovererId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopDiscovererResponse: AWSDecodableShape {
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The state of the discoverer.
        public let state: DiscovererState?

        public init(discovererId: String? = nil, state: DiscovererState? = nil) {
            self.discovererId = discovererId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case discovererId = "DiscovererId"
            case state = "State"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        /// Keys of key-value pairs.
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateDiscovererRequest: AWSEncodableShape {
        /// Support discovery of schemas in events sent to the bus from another account. (default: true)
        public let crossAccount: Bool?
        /// The description of the discoverer to update.
        public let description: String?
        /// The ID of the discoverer.
        public let discovererId: String

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererId: String) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererId = discovererId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.crossAccount, forKey: .crossAccount)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.discovererId, key: "DiscovererId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
        }
    }

    public struct UpdateDiscovererResponse: AWSDecodableShape {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public let crossAccount: Bool?
        /// The description of the discoverer.
        public let description: String?
        /// The ARN of the discoverer.
        public let discovererArn: String?
        /// The ID of the discoverer.
        public let discovererId: String?
        /// The ARN of the event bus.
        public let sourceArn: String?
        /// The state of the discoverer.
        public let state: DiscovererState?
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(crossAccount: Bool? = nil, description: String? = nil, discovererArn: String? = nil, discovererId: String? = nil, sourceArn: String? = nil, state: DiscovererState? = nil, tags: [String: String]? = nil) {
            self.crossAccount = crossAccount
            self.description = description
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccount = "CrossAccount"
            case description = "Description"
            case discovererArn = "DiscovererArn"
            case discovererId = "DiscovererId"
            case sourceArn = "SourceArn"
            case state = "State"
            case tags = "tags"
        }
    }

    public struct UpdateRegistryRequest: AWSEncodableShape {
        /// The description of the registry to update.
        public let description: String?
        /// The name of the registry.
        public let registryName: String

        public init(description: String? = nil, registryName: String) {
            self.description = description
            self.registryName = registryName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.registryName, key: "RegistryName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateRegistryResponse: AWSDecodableShape {
        /// The description of the registry.
        public let description: String?
        /// The ARN of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// Tags associated with the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "tags"
        }
    }

    public struct UpdateSchemaRequest: AWSEncodableShape {
        /// The ID of the client token.
        public let clientTokenId: String?
        /// The source of the schema definition.
        public let content: String?
        /// The description of the schema.
        public let description: String?
        /// The name of the registry.
        public let registryName: String
        /// The name of the schema.
        public let schemaName: String
        /// The schema type for the events schema.
        public let type: `Type`?

        public init(clientTokenId: String? = UpdateSchemaRequest.idempotencyToken(), content: String? = nil, description: String? = nil, registryName: String, schemaName: String, type: `Type`? = nil) {
            self.clientTokenId = clientTokenId
            self.content = content
            self.description = description
            self.registryName = registryName
            self.schemaName = schemaName
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientTokenId, forKey: .clientTokenId)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.registryName, key: "RegistryName")
            request.encodePath(self.schemaName, key: "SchemaName")
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientTokenId, name: "clientTokenId", parent: name, max: 36)
            try self.validate(self.content, name: "content", parent: name, max: 100000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case clientTokenId = "ClientTokenId"
            case content = "Content"
            case description = "Description"
            case type = "Type"
        }
    }

    public struct UpdateSchemaResponse: AWSDecodableShape {
        /// The description of the schema.
        public let description: String?
        /// The date and time that schema was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        /// The ARN of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version number of the schema
        public let schemaVersion: String?
        public let tags: [String: String]?
        /// The type of the schema.
        public let type: String?
        /// The date the schema version was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var versionCreatedDate: Date?

        public init(description: String? = nil, lastModified: Date? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersion: String? = nil, tags: [String: String]? = nil, type: String? = nil, versionCreatedDate: Date? = nil) {
            self.description = description
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.type = type
            self.versionCreatedDate = versionCreatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModified = "LastModified"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersion = "SchemaVersion"
            case tags = "tags"
            case type = "Type"
            case versionCreatedDate = "VersionCreatedDate"
        }
    }
}

// MARK: - Errors

/// Error enum for Schemas
public struct SchemasErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case goneException = "GoneException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case preconditionFailedException = "PreconditionFailedException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Schemas
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var badRequestException: Self { .init(.badRequestException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var forbiddenException: Self { .init(.forbiddenException) }
    public static var goneException: Self { .init(.goneException) }
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    public static var notFoundException: Self { .init(.notFoundException) }
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension SchemasErrorType: Equatable {
    public static func == (lhs: SchemasErrorType, rhs: SchemasErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SchemasErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
