//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension AuditManager {
    ///   Returns a list of changelogs from Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getChangeLogsPaginator<Result>(
        _ input: GetChangeLogsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetChangeLogsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getChangeLogs,
            inputKey: \GetChangeLogsRequest.nextToken,
            outputKey: \GetChangeLogsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getChangeLogsPaginator(
        _ input: GetChangeLogsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetChangeLogsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getChangeLogs,
            inputKey: \GetChangeLogsRequest.nextToken,
            outputKey: \GetChangeLogsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of delegations from an audit owner to a delegate.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getDelegationsPaginator<Result>(
        _ input: GetDelegationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetDelegationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getDelegations,
            inputKey: \GetDelegationsRequest.nextToken,
            outputKey: \GetDelegationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getDelegationsPaginator(
        _ input: GetDelegationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetDelegationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getDelegations,
            inputKey: \GetDelegationsRequest.nextToken,
            outputKey: \GetDelegationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns all evidence from a specified evidence folder in Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getEvidenceByEvidenceFolderPaginator<Result>(
        _ input: GetEvidenceByEvidenceFolderRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetEvidenceByEvidenceFolderResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getEvidenceByEvidenceFolder,
            inputKey: \GetEvidenceByEvidenceFolderRequest.nextToken,
            outputKey: \GetEvidenceByEvidenceFolderResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getEvidenceByEvidenceFolderPaginator(
        _ input: GetEvidenceByEvidenceFolderRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetEvidenceByEvidenceFolderResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getEvidenceByEvidenceFolder,
            inputKey: \GetEvidenceByEvidenceFolderRequest.nextToken,
            outputKey: \GetEvidenceByEvidenceFolderResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns the evidence folders from a specified assessment in Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getEvidenceFoldersByAssessmentPaginator<Result>(
        _ input: GetEvidenceFoldersByAssessmentRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetEvidenceFoldersByAssessmentResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getEvidenceFoldersByAssessment,
            inputKey: \GetEvidenceFoldersByAssessmentRequest.nextToken,
            outputKey: \GetEvidenceFoldersByAssessmentResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getEvidenceFoldersByAssessmentPaginator(
        _ input: GetEvidenceFoldersByAssessmentRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetEvidenceFoldersByAssessmentResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getEvidenceFoldersByAssessment,
            inputKey: \GetEvidenceFoldersByAssessmentRequest.nextToken,
            outputKey: \GetEvidenceFoldersByAssessmentResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of evidence folders that are associated with a specified control of an assessment in Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getEvidenceFoldersByAssessmentControlPaginator<Result>(
        _ input: GetEvidenceFoldersByAssessmentControlRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetEvidenceFoldersByAssessmentControlResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getEvidenceFoldersByAssessmentControl,
            inputKey: \GetEvidenceFoldersByAssessmentControlRequest.nextToken,
            outputKey: \GetEvidenceFoldersByAssessmentControlResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getEvidenceFoldersByAssessmentControlPaginator(
        _ input: GetEvidenceFoldersByAssessmentControlRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetEvidenceFoldersByAssessmentControlResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getEvidenceFoldersByAssessmentControl,
            inputKey: \GetEvidenceFoldersByAssessmentControlRequest.nextToken,
            outputKey: \GetEvidenceFoldersByAssessmentControlResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the latest analytics data for controls within a specific control domain and a specific active assessment.  Control insights are listed only if the control belongs to the control domain and assessment that was specified. Moreover, the control must have collected evidence on the lastUpdated date of controlInsightsByAssessment. If neither of these conditions are met, no data is listed for that control.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssessmentControlInsightsByControlDomainPaginator<Result>(
        _ input: ListAssessmentControlInsightsByControlDomainRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssessmentControlInsightsByControlDomainResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssessmentControlInsightsByControlDomain,
            inputKey: \ListAssessmentControlInsightsByControlDomainRequest.nextToken,
            outputKey: \ListAssessmentControlInsightsByControlDomainResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssessmentControlInsightsByControlDomainPaginator(
        _ input: ListAssessmentControlInsightsByControlDomainRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssessmentControlInsightsByControlDomainResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssessmentControlInsightsByControlDomain,
            inputKey: \ListAssessmentControlInsightsByControlDomainRequest.nextToken,
            outputKey: \ListAssessmentControlInsightsByControlDomainResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of sent or received share requests for custom frameworks in Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssessmentFrameworkShareRequestsPaginator<Result>(
        _ input: ListAssessmentFrameworkShareRequestsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssessmentFrameworkShareRequestsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssessmentFrameworkShareRequests,
            inputKey: \ListAssessmentFrameworkShareRequestsRequest.nextToken,
            outputKey: \ListAssessmentFrameworkShareRequestsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssessmentFrameworkShareRequestsPaginator(
        _ input: ListAssessmentFrameworkShareRequestsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssessmentFrameworkShareRequestsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssessmentFrameworkShareRequests,
            inputKey: \ListAssessmentFrameworkShareRequestsRequest.nextToken,
            outputKey: \ListAssessmentFrameworkShareRequestsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of the frameworks that are available in the Audit Manager framework library.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssessmentFrameworksPaginator<Result>(
        _ input: ListAssessmentFrameworksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssessmentFrameworksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssessmentFrameworks,
            inputKey: \ListAssessmentFrameworksRequest.nextToken,
            outputKey: \ListAssessmentFrameworksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssessmentFrameworksPaginator(
        _ input: ListAssessmentFrameworksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssessmentFrameworksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssessmentFrameworks,
            inputKey: \ListAssessmentFrameworksRequest.nextToken,
            outputKey: \ListAssessmentFrameworksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of assessment reports created in Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssessmentReportsPaginator<Result>(
        _ input: ListAssessmentReportsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssessmentReportsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssessmentReports,
            inputKey: \ListAssessmentReportsRequest.nextToken,
            outputKey: \ListAssessmentReportsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssessmentReportsPaginator(
        _ input: ListAssessmentReportsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssessmentReportsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssessmentReports,
            inputKey: \ListAssessmentReportsRequest.nextToken,
            outputKey: \ListAssessmentReportsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of current and past assessments from Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssessmentsPaginator<Result>(
        _ input: ListAssessmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssessmentsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssessments,
            inputKey: \ListAssessmentsRequest.nextToken,
            outputKey: \ListAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssessmentsPaginator(
        _ input: ListAssessmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssessmentsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssessments,
            inputKey: \ListAssessmentsRequest.nextToken,
            outputKey: \ListAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the latest analytics data for control domains across all of your active assessments.   A control domain is listed only if at least one of the controls within that domain collected evidence on the lastUpdated date of controlDomainInsights. If this condition isn’t met, no data is listed for that control domain.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listControlDomainInsightsPaginator<Result>(
        _ input: ListControlDomainInsightsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListControlDomainInsightsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listControlDomainInsights,
            inputKey: \ListControlDomainInsightsRequest.nextToken,
            outputKey: \ListControlDomainInsightsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listControlDomainInsightsPaginator(
        _ input: ListControlDomainInsightsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListControlDomainInsightsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listControlDomainInsights,
            inputKey: \ListControlDomainInsightsRequest.nextToken,
            outputKey: \ListControlDomainInsightsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists analytics data for control domains within a specified active assessment.  A control domain is listed only if at least one of the controls within that domain collected evidence on the lastUpdated date of controlDomainInsights. If this condition isn’t met, no data is listed for that domain.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listControlDomainInsightsByAssessmentPaginator<Result>(
        _ input: ListControlDomainInsightsByAssessmentRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListControlDomainInsightsByAssessmentResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listControlDomainInsightsByAssessment,
            inputKey: \ListControlDomainInsightsByAssessmentRequest.nextToken,
            outputKey: \ListControlDomainInsightsByAssessmentResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listControlDomainInsightsByAssessmentPaginator(
        _ input: ListControlDomainInsightsByAssessmentRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListControlDomainInsightsByAssessmentResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listControlDomainInsightsByAssessment,
            inputKey: \ListControlDomainInsightsByAssessmentRequest.nextToken,
            outputKey: \ListControlDomainInsightsByAssessmentResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the latest analytics data for controls within a specific control domain across all active assessments.   Control insights are listed only if the control belongs to the control domain that was specified and the control collected evidence on the lastUpdated date of controlInsightsMetadata. If neither of these conditions are met, no data is listed for that control.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listControlInsightsByControlDomainPaginator<Result>(
        _ input: ListControlInsightsByControlDomainRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListControlInsightsByControlDomainResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listControlInsightsByControlDomain,
            inputKey: \ListControlInsightsByControlDomainRequest.nextToken,
            outputKey: \ListControlInsightsByControlDomainResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listControlInsightsByControlDomainPaginator(
        _ input: ListControlInsightsByControlDomainRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListControlInsightsByControlDomainResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listControlInsightsByControlDomain,
            inputKey: \ListControlInsightsByControlDomainRequest.nextToken,
            outputKey: \ListControlInsightsByControlDomainResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of controls from Audit Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listControlsPaginator<Result>(
        _ input: ListControlsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListControlsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listControls,
            inputKey: \ListControlsRequest.nextToken,
            outputKey: \ListControlsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listControlsPaginator(
        _ input: ListControlsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListControlsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listControls,
            inputKey: \ListControlsRequest.nextToken,
            outputKey: \ListControlsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of keywords that are pre-mapped to the specified control data source.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listKeywordsForDataSourcePaginator<Result>(
        _ input: ListKeywordsForDataSourceRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListKeywordsForDataSourceResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listKeywordsForDataSource,
            inputKey: \ListKeywordsForDataSourceRequest.nextToken,
            outputKey: \ListKeywordsForDataSourceResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listKeywordsForDataSourcePaginator(
        _ input: ListKeywordsForDataSourceRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListKeywordsForDataSourceResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listKeywordsForDataSource,
            inputKey: \ListKeywordsForDataSourceRequest.nextToken,
            outputKey: \ListKeywordsForDataSourceResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of all Audit Manager notifications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listNotificationsPaginator<Result>(
        _ input: ListNotificationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListNotificationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listNotifications,
            inputKey: \ListNotificationsRequest.nextToken,
            outputKey: \ListNotificationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listNotificationsPaginator(
        _ input: ListNotificationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListNotificationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listNotifications,
            inputKey: \ListNotificationsRequest.nextToken,
            outputKey: \ListNotificationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension AuditManager.GetChangeLogsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.GetChangeLogsRequest {
        return .init(
            assessmentId: self.assessmentId,
            controlId: self.controlId,
            controlSetId: self.controlSetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.GetDelegationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.GetDelegationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.GetEvidenceByEvidenceFolderRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.GetEvidenceByEvidenceFolderRequest {
        return .init(
            assessmentId: self.assessmentId,
            controlSetId: self.controlSetId,
            evidenceFolderId: self.evidenceFolderId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.GetEvidenceFoldersByAssessmentRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.GetEvidenceFoldersByAssessmentRequest {
        return .init(
            assessmentId: self.assessmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.GetEvidenceFoldersByAssessmentControlRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.GetEvidenceFoldersByAssessmentControlRequest {
        return .init(
            assessmentId: self.assessmentId,
            controlId: self.controlId,
            controlSetId: self.controlSetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListAssessmentControlInsightsByControlDomainRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListAssessmentControlInsightsByControlDomainRequest {
        return .init(
            assessmentId: self.assessmentId,
            controlDomainId: self.controlDomainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListAssessmentFrameworkShareRequestsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListAssessmentFrameworkShareRequestsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            requestType: self.requestType
        )
    }
}

extension AuditManager.ListAssessmentFrameworksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListAssessmentFrameworksRequest {
        return .init(
            frameworkType: self.frameworkType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListAssessmentReportsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListAssessmentReportsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListAssessmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListAssessmentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension AuditManager.ListControlDomainInsightsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListControlDomainInsightsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListControlDomainInsightsByAssessmentRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListControlDomainInsightsByAssessmentRequest {
        return .init(
            assessmentId: self.assessmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListControlInsightsByControlDomainRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListControlInsightsByControlDomainRequest {
        return .init(
            controlDomainId: self.controlDomainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListControlsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListControlsRequest {
        return .init(
            controlType: self.controlType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension AuditManager.ListKeywordsForDataSourceRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListKeywordsForDataSourceRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            source: self.source
        )
    }
}

extension AuditManager.ListNotificationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AuditManager.ListNotificationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
