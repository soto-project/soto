//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AuditManager {
    // MARK: Enums

    public enum AccountStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case pendingActivation = "PENDING_ACTIVATION"
        public var description: String { return self.rawValue }
    }

    public enum ActionEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case create = "CREATE"
        case delete = "DELETE"
        case importEvidence = "IMPORT_EVIDENCE"
        case inactive = "INACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        case updateMetadata = "UPDATE_METADATA"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentReportDestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ControlResponse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `defer` = "DEFER"
        case automate = "AUTOMATE"
        case ignore = "IGNORE"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum ControlSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inactive = "INACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum ControlType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum DelegationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case inProgress = "IN_PROGRESS"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum DeleteResources: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum EvidenceFinderBackfillStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum EvidenceFinderEnablementStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case disabled = "DISABLED"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ExportDestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FrameworkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum KeywordInputType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inputText = "INPUT_TEXT"
        case selectFromList = "SELECT_FROM_LIST"
        case uploadFile = "UPLOAD_FILE"
        public var description: String { return self.rawValue }
    }

    public enum ObjectTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assessment = "ASSESSMENT"
        case assessmentReport = "ASSESSMENT_REPORT"
        case control = "CONTROL"
        case controlSet = "CONTROL_SET"
        case delegation = "DELEGATION"
        public var description: String { return self.rawValue }
    }

    public enum RoleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case processOwner = "PROCESS_OWNER"
        case resourceOwner = "RESOURCE_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum SettingAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case defaultAssessmentReportsDestination = "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
        case defaultExportDestination = "DEFAULT_EXPORT_DESTINATION"
        case defaultProcessOwners = "DEFAULT_PROCESS_OWNERS"
        case deregistrationPolicy = "DEREGISTRATION_POLICY"
        case evidenceFinderEnablement = "EVIDENCE_FINDER_ENABLEMENT"
        case isAwsOrgEnabled = "IS_AWS_ORG_ENABLED"
        case snsTopic = "SNS_TOPIC"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accept = "ACCEPT"
        case decline = "DECLINE"
        case revoke = "REVOKE"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case declined = "DECLINED"
        case expired = "EXPIRED"
        case expiring = "EXPIRING"
        case failed = "FAILED"
        case replicating = "REPLICATING"
        case revoked = "REVOKED"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case received = "RECEIVED"
        case sent = "SENT"
        public var description: String { return self.rawValue }
    }

    public enum SourceFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daily = "DAILY"
        case monthly = "MONTHLY"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum SourceSetUpOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case proceduralControlsMapping = "Procedural_Controls_Mapping"
        case systemControlsMapping = "System_Controls_Mapping"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsApiCall = "AWS_API_Call"
        case awsCloudtrail = "AWS_Cloudtrail"
        case awsConfig = "AWS_Config"
        case awsSecurityHub = "AWS_Security_Hub"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSAccount: AWSEncodableShape & AWSDecodableShape {
        ///  The email address that's associated with the Amazon Web Services account.
        public let emailAddress: String?
        ///  The identifier for the Amazon Web Services account.
        public let id: String?
        ///  The name of the Amazon Web Services account.
        public let name: String?

        public init(emailAddress: String? = nil, id: String? = nil, name: String? = nil) {
            self.emailAddress = emailAddress
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 320)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^.*@.*$")
            try self.validate(self.id, name: "id", parent: name, max: 12)
            try self.validate(self.id, name: "id", parent: name, min: 12)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u007E]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "emailAddress"
            case id = "id"
            case name = "name"
        }
    }

    public struct AWSService: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the Amazon Web Service.
        public let serviceName: String?

        public init(serviceName: String? = nil) {
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 40)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[a-zA-Z0-9-\\s().]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct Assessment: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the assessment.
        public let arn: String?
        ///  The Amazon Web Services account that's associated with the assessment.
        public let awsAccount: AWSAccount?
        ///  The framework that the assessment was created from.
        public let framework: AssessmentFramework?
        ///  The metadata for the assessment.
        public let metadata: AssessmentMetadata?
        ///  The tags that are associated with the assessment.
        public let tags: [String: String]?

        public init(arn: String? = nil, awsAccount: AWSAccount? = nil, framework: AssessmentFramework? = nil, metadata: AssessmentMetadata? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.awsAccount = awsAccount
            self.framework = framework
            self.metadata = metadata
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case awsAccount = "awsAccount"
            case framework = "framework"
            case metadata = "metadata"
            case tags = "tags"
        }
    }

    public struct AssessmentControl: AWSDecodableShape {
        ///  The amount of evidence in the assessment report.
        public let assessmentReportEvidenceCount: Int?
        ///  The list of comments that's attached to the control.
        public let comments: [ControlComment]?
        ///  The description of the control.
        public let description: String?
        ///  The amount of evidence that's collected for the control.
        public let evidenceCount: Int?
        ///  The list of data sources for the evidence.
        public let evidenceSources: [String]?
        ///  The identifier for the control.
        public let id: String?
        ///  The name of the control.
        public let name: String?
        ///  The response of the control.
        public let response: ControlResponse?
        ///  The status of the control.
        public let status: ControlStatus?

        public init(assessmentReportEvidenceCount: Int? = nil, comments: [ControlComment]? = nil, description: String? = nil, evidenceCount: Int? = nil, evidenceSources: [String]? = nil, id: String? = nil, name: String? = nil, response: ControlResponse? = nil, status: ControlStatus? = nil) {
            self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
            self.comments = comments
            self.description = description
            self.evidenceCount = evidenceCount
            self.evidenceSources = evidenceSources
            self.id = id
            self.name = name
            self.response = response
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportEvidenceCount = "assessmentReportEvidenceCount"
            case comments = "comments"
            case description = "description"
            case evidenceCount = "evidenceCount"
            case evidenceSources = "evidenceSources"
            case id = "id"
            case name = "name"
            case response = "response"
            case status = "status"
        }
    }

    public struct AssessmentControlSet: AWSDecodableShape {
        ///  The list of controls that's contained with the control set.
        public let controls: [AssessmentControl]?
        ///  The delegations that are associated with the control set.
        public let delegations: [Delegation]?
        ///  The description for the control set.
        public let description: String?
        ///  The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public let id: String?
        ///  The total number of evidence objects that are uploaded manually to the control set.
        public let manualEvidenceCount: Int?
        ///  The roles that are associated with the control set.
        public let roles: [Role]?
        ///  The current status of the control set.
        public let status: ControlSetStatus?
        ///  The total number of evidence objects that are retrieved automatically for the control set.
        public let systemEvidenceCount: Int?

        public init(controls: [AssessmentControl]? = nil, delegations: [Delegation]? = nil, description: String? = nil, id: String? = nil, manualEvidenceCount: Int? = nil, roles: [Role]? = nil, status: ControlSetStatus? = nil, systemEvidenceCount: Int? = nil) {
            self.controls = controls
            self.delegations = delegations
            self.description = description
            self.id = id
            self.manualEvidenceCount = manualEvidenceCount
            self.roles = roles
            self.status = status
            self.systemEvidenceCount = systemEvidenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "controls"
            case delegations = "delegations"
            case description = "description"
            case id = "id"
            case manualEvidenceCount = "manualEvidenceCount"
            case roles = "roles"
            case status = "status"
            case systemEvidenceCount = "systemEvidenceCount"
        }
    }

    public struct AssessmentEvidenceFolder: AWSDecodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String?
        ///  The total count of evidence that's included in the assessment report.
        public let assessmentReportSelectionCount: Int?
        ///  The name of the user who created the evidence folder.
        public let author: String?
        ///  The unique identifier for the control.
        public let controlId: String?
        ///  The name of the control.
        public let controlName: String?
        ///  The identifier for the control set.
        public let controlSetId: String?
        ///  The Amazon Web Service that the evidence was collected from.
        public let dataSource: String?
        ///  The date when the first evidence was added to the evidence folder.
        public let date: Date?
        ///  The total number of Amazon Web Services resources that were assessed to generate the evidence.
        public let evidenceAwsServiceSourceCount: Int?
        ///  The number of evidence that falls under the compliance check category. This evidence is collected from Config or Security Hub.
        public let evidenceByTypeComplianceCheckCount: Int?
        ///  The total number of issues that were reported directly from Security Hub, Config, or both.
        public let evidenceByTypeComplianceCheckIssuesCount: Int?
        ///  The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other Amazon Web Services such as Amazon EC2, Amazon S3, or IAM.
        public let evidenceByTypeConfigurationDataCount: Int?
        ///  The number of evidence that falls under the manual category. This evidence is imported manually.
        public let evidenceByTypeManualCount: Int?
        ///  The number of evidence that falls under the user activity category. This evidence is collected from CloudTrail logs.
        public let evidenceByTypeUserActivityCount: Int?
        ///  The amount of evidence that's included in the evidence folder.
        public let evidenceResourcesIncludedCount: Int?
        ///  The identifier for the folder that the evidence is stored in.
        public let id: String?
        ///  The name of the evidence folder.
        public let name: String?
        ///  The total amount of evidence in the evidence folder.
        public let totalEvidence: Int?

        public init(assessmentId: String? = nil, assessmentReportSelectionCount: Int? = nil, author: String? = nil, controlId: String? = nil, controlName: String? = nil, controlSetId: String? = nil, dataSource: String? = nil, date: Date? = nil, evidenceAwsServiceSourceCount: Int? = nil, evidenceByTypeComplianceCheckCount: Int? = nil, evidenceByTypeComplianceCheckIssuesCount: Int? = nil, evidenceByTypeConfigurationDataCount: Int? = nil, evidenceByTypeManualCount: Int? = nil, evidenceByTypeUserActivityCount: Int? = nil, evidenceResourcesIncludedCount: Int? = nil, id: String? = nil, name: String? = nil, totalEvidence: Int? = nil) {
            self.assessmentId = assessmentId
            self.assessmentReportSelectionCount = assessmentReportSelectionCount
            self.author = author
            self.controlId = controlId
            self.controlName = controlName
            self.controlSetId = controlSetId
            self.dataSource = dataSource
            self.date = date
            self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
            self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
            self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
            self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
            self.evidenceByTypeManualCount = evidenceByTypeManualCount
            self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
            self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
            self.id = id
            self.name = name
            self.totalEvidence = totalEvidence
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentReportSelectionCount = "assessmentReportSelectionCount"
            case author = "author"
            case controlId = "controlId"
            case controlName = "controlName"
            case controlSetId = "controlSetId"
            case dataSource = "dataSource"
            case date = "date"
            case evidenceAwsServiceSourceCount = "evidenceAwsServiceSourceCount"
            case evidenceByTypeComplianceCheckCount = "evidenceByTypeComplianceCheckCount"
            case evidenceByTypeComplianceCheckIssuesCount = "evidenceByTypeComplianceCheckIssuesCount"
            case evidenceByTypeConfigurationDataCount = "evidenceByTypeConfigurationDataCount"
            case evidenceByTypeManualCount = "evidenceByTypeManualCount"
            case evidenceByTypeUserActivityCount = "evidenceByTypeUserActivityCount"
            case evidenceResourcesIncludedCount = "evidenceResourcesIncludedCount"
            case id = "id"
            case name = "name"
            case totalEvidence = "totalEvidence"
        }
    }

    public struct AssessmentFramework: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [AssessmentControlSet]?
        ///  The unique identifier for the framework.
        public let id: String?
        public let metadata: FrameworkMetadata?

        public init(arn: String? = nil, controlSets: [AssessmentControlSet]? = nil, id: String? = nil, metadata: FrameworkMetadata? = nil) {
            self.arn = arn
            self.controlSets = controlSets
            self.id = id
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case controlSets = "controlSets"
            case id = "id"
            case metadata = "metadata"
        }
    }

    public struct AssessmentFrameworkMetadata: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The number of controls that are associated with the framework.
        public let controlsCount: Int?
        ///  The number of control sets that are associated with the framework.
        public let controlSetsCount: Int?
        ///  The time when the framework was created.
        public let createdAt: Date?
        ///  The description of the framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let id: String?
        ///  The time when the framework was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?
        ///  The framework type, such as a standard framework or a custom framework.
        public let type: FrameworkType?

        public init(arn: String? = nil, complianceType: String? = nil, controlsCount: Int? = nil, controlSetsCount: Int? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, logo: String? = nil, name: String? = nil, type: FrameworkType? = nil) {
            self.arn = arn
            self.complianceType = complianceType
            self.controlsCount = controlsCount
            self.controlSetsCount = controlSetsCount
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.logo = logo
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case complianceType = "complianceType"
            case controlsCount = "controlsCount"
            case controlSetsCount = "controlSetsCount"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case logo = "logo"
            case name = "name"
            case type = "type"
        }
    }

    public struct AssessmentFrameworkShareRequest: AWSDecodableShape {
        ///  An optional comment from the sender about the share request.
        public let comment: String?
        /// The compliance type that the shared custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The time when the share request was created.
        public let creationTime: Date?
        /// The number of custom controls that are part of the shared custom framework.
        public let customControlsCount: Int?
        ///  The Amazon Web Services account of the recipient.
        public let destinationAccount: String?
        ///  The Amazon Web Services Region of the recipient.
        public let destinationRegion: String?
        ///  The time when the share request expires.
        public let expirationTime: Date?
        /// The description of the shared custom framework.
        public let frameworkDescription: String?
        /// The unique identifier for the shared custom framework.
        public let frameworkId: String?
        ///  The name of the custom framework that the share request is for.
        public let frameworkName: String?
        ///  The unique identifier for the share request.
        public let id: String?
        ///  Specifies when the share request was last updated.
        public let lastUpdated: Date?
        ///  The Amazon Web Services account of the sender.
        public let sourceAccount: String?
        /// The number of standard controls that are part of the shared custom framework.
        public let standardControlsCount: Int?
        ///  The status of the share request.
        public let status: ShareRequestStatus?

        public init(comment: String? = nil, complianceType: String? = nil, creationTime: Date? = nil, customControlsCount: Int? = nil, destinationAccount: String? = nil, destinationRegion: String? = nil, expirationTime: Date? = nil, frameworkDescription: String? = nil, frameworkId: String? = nil, frameworkName: String? = nil, id: String? = nil, lastUpdated: Date? = nil, sourceAccount: String? = nil, standardControlsCount: Int? = nil, status: ShareRequestStatus? = nil) {
            self.comment = comment
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.customControlsCount = customControlsCount
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.expirationTime = expirationTime
            self.frameworkDescription = frameworkDescription
            self.frameworkId = frameworkId
            self.frameworkName = frameworkName
            self.id = id
            self.lastUpdated = lastUpdated
            self.sourceAccount = sourceAccount
            self.standardControlsCount = standardControlsCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case complianceType = "complianceType"
            case creationTime = "creationTime"
            case customControlsCount = "customControlsCount"
            case destinationAccount = "destinationAccount"
            case destinationRegion = "destinationRegion"
            case expirationTime = "expirationTime"
            case frameworkDescription = "frameworkDescription"
            case frameworkId = "frameworkId"
            case frameworkName = "frameworkName"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case sourceAccount = "sourceAccount"
            case standardControlsCount = "standardControlsCount"
            case status = "status"
        }
    }

    public struct AssessmentMetadata: AWSDecodableShape {
        ///  The destination that evidence reports are stored in for the assessment.
        public let assessmentReportsDestination: AssessmentReportsDestination?
        ///  The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public let complianceType: String?
        ///  Specifies when the assessment was created.
        public let creationTime: Date?
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  The description of the assessment.
        public let description: String?
        ///  The unique identifier for the assessment.
        public let id: String?
        ///  The time of the most recent update.
        public let lastUpdated: Date?
        ///  The name of the assessment.
        public let name: String?
        ///  The roles that are associated with the assessment.
        public let roles: [Role]?
        ///  The wrapper of Amazon Web Services accounts and services that are in scope for the assessment.
        public let scope: Scope?
        ///  The overall status of the assessment.
        public let status: AssessmentStatus?

        public init(assessmentReportsDestination: AssessmentReportsDestination? = nil, complianceType: String? = nil, creationTime: Date? = nil, delegations: [Delegation]? = nil, description: String? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, roles: [Role]? = nil, scope: Scope? = nil, status: AssessmentStatus? = nil) {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.scope = scope
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportsDestination = "assessmentReportsDestination"
            case complianceType = "complianceType"
            case creationTime = "creationTime"
            case delegations = "delegations"
            case description = "description"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case roles = "roles"
            case scope = "scope"
            case status = "status"
        }
    }

    public struct AssessmentMetadataItem: AWSDecodableShape {
        ///  The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public let complianceType: String?
        ///  Specifies when the assessment was created.
        public let creationTime: Date?
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  The unique identifier for the assessment.
        public let id: String?
        ///  The time of the most recent update.
        public let lastUpdated: Date?
        ///  The name of the assessment.
        public let name: String?
        ///  The roles that are associated with the assessment.
        public let roles: [Role]?
        ///  The current status of the assessment.
        public let status: AssessmentStatus?

        public init(complianceType: String? = nil, creationTime: Date? = nil, delegations: [Delegation]? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, roles: [Role]? = nil, status: AssessmentStatus? = nil) {
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "complianceType"
            case creationTime = "creationTime"
            case delegations = "delegations"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case roles = "roles"
            case status = "status"
        }
    }

    public struct AssessmentReport: AWSDecodableShape {
        ///  The identifier for the specified assessment.
        public let assessmentId: String?
        ///  The name of the associated assessment.
        public let assessmentName: String?
        ///  The name of the user who created the assessment report.
        public let author: String?
        ///  The identifier for the specified Amazon Web Services account.
        public let awsAccountId: String?
        ///  Specifies when the assessment report was created.
        public let creationTime: Date?
        ///  The description of the specified assessment report.
        public let description: String?
        ///  The unique identifier for the assessment report.
        public let id: String?
        ///  The name that's given to the assessment report.
        public let name: String?
        ///  The current status of the specified assessment report.
        public let status: AssessmentReportStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, author: String? = nil, awsAccountId: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: AssessmentReportStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.awsAccountId = awsAccountId
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentName = "assessmentName"
            case author = "author"
            case awsAccountId = "awsAccountId"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssessmentReportEvidenceError: AWSDecodableShape {
        ///  The error code that was returned.
        public let errorCode: String?
        ///  The error message that was returned.
        public let errorMessage: String?
        ///  The identifier for the evidence.
        public let evidenceId: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, evidenceId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evidenceId = evidenceId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case evidenceId = "evidenceId"
        }
    }

    public struct AssessmentReportMetadata: AWSDecodableShape {
        ///  The unique identifier for the associated assessment.
        public let assessmentId: String?
        /// The name of the associated assessment.
        public let assessmentName: String?
        ///  The name of the user who created the assessment report.
        public let author: String?
        ///  Specifies when the assessment report was created.
        public let creationTime: Date?
        ///  The description of the assessment report.
        public let description: String?
        ///  The unique identifier for the assessment report.
        public let id: String?
        ///  The name of the assessment report.
        public let name: String?
        ///  The current status of the assessment report.
        public let status: AssessmentReportStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, author: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: AssessmentReportStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentName = "assessmentName"
            case author = "author"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssessmentReportsDestination: AWSEncodableShape & AWSDecodableShape {
        ///  The destination bucket where Audit Manager stores assessment reports.
        public let destination: String?
        ///  The destination type, such as Amazon S3.
        public let destinationType: AssessmentReportDestinationType?

        public init(destination: String? = nil, destinationType: AssessmentReportDestinationType? = nil) {
            self.destination = destination
            self.destinationType = destinationType
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case destinationType = "destinationType"
        }
    }

    public struct AssociateAssessmentReportEvidenceFolderRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.evidenceFolderId, forKey: .evidenceFolderId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId = "evidenceFolderId"
        }
    }

    public struct AssociateAssessmentReportEvidenceFolderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchAssociateAssessmentReportEvidenceRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]

        public init(assessmentId: String, evidenceFolderId: String, evidenceIds: [String]) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceIds = evidenceIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.evidenceFolderId, forKey: .evidenceFolderId)
            try container.encode(self.evidenceIds, forKey: .evidenceIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.evidenceIds.forEach {
                try validate($0, name: "evidenceIds[]", parent: name, max: 36)
                try validate($0, name: "evidenceIds[]", parent: name, min: 36)
                try validate($0, name: "evidenceIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.evidenceIds, name: "evidenceIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId = "evidenceFolderId"
            case evidenceIds = "evidenceIds"
        }
    }

    public struct BatchAssociateAssessmentReportEvidenceResponse: AWSDecodableShape {
        ///  A list of errors that the BatchAssociateAssessmentReportEvidence API returned.
        public let errors: [AssessmentReportEvidenceError]?
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]?

        public init(errors: [AssessmentReportEvidenceError]? = nil, evidenceIds: [String]? = nil) {
            self.errors = errors
            self.evidenceIds = evidenceIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case evidenceIds = "evidenceIds"
        }
    }

    public struct BatchCreateDelegationByAssessmentError: AWSDecodableShape {
        ///  The API request to batch create delegations in Audit Manager.
        public let createDelegationRequest: CreateDelegationRequest?
        ///  The error code that the BatchCreateDelegationByAssessment API returned.
        public let errorCode: String?
        ///  The error message that the BatchCreateDelegationByAssessment API returned.
        public let errorMessage: String?

        public init(createDelegationRequest: CreateDelegationRequest? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
            self.createDelegationRequest = createDelegationRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case createDelegationRequest = "createDelegationRequest"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchCreateDelegationByAssessmentRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The API request to batch create delegations in Audit Manager.
        public let createDelegationRequests: [CreateDelegationRequest]

        public init(assessmentId: String, createDelegationRequests: [CreateDelegationRequest]) {
            self.assessmentId = assessmentId
            self.createDelegationRequests = createDelegationRequests
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.createDelegationRequests, forKey: .createDelegationRequests)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.createDelegationRequests.forEach {
                try $0.validate(name: "\(name).createDelegationRequests[]")
            }
            try self.validate(self.createDelegationRequests, name: "createDelegationRequests", parent: name, max: 50)
            try self.validate(self.createDelegationRequests, name: "createDelegationRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case createDelegationRequests = "createDelegationRequests"
        }
    }

    public struct BatchCreateDelegationByAssessmentResponse: AWSDecodableShape {
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  A list of errors that the BatchCreateDelegationByAssessment API returned.
        public let errors: [BatchCreateDelegationByAssessmentError]?

        public init(delegations: [Delegation]? = nil, errors: [BatchCreateDelegationByAssessmentError]? = nil) {
            self.delegations = delegations
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case delegations = "delegations"
            case errors = "errors"
        }
    }

    public struct BatchDeleteDelegationByAssessmentError: AWSDecodableShape {
        ///  The identifier for the delegation.
        public let delegationId: String?
        ///  The error code that the BatchDeleteDelegationByAssessment API returned.
        public let errorCode: String?
        ///  The error message that the BatchDeleteDelegationByAssessment API returned.
        public let errorMessage: String?

        public init(delegationId: String? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
            self.delegationId = delegationId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case delegationId = "delegationId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchDeleteDelegationByAssessmentRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifiers for the delegations.
        public let delegationIds: [String]

        public init(assessmentId: String, delegationIds: [String]) {
            self.assessmentId = assessmentId
            self.delegationIds = delegationIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.delegationIds, forKey: .delegationIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.delegationIds.forEach {
                try validate($0, name: "delegationIds[]", parent: name, max: 36)
                try validate($0, name: "delegationIds[]", parent: name, min: 36)
                try validate($0, name: "delegationIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.delegationIds, name: "delegationIds", parent: name, max: 50)
            try self.validate(self.delegationIds, name: "delegationIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delegationIds = "delegationIds"
        }
    }

    public struct BatchDeleteDelegationByAssessmentResponse: AWSDecodableShape {
        ///  A list of errors that the BatchDeleteDelegationByAssessment API returned.
        public let errors: [BatchDeleteDelegationByAssessmentError]?

        public init(errors: [BatchDeleteDelegationByAssessmentError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDisassociateAssessmentReportEvidenceRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]

        public init(assessmentId: String, evidenceFolderId: String, evidenceIds: [String]) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceIds = evidenceIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.evidenceFolderId, forKey: .evidenceFolderId)
            try container.encode(self.evidenceIds, forKey: .evidenceIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.evidenceIds.forEach {
                try validate($0, name: "evidenceIds[]", parent: name, max: 36)
                try validate($0, name: "evidenceIds[]", parent: name, min: 36)
                try validate($0, name: "evidenceIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.evidenceIds, name: "evidenceIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId = "evidenceFolderId"
            case evidenceIds = "evidenceIds"
        }
    }

    public struct BatchDisassociateAssessmentReportEvidenceResponse: AWSDecodableShape {
        ///  A list of errors that the BatchDisassociateAssessmentReportEvidence API returned.
        public let errors: [AssessmentReportEvidenceError]?
        ///  The identifier for the evidence.
        public let evidenceIds: [String]?

        public init(errors: [AssessmentReportEvidenceError]? = nil, evidenceIds: [String]? = nil) {
            self.errors = errors
            self.evidenceIds = evidenceIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case evidenceIds = "evidenceIds"
        }
    }

    public struct BatchImportEvidenceToAssessmentControlError: AWSDecodableShape {
        ///  The error code that the BatchImportEvidenceToAssessmentControl API returned.
        public let errorCode: String?
        ///  The error message that the BatchImportEvidenceToAssessmentControl API returned.
        public let errorMessage: String?
        ///  Manual evidence that can't be collected automatically by Audit Manager.
        public let manualEvidence: ManualEvidence?

        public init(errorCode: String? = nil, errorMessage: String? = nil, manualEvidence: ManualEvidence? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.manualEvidence = manualEvidence
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case manualEvidence = "manualEvidence"
        }
    }

    public struct BatchImportEvidenceToAssessmentControlRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control.
        public let controlId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  The list of manual evidence objects.
        public let manualEvidence: [ManualEvidence]

        public init(assessmentId: String, controlId: String, controlSetId: String, manualEvidence: [ManualEvidence]) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.manualEvidence = manualEvidence
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.controlId, key: "controlId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            try container.encode(self.manualEvidence, forKey: .manualEvidence)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.manualEvidence.forEach {
                try $0.validate(name: "\(name).manualEvidence[]")
            }
            try self.validate(self.manualEvidence, name: "manualEvidence", parent: name, max: 50)
            try self.validate(self.manualEvidence, name: "manualEvidence", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case manualEvidence = "manualEvidence"
        }
    }

    public struct BatchImportEvidenceToAssessmentControlResponse: AWSDecodableShape {
        ///  A list of errors that the BatchImportEvidenceToAssessmentControl API returned.
        public let errors: [BatchImportEvidenceToAssessmentControlError]?

        public init(errors: [BatchImportEvidenceToAssessmentControlError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct ChangeLog: AWSDecodableShape {
        ///  The action that was performed.
        public let action: ActionEnum?
        ///  The time when the action was performed and the changelog record was created.
        public let createdAt: Date?
        ///  The user or role that performed the action.
        public let createdBy: String?
        ///  The name of the object that changed. This could be the name of an assessment, control, or control set.
        public let objectName: String?
        ///  The object that was changed, such as an assessment, control, or control set.
        public let objectType: ObjectTypeEnum?

        public init(action: ActionEnum? = nil, createdAt: Date? = nil, createdBy: String? = nil, objectName: String? = nil, objectType: ObjectTypeEnum? = nil) {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.objectName = objectName
            self.objectType = objectType
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case objectName = "objectName"
            case objectType = "objectType"
        }
    }

    public struct Control: AWSDecodableShape {
        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The Amazon Resource Name (ARN) of the control.
        public let arn: String?
        ///  The data mapping sources for the control.
        public let controlMappingSources: [ControlMappingSource]?
        ///  The data source types that determine where Audit Manager collects evidence from for the control.
        public let controlSources: String?
        ///  The time when the control was created.
        public let createdAt: Date?
        ///  The user or role that created the control.
        public let createdBy: String?
        ///  The description of the control.
        public let description: String?
        ///  The unique identifier for the control.
        public let id: String?
        ///  The time when the control was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The user or role that most recently updated the control.
        public let lastUpdatedBy: String?
        ///  The name of the control.
        public let name: String?
        ///  The tags associated with the control.
        public let tags: [String: String]?
        ///  The steps that you should follow to determine if the control has been satisfied.
        public let testingInformation: String?
        ///  Specifies whether the control is a standard control or a custom control.
        public let type: ControlType?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, arn: String? = nil, controlMappingSources: [ControlMappingSource]? = nil, controlSources: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, name: String? = nil, tags: [String: String]? = nil, testingInformation: String? = nil, type: ControlType? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.arn = arn
            self.controlMappingSources = controlMappingSources
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions = "actionPlanInstructions"
            case actionPlanTitle = "actionPlanTitle"
            case arn = "arn"
            case controlMappingSources = "controlMappingSources"
            case controlSources = "controlSources"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case tags = "tags"
            case testingInformation = "testingInformation"
            case type = "type"
        }
    }

    public struct ControlComment: AWSDecodableShape {
        ///  The name of the user who authored the comment.
        public let authorName: String?
        ///  The body text of a control comment.
        public let commentBody: String?
        ///  The time when the comment was posted.
        public let postedDate: Date?

        public init(authorName: String? = nil, commentBody: String? = nil, postedDate: Date? = nil) {
            self.authorName = authorName
            self.commentBody = commentBody
            self.postedDate = postedDate
        }

        private enum CodingKeys: String, CodingKey {
            case authorName = "authorName"
            case commentBody = "commentBody"
            case postedDate = "postedDate"
        }
    }

    public struct ControlDomainInsights: AWSDecodableShape {
        /// The number of controls in the control domain that collected non-compliant evidence on the lastUpdated date.
        public let controlsCountByNoncompliantEvidence: Int?
        /// A breakdown of the compliance check status for the evidence that’s associated with the control domain.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the control domain.
        public let id: String?
        /// The time when the control domain insights were last updated.
        public let lastUpdated: Date?
        /// The name of the control domain.
        public let name: String?
        /// The total number of controls in the control domain.
        public let totalControlsCount: Int?

        public init(controlsCountByNoncompliantEvidence: Int? = nil, evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, totalControlsCount: Int? = nil) {
            self.controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidence
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.totalControlsCount = totalControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case controlsCountByNoncompliantEvidence = "controlsCountByNoncompliantEvidence"
            case evidenceInsights = "evidenceInsights"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case totalControlsCount = "totalControlsCount"
        }
    }

    public struct ControlInsightsMetadataByAssessmentItem: AWSDecodableShape {
        /// The name of the control set that the assessment control belongs to.
        public let controlSetName: String?
        /// A breakdown of the compliance check status for the evidence that’s associated with the assessment control.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the assessment control.
        public let id: String?
        /// The time when the assessment control insights were last updated.
        public let lastUpdated: Date?
        /// The name of the assessment control.
        public let name: String?

        public init(controlSetName: String? = nil, evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil) {
            self.controlSetName = controlSetName
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case controlSetName = "controlSetName"
            case evidenceInsights = "evidenceInsights"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case name = "name"
        }
    }

    public struct ControlInsightsMetadataItem: AWSDecodableShape {
        /// A breakdown of the compliance check status for the evidence that’s associated with the control.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the control.
        public let id: String?
        /// The time when the control insights were last updated.
        public let lastUpdated: Date?
        /// The name of the control.
        public let name: String?

        public init(evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil) {
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceInsights = "evidenceInsights"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case name = "name"
        }
    }

    public struct ControlMappingSource: AWSEncodableShape & AWSDecodableShape {
        ///  The description of the source.
        public let sourceDescription: String?
        /// Specifies how often evidence is collected from the control mapping source.
        public let sourceFrequency: SourceFrequency?
        ///  The unique identifier for the source.
        public let sourceId: String?
        public let sourceKeyword: SourceKeyword?
        ///  The name of the source.
        public let sourceName: String?
        ///  The setup option for the data source. This option reflects if the evidence collection is automated or manual.
        public let sourceSetUpOption: SourceSetUpOption?
        ///  Specifies one of the five data source types for evidence collection.
        public let sourceType: SourceType?
        ///  The instructions for troubleshooting the control.
        public let troubleshootingText: String?

        public init(sourceDescription: String? = nil, sourceFrequency: SourceFrequency? = nil, sourceId: String? = nil, sourceKeyword: SourceKeyword? = nil, sourceName: String? = nil, sourceSetUpOption: SourceSetUpOption? = nil, sourceType: SourceType? = nil, troubleshootingText: String? = nil) {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceId = sourceId
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, max: 1000)
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.sourceId, name: "sourceId", parent: name, max: 36)
            try self.validate(self.sourceId, name: "sourceId", parent: name, min: 36)
            try self.validate(self.sourceId, name: "sourceId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.sourceKeyword?.validate(name: "\(name).sourceKeyword")
            try self.validate(self.sourceName, name: "sourceName", parent: name, max: 100)
            try self.validate(self.sourceName, name: "sourceName", parent: name, min: 1)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, max: 1000)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDescription = "sourceDescription"
            case sourceFrequency = "sourceFrequency"
            case sourceId = "sourceId"
            case sourceKeyword = "sourceKeyword"
            case sourceName = "sourceName"
            case sourceSetUpOption = "sourceSetUpOption"
            case sourceType = "sourceType"
            case troubleshootingText = "troubleshootingText"
        }
    }

    public struct ControlMetadata: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the control.
        public let arn: String?
        ///  The data source that determines where Audit Manager collects evidence from for the control.
        public let controlSources: String?
        ///  The time when the control was created.
        public let createdAt: Date?
        ///  The unique identifier for the control.
        public let id: String?
        ///  The time when the control was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The name of the control.
        public let name: String?

        public init(arn: String? = nil, controlSources: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case controlSources = "controlSources"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
        }
    }

    public struct ControlSet: AWSDecodableShape {
        ///  The list of controls within the control set.
        public let controls: [Control]?
        ///  The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public let id: String?
        ///  The name of the control set.
        public let name: String?

        public init(controls: [Control]? = nil, id: String? = nil, name: String? = nil) {
            self.controls = controls
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "controls"
            case id = "id"
            case name = "name"
        }
    }

    public struct CreateAssessmentFrameworkControl: AWSEncodableShape {
        ///  The unique identifier of the control.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CreateAssessmentFrameworkControlSet: AWSEncodableShape {
        ///  The list of controls within the control set. This doesn't contain the control set ID.
        public let controls: [CreateAssessmentFrameworkControl]?
        ///  The name of the control set.
        public let name: String

        public init(controls: [CreateAssessmentFrameworkControl]? = nil, name: String) {
            self.controls = controls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.controls?.forEach {
                try $0.validate(name: "\(name).controls[]")
            }
            try self.validate(self.controls, name: "controls", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\\\_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "controls"
            case name = "name"
        }
    }

    public struct CreateAssessmentFrameworkRequest: AWSEncodableShape {
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [CreateAssessmentFrameworkControlSet]
        ///  An optional description for the new custom framework.
        public let description: String?
        ///  The name of the new custom framework.
        public let name: String
        ///  The tags that are associated with the framework.
        public let tags: [String: String]?

        public init(complianceType: String? = nil, controlSets: [CreateAssessmentFrameworkControlSet], description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, max: 100)
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlSets.forEach {
                try $0.validate(name: "\(name).controlSets[]")
            }
            try self.validate(self.controlSets, name: "controlSets", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "complianceType"
            case controlSets = "controlSets"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The name of the new framework that the CreateAssessmentFramework API returned.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework = "framework"
        }
    }

    public struct CreateAssessmentReportRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The description of the assessment report.
        public let description: String?
        ///  The name of the new assessment report.
        public let name: String
        /// A SQL statement that represents an evidence finder query. Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually added to a report using the console, or associated with a report using the API.  To use this parameter, the enablementStatus of evidence finder must be ENABLED.  For examples and help resolving queryStatement validation exceptions, see Troubleshooting evidence finder issues in the Audit Manager User Guide.
        public let queryStatement: String?

        public init(assessmentId: String, description: String? = nil, name: String, queryStatement: String? = nil) {
            self.assessmentId = assessmentId
            self.description = description
            self.name = name
            self.queryStatement = queryStatement
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.queryStatement, forKey: .queryStatement)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_\\.]+$")
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, max: 10000)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case queryStatement = "queryStatement"
        }
    }

    public struct CreateAssessmentReportResponse: AWSDecodableShape {
        ///  The new assessment report that the CreateAssessmentReport API returned.
        public let assessmentReport: AssessmentReport?

        public init(assessmentReport: AssessmentReport? = nil) {
            self.assessmentReport = assessmentReport
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReport = "assessmentReport"
        }
    }

    public struct CreateAssessmentRequest: AWSEncodableShape {
        ///  The assessment report storage destination for the assessment that's being created.
        public let assessmentReportsDestination: AssessmentReportsDestination
        ///  The optional description of the assessment to be created.
        public let description: String?
        ///  The identifier for the framework that the assessment will be created from.
        public let frameworkId: String
        ///  The name of the assessment to be created.
        public let name: String
        ///  The list of roles for the assessment.
        public let roles: [Role]
        public let scope: Scope
        ///  The tags that are associated with the assessment.
        public let tags: [String: String]?

        public init(assessmentReportsDestination: AssessmentReportsDestination, description: String? = nil, frameworkId: String, name: String, roles: [Role], scope: Scope, tags: [String: String]? = nil) {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.description = description
            self.frameworkId = frameworkId
            self.name = name
            self.roles = roles
            self.scope = scope
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assessmentReportsDestination.validate(name: "\(name).assessmentReportsDestination")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.roles.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
            try self.scope.validate(name: "\(name).scope")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportsDestination = "assessmentReportsDestination"
            case description = "description"
            case frameworkId = "frameworkId"
            case name = "name"
            case roles = "roles"
            case scope = "scope"
            case tags = "tags"
        }
    }

    public struct CreateAssessmentResponse: AWSDecodableShape {
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment = "assessment"
        }
    }

    public struct CreateControlMappingSource: AWSEncodableShape {
        ///  The description of the data source that determines where Audit Manager collects evidence from for the control.
        public let sourceDescription: String?
        /// Specifies how often evidence is collected from the control mapping source.
        public let sourceFrequency: SourceFrequency?
        public let sourceKeyword: SourceKeyword?
        ///  The name of the control mapping data source.
        public let sourceName: String?
        ///  The setup option for the data source, which reflects if the evidence collection is automated or manual.
        public let sourceSetUpOption: SourceSetUpOption?
        ///  Specifies one of the five types of data sources for evidence collection.
        public let sourceType: SourceType?
        ///  The instructions for troubleshooting the control.
        public let troubleshootingText: String?

        public init(sourceDescription: String? = nil, sourceFrequency: SourceFrequency? = nil, sourceKeyword: SourceKeyword? = nil, sourceName: String? = nil, sourceSetUpOption: SourceSetUpOption? = nil, sourceType: SourceType? = nil, troubleshootingText: String? = nil) {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, max: 1000)
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.sourceKeyword?.validate(name: "\(name).sourceKeyword")
            try self.validate(self.sourceName, name: "sourceName", parent: name, max: 100)
            try self.validate(self.sourceName, name: "sourceName", parent: name, min: 1)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, max: 1000)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDescription = "sourceDescription"
            case sourceFrequency = "sourceFrequency"
            case sourceKeyword = "sourceKeyword"
            case sourceName = "sourceName"
            case sourceSetUpOption = "sourceSetUpOption"
            case sourceType = "sourceType"
            case troubleshootingText = "troubleshootingText"
        }
    }

    public struct CreateControlRequest: AWSEncodableShape {
        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The data mapping sources for the control.
        public let controlMappingSources: [CreateControlMappingSource]
        ///  The description of the control.
        public let description: String?
        ///  The name of the control.
        public let name: String
        ///  The tags that are associated with the control.
        public let tags: [String: String]?
        ///  The steps to follow to determine if the control is satisfied.
        public let testingInformation: String?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, controlMappingSources: [CreateControlMappingSource], description: String? = nil, name: String, tags: [String: String]? = nil, testingInformation: String? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.controlMappingSources = controlMappingSources
            self.description = description
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
        }

        public func validate(name: String) throws {
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, max: 1000)
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, max: 300)
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlMappingSources.forEach {
                try $0.validate(name: "\(name).controlMappingSources[]")
            }
            try self.validate(self.controlMappingSources, name: "controlMappingSources", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, max: 1000)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions = "actionPlanInstructions"
            case actionPlanTitle = "actionPlanTitle"
            case controlMappingSources = "controlMappingSources"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case testingInformation = "testingInformation"
        }
    }

    public struct CreateControlResponse: AWSDecodableShape {
        ///  The new control that the CreateControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct CreateDelegationRequest: AWSEncodableShape & AWSDecodableShape {
        ///  A comment that's related to the delegation request.
        public let comment: String?
        ///  The unique identifier for the control set.
        public let controlSetId: String?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType?

        public init(comment: String? = nil, controlSetId: String? = nil, roleArn: String? = nil, roleType: RoleType? = nil) {
            self.comment = comment
            self.controlSetId = controlSetId
            self.roleArn = roleArn
            self.roleType = roleType
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 350)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*:iam:")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case controlSetId = "controlSetId"
            case roleArn = "roleArn"
            case roleType = "roleType"
        }
    }

    public struct DefaultExportDestination: AWSEncodableShape & AWSDecodableShape {
        /// The destination bucket where Audit Manager stores exported files.
        public let destination: String?
        /// The destination type, such as Amazon S3.
        public let destinationType: ExportDestinationType?

        public init(destination: String? = nil, destinationType: ExportDestinationType? = nil) {
            self.destination = destination
            self.destinationType = destinationType
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case destinationType = "destinationType"
        }
    }

    public struct Delegation: AWSDecodableShape {
        ///  The identifier for the assessment that's associated with the delegation.
        public let assessmentId: String?
        ///  The name of the assessment that's associated with the delegation.
        public let assessmentName: String?
        ///  The comment that's related to the delegation.
        public let comment: String?
        ///  The identifier for the control set that's associated with the delegation.
        public let controlSetId: String?
        ///  The user or role that created the delegation.
        public let createdBy: String?
        ///  Specifies when the delegation was created.
        public let creationTime: Date?
        ///  The unique identifier for the delegation.
        public let id: String?
        ///  Specifies when the delegation was last updated.
        public let lastUpdated: Date?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType?
        ///  The status of the delegation.
        public let status: DelegationStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, comment: String? = nil, controlSetId: String? = nil, createdBy: String? = nil, creationTime: Date? = nil, id: String? = nil, lastUpdated: Date? = nil, roleArn: String? = nil, roleType: RoleType? = nil, status: DelegationStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.comment = comment
            self.controlSetId = controlSetId
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.id = id
            self.lastUpdated = lastUpdated
            self.roleArn = roleArn
            self.roleType = roleType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentName = "assessmentName"
            case comment = "comment"
            case controlSetId = "controlSetId"
            case createdBy = "createdBy"
            case creationTime = "creationTime"
            case id = "id"
            case lastUpdated = "lastUpdated"
            case roleArn = "roleArn"
            case roleType = "roleType"
            case status = "status"
        }
    }

    public struct DelegationMetadata: AWSDecodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String?
        ///  The name of the associated assessment.
        public let assessmentName: String?
        ///  Specifies the name of the control set that was delegated for review.
        public let controlSetName: String?
        ///  Specifies when the delegation was created.
        public let creationTime: Date?
        ///  The unique identifier for the delegation.
        public let id: String?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The current status of the delegation.
        public let status: DelegationStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, controlSetName: String? = nil, creationTime: Date? = nil, id: String? = nil, roleArn: String? = nil, status: DelegationStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetName = controlSetName
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentName = "assessmentName"
            case controlSetName = "controlSetName"
            case creationTime = "creationTime"
            case id = "id"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DeleteAssessmentFrameworkRequest: AWSEncodableShape {
        ///  The identifier for the custom framework.
        public let frameworkId: String

        public init(frameworkId: String) {
            self.frameworkId = frameworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.frameworkId, key: "frameworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentFrameworkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentFrameworkShareRequest: AWSEncodableShape {
        /// The unique identifier for the share request to be deleted.
        public let requestId: String
        /// Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(requestId: String, requestType: ShareRequestType) {
            self.requestId = requestId
            self.requestType = requestType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.requestId, key: "requestId")
            request.encodeQuery(self.requestType, key: "requestType")
        }

        public func validate(name: String) throws {
            try self.validate(self.requestId, name: "requestId", parent: name, max: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentFrameworkShareResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentReportRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the assessment report.
        public let assessmentReportId: String

        public init(assessmentId: String, assessmentReportId: String) {
            self.assessmentId = assessmentId
            self.assessmentReportId = assessmentReportId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.assessmentReportId, key: "assessmentReportId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, max: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, min: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentReportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteControlRequest: AWSEncodableShape {
        ///  The unique identifier for the control.
        public let controlId: String

        public init(controlId: String) {
            self.controlId = controlId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.controlId, key: "controlId")
        }

        public func validate(name: String) throws {
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeregisterAccountResponse: AWSDecodableShape {
        ///  The registration status of the account.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeregisterOrganizationAdminAccountRequest: AWSEncodableShape {
        ///  The identifier for the administrator account.
        public let adminAccountId: String?

        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, max: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, min: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
        }
    }

    public struct DeregisterOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregistrationPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specifies which Audit Manager data will be deleted when you deregister Audit Manager.   If you set the value to ALL, all of your data is deleted within seven days of deregistration.   If you set the value to DEFAULT, none of your data is deleted at the time of deregistration. However, keep in mind that the Audit Manager data retention policy still applies. As a result, any evidence data will be deleted two years after its creation date. Your other Audit Manager resources will continue to exist indefinitely.
        public let deleteResources: DeleteResources?

        public init(deleteResources: DeleteResources? = nil) {
            self.deleteResources = deleteResources
        }

        private enum CodingKeys: String, CodingKey {
            case deleteResources = "deleteResources"
        }
    }

    public struct DisassociateAssessmentReportEvidenceFolderRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.evidenceFolderId, forKey: .evidenceFolderId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId = "evidenceFolderId"
        }
    }

    public struct DisassociateAssessmentReportEvidenceFolderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Evidence: AWSDecodableShape {
        ///  Specifies whether the evidence is included in the assessment report.
        public let assessmentReportSelection: String?
        ///  The names and values that are used by the evidence event. This includes an attribute name (such as allowUsersToChangePassword) and value (such as true or false).
        public let attributes: [String: String]?
        ///  The identifier for the Amazon Web Services account.
        public let awsAccountId: String?
        ///  The Amazon Web Services account that the evidence is collected from, and its organization path.
        public let awsOrganization: String?
        /// The evaluation status for automated evidence that falls under the compliance check category.   Audit Manager classes evidence as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.   Audit Manager classes evidence as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.   If a compliance check isn't available or applicable, then no compliance evaluation can be made for that evidence. This is the case if the evidence uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the evidence uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public let complianceCheck: String?
        ///  The data source where the evidence was collected from.
        public let dataSource: String?
        ///  The name of the evidence event.
        public let eventName: String?
        ///  The Amazon Web Service that the evidence is collected from.
        public let eventSource: String?
        ///  The identifier for the Amazon Web Services account.
        public let evidenceAwsAccountId: String?
        ///  The type of automated evidence.
        public let evidenceByType: String?
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String?
        ///  The unique identifier for the user or role that's associated with the evidence.
        public let iamId: String?
        ///  The identifier for the evidence.
        public let id: String?
        ///  The list of resources that are assessed to generate the evidence.
        public let resourcesIncluded: [Resource]?
        ///  The timestamp that represents when the evidence was collected.
        public let time: Date?

        public init(assessmentReportSelection: String? = nil, attributes: [String: String]? = nil, awsAccountId: String? = nil, awsOrganization: String? = nil, complianceCheck: String? = nil, dataSource: String? = nil, eventName: String? = nil, eventSource: String? = nil, evidenceAwsAccountId: String? = nil, evidenceByType: String? = nil, evidenceFolderId: String? = nil, iamId: String? = nil, id: String? = nil, resourcesIncluded: [Resource]? = nil, time: Date? = nil) {
            self.assessmentReportSelection = assessmentReportSelection
            self.attributes = attributes
            self.awsAccountId = awsAccountId
            self.awsOrganization = awsOrganization
            self.complianceCheck = complianceCheck
            self.dataSource = dataSource
            self.eventName = eventName
            self.eventSource = eventSource
            self.evidenceAwsAccountId = evidenceAwsAccountId
            self.evidenceByType = evidenceByType
            self.evidenceFolderId = evidenceFolderId
            self.iamId = iamId
            self.id = id
            self.resourcesIncluded = resourcesIncluded
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportSelection = "assessmentReportSelection"
            case attributes = "attributes"
            case awsAccountId = "awsAccountId"
            case awsOrganization = "awsOrganization"
            case complianceCheck = "complianceCheck"
            case dataSource = "dataSource"
            case eventName = "eventName"
            case eventSource = "eventSource"
            case evidenceAwsAccountId = "evidenceAwsAccountId"
            case evidenceByType = "evidenceByType"
            case evidenceFolderId = "evidenceFolderId"
            case iamId = "iamId"
            case id = "id"
            case resourcesIncluded = "resourcesIncluded"
            case time = "time"
        }
    }

    public struct EvidenceFinderEnablement: AWSDecodableShape {
        /// The current status of the evidence data backfill process.  The backfill starts after you enable evidence finder. During this task, Audit Manager populates an event data store with your past two years’ worth of evidence data so that your evidence can be queried.    NOT_STARTED means that the backfill hasn’t started yet.     IN_PROGRESS means that the backfill is in progress. This can take up to 7 days to complete, depending on the amount of evidence data.     COMPLETED means that the backfill is complete. All of your past evidence is now queryable.
        public let backfillStatus: EvidenceFinderBackfillStatus?
        /// The current status of the evidence finder feature and the related event data store.     ENABLE_IN_PROGRESS means that you requested to enable evidence finder. An event data store is currently being created to support evidence finder queries.    ENABLED means that an event data store was successfully created and evidence finder is enabled. We recommend that you wait 7 days until the event data store is backfilled with your past two years’ worth of evidence data. You can use evidence finder in the meantime, but not all data might be available until the backfill is complete.    DISABLE_IN_PROGRESS means that you requested to disable evidence finder, and your request is pending the deletion of the event data store.    DISABLED means that you have permanently disabled evidence finder and the event data store has been deleted. You can't re-enable evidence finder after this point.
        public let enablementStatus: EvidenceFinderEnablementStatus?
        /// Represents any errors that occurred when enabling or disabling evidence finder.
        public let error: String?
        /// The Amazon Resource Name (ARN) of the CloudTrail Lake event data store that’s used by evidence finder. The event data store is the lake of evidence data that evidence finder runs queries against.
        public let eventDataStoreArn: String?

        public init(backfillStatus: EvidenceFinderBackfillStatus? = nil, enablementStatus: EvidenceFinderEnablementStatus? = nil, error: String? = nil, eventDataStoreArn: String? = nil) {
            self.backfillStatus = backfillStatus
            self.enablementStatus = enablementStatus
            self.error = error
            self.eventDataStoreArn = eventDataStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case backfillStatus = "backfillStatus"
            case enablementStatus = "enablementStatus"
            case error = "error"
            case eventDataStoreArn = "eventDataStoreArn"
        }
    }

    public struct EvidenceInsights: AWSDecodableShape {
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The number of evidence that a compliance check ruling isn't available for. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesn’t support compliance checks (for example, manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable in the console, it's classified as inconclusive in EvidenceInsights data.
        public let inconclusiveEvidenceCount: Int?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?

        public init(compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, noncompliantEvidenceCount: Int? = nil) {
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case compliantEvidenceCount = "compliantEvidenceCount"
            case inconclusiveEvidenceCount = "inconclusiveEvidenceCount"
            case noncompliantEvidenceCount = "noncompliantEvidenceCount"
        }
    }

    public struct Framework: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The compliance type that the framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [ControlSet]?
        ///  The control data sources where Audit Manager collects evidence from.
        public let controlSources: String?
        ///  The time when the framework was created.
        public let createdAt: Date?
        ///  The user or role that created the framework.
        public let createdBy: String?
        ///  The description of the framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let id: String?
        ///  The time when the framework was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The user or role that most recently updated the framework.
        public let lastUpdatedBy: String?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?
        ///  The tags that are associated with the framework.
        public let tags: [String: String]?
        ///  Specifies whether the framework is a standard framework or a custom framework.
        public let type: FrameworkType?

        public init(arn: String? = nil, complianceType: String? = nil, controlSets: [ControlSet]? = nil, controlSources: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, logo: String? = nil, name: String? = nil, tags: [String: String]? = nil, type: FrameworkType? = nil) {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.logo = logo
            self.name = name
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case complianceType = "complianceType"
            case controlSets = "controlSets"
            case controlSources = "controlSources"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case logo = "logo"
            case name = "name"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct FrameworkMetadata: AWSDecodableShape {
        ///  The compliance standard that's associated with the framework. For example, this could be PCI DSS or HIPAA.
        public let complianceType: String?
        ///  The description of the framework.
        public let description: String?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?

        public init(complianceType: String? = nil, description: String? = nil, logo: String? = nil, name: String? = nil) {
            self.complianceType = complianceType
            self.description = description
            self.logo = logo
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "complianceType"
            case description = "description"
            case logo = "logo"
            case name = "name"
        }
    }

    public struct GetAccountStatusRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountStatusResponse: AWSDecodableShape {
        ///  The status of the Amazon Web Services account.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GetAssessmentFrameworkRequest: AWSEncodableShape {
        ///  The identifier for the framework.
        public let frameworkId: String

        public init(frameworkId: String) {
            self.frameworkId = frameworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.frameworkId, key: "frameworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The framework that the GetAssessmentFramework API returned.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework = "framework"
        }
    }

    public struct GetAssessmentReportUrlRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the assessment report.
        public let assessmentReportId: String

        public init(assessmentId: String, assessmentReportId: String) {
            self.assessmentId = assessmentId
            self.assessmentReportId = assessmentReportId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.assessmentReportId, key: "assessmentReportId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, max: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, min: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentReportUrlResponse: AWSDecodableShape {
        public let preSignedUrl: URL?

        public init(preSignedUrl: URL? = nil) {
            self.preSignedUrl = preSignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case preSignedUrl = "preSignedUrl"
        }
    }

    public struct GetAssessmentRequest: AWSEncodableShape {
        /// The unique identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentResponse: AWSDecodableShape {
        public let assessment: Assessment?
        public let userRole: Role?

        public init(assessment: Assessment? = nil, userRole: Role? = nil) {
            self.assessment = assessment
            self.userRole = userRole
        }

        private enum CodingKeys: String, CodingKey {
            case assessment = "assessment"
            case userRole = "userRole"
        }
    }

    public struct GetChangeLogsRequest: AWSEncodableShape {
        /// The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control.
        public let controlId: String?
        ///  The unique identifier for the control set.
        public let controlSetId: String?
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlId: String? = nil, controlSetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodeQuery(self.controlId, key: "controlId")
            request.encodeQuery(self.controlSetId, key: "controlSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChangeLogsResponse: AWSDecodableShape {
        /// The list of user activity for the control.
        public let changeLogs: [ChangeLog]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(changeLogs: [ChangeLog]? = nil, nextToken: String? = nil) {
            self.changeLogs = changeLogs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeLogs = "changeLogs"
            case nextToken = "nextToken"
        }
    }

    public struct GetControlRequest: AWSEncodableShape {
        ///  The identifier for the control.
        public let controlId: String

        public init(controlId: String) {
            self.controlId = controlId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.controlId, key: "controlId")
        }

        public func validate(name: String) throws {
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetControlResponse: AWSDecodableShape {
        ///  The details of the control that the GetControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct GetDelegationsRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDelegationsResponse: AWSDecodableShape {
        ///  The list of delegations that the GetDelegations API returned.
        public let delegations: [DelegationMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(delegations: [DelegationMetadata]? = nil, nextToken: String? = nil) {
            self.delegations = delegations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case delegations = "delegations"
            case nextToken = "nextToken"
        }
    }

    public struct GetEvidenceByEvidenceFolderRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            request.encodePath(self.evidenceFolderId, key: "evidenceFolderId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceByEvidenceFolderResponse: AWSDecodableShape {
        ///  The list of evidence that the GetEvidenceByEvidenceFolder API returned.
        public let evidence: [Evidence]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidence: [Evidence]? = nil, nextToken: String? = nil) {
            self.evidence = evidence
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidence = "evidence"
            case nextToken = "nextToken"
        }
    }

    public struct GetEvidenceFileUploadUrlRequest: AWSEncodableShape {
        /// The file that you want to upload. For a list of supported file formats, see Supported file types for manual evidence in the Audit Manager User Guide.
        public let fileName: String

        public init(fileName: String) {
            self.fileName = fileName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.fileName, key: "fileName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, max: 300)
            try self.validate(self.fileName, name: "fileName", parent: name, min: 1)
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "^[^\\/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFileUploadUrlResponse: AWSDecodableShape {
        /// The name of the uploaded manual evidence file that the presigned URL was generated for.
        public let evidenceFileName: String?
        /// The presigned URL that was generated.
        public let uploadUrl: String?

        public init(evidenceFileName: String? = nil, uploadUrl: String? = nil) {
            self.evidenceFileName = evidenceFileName
            self.uploadUrl = uploadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFileName = "evidenceFileName"
            case uploadUrl = "uploadUrl"
        }
    }

    public struct GetEvidenceFolderRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            request.encodePath(self.evidenceFolderId, key: "evidenceFolderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFolderResponse: AWSDecodableShape {
        ///  The folder that the evidence is stored in.
        public let evidenceFolder: AssessmentEvidenceFolder?

        public init(evidenceFolder: AssessmentEvidenceFolder? = nil) {
            self.evidenceFolder = evidenceFolder
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolder = "evidenceFolder"
        }
    }

    public struct GetEvidenceFoldersByAssessmentControlRequest: AWSEncodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control.
        public let controlId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlId: String, controlSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.controlId, key: "controlId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFoldersByAssessmentControlResponse: AWSDecodableShape {
        ///  The list of evidence folders that the GetEvidenceFoldersByAssessmentControl API returned.
        public let evidenceFolders: [AssessmentEvidenceFolder]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidenceFolders: [AssessmentEvidenceFolder]? = nil, nextToken: String? = nil) {
            self.evidenceFolders = evidenceFolders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolders = "evidenceFolders"
            case nextToken = "nextToken"
        }
    }

    public struct GetEvidenceFoldersByAssessmentRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFoldersByAssessmentResponse: AWSDecodableShape {
        ///  The list of evidence folders that the GetEvidenceFoldersByAssessment API returned.
        public let evidenceFolders: [AssessmentEvidenceFolder]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidenceFolders: [AssessmentEvidenceFolder]? = nil, nextToken: String? = nil) {
            self.evidenceFolders = evidenceFolders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolders = "evidenceFolders"
            case nextToken = "nextToken"
        }
    }

    public struct GetEvidenceRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The unique identifier for the evidence.
        public let evidenceId: String

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String, evidenceId: String) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceId = evidenceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            request.encodePath(self.evidenceFolderId, key: "evidenceFolderId")
            request.encodePath(self.evidenceId, key: "evidenceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, max: 36)
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, min: 36)
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceResponse: AWSDecodableShape {
        ///  The evidence that the GetEvidence API returned.
        public let evidence: Evidence?

        public init(evidence: Evidence? = nil) {
            self.evidence = evidence
        }

        private enum CodingKeys: String, CodingKey {
            case evidence = "evidence"
        }
    }

    public struct GetInsightsByAssessmentRequest: AWSEncodableShape {
        /// The unique identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInsightsByAssessmentResponse: AWSDecodableShape {
        ///  The assessment analytics data that the GetInsightsByAssessment API returned.
        public let insights: InsightsByAssessment?

        public init(insights: InsightsByAssessment? = nil) {
            self.insights = insights
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "insights"
        }
    }

    public struct GetInsightsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInsightsResponse: AWSDecodableShape {
        /// The analytics data that the GetInsights API returned.
        public let insights: Insights?

        public init(insights: Insights? = nil) {
            self.insights = insights
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "insights"
        }
    }

    public struct GetOrganizationAdminAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetOrganizationAdminAccountResponse: AWSDecodableShape {
        ///  The identifier for the administrator account.
        public let adminAccountId: String?
        ///  The identifier for the organization.
        public let organizationId: String?

        public init(adminAccountId: String? = nil, organizationId: String? = nil) {
            self.adminAccountId = adminAccountId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
            case organizationId = "organizationId"
        }
    }

    public struct GetServicesInScopeRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetServicesInScopeResponse: AWSDecodableShape {
        ///  The metadata that's associated with the Amazon Web Service.
        public let serviceMetadata: [ServiceMetadata]?

        public init(serviceMetadata: [ServiceMetadata]? = nil) {
            self.serviceMetadata = serviceMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case serviceMetadata = "serviceMetadata"
        }
    }

    public struct GetSettingsRequest: AWSEncodableShape {
        ///  The list of setting attribute enum values.
        public let attribute: SettingAttribute

        public init(attribute: SettingAttribute) {
            self.attribute = attribute
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attribute, key: "attribute")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSettingsResponse: AWSDecodableShape {
        ///  The settings object that holds all supported Audit Manager settings.
        public let settings: Settings?

        public init(settings: Settings? = nil) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
        }
    }

    public struct Insights: AWSDecodableShape {
        /// The number of active assessments in Audit Manager.
        public let activeAssessmentsCount: Int?
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public let assessmentControlsCountByNoncompliantEvidence: Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The number of evidence without a compliance check ruling. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesn’t support compliance checks (for example: manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable, it's classed as inconclusive in Insights data.
        public let inconclusiveEvidenceCount: Int?
        /// The time when the cross-assessment insights were last updated.
        public let lastUpdated: Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?
        /// The total number of controls across all active assessments.
        public let totalAssessmentControlsCount: Int?

        public init(activeAssessmentsCount: Int? = nil, assessmentControlsCountByNoncompliantEvidence: Int? = nil, compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, lastUpdated: Date? = nil, noncompliantEvidenceCount: Int? = nil, totalAssessmentControlsCount: Int? = nil) {
            self.activeAssessmentsCount = activeAssessmentsCount
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case activeAssessmentsCount = "activeAssessmentsCount"
            case assessmentControlsCountByNoncompliantEvidence = "assessmentControlsCountByNoncompliantEvidence"
            case compliantEvidenceCount = "compliantEvidenceCount"
            case inconclusiveEvidenceCount = "inconclusiveEvidenceCount"
            case lastUpdated = "lastUpdated"
            case noncompliantEvidenceCount = "noncompliantEvidenceCount"
            case totalAssessmentControlsCount = "totalAssessmentControlsCount"
        }
    }

    public struct InsightsByAssessment: AWSDecodableShape {
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public let assessmentControlsCountByNoncompliantEvidence: Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The amount of evidence without a compliance check ruling. Evidence is inconclusive if the associated control uses Security Hub or Config as a data source and you didn't enable those services. This is also the case if a control uses a data source that doesn’t support compliance checks (for example, manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable, it's classified as inconclusive in InsightsByAssessment data.
        public let inconclusiveEvidenceCount: Int?
        /// The time when the assessment insights were last updated.
        public let lastUpdated: Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?
        /// The total number of controls in the assessment.
        public let totalAssessmentControlsCount: Int?

        public init(assessmentControlsCountByNoncompliantEvidence: Int? = nil, compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, lastUpdated: Date? = nil, noncompliantEvidenceCount: Int? = nil, totalAssessmentControlsCount: Int? = nil) {
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentControlsCountByNoncompliantEvidence = "assessmentControlsCountByNoncompliantEvidence"
            case compliantEvidenceCount = "compliantEvidenceCount"
            case inconclusiveEvidenceCount = "inconclusiveEvidenceCount"
            case lastUpdated = "lastUpdated"
            case noncompliantEvidenceCount = "noncompliantEvidenceCount"
            case totalAssessmentControlsCount = "totalAssessmentControlsCount"
        }
    }

    public struct ListAssessmentControlInsightsByControlDomainRequest: AWSEncodableShape {
        /// The unique identifier for the active assessment.
        public let assessmentId: String
        /// The unique identifier for the control domain.
        public let controlDomainId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlDomainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlDomainId = controlDomainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assessmentId, key: "assessmentId")
            request.encodeQuery(self.controlDomainId, key: "controlDomainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, max: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, min: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentControlInsightsByControlDomainResponse: AWSDecodableShape {
        /// The assessment control analytics data that the ListAssessmentControlInsightsByControlDomain API returned.
        public let controlInsightsByAssessment: [ControlInsightsMetadataByAssessmentItem]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlInsightsByAssessment: [ControlInsightsMetadataByAssessmentItem]? = nil, nextToken: String? = nil) {
            self.controlInsightsByAssessment = controlInsightsByAssessment
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlInsightsByAssessment = "controlInsightsByAssessment"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssessmentFrameworkShareRequestsRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(maxResults: Int? = nil, nextToken: String? = nil, requestType: ShareRequestType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.requestType = requestType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.requestType, key: "requestType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentFrameworkShareRequestsResponse: AWSDecodableShape {
        ///  The list of share requests that the ListAssessmentFrameworkShareRequests API returned.
        public let assessmentFrameworkShareRequests: [AssessmentFrameworkShareRequest]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentFrameworkShareRequests: [AssessmentFrameworkShareRequest]? = nil, nextToken: String? = nil) {
            self.assessmentFrameworkShareRequests = assessmentFrameworkShareRequests
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequests = "assessmentFrameworkShareRequests"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssessmentFrameworksRequest: AWSEncodableShape {
        ///  The type of framework, such as a standard framework or a custom framework.
        public let frameworkType: FrameworkType
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(frameworkType: FrameworkType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.frameworkType = frameworkType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.frameworkType, key: "frameworkType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentFrameworksResponse: AWSDecodableShape {
        ///  A list of metadata that the ListAssessmentFrameworks API returns for each framework.
        public let frameworkMetadataList: [AssessmentFrameworkMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(frameworkMetadataList: [AssessmentFrameworkMetadata]? = nil, nextToken: String? = nil) {
            self.frameworkMetadataList = frameworkMetadataList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkMetadataList = "frameworkMetadataList"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssessmentReportsRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentReportsResponse: AWSDecodableShape {
        ///  The list of assessment reports that the ListAssessmentReports API returned.
        public let assessmentReports: [AssessmentReportMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentReports: [AssessmentReportMetadata]? = nil, nextToken: String? = nil) {
            self.assessmentReports = assessmentReports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReports = "assessmentReports"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssessmentsRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The current status of the assessment.
        public let status: AssessmentStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: AssessmentStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentsResponse: AWSDecodableShape {
        /// The metadata that the ListAssessments API returns for each assessment.
        public let assessmentMetadata: [AssessmentMetadataItem]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentMetadata: [AssessmentMetadataItem]? = nil, nextToken: String? = nil) {
            self.assessmentMetadata = assessmentMetadata
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentMetadata = "assessmentMetadata"
            case nextToken = "nextToken"
        }
    }

    public struct ListControlDomainInsightsByAssessmentRequest: AWSEncodableShape {
        /// The unique identifier for the active assessment.
        public let assessmentId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assessmentId, key: "assessmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlDomainInsightsByAssessmentResponse: AWSDecodableShape {
        /// The control domain analytics data that the ListControlDomainInsightsByAssessment API returned.
        public let controlDomainInsights: [ControlDomainInsights]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainInsights: [ControlDomainInsights]? = nil, nextToken: String? = nil) {
            self.controlDomainInsights = controlDomainInsights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlDomainInsights = "controlDomainInsights"
            case nextToken = "nextToken"
        }
    }

    public struct ListControlDomainInsightsRequest: AWSEncodableShape {
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlDomainInsightsResponse: AWSDecodableShape {
        /// The control domain analytics data that the ListControlDomainInsights API returned.
        public let controlDomainInsights: [ControlDomainInsights]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainInsights: [ControlDomainInsights]? = nil, nextToken: String? = nil) {
            self.controlDomainInsights = controlDomainInsights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlDomainInsights = "controlDomainInsights"
            case nextToken = "nextToken"
        }
    }

    public struct ListControlInsightsByControlDomainRequest: AWSEncodableShape {
        /// The unique identifier for the control domain.
        public let controlDomainId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlDomainId = controlDomainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.controlDomainId, key: "controlDomainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, max: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, min: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlInsightsByControlDomainResponse: AWSDecodableShape {
        /// The control analytics data that the ListControlInsightsByControlDomain API returned.
        public let controlInsightsMetadata: [ControlInsightsMetadataItem]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlInsightsMetadata: [ControlInsightsMetadataItem]? = nil, nextToken: String? = nil) {
            self.controlInsightsMetadata = controlInsightsMetadata
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlInsightsMetadata = "controlInsightsMetadata"
            case nextToken = "nextToken"
        }
    }

    public struct ListControlsRequest: AWSEncodableShape {
        ///  The type of control, such as a standard control or a custom control.
        public let controlType: ControlType
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlType: ControlType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlType = controlType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.controlType, key: "controlType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlsResponse: AWSDecodableShape {
        ///  A list of metadata that the ListControls API returns for each control.
        public let controlMetadataList: [ControlMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlMetadataList: [ControlMetadata]? = nil, nextToken: String? = nil) {
            self.controlMetadataList = controlMetadataList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlMetadataList = "controlMetadataList"
            case nextToken = "nextToken"
        }
    }

    public struct ListKeywordsForDataSourceRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The control mapping data source that the keywords apply to.
        public let source: SourceType

        public init(maxResults: Int? = nil, nextToken: String? = nil, source: SourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.source = source
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.source, key: "source")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKeywordsForDataSourceResponse: AWSDecodableShape {
        ///  The list of keywords for the event mapping source.
        public let keywords: [String]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(keywords: [String]? = nil, nextToken: String? = nil) {
            self.keywords = keywords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case keywords = "keywords"
            case nextToken = "nextToken"
        }
    }

    public struct ListNotificationsRequest: AWSEncodableShape {
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationsResponse: AWSDecodableShape {
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The returned list of notifications.
        public let notifications: [Notification]?

        public init(nextToken: String? = nil, notifications: [Notification]? = nil) {
            self.nextToken = nextToken
            self.notifications = notifications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notifications = "notifications"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags that the ListTagsForResource API returned.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManualEvidence: AWSEncodableShape & AWSDecodableShape {
        /// The name of the file that's uploaded as manual evidence. This name is populated using the evidenceFileName value from the  GetEvidenceFileUploadUrl API response.
        public let evidenceFileName: String?
        /// The S3 URL of the object that's imported as manual evidence.
        public let s3ResourcePath: String?
        /// The plain text response that's entered and saved as manual evidence.
        public let textResponse: String?

        public init(evidenceFileName: String? = nil, s3ResourcePath: String? = nil, textResponse: String? = nil) {
            self.evidenceFileName = evidenceFileName
            self.s3ResourcePath = s3ResourcePath
            self.textResponse = textResponse
        }

        public func validate(name: String) throws {
            try self.validate(self.evidenceFileName, name: "evidenceFileName", parent: name, max: 300)
            try self.validate(self.evidenceFileName, name: "evidenceFileName", parent: name, min: 1)
            try self.validate(self.evidenceFileName, name: "evidenceFileName", parent: name, pattern: "^[^\\/]*$")
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, max: 1024)
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, min: 1)
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
            try self.validate(self.textResponse, name: "textResponse", parent: name, max: 1000)
            try self.validate(self.textResponse, name: "textResponse", parent: name, min: 1)
            try self.validate(self.textResponse, name: "textResponse", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFileName = "evidenceFileName"
            case s3ResourcePath = "s3ResourcePath"
            case textResponse = "textResponse"
        }
    }

    public struct Notification: AWSDecodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String?
        ///  The name of the related assessment.
        public let assessmentName: String?
        ///  The identifier for the control set.
        public let controlSetId: String?
        ///  Specifies the name of the control set that the notification is about.
        public let controlSetName: String?
        ///  The description of the notification.
        public let description: String?
        ///  The time when the notification was sent.
        public let eventTime: Date?
        ///  The unique identifier for the notification.
        public let id: String?
        ///  The sender of the notification.
        public let source: String?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, controlSetId: String? = nil, controlSetName: String? = nil, description: String? = nil, eventTime: Date? = nil, id: String? = nil, source: String? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetId = controlSetId
            self.controlSetName = controlSetName
            self.description = description
            self.eventTime = eventTime
            self.id = id
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
            case assessmentName = "assessmentName"
            case controlSetId = "controlSetId"
            case controlSetName = "controlSetName"
            case description = "description"
            case eventTime = "eventTime"
            case id = "id"
            case source = "source"
        }
    }

    public struct RegisterAccountRequest: AWSEncodableShape {
        ///  The delegated administrator account for Audit Manager.
        public let delegatedAdminAccount: String?
        ///  The KMS key details.
        public let kmsKey: String?

        public init(delegatedAdminAccount: String? = nil, kmsKey: String? = nil) {
            self.delegatedAdminAccount = delegatedAdminAccount
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^arn:.*:kms:.*|DEFAULT$")
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccount = "delegatedAdminAccount"
            case kmsKey = "kmsKey"
        }
    }

    public struct RegisterAccountResponse: AWSDecodableShape {
        ///  The status of the account registration request.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct RegisterOrganizationAdminAccountRequest: AWSEncodableShape {
        ///  The identifier for the delegated administrator account.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, max: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, min: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
        }
    }

    public struct RegisterOrganizationAdminAccountResponse: AWSDecodableShape {
        ///  The identifier for the delegated administrator account.
        public let adminAccountId: String?
        ///  The identifier for the organization.
        public let organizationId: String?

        public init(adminAccountId: String? = nil, organizationId: String? = nil) {
            self.adminAccountId = adminAccountId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
            case organizationId = "organizationId"
        }
    }

    public struct Resource: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) for the resource.
        public let arn: String?
        ///  The evaluation status for a resource that was assessed when collecting compliance check evidence.    Audit Manager classes the resource as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.   Audit Manager classes the resource as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.   If a compliance check isn't available or applicable, then no compliance evaluation can be made for that resource. This is the case if a resource assessment uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the resource assessment uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public let complianceCheck: String?
        ///  The value of the resource.
        public let value: String?

        public init(arn: String? = nil, complianceCheck: String? = nil, value: String? = nil) {
            self.arn = arn
            self.complianceCheck = complianceCheck
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case complianceCheck = "complianceCheck"
            case value = "value"
        }
    }

    public struct Role: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType

        public init(roleArn: String, roleType: RoleType) {
            self.roleArn = roleArn
            self.roleType = roleType
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*:iam:")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case roleType = "roleType"
        }
    }

    public struct Scope: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Web Services accounts that are included in the scope of the assessment.
        public let awsAccounts: [AWSAccount]?
        ///  The Amazon Web Services services that are included in the scope of the assessment.
        public let awsServices: [AWSService]?

        public init(awsAccounts: [AWSAccount]? = nil, awsServices: [AWSService]? = nil) {
            self.awsAccounts = awsAccounts
            self.awsServices = awsServices
        }

        public func validate(name: String) throws {
            try self.awsAccounts?.forEach {
                try $0.validate(name: "\(name).awsAccounts[]")
            }
            try self.validate(self.awsAccounts, name: "awsAccounts", parent: name, max: 200)
            try self.validate(self.awsAccounts, name: "awsAccounts", parent: name, min: 1)
            try self.awsServices?.forEach {
                try $0.validate(name: "\(name).awsServices[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccounts = "awsAccounts"
            case awsServices = "awsServices"
        }
    }

    public struct ServiceMetadata: AWSDecodableShape {
        ///  The category that the Amazon Web Service belongs to, such as compute, storage, or database.
        public let category: String?
        ///  The description of the Amazon Web Service.
        public let description: String?
        ///  The display name of the Amazon Web Service.
        public let displayName: String?
        ///  The name of the Amazon Web Service.
        public let name: String?

        public init(category: String? = nil, description: String? = nil, displayName: String? = nil, name: String? = nil) {
            self.category = category
            self.description = description
            self.displayName = displayName
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case description = "description"
            case displayName = "displayName"
            case name = "name"
        }
    }

    public struct Settings: AWSDecodableShape {
        /// The default S3 destination bucket for storing assessment reports.
        public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
        /// The default S3 destination bucket for storing evidence finder exports.
        public let defaultExportDestination: DefaultExportDestination?
        ///  The designated default audit owners.
        public let defaultProcessOwners: [Role]?
        /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
        public let deregistrationPolicy: DeregistrationPolicy?
        /// The current evidence finder status and event data store details.
        public let evidenceFinderEnablement: EvidenceFinderEnablement?
        ///  Specifies whether Organizations is enabled.
        public let isAwsOrgEnabled: Bool?
        ///  The KMS key details.
        public let kmsKey: String?
        ///  The designated Amazon Simple Notification Service (Amazon SNS) topic.
        public let snsTopic: String?

        public init(defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil, defaultExportDestination: DefaultExportDestination? = nil, defaultProcessOwners: [Role]? = nil, deregistrationPolicy: DeregistrationPolicy? = nil, evidenceFinderEnablement: EvidenceFinderEnablement? = nil, isAwsOrgEnabled: Bool? = nil, kmsKey: String? = nil, snsTopic: String? = nil) {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultExportDestination = defaultExportDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.deregistrationPolicy = deregistrationPolicy
            self.evidenceFinderEnablement = evidenceFinderEnablement
            self.isAwsOrgEnabled = isAwsOrgEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAssessmentReportsDestination = "defaultAssessmentReportsDestination"
            case defaultExportDestination = "defaultExportDestination"
            case defaultProcessOwners = "defaultProcessOwners"
            case deregistrationPolicy = "deregistrationPolicy"
            case evidenceFinderEnablement = "evidenceFinderEnablement"
            case isAwsOrgEnabled = "isAwsOrgEnabled"
            case kmsKey = "kmsKey"
            case snsTopic = "snsTopic"
        }
    }

    public struct SourceKeyword: AWSEncodableShape & AWSDecodableShape {
        ///  The input method for the keyword.     SELECT_FROM_LIST is used when mapping a data source for automated evidence.   When keywordInputType is SELECT_FROM_LIST, a keyword must be selected to collect automated evidence. For example, this keyword can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call.      UPLOAD_FILE and INPUT_TEXT are only used when mapping a data source for manual evidence.   When keywordInputType is UPLOAD_FILE, a file must be uploaded as manual evidence.   When keywordInputType is INPUT_TEXT, text must be entered as manual evidence.
        public let keywordInputType: KeywordInputType?
        ///  The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call.  If you’re mapping a data source to a rule in Config, the keywordValue that you specify depends on the type of rule:   For managed rules, you can use the rule identifier as the keywordValue. You can find the rule identifier from the list of Config managed rules. For some rules, the rule identifier is different from the rule name. For example, the rule name restricted-ssh has the following rule identifier: INCOMING_SSH_DISABLED. Make sure to use the rule identifier, not the rule name.  Keyword example for managed rules:   Managed rule name: s3-bucket-acl-prohibited   keywordValue: S3_BUCKET_ACL_PROHIBITED      For custom rules, you form the keywordValue by adding the Custom_ prefix to the rule name. This prefix distinguishes the custom rule from a managed rule.  Keyword example for custom rules:   Custom rule name: my-custom-config-rule  keywordValue: Custom_my-custom-config-rule      For service-linked rules, you form the keywordValue by adding the Custom_ prefix to the rule name. In addition, you remove the suffix ID that appears at the end of the rule name.  Keyword examples for service-linked rules:   Service-linked rule name: CustomRuleForAccount-conformance-pack-szsm1uv0w  keywordValue: Custom_CustomRuleForAccount-conformance-pack    Service-linked rule name: OrgConfigRule-s3-bucket-versioning-enabled-dbgzf8ba  keywordValue: Custom_OrgConfigRule-s3-bucket-versioning-enabled       The keywordValue is case sensitive. If you enter a value incorrectly, Audit Manager might not recognize the data source mapping. As a result, you might not successfully collect evidence from that data source as intended.  Keep in mind the following requirements, depending on the data source type that you're using.    For Config:    For managed rules, make sure that the keywordValue is the rule identifier in ALL_CAPS_WITH_UNDERSCORES. For example, CLOUDWATCH_LOG_GROUP_ENCRYPTED. For accuracy, we recommend that you reference the list of supported Config managed rules.   For custom rules, make sure that the keywordValue has the Custom_ prefix followed by the custom rule name. The format of the custom rule name itself may vary. For accuracy, we recommend that you visit the Config console to verify your custom rule name.     For Security Hub: The format varies for Security Hub control names. For accuracy, we recommend that you reference the list of supported Security Hub controls.   For Amazon Web Services API calls: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, iam_ListGroups. For accuracy, we recommend that you reference the list of supported API calls.   For CloudTrail: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, cloudtrail_StartLogging. For accuracy, we recommend that you review the Amazon Web Service prefix and action names in the Service Authorization Reference.
        public let keywordValue: String?

        public init(keywordInputType: KeywordInputType? = nil, keywordValue: String? = nil) {
            self.keywordInputType = keywordInputType
            self.keywordValue = keywordValue
        }

        public func validate(name: String) throws {
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, max: 100)
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, min: 1)
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, pattern: "^[a-zA-Z_0-9-\\s().]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keywordInputType = "keywordInputType"
            case keywordValue = "keywordValue"
        }
    }

    public struct StartAssessmentFrameworkShareRequest: AWSEncodableShape {
        ///  An optional comment from the sender about the share request.
        public let comment: String?
        ///  The Amazon Web Services account of the recipient.
        public let destinationAccount: String
        ///  The Amazon Web Services Region of the recipient.
        public let destinationRegion: String
        ///  The unique identifier for the custom framework to be shared.
        public let frameworkId: String

        public init(comment: String? = nil, destinationAccount: String, destinationRegion: String, frameworkId: String) {
            self.comment = comment
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.frameworkId = frameworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.comment, forKey: .comment)
            try container.encode(self.destinationAccount, forKey: .destinationAccount)
            try container.encode(self.destinationRegion, forKey: .destinationRegion)
            request.encodePath(self.frameworkId, key: "frameworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 500)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, max: 12)
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, min: 12)
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.destinationRegion, name: "destinationRegion", parent: name, pattern: "^[a-z]{2}-[a-z]+-[0-9]{1}$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case destinationAccount = "destinationAccount"
            case destinationRegion = "destinationRegion"
        }
    }

    public struct StartAssessmentFrameworkShareResponse: AWSDecodableShape {
        ///  The share request that's created by the StartAssessmentFrameworkShare API.
        public let assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest?

        public init(assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest? = nil) {
            self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequest = "assessmentFrameworkShareRequest"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        ///  The tags that are associated with the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct URL: AWSDecodableShape {
        ///  The name or word that's used as a hyperlink to the URL.
        public let hyperlinkName: String?
        ///  The unique identifier for the internet resource.
        public let link: String?

        public init(hyperlinkName: String? = nil, link: String? = nil) {
            self.hyperlinkName = hyperlinkName
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case hyperlinkName = "hyperlinkName"
            case link = "link"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the specified resource.
        public let resourceArn: String
        ///  The name or key of the tag.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssessmentControlRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The comment body text for the control.
        public let commentBody: String?
        ///  The unique identifier for the control.
        public let controlId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The status of the control.
        public let controlStatus: ControlStatus?

        public init(assessmentId: String, commentBody: String? = nil, controlId: String, controlSetId: String, controlStatus: ControlStatus? = nil) {
            self.assessmentId = assessmentId
            self.commentBody = commentBody
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.controlStatus = controlStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encodeIfPresent(self.commentBody, forKey: .commentBody)
            request.encodePath(self.controlId, key: "controlId")
            request.encodePath(self.controlSetId, key: "controlSetId")
            try container.encodeIfPresent(self.controlStatus, forKey: .controlStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.commentBody, name: "commentBody", parent: name, max: 500)
            try self.validate(self.commentBody, name: "commentBody", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case commentBody = "commentBody"
            case controlStatus = "controlStatus"
        }
    }

    public struct UpdateAssessmentControlResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateAssessmentControl API returned.
        public let control: AssessmentControl?

        public init(control: AssessmentControl? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct UpdateAssessmentControlSetStatusRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The comment that's related to the status update.
        public let comment: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The status of the control set that's being updated.
        public let status: ControlSetStatus

        public init(assessmentId: String, comment: String, controlSetId: String, status: ControlSetStatus) {
            self.assessmentId = assessmentId
            self.comment = comment
            self.controlSetId = controlSetId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.comment, forKey: .comment)
            request.encodePath(self.controlSetId, key: "controlSetId")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.comment, name: "comment", parent: name, max: 350)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 2048)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case status = "status"
        }
    }

    public struct UpdateAssessmentControlSetStatusResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateAssessmentControlSetStatus API returned.
        public let controlSet: AssessmentControlSet?

        public init(controlSet: AssessmentControlSet? = nil) {
            self.controlSet = controlSet
        }

        private enum CodingKeys: String, CodingKey {
            case controlSet = "controlSet"
        }
    }

    public struct UpdateAssessmentFrameworkControlSet: AWSEncodableShape {
        ///  The list of controls that are contained within the control set.
        public let controls: [CreateAssessmentFrameworkControl]
        ///  The unique identifier for the control set.
        public let id: String?
        ///  The name of the control set.
        public let name: String

        public init(controls: [CreateAssessmentFrameworkControl], id: String? = nil, name: String) {
            self.controls = controls
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.controls.forEach {
                try $0.validate(name: "\(name).controls[]")
            }
            try self.validate(self.controls, name: "controls", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 300)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[^\\\\\\_]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\\\_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "controls"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateAssessmentFrameworkRequest: AWSEncodableShape {
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [UpdateAssessmentFrameworkControlSet]
        ///  The description of the updated framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let frameworkId: String
        ///  The name of the framework to be updated.
        public let name: String

        public init(complianceType: String? = nil, controlSets: [UpdateAssessmentFrameworkControlSet], description: String? = nil, frameworkId: String, name: String) {
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.description = description
            self.frameworkId = frameworkId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.complianceType, forKey: .complianceType)
            try container.encode(self.controlSets, forKey: .controlSets)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.frameworkId, key: "frameworkId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, max: 100)
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlSets.forEach {
                try $0.validate(name: "\(name).controlSets[]")
            }
            try self.validate(self.controlSets, name: "controlSets", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "complianceType"
            case controlSets = "controlSets"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The name of the framework.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework = "framework"
        }
    }

    public struct UpdateAssessmentFrameworkShareRequest: AWSEncodableShape {
        /// Specifies the update action for the share request.
        public let action: ShareRequestAction
        ///  The unique identifier for the share request.
        public let requestId: String
        /// Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(action: ShareRequestAction, requestId: String, requestType: ShareRequestType) {
            self.action = action
            self.requestId = requestId
            self.requestType = requestType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            request.encodePath(self.requestId, key: "requestId")
            try container.encode(self.requestType, forKey: .requestType)
        }

        public func validate(name: String) throws {
            try self.validate(self.requestId, name: "requestId", parent: name, max: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case requestType = "requestType"
        }
    }

    public struct UpdateAssessmentFrameworkShareResponse: AWSDecodableShape {
        ///  The updated share request that's returned by the UpdateAssessmentFrameworkShare operation.
        public let assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest?

        public init(assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest? = nil) {
            self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequest = "assessmentFrameworkShareRequest"
        }
    }

    public struct UpdateAssessmentRequest: AWSEncodableShape {
        ///  The description of the assessment.
        public let assessmentDescription: String?
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The name of the assessment to be updated.
        public let assessmentName: String?
        ///  The assessment report storage destination for the assessment that's being updated.
        public let assessmentReportsDestination: AssessmentReportsDestination?
        ///  The list of roles for the assessment.
        public let roles: [Role]?
        ///  The scope of the assessment.
        public let scope: Scope

        public init(assessmentDescription: String? = nil, assessmentId: String, assessmentName: String? = nil, assessmentReportsDestination: AssessmentReportsDestination? = nil, roles: [Role]? = nil, scope: Scope) {
            self.assessmentDescription = assessmentDescription
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.assessmentReportsDestination = assessmentReportsDestination
            self.roles = roles
            self.scope = scope
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assessmentDescription, forKey: .assessmentDescription)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encodeIfPresent(self.assessmentName, forKey: .assessmentName)
            try container.encodeIfPresent(self.assessmentReportsDestination, forKey: .assessmentReportsDestination)
            try container.encodeIfPresent(self.roles, forKey: .roles)
            try container.encode(self.scope, forKey: .scope)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentDescription, name: "assessmentDescription", parent: name, max: 1000)
            try self.validate(self.assessmentDescription, name: "assessmentDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, max: 300)
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, min: 1)
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, pattern: "^[^\\\\]*$")
            try self.assessmentReportsDestination?.validate(name: "\(name).assessmentReportsDestination")
            try self.roles?.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
            try self.scope.validate(name: "\(name).scope")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentDescription = "assessmentDescription"
            case assessmentName = "assessmentName"
            case assessmentReportsDestination = "assessmentReportsDestination"
            case roles = "roles"
            case scope = "scope"
        }
    }

    public struct UpdateAssessmentResponse: AWSDecodableShape {
        ///  The response object for the UpdateAssessment API. This is the name of the updated assessment.
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment = "assessment"
        }
    }

    public struct UpdateAssessmentStatusRequest: AWSEncodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The current status of the assessment.
        public let status: AssessmentStatus

        public init(assessmentId: String, status: AssessmentStatus) {
            self.assessmentId = assessmentId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assessmentId, key: "assessmentId")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateAssessmentStatusResponse: AWSDecodableShape {
        ///  The name of the updated assessment that the UpdateAssessmentStatus API returned.
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment = "assessment"
        }
    }

    public struct UpdateControlRequest: AWSEncodableShape {
        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The identifier for the control.
        public let controlId: String
        ///  The data mapping sources for the control.
        public let controlMappingSources: [ControlMappingSource]
        ///  The optional description of the control.
        public let description: String?
        ///  The name of the updated control.
        public let name: String
        ///  The steps that you should follow to determine if the control is met.
        public let testingInformation: String?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, controlId: String, controlMappingSources: [ControlMappingSource], description: String? = nil, name: String, testingInformation: String? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.controlId = controlId
            self.controlMappingSources = controlMappingSources
            self.description = description
            self.name = name
            self.testingInformation = testingInformation
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionPlanInstructions, forKey: .actionPlanInstructions)
            try container.encodeIfPresent(self.actionPlanTitle, forKey: .actionPlanTitle)
            request.encodePath(self.controlId, key: "controlId")
            try container.encode(self.controlMappingSources, forKey: .controlMappingSources)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.testingInformation, forKey: .testingInformation)
        }

        public func validate(name: String) throws {
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, max: 1000)
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, max: 300)
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.controlMappingSources.forEach {
                try $0.validate(name: "\(name).controlMappingSources[]")
            }
            try self.validate(self.controlMappingSources, name: "controlMappingSources", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, max: 1000)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions = "actionPlanInstructions"
            case actionPlanTitle = "actionPlanTitle"
            case controlMappingSources = "controlMappingSources"
            case description = "description"
            case name = "name"
            case testingInformation = "testingInformation"
        }
    }

    public struct UpdateControlResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct UpdateSettingsRequest: AWSEncodableShape {
        ///  The default S3 destination bucket for storing assessment reports.
        public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
        ///  The default S3 destination bucket for storing evidence finder exports.
        public let defaultExportDestination: DefaultExportDestination?
        ///  A list of the default audit owners.
        public let defaultProcessOwners: [Role]?
        /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
        public let deregistrationPolicy: DeregistrationPolicy?
        /// Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.  When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to deregister and then re-register Audit Manager.
        public let evidenceFinderEnabled: Bool?
        ///  The KMS key details.
        public let kmsKey: String?
        ///  The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to.
        public let snsTopic: String?

        public init(defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil, defaultExportDestination: DefaultExportDestination? = nil, defaultProcessOwners: [Role]? = nil, deregistrationPolicy: DeregistrationPolicy? = nil, evidenceFinderEnabled: Bool? = nil, kmsKey: String? = nil, snsTopic: String? = nil) {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultExportDestination = defaultExportDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.deregistrationPolicy = deregistrationPolicy
            self.evidenceFinderEnabled = evidenceFinderEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }

        public func validate(name: String) throws {
            try self.defaultAssessmentReportsDestination?.validate(name: "\(name).defaultAssessmentReportsDestination")
            try self.defaultExportDestination?.validate(name: "\(name).defaultExportDestination")
            try self.defaultProcessOwners?.forEach {
                try $0.validate(name: "\(name).defaultProcessOwners[]")
            }
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^arn:.*:kms:.*|DEFAULT$")
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, max: 2048)
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, min: 4)
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, pattern: "^arn:.*:sns:.*|NONE$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAssessmentReportsDestination = "defaultAssessmentReportsDestination"
            case defaultExportDestination = "defaultExportDestination"
            case defaultProcessOwners = "defaultProcessOwners"
            case deregistrationPolicy = "deregistrationPolicy"
            case evidenceFinderEnabled = "evidenceFinderEnabled"
            case kmsKey = "kmsKey"
            case snsTopic = "snsTopic"
        }
    }

    public struct UpdateSettingsResponse: AWSDecodableShape {
        ///  The current list of settings.
        public let settings: Settings?

        public init(settings: Settings? = nil) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
        }
    }

    public struct ValidateAssessmentReportIntegrityRequest: AWSEncodableShape {
        ///  The relative path of the Amazon S3 bucket that the assessment report is stored in.
        public let s3RelativePath: String

        public init(s3RelativePath: String) {
            self.s3RelativePath = s3RelativePath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, max: 1024)
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, min: 1)
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3RelativePath = "s3RelativePath"
        }
    }

    public struct ValidateAssessmentReportIntegrityResponse: AWSDecodableShape {
        ///  The signature algorithm that's used to code sign the assessment report file.
        public let signatureAlgorithm: String?
        ///  The date and time signature that specifies when the assessment report was created.
        public let signatureDateTime: String?
        ///  The unique identifier for the validation signature key.
        public let signatureKeyId: String?
        ///  Specifies whether the signature key is valid.
        public let signatureValid: Bool?
        ///  Represents any errors that occurred when validating the assessment report.
        public let validationErrors: [String]?

        public init(signatureAlgorithm: String? = nil, signatureDateTime: String? = nil, signatureKeyId: String? = nil, signatureValid: Bool? = nil, validationErrors: [String]? = nil) {
            self.signatureAlgorithm = signatureAlgorithm
            self.signatureDateTime = signatureDateTime
            self.signatureKeyId = signatureKeyId
            self.signatureValid = signatureValid
            self.validationErrors = validationErrors
        }

        private enum CodingKeys: String, CodingKey {
            case signatureAlgorithm = "signatureAlgorithm"
            case signatureDateTime = "signatureDateTime"
            case signatureKeyId = "signatureKeyId"
            case signatureValid = "signatureValid"
            case validationErrors = "validationErrors"
        }
    }
}

// MARK: - Errors

/// Error enum for AuditManager
public struct AuditManagerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AuditManager
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  Your account isn't registered with Audit Manager. Check the delegated administrator setup on the Audit Manager settings page, and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  An internal service error occurred during the processing of your request. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The resource that's specified in the request can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You've reached your account quota for this resource type. To perform the requested action, delete some existing resources or request a quota increase from the Service Quotas console. For a list of Audit Manager service quotas, see Quotas and restrictions for Audit Manager.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The request has invalid or missing parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension AuditManagerErrorType: Equatable {
    public static func == (lhs: AuditManagerErrorType, rhs: AuditManagerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AuditManagerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
