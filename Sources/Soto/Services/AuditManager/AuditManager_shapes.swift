//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension AuditManager {
    // MARK: Enums

    public enum AccountStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case pendingActivation = "PENDING_ACTIVATION"
        public var description: String { return self.rawValue }
    }

    public enum ActionEnum: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case create = "CREATE"
        case delete = "DELETE"
        case importEvidence = "IMPORT_EVIDENCE"
        case inactive = "INACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        case updateMetadata = "UPDATE_METADATA"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentReportDestinationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentReportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ControlResponse: String, CustomStringConvertible, Codable, _SotoSendable {
        case `defer` = "DEFER"
        case automate = "AUTOMATE"
        case ignore = "IGNORE"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum ControlSetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case inactive = "INACTIVE"
        case reviewed = "REVIEWED"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum ControlType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "Custom"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum DelegationStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case complete = "COMPLETE"
        case inProgress = "IN_PROGRESS"
        case underReview = "UNDER_REVIEW"
        public var description: String { return self.rawValue }
    }

    public enum EvidenceFinderBackfillStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum EvidenceFinderEnablementStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case disabled = "DISABLED"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum FrameworkType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "Custom"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum KeywordInputType: String, CustomStringConvertible, Codable, _SotoSendable {
        case selectFromList = "SELECT_FROM_LIST"
        public var description: String { return self.rawValue }
    }

    public enum ObjectTypeEnum: String, CustomStringConvertible, Codable, _SotoSendable {
        case assessment = "ASSESSMENT"
        case assessmentReport = "ASSESSMENT_REPORT"
        case control = "CONTROL"
        case controlSet = "CONTROL_SET"
        case delegation = "DELEGATION"
        public var description: String { return self.rawValue }
    }

    public enum RoleType: String, CustomStringConvertible, Codable, _SotoSendable {
        case processOwner = "PROCESS_OWNER"
        case resourceOwner = "RESOURCE_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum SettingAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case defaultAssessmentReportsDestination = "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
        case defaultProcessOwners = "DEFAULT_PROCESS_OWNERS"
        case evidenceFinderEnablement = "EVIDENCE_FINDER_ENABLEMENT"
        case isAwsOrgEnabled = "IS_AWS_ORG_ENABLED"
        case snsTopic = "SNS_TOPIC"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case accept = "ACCEPT"
        case decline = "DECLINE"
        case revoke = "REVOKE"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case declined = "DECLINED"
        case expired = "EXPIRED"
        case expiring = "EXPIRING"
        case failed = "FAILED"
        case replicating = "REPLICATING"
        case revoked = "REVOKED"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum ShareRequestType: String, CustomStringConvertible, Codable, _SotoSendable {
        case received = "RECEIVED"
        case sent = "SENT"
        public var description: String { return self.rawValue }
    }

    public enum SourceFrequency: String, CustomStringConvertible, Codable, _SotoSendable {
        case daily = "DAILY"
        case monthly = "MONTHLY"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum SourceSetUpOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case proceduralControlsMapping = "Procedural_Controls_Mapping"
        case systemControlsMapping = "System_Controls_Mapping"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsApiCall = "AWS_API_Call"
        case awsCloudtrail = "AWS_Cloudtrail"
        case awsConfig = "AWS_Config"
        case awsSecurityHub = "AWS_Security_Hub"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSAccount: AWSEncodableShape & AWSDecodableShape {
        ///  The email address that's associated with the Amazon Web Services account.
        public let emailAddress: String?
        ///  The identifier for the Amazon Web Services account.
        public let id: String?
        ///  The name of the Amazon Web Services account.
        public let name: String?

        public init(emailAddress: String? = nil, id: String? = nil, name: String? = nil) {
            self.emailAddress = emailAddress
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 320)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^.*@.*$")
            try self.validate(self.id, name: "id", parent: name, max: 12)
            try self.validate(self.id, name: "id", parent: name, min: 12)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u007E]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress
            case id
            case name
        }
    }

    public struct AWSService: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the Amazon Web Service.
        public let serviceName: String?

        public init(serviceName: String? = nil) {
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 40)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "^[a-zA-Z0-9-\\s().]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName
        }
    }

    public struct Assessment: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the assessment.
        public let arn: String?
        ///  The Amazon Web Services account that's associated with the assessment.
        public let awsAccount: AWSAccount?
        ///  The framework that the assessment was created from.
        public let framework: AssessmentFramework?
        ///  The metadata for the assessment.
        public let metadata: AssessmentMetadata?
        ///  The tags that are associated with the assessment.
        public let tags: [String: String]?

        public init(arn: String? = nil, awsAccount: AWSAccount? = nil, framework: AssessmentFramework? = nil, metadata: AssessmentMetadata? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.awsAccount = awsAccount
            self.framework = framework
            self.metadata = metadata
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case awsAccount
            case framework
            case metadata
            case tags
        }
    }

    public struct AssessmentControl: AWSDecodableShape {
        ///  The amount of evidence in the assessment report.
        public let assessmentReportEvidenceCount: Int?
        ///  The list of comments that's attached to the control.
        public let comments: [ControlComment]?
        ///  The description of the control.
        public let description: String?
        ///  The amount of evidence that's generated for the control.
        public let evidenceCount: Int?
        ///  The list of data sources for the evidence.
        public let evidenceSources: [String]?
        ///  The identifier for the control.
        public let id: String?
        ///  The name of the control.
        public let name: String?
        ///  The response of the control.
        public let response: ControlResponse?
        ///  The status of the control.
        public let status: ControlStatus?

        public init(assessmentReportEvidenceCount: Int? = nil, comments: [ControlComment]? = nil, description: String? = nil, evidenceCount: Int? = nil, evidenceSources: [String]? = nil, id: String? = nil, name: String? = nil, response: ControlResponse? = nil, status: ControlStatus? = nil) {
            self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
            self.comments = comments
            self.description = description
            self.evidenceCount = evidenceCount
            self.evidenceSources = evidenceSources
            self.id = id
            self.name = name
            self.response = response
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportEvidenceCount
            case comments
            case description
            case evidenceCount
            case evidenceSources
            case id
            case name
            case response
            case status
        }
    }

    public struct AssessmentControlSet: AWSDecodableShape {
        ///  The list of controls that's contained with the control set.
        public let controls: [AssessmentControl]?
        ///  The delegations that are associated with the control set.
        public let delegations: [Delegation]?
        ///  The description for the control set.
        public let description: String?
        ///  The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public let id: String?
        ///  The total number of evidence objects that are uploaded manually to the control set.
        public let manualEvidenceCount: Int?
        ///  The roles that are associated with the control set.
        public let roles: [Role]?
        ///  Specifies the current status of the control set.
        public let status: ControlSetStatus?
        ///  The total number of evidence objects that are retrieved automatically for the control set.
        public let systemEvidenceCount: Int?

        public init(controls: [AssessmentControl]? = nil, delegations: [Delegation]? = nil, description: String? = nil, id: String? = nil, manualEvidenceCount: Int? = nil, roles: [Role]? = nil, status: ControlSetStatus? = nil, systemEvidenceCount: Int? = nil) {
            self.controls = controls
            self.delegations = delegations
            self.description = description
            self.id = id
            self.manualEvidenceCount = manualEvidenceCount
            self.roles = roles
            self.status = status
            self.systemEvidenceCount = systemEvidenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case controls
            case delegations
            case description
            case id
            case manualEvidenceCount
            case roles
            case status
            case systemEvidenceCount
        }
    }

    public struct AssessmentEvidenceFolder: AWSDecodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String?
        ///  The total count of evidence that's included in the assessment report.
        public let assessmentReportSelectionCount: Int?
        ///  The name of the user who created the evidence folder.
        public let author: String?
        ///  The unique identifier for the control.
        public let controlId: String?
        ///  The name of the control.
        public let controlName: String?
        ///  The identifier for the control set.
        public let controlSetId: String?
        ///  The Amazon Web Service that the evidence was collected from.
        public let dataSource: String?
        ///  The date when the first evidence was added to the evidence folder.
        public let date: Date?
        ///  The total number of Amazon Web Services resources that were assessed to generate the evidence.
        public let evidenceAwsServiceSourceCount: Int?
        ///  The number of evidence that falls under the compliance check category. This evidence is collected from Config or Security Hub.
        public let evidenceByTypeComplianceCheckCount: Int?
        ///  The total number of issues that were reported directly from Security Hub, Config, or both.
        public let evidenceByTypeComplianceCheckIssuesCount: Int?
        ///  The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other Amazon Web Services such as Amazon EC2, Amazon S3, or IAM.
        public let evidenceByTypeConfigurationDataCount: Int?
        ///  The number of evidence that falls under the manual category. This evidence is imported manually.
        public let evidenceByTypeManualCount: Int?
        ///  The number of evidence that falls under the user activity category. This evidence is collected from CloudTrail logs.
        public let evidenceByTypeUserActivityCount: Int?
        ///  The amount of evidence that's included in the evidence folder.
        public let evidenceResourcesIncludedCount: Int?
        ///  The identifier for the folder that the evidence is stored in.
        public let id: String?
        ///  The name of the evidence folder.
        public let name: String?
        ///  The total amount of evidence in the evidence folder.
        public let totalEvidence: Int?

        public init(assessmentId: String? = nil, assessmentReportSelectionCount: Int? = nil, author: String? = nil, controlId: String? = nil, controlName: String? = nil, controlSetId: String? = nil, dataSource: String? = nil, date: Date? = nil, evidenceAwsServiceSourceCount: Int? = nil, evidenceByTypeComplianceCheckCount: Int? = nil, evidenceByTypeComplianceCheckIssuesCount: Int? = nil, evidenceByTypeConfigurationDataCount: Int? = nil, evidenceByTypeManualCount: Int? = nil, evidenceByTypeUserActivityCount: Int? = nil, evidenceResourcesIncludedCount: Int? = nil, id: String? = nil, name: String? = nil, totalEvidence: Int? = nil) {
            self.assessmentId = assessmentId
            self.assessmentReportSelectionCount = assessmentReportSelectionCount
            self.author = author
            self.controlId = controlId
            self.controlName = controlName
            self.controlSetId = controlSetId
            self.dataSource = dataSource
            self.date = date
            self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
            self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
            self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
            self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
            self.evidenceByTypeManualCount = evidenceByTypeManualCount
            self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
            self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
            self.id = id
            self.name = name
            self.totalEvidence = totalEvidence
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentReportSelectionCount
            case author
            case controlId
            case controlName
            case controlSetId
            case dataSource
            case date
            case evidenceAwsServiceSourceCount
            case evidenceByTypeComplianceCheckCount
            case evidenceByTypeComplianceCheckIssuesCount
            case evidenceByTypeConfigurationDataCount
            case evidenceByTypeManualCount
            case evidenceByTypeUserActivityCount
            case evidenceResourcesIncludedCount
            case id
            case name
            case totalEvidence
        }
    }

    public struct AssessmentFramework: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [AssessmentControlSet]?
        ///  The unique identifier for the framework.
        public let id: String?
        public let metadata: FrameworkMetadata?

        public init(arn: String? = nil, controlSets: [AssessmentControlSet]? = nil, id: String? = nil, metadata: FrameworkMetadata? = nil) {
            self.arn = arn
            self.controlSets = controlSets
            self.id = id
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case controlSets
            case id
            case metadata
        }
    }

    public struct AssessmentFrameworkMetadata: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The number of controls that are associated with the framework.
        public let controlsCount: Int?
        ///  The number of control sets that are associated with the framework.
        public let controlSetsCount: Int?
        ///  Specifies when the framework was created.
        public let createdAt: Date?
        ///  The description of the framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let id: String?
        ///  Specifies when the framework was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?
        ///  The framework type, such as a standard framework or a custom framework.
        public let type: FrameworkType?

        public init(arn: String? = nil, complianceType: String? = nil, controlsCount: Int? = nil, controlSetsCount: Int? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, logo: String? = nil, name: String? = nil, type: FrameworkType? = nil) {
            self.arn = arn
            self.complianceType = complianceType
            self.controlsCount = controlsCount
            self.controlSetsCount = controlSetsCount
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.logo = logo
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case complianceType
            case controlsCount
            case controlSetsCount
            case createdAt
            case description
            case id
            case lastUpdatedAt
            case logo
            case name
            case type
        }
    }

    public struct AssessmentFrameworkShareRequest: AWSDecodableShape {
        ///  An optional comment from the sender about the share request.
        public let comment: String?
        /// The compliance type that the shared custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The time when the share request was created.
        public let creationTime: Date?
        /// The number of custom controls that are part of the shared custom framework.
        public let customControlsCount: Int?
        ///  The Amazon Web Services account of the recipient.
        public let destinationAccount: String?
        ///  The Amazon Web Services Region of the recipient.
        public let destinationRegion: String?
        ///  The time when the share request expires.
        public let expirationTime: Date?
        /// The description of the shared custom framework.
        public let frameworkDescription: String?
        /// The unique identifier for the shared custom framework.
        public let frameworkId: String?
        ///  The name of the custom framework that the share request is for.
        public let frameworkName: String?
        ///  The unique identifier for the share request.
        public let id: String?
        ///  Specifies when the share request was last updated.
        public let lastUpdated: Date?
        ///  The Amazon Web Services account of the sender.
        public let sourceAccount: String?
        /// The number of standard controls that are part of the shared custom framework.
        public let standardControlsCount: Int?
        ///  The status of the share request.
        public let status: ShareRequestStatus?

        public init(comment: String? = nil, complianceType: String? = nil, creationTime: Date? = nil, customControlsCount: Int? = nil, destinationAccount: String? = nil, destinationRegion: String? = nil, expirationTime: Date? = nil, frameworkDescription: String? = nil, frameworkId: String? = nil, frameworkName: String? = nil, id: String? = nil, lastUpdated: Date? = nil, sourceAccount: String? = nil, standardControlsCount: Int? = nil, status: ShareRequestStatus? = nil) {
            self.comment = comment
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.customControlsCount = customControlsCount
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.expirationTime = expirationTime
            self.frameworkDescription = frameworkDescription
            self.frameworkId = frameworkId
            self.frameworkName = frameworkName
            self.id = id
            self.lastUpdated = lastUpdated
            self.sourceAccount = sourceAccount
            self.standardControlsCount = standardControlsCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case complianceType
            case creationTime
            case customControlsCount
            case destinationAccount
            case destinationRegion
            case expirationTime
            case frameworkDescription
            case frameworkId
            case frameworkName
            case id
            case lastUpdated
            case sourceAccount
            case standardControlsCount
            case status
        }
    }

    public struct AssessmentMetadata: AWSDecodableShape {
        ///  The destination that evidence reports are stored in for the assessment.
        public let assessmentReportsDestination: AssessmentReportsDestination?
        ///  The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public let complianceType: String?
        ///  Specifies when the assessment was created.
        public let creationTime: Date?
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  The description of the assessment.
        public let description: String?
        ///  The unique identifier for the assessment.
        public let id: String?
        ///  The time of the most recent update.
        public let lastUpdated: Date?
        ///  The name of the assessment.
        public let name: String?
        ///  The roles that are associated with the assessment.
        public let roles: [Role]?
        ///  The wrapper of Amazon Web Services accounts and services that are in scope for the assessment.
        public let scope: Scope?
        ///  The overall status of the assessment.
        public let status: AssessmentStatus?

        public init(assessmentReportsDestination: AssessmentReportsDestination? = nil, complianceType: String? = nil, creationTime: Date? = nil, delegations: [Delegation]? = nil, description: String? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, roles: [Role]? = nil, scope: Scope? = nil, status: AssessmentStatus? = nil) {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.scope = scope
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportsDestination
            case complianceType
            case creationTime
            case delegations
            case description
            case id
            case lastUpdated
            case name
            case roles
            case scope
            case status
        }
    }

    public struct AssessmentMetadataItem: AWSDecodableShape {
        ///  The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public let complianceType: String?
        ///  Specifies when the assessment was created.
        public let creationTime: Date?
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  The unique identifier for the assessment.
        public let id: String?
        ///  The time of the most recent update.
        public let lastUpdated: Date?
        ///  The name of the assessment.
        public let name: String?
        ///  The roles that are associated with the assessment.
        public let roles: [Role]?
        ///  The current status of the assessment.
        public let status: AssessmentStatus?

        public init(complianceType: String? = nil, creationTime: Date? = nil, delegations: [Delegation]? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, roles: [Role]? = nil, status: AssessmentStatus? = nil) {
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType
            case creationTime
            case delegations
            case id
            case lastUpdated
            case name
            case roles
            case status
        }
    }

    public struct AssessmentReport: AWSDecodableShape {
        ///  The identifier for the specified assessment.
        public let assessmentId: String?
        ///  The name of the associated assessment.
        public let assessmentName: String?
        ///  The name of the user who created the assessment report.
        public let author: String?
        ///  The identifier for the specified Amazon Web Services account.
        public let awsAccountId: String?
        ///  Specifies when the assessment report was created.
        public let creationTime: Date?
        ///  The description of the specified assessment report.
        public let description: String?
        ///  The unique identifier for the assessment report.
        public let id: String?
        ///  The name that's given to the assessment report.
        public let name: String?
        ///  The current status of the specified assessment report.
        public let status: AssessmentReportStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, author: String? = nil, awsAccountId: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: AssessmentReportStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.awsAccountId = awsAccountId
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentName
            case author
            case awsAccountId
            case creationTime
            case description
            case id
            case name
            case status
        }
    }

    public struct AssessmentReportEvidenceError: AWSDecodableShape {
        ///  The error code that was returned.
        public let errorCode: String?
        ///  The error message that was returned.
        public let errorMessage: String?
        ///  The identifier for the evidence.
        public let evidenceId: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, evidenceId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evidenceId = evidenceId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case evidenceId
        }
    }

    public struct AssessmentReportMetadata: AWSDecodableShape {
        ///  The unique identifier for the associated assessment.
        public let assessmentId: String?
        /// The name of the associated assessment.
        public let assessmentName: String?
        ///  The name of the user who created the assessment report.
        public let author: String?
        ///  Specifies when the assessment report was created.
        public let creationTime: Date?
        ///  The description of the assessment report.
        public let description: String?
        ///  The unique identifier for the assessment report.
        public let id: String?
        ///  The name of the assessment report.
        public let name: String?
        ///  The current status of the assessment report.
        public let status: AssessmentReportStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, author: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: AssessmentReportStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentName
            case author
            case creationTime
            case description
            case id
            case name
            case status
        }
    }

    public struct AssessmentReportsDestination: AWSEncodableShape & AWSDecodableShape {
        ///  The destination of the assessment report.
        public let destination: String?
        ///  The destination type, such as Amazon S3.
        public let destinationType: AssessmentReportDestinationType?

        public init(destination: String? = nil, destinationType: AssessmentReportDestinationType? = nil) {
            self.destination = destination
            self.destinationType = destinationType
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination
            case destinationType
        }
    }

    public struct AssociateAssessmentReportEvidenceFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId
        }
    }

    public struct AssociateAssessmentReportEvidenceFolderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchAssociateAssessmentReportEvidenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]

        public init(assessmentId: String, evidenceFolderId: String, evidenceIds: [String]) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceIds = evidenceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.evidenceIds.forEach {
                try validate($0, name: "evidenceIds[]", parent: name, max: 36)
                try validate($0, name: "evidenceIds[]", parent: name, min: 36)
                try validate($0, name: "evidenceIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.evidenceIds, name: "evidenceIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId
            case evidenceIds
        }
    }

    public struct BatchAssociateAssessmentReportEvidenceResponse: AWSDecodableShape {
        ///  A list of errors that the BatchAssociateAssessmentReportEvidence API returned.
        public let errors: [AssessmentReportEvidenceError]?
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]?

        public init(errors: [AssessmentReportEvidenceError]? = nil, evidenceIds: [String]? = nil) {
            self.errors = errors
            self.evidenceIds = evidenceIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors
            case evidenceIds
        }
    }

    public struct BatchCreateDelegationByAssessmentError: AWSDecodableShape {
        ///  The API request to batch create delegations in Audit Manager.
        public let createDelegationRequest: CreateDelegationRequest?
        ///  The error code that the BatchCreateDelegationByAssessment API returned.
        public let errorCode: String?
        ///  The error message that the BatchCreateDelegationByAssessment API returned.
        public let errorMessage: String?

        public init(createDelegationRequest: CreateDelegationRequest? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
            self.createDelegationRequest = createDelegationRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case createDelegationRequest
            case errorCode
            case errorMessage
        }
    }

    public struct BatchCreateDelegationByAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The API request to batch create delegations in Audit Manager.
        public let createDelegationRequests: [CreateDelegationRequest]

        public init(assessmentId: String, createDelegationRequests: [CreateDelegationRequest]) {
            self.assessmentId = assessmentId
            self.createDelegationRequests = createDelegationRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.createDelegationRequests.forEach {
                try $0.validate(name: "\(name).createDelegationRequests[]")
            }
            try self.validate(self.createDelegationRequests, name: "createDelegationRequests", parent: name, max: 50)
            try self.validate(self.createDelegationRequests, name: "createDelegationRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case createDelegationRequests
        }
    }

    public struct BatchCreateDelegationByAssessmentResponse: AWSDecodableShape {
        ///  The delegations that are associated with the assessment.
        public let delegations: [Delegation]?
        ///  A list of errors that the BatchCreateDelegationByAssessment API returned.
        public let errors: [BatchCreateDelegationByAssessmentError]?

        public init(delegations: [Delegation]? = nil, errors: [BatchCreateDelegationByAssessmentError]? = nil) {
            self.delegations = delegations
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case delegations
            case errors
        }
    }

    public struct BatchDeleteDelegationByAssessmentError: AWSDecodableShape {
        ///  The identifier for the delegation.
        public let delegationId: String?
        ///  The error code that the BatchDeleteDelegationByAssessment API returned.
        public let errorCode: String?
        ///  The error message that the BatchDeleteDelegationByAssessment API returned.
        public let errorMessage: String?

        public init(delegationId: String? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
            self.delegationId = delegationId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case delegationId
            case errorCode
            case errorMessage
        }
    }

    public struct BatchDeleteDelegationByAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifiers for the delegations.
        public let delegationIds: [String]

        public init(assessmentId: String, delegationIds: [String]) {
            self.assessmentId = assessmentId
            self.delegationIds = delegationIds
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.delegationIds.forEach {
                try validate($0, name: "delegationIds[]", parent: name, max: 36)
                try validate($0, name: "delegationIds[]", parent: name, min: 36)
                try validate($0, name: "delegationIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.delegationIds, name: "delegationIds", parent: name, max: 50)
            try self.validate(self.delegationIds, name: "delegationIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delegationIds
        }
    }

    public struct BatchDeleteDelegationByAssessmentResponse: AWSDecodableShape {
        ///  A list of errors that the BatchDeleteDelegationByAssessment API returned.
        public let errors: [BatchDeleteDelegationByAssessmentError]?

        public init(errors: [BatchDeleteDelegationByAssessmentError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchDisassociateAssessmentReportEvidenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The list of evidence identifiers.
        public let evidenceIds: [String]

        public init(assessmentId: String, evidenceFolderId: String, evidenceIds: [String]) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceIds = evidenceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.evidenceIds.forEach {
                try validate($0, name: "evidenceIds[]", parent: name, max: 36)
                try validate($0, name: "evidenceIds[]", parent: name, min: 36)
                try validate($0, name: "evidenceIds[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.evidenceIds, name: "evidenceIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId
            case evidenceIds
        }
    }

    public struct BatchDisassociateAssessmentReportEvidenceResponse: AWSDecodableShape {
        ///  A list of errors that the BatchDisassociateAssessmentReportEvidence API returned.
        public let errors: [AssessmentReportEvidenceError]?
        ///  The identifier for the evidence.
        public let evidenceIds: [String]?

        public init(errors: [AssessmentReportEvidenceError]? = nil, evidenceIds: [String]? = nil) {
            self.errors = errors
            self.evidenceIds = evidenceIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors
            case evidenceIds
        }
    }

    public struct BatchImportEvidenceToAssessmentControlError: AWSDecodableShape {
        ///  The error code that the BatchImportEvidenceToAssessmentControl API returned.
        public let errorCode: String?
        ///  The error message that the BatchImportEvidenceToAssessmentControl API returned.
        public let errorMessage: String?
        ///  Manual evidence that can't be collected automatically by Audit Manager.
        public let manualEvidence: ManualEvidence?

        public init(errorCode: String? = nil, errorMessage: String? = nil, manualEvidence: ManualEvidence? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.manualEvidence = manualEvidence
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case manualEvidence
        }
    }

    public struct BatchImportEvidenceToAssessmentControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlId", location: .uri("controlId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control.
        public let controlId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  The list of manual evidence objects.
        public let manualEvidence: [ManualEvidence]

        public init(assessmentId: String, controlId: String, controlSetId: String, manualEvidence: [ManualEvidence]) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.manualEvidence = manualEvidence
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.manualEvidence.forEach {
                try $0.validate(name: "\(name).manualEvidence[]")
            }
            try self.validate(self.manualEvidence, name: "manualEvidence", parent: name, max: 50)
            try self.validate(self.manualEvidence, name: "manualEvidence", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case manualEvidence
        }
    }

    public struct BatchImportEvidenceToAssessmentControlResponse: AWSDecodableShape {
        ///  A list of errors that the BatchImportEvidenceToAssessmentControl API returned.
        public let errors: [BatchImportEvidenceToAssessmentControlError]?

        public init(errors: [BatchImportEvidenceToAssessmentControlError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct ChangeLog: AWSDecodableShape {
        ///  The action that was performed.
        public let action: ActionEnum?
        ///  The time when the action was performed and the changelog record was created.
        public let createdAt: Date?
        ///  The IAM user or role that performed the action.
        public let createdBy: String?
        ///  The name of the object that changed. This could be the name of an assessment, control, or control set.
        public let objectName: String?
        ///  The object that was changed, such as an assessment, control, or control set.
        public let objectType: ObjectTypeEnum?

        public init(action: ActionEnum? = nil, createdAt: Date? = nil, createdBy: String? = nil, objectName: String? = nil, objectType: ObjectTypeEnum? = nil) {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.objectName = objectName
            self.objectType = objectType
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case createdAt
            case createdBy
            case objectName
            case objectType
        }
    }

    public struct Control: AWSDecodableShape {
        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The Amazon Resource Name (ARN) of the control.
        public let arn: String?
        ///  The data mapping sources for the control.
        public let controlMappingSources: [ControlMappingSource]?
        ///  The data source types that determine where Audit Manager collects evidence from for the control.
        public let controlSources: String?
        ///  Specifies when the control was created.
        public let createdAt: Date?
        ///  The IAM user or role that created the control.
        public let createdBy: String?
        ///  The description of the control.
        public let description: String?
        ///  The unique identifier for the control.
        public let id: String?
        ///  Specifies when the control was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The IAM user or role that most recently updated the control.
        public let lastUpdatedBy: String?
        ///  The name of the control.
        public let name: String?
        ///  The tags associated with the control.
        public let tags: [String: String]?
        ///  The steps that you should follow to determine if the control has been satisfied.
        public let testingInformation: String?
        ///  The type of control, such as a custom control or a standard control.
        public let type: ControlType?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, arn: String? = nil, controlMappingSources: [ControlMappingSource]? = nil, controlSources: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, name: String? = nil, tags: [String: String]? = nil, testingInformation: String? = nil, type: ControlType? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.arn = arn
            self.controlMappingSources = controlMappingSources
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions
            case actionPlanTitle
            case arn
            case controlMappingSources
            case controlSources
            case createdAt
            case createdBy
            case description
            case id
            case lastUpdatedAt
            case lastUpdatedBy
            case name
            case tags
            case testingInformation
            case type
        }
    }

    public struct ControlComment: AWSDecodableShape {
        ///  The name of the user who authored the comment.
        public let authorName: String?
        ///  The body text of a control comment.
        public let commentBody: String?
        ///  The time when the comment was posted.
        public let postedDate: Date?

        public init(authorName: String? = nil, commentBody: String? = nil, postedDate: Date? = nil) {
            self.authorName = authorName
            self.commentBody = commentBody
            self.postedDate = postedDate
        }

        private enum CodingKeys: String, CodingKey {
            case authorName
            case commentBody
            case postedDate
        }
    }

    public struct ControlDomainInsights: AWSDecodableShape {
        /// The number of controls in the control domain that collected non-compliant evidence on the lastUpdated date.
        public let controlsCountByNoncompliantEvidence: Int?
        /// A breakdown of the compliance check status for the evidence thats associated with the control domain.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the control domain.
        public let id: String?
        /// The time when the control domain insights were last updated.
        public let lastUpdated: Date?
        /// The name of the control domain.
        public let name: String?
        /// The total number of controls in the control domain.
        public let totalControlsCount: Int?

        public init(controlsCountByNoncompliantEvidence: Int? = nil, evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil, totalControlsCount: Int? = nil) {
            self.controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidence
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.totalControlsCount = totalControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case controlsCountByNoncompliantEvidence
            case evidenceInsights
            case id
            case lastUpdated
            case name
            case totalControlsCount
        }
    }

    public struct ControlInsightsMetadataByAssessmentItem: AWSDecodableShape {
        /// The name of the control set that the assessment control belongs to.
        public let controlSetName: String?
        /// A breakdown of the compliance check status for the evidence thats associated with the assessment control.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the assessment control.
        public let id: String?
        /// The time when the assessment control insights were last updated.
        public let lastUpdated: Date?
        /// The name of the assessment control.
        public let name: String?

        public init(controlSetName: String? = nil, evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil) {
            self.controlSetName = controlSetName
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case controlSetName
            case evidenceInsights
            case id
            case lastUpdated
            case name
        }
    }

    public struct ControlInsightsMetadataItem: AWSDecodableShape {
        /// A breakdown of the compliance check status for the evidence thats associated with the control.
        public let evidenceInsights: EvidenceInsights?
        /// The unique identifier for the control.
        public let id: String?
        /// The time when the control insights were last updated.
        public let lastUpdated: Date?
        /// The name of the control.
        public let name: String?

        public init(evidenceInsights: EvidenceInsights? = nil, id: String? = nil, lastUpdated: Date? = nil, name: String? = nil) {
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceInsights
            case id
            case lastUpdated
            case name
        }
    }

    public struct ControlMappingSource: AWSEncodableShape & AWSDecodableShape {
        ///  The description of the source.
        public let sourceDescription: String?
        ///  The frequency of evidence collection for the control mapping source.
        public let sourceFrequency: SourceFrequency?
        ///  The unique identifier for the source.
        public let sourceId: String?
        public let sourceKeyword: SourceKeyword?
        ///  The name of the source.
        public let sourceName: String?
        ///  The setup option for the data source. This option reflects if the evidence collection is automated or manual.
        public let sourceSetUpOption: SourceSetUpOption?
        ///  Specifies one of the five types of data sources for evidence collection.
        public let sourceType: SourceType?
        ///  The instructions for troubleshooting the control.
        public let troubleshootingText: String?

        public init(sourceDescription: String? = nil, sourceFrequency: SourceFrequency? = nil, sourceId: String? = nil, sourceKeyword: SourceKeyword? = nil, sourceName: String? = nil, sourceSetUpOption: SourceSetUpOption? = nil, sourceType: SourceType? = nil, troubleshootingText: String? = nil) {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceId = sourceId
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, max: 1000)
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.sourceId, name: "sourceId", parent: name, max: 36)
            try self.validate(self.sourceId, name: "sourceId", parent: name, min: 36)
            try self.validate(self.sourceId, name: "sourceId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.sourceKeyword?.validate(name: "\(name).sourceKeyword")
            try self.validate(self.sourceName, name: "sourceName", parent: name, max: 100)
            try self.validate(self.sourceName, name: "sourceName", parent: name, min: 1)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, max: 1000)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDescription
            case sourceFrequency
            case sourceId
            case sourceKeyword
            case sourceName
            case sourceSetUpOption
            case sourceType
            case troubleshootingText
        }
    }

    public struct ControlMetadata: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the control.
        public let arn: String?
        ///  The data source that determines where Audit Manager collects evidence from for the control.
        public let controlSources: String?
        ///  Specifies when the control was created.
        public let createdAt: Date?
        ///  The unique identifier for the control.
        public let id: String?
        ///  Specifies when the control was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The name of the control.
        public let name: String?

        public init(arn: String? = nil, controlSources: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case controlSources
            case createdAt
            case id
            case lastUpdatedAt
            case name
        }
    }

    public struct ControlSet: AWSDecodableShape {
        ///  The list of controls within the control set.
        public let controls: [Control]?
        ///  The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public let id: String?
        ///  The name of the control set.
        public let name: String?

        public init(controls: [Control]? = nil, id: String? = nil, name: String? = nil) {
            self.controls = controls
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case controls
            case id
            case name
        }
    }

    public struct CreateAssessmentFrameworkControl: AWSEncodableShape {
        ///  The unique identifier of the control.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct CreateAssessmentFrameworkControlSet: AWSEncodableShape {
        ///  The list of controls within the control set. This doesn't contain the control set ID.
        public let controls: [CreateAssessmentFrameworkControl]?
        ///  The name of the control set.
        public let name: String

        public init(controls: [CreateAssessmentFrameworkControl]? = nil, name: String) {
            self.controls = controls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.controls?.forEach {
                try $0.validate(name: "\(name).controls[]")
            }
            try self.validate(self.controls, name: "controls", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\\\_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case controls
            case name
        }
    }

    public struct CreateAssessmentFrameworkRequest: AWSEncodableShape {
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [CreateAssessmentFrameworkControlSet]
        ///  An optional description for the new custom framework.
        public let description: String?
        ///  The name of the new custom framework.
        public let name: String
        ///  The tags that are associated with the framework.
        public let tags: [String: String]?

        public init(complianceType: String? = nil, controlSets: [CreateAssessmentFrameworkControlSet], description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, max: 100)
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlSets.forEach {
                try $0.validate(name: "\(name).controlSets[]")
            }
            try self.validate(self.controlSets, name: "controlSets", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType
            case controlSets
            case description
            case name
            case tags
        }
    }

    public struct CreateAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The name of the new framework that the CreateAssessmentFramework API returned.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework
        }
    }

    public struct CreateAssessmentReportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The description of the assessment report.
        public let description: String?
        ///  The name of the new assessment report.
        public let name: String
        /// A SQL statement that represents an evidence finder query. Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually added to a report using the console, or associated with a report using the API.  To use this parameter, the enablementStatus of evidence finder must be ENABLED.  For examples and help resolving queryStatement validation exceptions, see Troubleshooting evidence finder issues in the AWS Audit Manager User Guide.
        public let queryStatement: String?

        public init(assessmentId: String, description: String? = nil, name: String, queryStatement: String? = nil) {
            self.assessmentId = assessmentId
            self.description = description
            self.name = name
            self.queryStatement = queryStatement
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_\\.]+$")
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, max: 10000)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case queryStatement
        }
    }

    public struct CreateAssessmentReportResponse: AWSDecodableShape {
        ///  The new assessment report that the CreateAssessmentReport API returned.
        public let assessmentReport: AssessmentReport?

        public init(assessmentReport: AssessmentReport? = nil) {
            self.assessmentReport = assessmentReport
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReport
        }
    }

    public struct CreateAssessmentRequest: AWSEncodableShape {
        ///  The assessment report storage destination for the assessment that's being created.
        public let assessmentReportsDestination: AssessmentReportsDestination
        ///  The optional description of the assessment to be created.
        public let description: String?
        ///  The identifier for the framework that the assessment will be created from.
        public let frameworkId: String
        ///  The name of the assessment to be created.
        public let name: String
        ///  The list of roles for the assessment.
        public let roles: [Role]
        public let scope: Scope
        ///  The tags that are associated with the assessment.
        public let tags: [String: String]?

        public init(assessmentReportsDestination: AssessmentReportsDestination, description: String? = nil, frameworkId: String, name: String, roles: [Role], scope: Scope, tags: [String: String]? = nil) {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.description = description
            self.frameworkId = frameworkId
            self.name = name
            self.roles = roles
            self.scope = scope
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assessmentReportsDestination.validate(name: "\(name).assessmentReportsDestination")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.roles.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
            try self.scope.validate(name: "\(name).scope")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportsDestination
            case description
            case frameworkId
            case name
            case roles
            case scope
            case tags
        }
    }

    public struct CreateAssessmentResponse: AWSDecodableShape {
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment
        }
    }

    public struct CreateControlMappingSource: AWSEncodableShape {
        ///  The description of the data source that determines where Audit Manager collects evidence from for the control.
        public let sourceDescription: String?
        ///  The frequency of evidence collection for the control mapping source.
        public let sourceFrequency: SourceFrequency?
        public let sourceKeyword: SourceKeyword?
        ///  The name of the control mapping data source.
        public let sourceName: String?
        ///  The setup option for the data source, which reflects if the evidence collection is automated or manual.
        public let sourceSetUpOption: SourceSetUpOption?
        ///  Specifies one of the five types of data sources for evidence collection.
        public let sourceType: SourceType?
        ///  The instructions for troubleshooting the control.
        public let troubleshootingText: String?

        public init(sourceDescription: String? = nil, sourceFrequency: SourceFrequency? = nil, sourceKeyword: SourceKeyword? = nil, sourceName: String? = nil, sourceSetUpOption: SourceSetUpOption? = nil, sourceType: SourceType? = nil, troubleshootingText: String? = nil) {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, max: 1000)
            try self.validate(self.sourceDescription, name: "sourceDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.sourceKeyword?.validate(name: "\(name).sourceKeyword")
            try self.validate(self.sourceName, name: "sourceName", parent: name, max: 100)
            try self.validate(self.sourceName, name: "sourceName", parent: name, min: 1)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, max: 1000)
            try self.validate(self.troubleshootingText, name: "troubleshootingText", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDescription
            case sourceFrequency
            case sourceKeyword
            case sourceName
            case sourceSetUpOption
            case sourceType
            case troubleshootingText
        }
    }

    public struct CreateControlRequest: AWSEncodableShape {
        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The data mapping sources for the control.
        public let controlMappingSources: [CreateControlMappingSource]
        ///  The description of the control.
        public let description: String?
        ///  The name of the control.
        public let name: String
        ///  The tags that are associated with the control.
        public let tags: [String: String]?
        ///  The steps to follow to determine if the control is satisfied.
        public let testingInformation: String?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, controlMappingSources: [CreateControlMappingSource], description: String? = nil, name: String, tags: [String: String]? = nil, testingInformation: String? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.controlMappingSources = controlMappingSources
            self.description = description
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
        }

        public func validate(name: String) throws {
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, max: 1000)
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, max: 300)
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlMappingSources.forEach {
                try $0.validate(name: "\(name).controlMappingSources[]")
            }
            try self.validate(self.controlMappingSources, name: "controlMappingSources", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, max: 1000)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions
            case actionPlanTitle
            case controlMappingSources
            case description
            case name
            case tags
            case testingInformation
        }
    }

    public struct CreateControlResponse: AWSDecodableShape {
        ///  The new control that the CreateControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control
        }
    }

    public struct CreateDelegationRequest: AWSEncodableShape & AWSDecodableShape {
        ///  A comment that's related to the delegation request.
        public let comment: String?
        ///  The unique identifier for the control set.
        public let controlSetId: String?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType?

        public init(comment: String? = nil, controlSetId: String? = nil, roleArn: String? = nil, roleType: RoleType? = nil) {
            self.comment = comment
            self.controlSetId = controlSetId
            self.roleArn = roleArn
            self.roleType = roleType
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 350)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*:iam:")
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case controlSetId
            case roleArn
            case roleType
        }
    }

    public struct Delegation: AWSDecodableShape {
        ///  The identifier for the assessment that's associated with the delegation.
        public let assessmentId: String?
        ///  The name of the assessment that's associated with the delegation.
        public let assessmentName: String?
        ///  The comment that's related to the delegation.
        public let comment: String?
        ///  The identifier for the control set that's associated with the delegation.
        public let controlSetId: String?
        ///  The IAM user or role that created the delegation.
        public let createdBy: String?
        ///  Specifies when the delegation was created.
        public let creationTime: Date?
        ///  The unique identifier for the delegation.
        public let id: String?
        ///  Specifies when the delegation was last updated.
        public let lastUpdated: Date?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType?
        ///  The status of the delegation.
        public let status: DelegationStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, comment: String? = nil, controlSetId: String? = nil, createdBy: String? = nil, creationTime: Date? = nil, id: String? = nil, lastUpdated: Date? = nil, roleArn: String? = nil, roleType: RoleType? = nil, status: DelegationStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.comment = comment
            self.controlSetId = controlSetId
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.id = id
            self.lastUpdated = lastUpdated
            self.roleArn = roleArn
            self.roleType = roleType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentName
            case comment
            case controlSetId
            case createdBy
            case creationTime
            case id
            case lastUpdated
            case roleArn
            case roleType
            case status
        }
    }

    public struct DelegationMetadata: AWSDecodableShape {
        ///  The unique identifier for the assessment.
        public let assessmentId: String?
        ///  The name of the associated assessment.
        public let assessmentName: String?
        ///  Specifies the name of the control set that was delegated for review.
        public let controlSetName: String?
        ///  Specifies when the delegation was created.
        public let creationTime: Date?
        ///  The unique identifier for the delegation.
        public let id: String?
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String?
        ///  The current status of the delegation.
        public let status: DelegationStatus?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, controlSetName: String? = nil, creationTime: Date? = nil, id: String? = nil, roleArn: String? = nil, status: DelegationStatus? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetName = controlSetName
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentName
            case controlSetName
            case creationTime
            case id
            case roleArn
            case status
        }
    }

    public struct DeleteAssessmentFrameworkRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkId", location: .uri("frameworkId"))
        ]

        ///  The identifier for the custom framework.
        public let frameworkId: String

        public init(frameworkId: String) {
            self.frameworkId = frameworkId
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentFrameworkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentFrameworkShareRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "requestId", location: .uri("requestId")),
            AWSMemberEncoding(label: "requestType", location: .querystring("requestType"))
        ]

        /// The unique identifier for the share request to be deleted.
        public let requestId: String
        /// Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(requestId: String, requestType: ShareRequestType) {
            self.requestId = requestId
            self.requestType = requestType
        }

        public func validate(name: String) throws {
            try self.validate(self.requestId, name: "requestId", parent: name, max: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentFrameworkShareResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentReportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "assessmentReportId", location: .uri("assessmentReportId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the assessment report.
        public let assessmentReportId: String

        public init(assessmentId: String, assessmentReportId: String) {
            self.assessmentId = assessmentId
            self.assessmentReportId = assessmentReportId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, max: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, min: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentReportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssessmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlId", location: .uri("controlId"))
        ]

        ///  The unique identifier for the control.
        public let controlId: String

        public init(controlId: String) {
            self.controlId = controlId
        }

        public func validate(name: String) throws {
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeregisterAccountResponse: AWSDecodableShape {
        ///  The registration status of the account.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct DeregisterOrganizationAdminAccountRequest: AWSEncodableShape {
        ///  The identifier for the administrator account.
        public let adminAccountId: String?

        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, max: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, min: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
        }
    }

    public struct DeregisterOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateAssessmentReportEvidenceFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.evidenceFolderId = evidenceFolderId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolderId
        }
    }

    public struct DisassociateAssessmentReportEvidenceFolderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Evidence: AWSDecodableShape {
        ///  Specifies whether the evidence is included in the assessment report.
        public let assessmentReportSelection: String?
        ///  The names and values that are used by the evidence event. This includes an attribute name (such as allowUsersToChangePassword) and value (such as true or false).
        public let attributes: [String: String]?
        ///  The identifier for the Amazon Web Services account.
        public let awsAccountId: String?
        ///  The Amazon Web Services account that the evidence is collected from, and its organization path.
        public let awsOrganization: String?
        /// The evaluation status for automated evidence that falls under the compliance check category.   Audit Manager classes evidence as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.   Audit Manager classes evidence as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.   If a compliance check isn't available or applicable, then no compliance evaluation can be made for that evidence. This is the case if the evidence uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the evidence uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public let complianceCheck: String?
        ///  The data source where the evidence was collected from.
        public let dataSource: String?
        ///  The name of the evidence event.
        public let eventName: String?
        ///  The Amazon Web Service that the evidence is collected from.
        public let eventSource: String?
        ///  The identifier for the Amazon Web Services account.
        public let evidenceAwsAccountId: String?
        ///  The type of automated evidence.
        public let evidenceByType: String?
        ///  The identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String?
        ///  The unique identifier for the IAM user or role that's associated with the evidence.
        public let iamId: String?
        ///  The identifier for the evidence.
        public let id: String?
        ///  The list of resources that are assessed to generate the evidence.
        public let resourcesIncluded: [Resource]?
        ///  The timestamp that represents when the evidence was collected.
        public let time: Date?

        public init(assessmentReportSelection: String? = nil, attributes: [String: String]? = nil, awsAccountId: String? = nil, awsOrganization: String? = nil, complianceCheck: String? = nil, dataSource: String? = nil, eventName: String? = nil, eventSource: String? = nil, evidenceAwsAccountId: String? = nil, evidenceByType: String? = nil, evidenceFolderId: String? = nil, iamId: String? = nil, id: String? = nil, resourcesIncluded: [Resource]? = nil, time: Date? = nil) {
            self.assessmentReportSelection = assessmentReportSelection
            self.attributes = attributes
            self.awsAccountId = awsAccountId
            self.awsOrganization = awsOrganization
            self.complianceCheck = complianceCheck
            self.dataSource = dataSource
            self.eventName = eventName
            self.eventSource = eventSource
            self.evidenceAwsAccountId = evidenceAwsAccountId
            self.evidenceByType = evidenceByType
            self.evidenceFolderId = evidenceFolderId
            self.iamId = iamId
            self.id = id
            self.resourcesIncluded = resourcesIncluded
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportSelection
            case attributes
            case awsAccountId
            case awsOrganization
            case complianceCheck
            case dataSource
            case eventName
            case eventSource
            case evidenceAwsAccountId
            case evidenceByType
            case evidenceFolderId
            case iamId
            case id
            case resourcesIncluded
            case time
        }
    }

    public struct EvidenceFinderEnablement: AWSDecodableShape {
        /// The current status of the evidence data backfill process.  The backfill starts after you enable evidence finder. During this task, Audit Manager populates an event data store with your past evidence data so that your evidence can be queried.    NOT_STARTED means that the backfill hasnt started yet.     IN_PROGRESS means that the backfill is in progress. This can take up to 24 hours to complete, depending on the amount of evidence data.     COMPLETED means that the backfill is complete. All of your past evidence is now queryable.
        public let backfillStatus: EvidenceFinderBackfillStatus?
        /// The current status of the evidence finder feature and the related event data store.     ENABLE_IN_PROGRESS means that you requested to enable evidence finder. An event data store is currently being created to support evidence finder queries.    ENABLED means that an event data store was successfully created and evidence finder is enabled. We recommend that you wait 24 hours until the event data store is backfilled with your past evidence data. You can use evidence finder in the meantime, but not all data might be available until the backfill is complete.    DISABLE_IN_PROGRESS means that you requested to disable evidence finder, and your request is pending the deletion of the event data store.    DISABLED means that you have permanently disabled evidence finder and the event data store has been deleted. You can't re-enable evidence finder after this point.
        public let enablementStatus: EvidenceFinderEnablementStatus?
        /// Represents any errors that occurred when enabling or disabling evidence finder.
        public let error: String?
        /// The Amazon Resource Name (ARN) of the CloudTrail Lake event data store thats used by evidence finder. The event data store is the lake of evidence data that evidence finder runs queries against.
        public let eventDataStoreArn: String?

        public init(backfillStatus: EvidenceFinderBackfillStatus? = nil, enablementStatus: EvidenceFinderEnablementStatus? = nil, error: String? = nil, eventDataStoreArn: String? = nil) {
            self.backfillStatus = backfillStatus
            self.enablementStatus = enablementStatus
            self.error = error
            self.eventDataStoreArn = eventDataStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case backfillStatus
            case enablementStatus
            case error
            case eventDataStoreArn
        }
    }

    public struct EvidenceInsights: AWSDecodableShape {
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The number of evidence that a compliance check ruling isn't available for. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable in the console, it's classified as inconclusive in EvidenceInsights data.
        public let inconclusiveEvidenceCount: Int?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?

        public init(compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, noncompliantEvidenceCount: Int? = nil) {
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case compliantEvidenceCount
            case inconclusiveEvidenceCount
            case noncompliantEvidenceCount
        }
    }

    public struct Framework: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the framework.
        public let arn: String?
        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [ControlSet]?
        ///  The sources that Audit Manager collects evidence from for the control.
        public let controlSources: String?
        ///  Specifies when the framework was created.
        public let createdAt: Date?
        ///  The IAM user or role that created the framework.
        public let createdBy: String?
        ///  The description of the framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let id: String?
        ///  Specifies when the framework was most recently updated.
        public let lastUpdatedAt: Date?
        ///  The IAM user or role that most recently updated the framework.
        public let lastUpdatedBy: String?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?
        ///  The tags that are associated with the framework.
        public let tags: [String: String]?
        ///  The framework type, such as a custom framework or a standard framework.
        public let type: FrameworkType?

        public init(arn: String? = nil, complianceType: String? = nil, controlSets: [ControlSet]? = nil, controlSources: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, logo: String? = nil, name: String? = nil, tags: [String: String]? = nil, type: FrameworkType? = nil) {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.logo = logo
            self.name = name
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case complianceType
            case controlSets
            case controlSources
            case createdAt
            case createdBy
            case description
            case id
            case lastUpdatedAt
            case lastUpdatedBy
            case logo
            case name
            case tags
            case type
        }
    }

    public struct FrameworkMetadata: AWSDecodableShape {
        ///  The compliance standard that's associated with the framework. For example, this could be PCI DSS or HIPAA.
        public let complianceType: String?
        ///  The description of the framework.
        public let description: String?
        ///  The logo that's associated with the framework.
        public let logo: String?
        ///  The name of the framework.
        public let name: String?

        public init(complianceType: String? = nil, description: String? = nil, logo: String? = nil, name: String? = nil) {
            self.complianceType = complianceType
            self.description = description
            self.logo = logo
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType
            case description
            case logo
            case name
        }
    }

    public struct GetAccountStatusRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountStatusResponse: AWSDecodableShape {
        ///  The status of the Amazon Web Services account.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct GetAssessmentFrameworkRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkId", location: .uri("frameworkId"))
        ]

        ///  The identifier for the framework.
        public let frameworkId: String

        public init(frameworkId: String) {
            self.frameworkId = frameworkId
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The framework that the GetAssessmentFramework API returned.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework
        }
    }

    public struct GetAssessmentReportUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "assessmentReportId", location: .uri("assessmentReportId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the assessment report.
        public let assessmentReportId: String

        public init(assessmentId: String, assessmentReportId: String) {
            self.assessmentId = assessmentId
            self.assessmentReportId = assessmentReportId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, max: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, min: 36)
            try self.validate(self.assessmentReportId, name: "assessmentReportId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentReportUrlResponse: AWSDecodableShape {
        public let preSignedUrl: URL?

        public init(preSignedUrl: URL? = nil) {
            self.preSignedUrl = preSignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case preSignedUrl
        }
    }

    public struct GetAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        /// The unique identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentResponse: AWSDecodableShape {
        public let assessment: Assessment?
        public let userRole: Role?

        public init(assessment: Assessment? = nil, userRole: Role? = nil) {
            self.assessment = assessment
            self.userRole = userRole
        }

        private enum CodingKeys: String, CodingKey {
            case assessment
            case userRole
        }
    }

    public struct GetChangeLogsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlId", location: .querystring("controlId")),
            AWSMemberEncoding(label: "controlSetId", location: .querystring("controlSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control.
        public let controlId: String?
        ///  The unique identifier for the control set.
        public let controlSetId: String?
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlId: String? = nil, controlSetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChangeLogsResponse: AWSDecodableShape {
        /// The list of user activity for the control.
        public let changeLogs: [ChangeLog]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(changeLogs: [ChangeLog]? = nil, nextToken: String? = nil) {
            self.changeLogs = changeLogs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeLogs
            case nextToken
        }
    }

    public struct GetControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlId", location: .uri("controlId"))
        ]

        ///  The identifier for the control.
        public let controlId: String

        public init(controlId: String) {
            self.controlId = controlId
        }

        public func validate(name: String) throws {
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetControlResponse: AWSDecodableShape {
        ///  The name of the control that the GetControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control
        }
    }

    public struct GetDelegationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDelegationsResponse: AWSDecodableShape {
        ///  The list of delegations that the GetDelegations API returned.
        public let delegations: [DelegationMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(delegations: [DelegationMetadata]? = nil, nextToken: String? = nil) {
            self.delegations = delegations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case delegations
            case nextToken
        }
    }

    public struct GetEvidenceByEvidenceFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId")),
            AWSMemberEncoding(label: "evidenceFolderId", location: .uri("evidenceFolderId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceByEvidenceFolderResponse: AWSDecodableShape {
        ///  The list of evidence that the GetEvidenceByEvidenceFolder API returned.
        public let evidence: [Evidence]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidence: [Evidence]? = nil, nextToken: String? = nil) {
            self.evidence = evidence
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidence
            case nextToken
        }
    }

    public struct GetEvidenceFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId")),
            AWSMemberEncoding(label: "evidenceFolderId", location: .uri("evidenceFolderId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFolderResponse: AWSDecodableShape {
        ///  The folder that the evidence is stored in.
        public let evidenceFolder: AssessmentEvidenceFolder?

        public init(evidenceFolder: AssessmentEvidenceFolder? = nil) {
            self.evidenceFolder = evidenceFolder
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolder
        }
    }

    public struct GetEvidenceFoldersByAssessmentControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlId", location: .uri("controlId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The identifier for the assessment.
        public let assessmentId: String
        ///  The identifier for the control.
        public let controlId: String
        ///  The identifier for the control set.
        public let controlSetId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlId: String, controlSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFoldersByAssessmentControlResponse: AWSDecodableShape {
        ///  The list of evidence folders that the GetEvidenceFoldersByAssessmentControl API returned.
        public let evidenceFolders: [AssessmentEvidenceFolder]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidenceFolders: [AssessmentEvidenceFolder]? = nil, nextToken: String? = nil) {
            self.evidenceFolders = evidenceFolders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolders
            case nextToken
        }
    }

    public struct GetEvidenceFoldersByAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceFoldersByAssessmentResponse: AWSDecodableShape {
        ///  The list of evidence folders that the GetEvidenceFoldersByAssessment API returned.
        public let evidenceFolders: [AssessmentEvidenceFolder]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(evidenceFolders: [AssessmentEvidenceFolder]? = nil, nextToken: String? = nil) {
            self.evidenceFolders = evidenceFolders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceFolders
            case nextToken
        }
    }

    public struct GetEvidenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId")),
            AWSMemberEncoding(label: "evidenceFolderId", location: .uri("evidenceFolderId")),
            AWSMemberEncoding(label: "evidenceId", location: .uri("evidenceId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The unique identifier for the folder that the evidence is stored in.
        public let evidenceFolderId: String
        ///  The unique identifier for the evidence.
        public let evidenceId: String

        public init(assessmentId: String, controlSetId: String, evidenceFolderId: String, evidenceId: String) {
            self.assessmentId = assessmentId
            self.controlSetId = controlSetId
            self.evidenceFolderId = evidenceFolderId
            self.evidenceId = evidenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, max: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, min: 36)
            try self.validate(self.evidenceFolderId, name: "evidenceFolderId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, max: 36)
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, min: 36)
            try self.validate(self.evidenceId, name: "evidenceId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvidenceResponse: AWSDecodableShape {
        ///  The evidence that the GetEvidenceResponse API returned.
        public let evidence: Evidence?

        public init(evidence: Evidence? = nil) {
            self.evidence = evidence
        }

        private enum CodingKeys: String, CodingKey {
            case evidence
        }
    }

    public struct GetInsightsByAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        /// The unique identifier for the assessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInsightsByAssessmentResponse: AWSDecodableShape {
        ///  The assessment analytics data that the GetInsightsByAssessment API returned.
        public let insights: InsightsByAssessment?

        public init(insights: InsightsByAssessment? = nil) {
            self.insights = insights
        }

        private enum CodingKeys: String, CodingKey {
            case insights
        }
    }

    public struct GetInsightsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInsightsResponse: AWSDecodableShape {
        /// The analytics data that the GetInsights API returned.
        public let insights: Insights?

        public init(insights: Insights? = nil) {
            self.insights = insights
        }

        private enum CodingKeys: String, CodingKey {
            case insights
        }
    }

    public struct GetOrganizationAdminAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetOrganizationAdminAccountResponse: AWSDecodableShape {
        ///  The identifier for the administrator account.
        public let adminAccountId: String?
        ///  The identifier for the organization.
        public let organizationId: String?

        public init(adminAccountId: String? = nil, organizationId: String? = nil) {
            self.adminAccountId = adminAccountId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
            case organizationId
        }
    }

    public struct GetServicesInScopeRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetServicesInScopeResponse: AWSDecodableShape {
        ///  The metadata that's associated with the Amazon Web Service.
        public let serviceMetadata: [ServiceMetadata]?

        public init(serviceMetadata: [ServiceMetadata]? = nil) {
            self.serviceMetadata = serviceMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case serviceMetadata
        }
    }

    public struct GetSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "attribute", location: .uri("attribute"))
        ]

        ///  The list of SettingAttribute enum values.
        public let attribute: SettingAttribute

        public init(attribute: SettingAttribute) {
            self.attribute = attribute
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSettingsResponse: AWSDecodableShape {
        ///  The settings object that holds all supported Audit Manager settings.
        public let settings: Settings?

        public init(settings: Settings? = nil) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings
        }
    }

    public struct Insights: AWSDecodableShape {
        /// The number of active assessments in Audit Manager.
        public let activeAssessmentsCount: Int?
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public let assessmentControlsCountByNoncompliantEvidence: Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The number of evidence without a compliance check ruling. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example: manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable, it's classed as inconclusive in Insights data.
        public let inconclusiveEvidenceCount: Int?
        /// The time when the cross-assessment insights were last updated.
        public let lastUpdated: Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?
        /// The total number of controls across all active assessments.
        public let totalAssessmentControlsCount: Int?

        public init(activeAssessmentsCount: Int? = nil, assessmentControlsCountByNoncompliantEvidence: Int? = nil, compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, lastUpdated: Date? = nil, noncompliantEvidenceCount: Int? = nil, totalAssessmentControlsCount: Int? = nil) {
            self.activeAssessmentsCount = activeAssessmentsCount
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case activeAssessmentsCount
            case assessmentControlsCountByNoncompliantEvidence
            case compliantEvidenceCount
            case inconclusiveEvidenceCount
            case lastUpdated
            case noncompliantEvidenceCount
            case totalAssessmentControlsCount
        }
    }

    public struct InsightsByAssessment: AWSDecodableShape {
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public let assessmentControlsCountByNoncompliantEvidence: Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public let compliantEvidenceCount: Int?
        /// The amount of evidence without a compliance check ruling. Evidence is inconclusive if the associated control uses Security Hub or Config as a data source and you didn't enable those services. This is also the case if a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail).   If evidence has a compliance check status of not applicable, it's classified as inconclusive in InsightsByAssessment data.
        public let inconclusiveEvidenceCount: Int?
        /// The time when the assessment insights were last updated.
        public let lastUpdated: Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public let noncompliantEvidenceCount: Int?
        /// The total number of controls in the assessment.
        public let totalAssessmentControlsCount: Int?

        public init(assessmentControlsCountByNoncompliantEvidence: Int? = nil, compliantEvidenceCount: Int? = nil, inconclusiveEvidenceCount: Int? = nil, lastUpdated: Date? = nil, noncompliantEvidenceCount: Int? = nil, totalAssessmentControlsCount: Int? = nil) {
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentControlsCountByNoncompliantEvidence
            case compliantEvidenceCount
            case inconclusiveEvidenceCount
            case lastUpdated
            case noncompliantEvidenceCount
            case totalAssessmentControlsCount
        }
    }

    public struct ListAssessmentControlInsightsByControlDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .querystring("assessmentId")),
            AWSMemberEncoding(label: "controlDomainId", location: .querystring("controlDomainId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier for the active assessment.
        public let assessmentId: String
        /// The unique identifier for the control domain.
        public let controlDomainId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, controlDomainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.controlDomainId = controlDomainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, max: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, min: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentControlInsightsByControlDomainResponse: AWSDecodableShape {
        /// The assessment control analytics data that the ListAssessmentControlInsightsByControlDomain API returned.
        public let controlInsightsByAssessment: [ControlInsightsMetadataByAssessmentItem]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlInsightsByAssessment: [ControlInsightsMetadataByAssessmentItem]? = nil, nextToken: String? = nil) {
            self.controlInsightsByAssessment = controlInsightsByAssessment
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlInsightsByAssessment
            case nextToken
        }
    }

    public struct ListAssessmentFrameworkShareRequestsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "requestType", location: .querystring("requestType"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(maxResults: Int? = nil, nextToken: String? = nil, requestType: ShareRequestType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.requestType = requestType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentFrameworkShareRequestsResponse: AWSDecodableShape {
        ///  The list of share requests that the ListAssessmentFrameworkShareRequests API returned.
        public let assessmentFrameworkShareRequests: [AssessmentFrameworkShareRequest]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentFrameworkShareRequests: [AssessmentFrameworkShareRequest]? = nil, nextToken: String? = nil) {
            self.assessmentFrameworkShareRequests = assessmentFrameworkShareRequests
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequests
            case nextToken
        }
    }

    public struct ListAssessmentFrameworksRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkType", location: .querystring("frameworkType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The type of framework, such as a standard framework or a custom framework.
        public let frameworkType: FrameworkType
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(frameworkType: FrameworkType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.frameworkType = frameworkType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentFrameworksResponse: AWSDecodableShape {
        ///  The list of metadata objects for the framework.
        public let frameworkMetadataList: [AssessmentFrameworkMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(frameworkMetadataList: [AssessmentFrameworkMetadata]? = nil, nextToken: String? = nil) {
            self.frameworkMetadataList = frameworkMetadataList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkMetadataList
            case nextToken
        }
    }

    public struct ListAssessmentReportsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentReportsResponse: AWSDecodableShape {
        ///  The list of assessment reports that the ListAssessmentReports API returned.
        public let assessmentReports: [AssessmentReportMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentReports: [AssessmentReportMetadata]? = nil, nextToken: String? = nil) {
            self.assessmentReports = assessmentReports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReports
            case nextToken
        }
    }

    public struct ListAssessmentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring("status"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The current status of the assessment.
        public let status: AssessmentStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: AssessmentStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssessmentsResponse: AWSDecodableShape {
        ///  The metadata that's associated with the assessment.
        public let assessmentMetadata: [AssessmentMetadataItem]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentMetadata: [AssessmentMetadataItem]? = nil, nextToken: String? = nil) {
            self.assessmentMetadata = assessmentMetadata
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentMetadata
            case nextToken
        }
    }

    public struct ListControlDomainInsightsByAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .querystring("assessmentId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier for the active assessment.
        public let assessmentId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(assessmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assessmentId = assessmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlDomainInsightsByAssessmentResponse: AWSDecodableShape {
        /// The control domain analytics data that the ListControlDomainInsightsByAssessment API returned.
        public let controlDomainInsights: [ControlDomainInsights]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainInsights: [ControlDomainInsights]? = nil, nextToken: String? = nil) {
            self.controlDomainInsights = controlDomainInsights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlDomainInsights
            case nextToken
        }
    }

    public struct ListControlDomainInsightsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlDomainInsightsResponse: AWSDecodableShape {
        /// The control domain analytics data that the ListControlDomainInsights API returned.
        public let controlDomainInsights: [ControlDomainInsights]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainInsights: [ControlDomainInsights]? = nil, nextToken: String? = nil) {
            self.controlDomainInsights = controlDomainInsights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlDomainInsights
            case nextToken
        }
    }

    public struct ListControlInsightsByControlDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlDomainId", location: .querystring("controlDomainId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier for the control domain.
        public let controlDomainId: String
        /// Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlDomainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlDomainId = controlDomainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, max: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, min: 36)
            try self.validate(self.controlDomainId, name: "controlDomainId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlInsightsByControlDomainResponse: AWSDecodableShape {
        /// The control analytics data that the ListControlInsightsByControlDomain API returned.
        public let controlInsightsMetadata: [ControlInsightsMetadataItem]?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlInsightsMetadata: [ControlInsightsMetadataItem]? = nil, nextToken: String? = nil) {
            self.controlInsightsMetadata = controlInsightsMetadata
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlInsightsMetadata
            case nextToken
        }
    }

    public struct ListControlsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlType", location: .querystring("controlType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The type of control, such as a standard control or a custom control.
        public let controlType: ControlType
        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlType: ControlType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlType = controlType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlsResponse: AWSDecodableShape {
        ///  The list of control metadata objects that the ListControls API returned.
        public let controlMetadataList: [ControlMetadata]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(controlMetadataList: [ControlMetadata]? = nil, nextToken: String? = nil) {
            self.controlMetadataList = controlMetadataList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlMetadataList
            case nextToken
        }
    }

    public struct ListKeywordsForDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "source", location: .querystring("source"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The control mapping data source that the keywords apply to.
        public let source: SourceType

        public init(maxResults: Int? = nil, nextToken: String? = nil, source: SourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKeywordsForDataSourceResponse: AWSDecodableShape {
        ///  The list of keywords for the event mapping source.
        public let keywords: [String]?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(keywords: [String]? = nil, nextToken: String? = nil) {
            self.keywords = keywords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case keywords
            case nextToken
        }
    }

    public struct ListNotificationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  Represents the maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+\\/=]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationsResponse: AWSDecodableShape {
        ///  The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        ///  The returned list of notifications.
        public let notifications: [Notification]?

        public init(nextToken: String? = nil, notifications: [Notification]? = nil) {
            self.nextToken = nextToken
            self.notifications = notifications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case notifications
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags that the ListTagsForResource API returned.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ManualEvidence: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon S3 URL that points to a manual evidence object.
        public let s3ResourcePath: String?

        public init(s3ResourcePath: String? = nil) {
            self.s3ResourcePath = s3ResourcePath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, max: 1024)
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, min: 1)
            try self.validate(self.s3ResourcePath, name: "s3ResourcePath", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3ResourcePath
        }
    }

    public struct Notification: AWSDecodableShape {
        ///  The identifier for the assessment.
        public let assessmentId: String?
        ///  The name of the related assessment.
        public let assessmentName: String?
        ///  The identifier for the control set.
        public let controlSetId: String?
        ///  Specifies the name of the control set that the notification is about.
        public let controlSetName: String?
        ///  The description of the notification.
        public let description: String?
        ///  The time when the notification was sent.
        public let eventTime: Date?
        ///  The unique identifier for the notification.
        public let id: String?
        ///  The sender of the notification.
        public let source: String?

        public init(assessmentId: String? = nil, assessmentName: String? = nil, controlSetId: String? = nil, controlSetName: String? = nil, description: String? = nil, eventTime: Date? = nil, id: String? = nil, source: String? = nil) {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetId = controlSetId
            self.controlSetName = controlSetName
            self.description = description
            self.eventTime = eventTime
            self.id = id
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
            case assessmentName
            case controlSetId
            case controlSetName
            case description
            case eventTime
            case id
            case source
        }
    }

    public struct RegisterAccountRequest: AWSEncodableShape {
        ///  The delegated administrator account for Audit Manager.
        public let delegatedAdminAccount: String?
        ///  The KMS key details.
        public let kmsKey: String?

        public init(delegatedAdminAccount: String? = nil, kmsKey: String? = nil) {
            self.delegatedAdminAccount = delegatedAdminAccount
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccount, name: "delegatedAdminAccount", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^arn:.*:kms:.*|DEFAULT$")
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccount
            case kmsKey
        }
    }

    public struct RegisterAccountResponse: AWSDecodableShape {
        ///  The status of the account registration request.
        public let status: AccountStatus?

        public init(status: AccountStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct RegisterOrganizationAdminAccountRequest: AWSEncodableShape {
        ///  The identifier for the delegated administrator account.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, max: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, min: 12)
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
        }
    }

    public struct RegisterOrganizationAdminAccountResponse: AWSDecodableShape {
        ///  The identifier for the delegated administrator account.
        public let adminAccountId: String?
        ///  The identifier for the organization.
        public let organizationId: String?

        public init(adminAccountId: String? = nil, organizationId: String? = nil) {
            self.adminAccountId = adminAccountId
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
            case organizationId
        }
    }

    public struct Resource: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) for the resource.
        public let arn: String?
        ///  The evaluation status for a resource that was assessed when collecting compliance check evidence.    Audit Manager classes the resource as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.   Audit Manager classes the resource as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.   If a compliance check isn't available or applicable, then no compliance evaluation can be made for that resource. This is the case if a resource assessment uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the resource assessment uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public let complianceCheck: String?
        ///  The value of the resource.
        public let value: String?

        public init(arn: String? = nil, complianceCheck: String? = nil, value: String? = nil) {
            self.arn = arn
            self.complianceCheck = complianceCheck
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case complianceCheck
            case value
        }
    }

    public struct Role: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String
        ///  The type of customer persona.   In CreateAssessment, roleType can only be PROCESS_OWNER.  In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public let roleType: RoleType

        public init(roleArn: String, roleType: RoleType) {
            self.roleArn = roleArn
            self.roleType = roleType
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:.*:iam:")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case roleType
        }
    }

    public struct Scope: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Web Services accounts that are included in the scope of the assessment.
        public let awsAccounts: [AWSAccount]?
        ///  The Amazon Web Services services that are included in the scope of the assessment.
        public let awsServices: [AWSService]?

        public init(awsAccounts: [AWSAccount]? = nil, awsServices: [AWSService]? = nil) {
            self.awsAccounts = awsAccounts
            self.awsServices = awsServices
        }

        public func validate(name: String) throws {
            try self.awsAccounts?.forEach {
                try $0.validate(name: "\(name).awsAccounts[]")
            }
            try self.awsServices?.forEach {
                try $0.validate(name: "\(name).awsServices[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccounts
            case awsServices
        }
    }

    public struct ServiceMetadata: AWSDecodableShape {
        ///  The category that the Amazon Web Service belongs to, such as compute, storage, or database.
        public let category: String?
        ///  The description of the Amazon Web Service.
        public let description: String?
        ///  The display name of the Amazon Web Service.
        public let displayName: String?
        ///  The name of the Amazon Web Service.
        public let name: String?

        public init(category: String? = nil, description: String? = nil, displayName: String? = nil, name: String? = nil) {
            self.category = category
            self.description = description
            self.displayName = displayName
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case category
            case description
            case displayName
            case name
        }
    }

    public struct Settings: AWSDecodableShape {
        ///  The default storage destination for assessment reports.
        public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
        ///  The designated default audit owners.
        public let defaultProcessOwners: [Role]?
        /// The current evidence finder status and event data store details.
        public let evidenceFinderEnablement: EvidenceFinderEnablement?
        ///  Specifies whether Organizations is enabled.
        public let isAwsOrgEnabled: Bool?
        ///  The KMS key details.
        public let kmsKey: String?
        ///  The designated Amazon Simple Notification Service (Amazon SNS) topic.
        public let snsTopic: String?

        public init(defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil, defaultProcessOwners: [Role]? = nil, evidenceFinderEnablement: EvidenceFinderEnablement? = nil, isAwsOrgEnabled: Bool? = nil, kmsKey: String? = nil, snsTopic: String? = nil) {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.evidenceFinderEnablement = evidenceFinderEnablement
            self.isAwsOrgEnabled = isAwsOrgEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAssessmentReportsDestination
            case defaultProcessOwners
            case evidenceFinderEnablement
            case isAwsOrgEnabled
            case kmsKey
            case snsTopic
        }
    }

    public struct SourceKeyword: AWSEncodableShape & AWSDecodableShape {
        ///  The input method for the keyword.
        public let keywordInputType: KeywordInputType?
        ///  The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call.  If youre mapping a data source to a rule in Config, the keywordValue that you specify depends on the type of rule:   For managed rules, you can use the rule identifier as the keywordValue. You can find the rule identifier from the list of Config managed rules.   Managed rule name: s3-bucket-acl-prohibited   keywordValue: S3_BUCKET_ACL_PROHIBITED      For custom rules, you form the keywordValue by adding the Custom_ prefix to the rule name. This prefix distinguishes the rule from a managed rule.   Custom rule name: my-custom-config-rule  keywordValue: Custom_my-custom-config-rule      For service-linked rules, you form the keywordValue by adding the Custom_ prefix to the rule name. In addition, you remove the suffix ID that appears at the end of the rule name.   Service-linked rule name: CustomRuleForAccount-conformance-pack-szsm1uv0w  keywordValue: Custom_CustomRuleForAccount-conformance-pack    Service-linked rule name: OrgConfigRule-s3-bucket-versioning-enabled-dbgzf8ba  keywordValue: Custom_OrgConfigRule-s3-bucket-versioning-enabled
        public let keywordValue: String?

        public init(keywordInputType: KeywordInputType? = nil, keywordValue: String? = nil) {
            self.keywordInputType = keywordInputType
            self.keywordValue = keywordValue
        }

        public func validate(name: String) throws {
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, max: 100)
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, min: 1)
            try self.validate(self.keywordValue, name: "keywordValue", parent: name, pattern: "^[a-zA-Z_0-9-\\s().]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keywordInputType
            case keywordValue
        }
    }

    public struct StartAssessmentFrameworkShareRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkId", location: .uri("frameworkId"))
        ]

        ///  An optional comment from the sender about the share request.
        public let comment: String?
        ///  The Amazon Web Services account of the recipient.
        public let destinationAccount: String
        ///  The Amazon Web Services Region of the recipient.
        public let destinationRegion: String
        ///  The unique identifier for the custom framework to be shared.
        public let frameworkId: String

        public init(comment: String? = nil, destinationAccount: String, destinationRegion: String, frameworkId: String) {
            self.comment = comment
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.frameworkId = frameworkId
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 500)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, max: 12)
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, min: 12)
            try self.validate(self.destinationAccount, name: "destinationAccount", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.destinationRegion, name: "destinationRegion", parent: name, pattern: "^[a-z]{2}-[a-z]+-[0-9]{1}$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case destinationAccount
            case destinationRegion
        }
    }

    public struct StartAssessmentFrameworkShareResponse: AWSDecodableShape {
        ///  The share request that's created by the StartAssessmentFrameworkShare API.
        public let assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest?

        public init(assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest? = nil) {
            self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequest
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        ///  The tags that are associated with the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.{0,255}$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct URL: AWSDecodableShape {
        ///  The name or word that's used as a hyperlink to the URL.
        public let hyperlinkName: String?
        ///  The unique identifier for the internet resource.
        public let link: String?

        public init(hyperlinkName: String? = nil, link: String? = nil) {
            self.hyperlinkName = hyperlinkName
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case hyperlinkName
            case link
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        ///  The Amazon Resource Name (ARN) of the specified resource.
        public let resourceArn: String
        ///  The name or key of the tag.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*:auditmanager:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssessmentControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlId", location: .uri("controlId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The comment body text for the control.
        public let commentBody: String?
        ///  The unique identifier for the control.
        public let controlId: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The status of the control.
        public let controlStatus: ControlStatus?

        public init(assessmentId: String, commentBody: String? = nil, controlId: String, controlSetId: String, controlStatus: ControlStatus? = nil) {
            self.assessmentId = assessmentId
            self.commentBody = commentBody
            self.controlId = controlId
            self.controlSetId = controlSetId
            self.controlStatus = controlStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.commentBody, name: "commentBody", parent: name, max: 500)
            try self.validate(self.commentBody, name: "commentBody", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 300)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, min: 1)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case commentBody
            case controlStatus
        }
    }

    public struct UpdateAssessmentControlResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateAssessmentControl API returned.
        public let control: AssessmentControl?

        public init(control: AssessmentControl? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control
        }
    }

    public struct UpdateAssessmentControlSetStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId")),
            AWSMemberEncoding(label: "controlSetId", location: .uri("controlSetId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The comment that's related to the status update.
        public let comment: String
        ///  The unique identifier for the control set.
        public let controlSetId: String
        ///  The status of the control set that's being updated.
        public let status: ControlSetStatus

        public init(assessmentId: String, comment: String, controlSetId: String, status: ControlSetStatus) {
            self.assessmentId = assessmentId
            self.comment = comment
            self.controlSetId = controlSetId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.comment, name: "comment", parent: name, max: 350)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, max: 2048)
            try self.validate(self.controlSetId, name: "controlSetId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case status
        }
    }

    public struct UpdateAssessmentControlSetStatusResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateAssessmentControlSetStatus API returned.
        public let controlSet: AssessmentControlSet?

        public init(controlSet: AssessmentControlSet? = nil) {
            self.controlSet = controlSet
        }

        private enum CodingKeys: String, CodingKey {
            case controlSet
        }
    }

    public struct UpdateAssessmentFrameworkControlSet: AWSEncodableShape {
        ///  The list of controls that are contained within the control set.
        public let controls: [CreateAssessmentFrameworkControl]
        ///  The unique identifier for the control set.
        public let id: String?
        ///  The name of the control set.
        public let name: String

        public init(controls: [CreateAssessmentFrameworkControl], id: String? = nil, name: String) {
            self.controls = controls
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.controls.forEach {
                try $0.validate(name: "\(name).controls[]")
            }
            try self.validate(self.controls, name: "controls", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 300)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[^\\\\\\_]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\\\_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case controls
            case id
            case name
        }
    }

    public struct UpdateAssessmentFrameworkRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkId", location: .uri("frameworkId"))
        ]

        ///  The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public let complianceType: String?
        ///  The control sets that are associated with the framework.
        public let controlSets: [UpdateAssessmentFrameworkControlSet]
        ///  The description of the updated framework.
        public let description: String?
        ///  The unique identifier for the framework.
        public let frameworkId: String
        ///  The name of the framework to be updated.
        public let name: String

        public init(complianceType: String? = nil, controlSets: [UpdateAssessmentFrameworkControlSet], description: String? = nil, frameworkId: String, name: String) {
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.description = description
            self.frameworkId = frameworkId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, max: 100)
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.controlSets.forEach {
                try $0.validate(name: "\(name).controlSets[]")
            }
            try self.validate(self.controlSets, name: "controlSets", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, max: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, min: 36)
            try self.validate(self.frameworkId, name: "frameworkId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType
            case controlSets
            case description
            case name
        }
    }

    public struct UpdateAssessmentFrameworkResponse: AWSDecodableShape {
        ///  The name of the framework.
        public let framework: Framework?

        public init(framework: Framework? = nil) {
            self.framework = framework
        }

        private enum CodingKeys: String, CodingKey {
            case framework
        }
    }

    public struct UpdateAssessmentFrameworkShareRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "requestId", location: .uri("requestId"))
        ]

        /// Specifies the update action for the share request.
        public let action: ShareRequestAction
        ///  The unique identifier for the share request.
        public let requestId: String
        /// Specifies whether the share request is a sent request or a received request.
        public let requestType: ShareRequestType

        public init(action: ShareRequestAction, requestId: String, requestType: ShareRequestType) {
            self.action = action
            self.requestId = requestId
            self.requestType = requestType
        }

        public func validate(name: String) throws {
            try self.validate(self.requestId, name: "requestId", parent: name, max: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 36)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case requestType
        }
    }

    public struct UpdateAssessmentFrameworkShareResponse: AWSDecodableShape {
        ///  The updated share request that's returned by the UpdateAssessmentFrameworkShare operation.
        public let assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest?

        public init(assessmentFrameworkShareRequest: AssessmentFrameworkShareRequest? = nil) {
            self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentFrameworkShareRequest
        }
    }

    public struct UpdateAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The description of the assessment.
        public let assessmentDescription: String?
        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The name of the assessment to be updated.
        public let assessmentName: String?
        ///  The assessment report storage destination for the assessment that's being updated.
        public let assessmentReportsDestination: AssessmentReportsDestination?
        ///  The list of roles for the assessment.
        public let roles: [Role]?
        ///  The scope of the assessment.
        public let scope: Scope

        public init(assessmentDescription: String? = nil, assessmentId: String, assessmentName: String? = nil, assessmentReportsDestination: AssessmentReportsDestination? = nil, roles: [Role]? = nil, scope: Scope) {
            self.assessmentDescription = assessmentDescription
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.assessmentReportsDestination = assessmentReportsDestination
            self.roles = roles
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentDescription, name: "assessmentDescription", parent: name, max: 1000)
            try self.validate(self.assessmentDescription, name: "assessmentDescription", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, max: 300)
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, min: 1)
            try self.validate(self.assessmentName, name: "assessmentName", parent: name, pattern: "^[^\\\\]*$")
            try self.assessmentReportsDestination?.validate(name: "\(name).assessmentReportsDestination")
            try self.roles?.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
            try self.scope.validate(name: "\(name).scope")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentDescription
            case assessmentName
            case assessmentReportsDestination
            case roles
            case scope
        }
    }

    public struct UpdateAssessmentResponse: AWSDecodableShape {
        ///  The response object for the UpdateAssessmentRequest API. This is the name of the updated assessment.
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment
        }
    }

    public struct UpdateAssessmentStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assessmentId", location: .uri("assessmentId"))
        ]

        ///  The unique identifier for the assessment.
        public let assessmentId: String
        ///  The current status of the assessment.
        public let status: AssessmentStatus

        public init(assessmentId: String, status: AssessmentStatus) {
            self.assessmentId = assessmentId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, min: 36)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct UpdateAssessmentStatusResponse: AWSDecodableShape {
        ///  The name of the updated assessment that the UpdateAssessmentStatus API returned.
        public let assessment: Assessment?

        public init(assessment: Assessment? = nil) {
            self.assessment = assessment
        }

        private enum CodingKeys: String, CodingKey {
            case assessment
        }
    }

    public struct UpdateControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlId", location: .uri("controlId"))
        ]

        ///  The recommended actions to carry out if the control isn't fulfilled.
        public let actionPlanInstructions: String?
        ///  The title of the action plan for remediating the control.
        public let actionPlanTitle: String?
        ///  The identifier for the control.
        public let controlId: String
        ///  The data mapping sources for the control.
        public let controlMappingSources: [ControlMappingSource]
        ///  The optional description of the control.
        public let description: String?
        ///  The name of the updated control.
        public let name: String
        ///  The steps that you should follow to determine if the control is met.
        public let testingInformation: String?

        public init(actionPlanInstructions: String? = nil, actionPlanTitle: String? = nil, controlId: String, controlMappingSources: [ControlMappingSource], description: String? = nil, name: String, testingInformation: String? = nil) {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.controlId = controlId
            self.controlMappingSources = controlMappingSources
            self.description = description
            self.name = name
            self.testingInformation = testingInformation
        }

        public func validate(name: String) throws {
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, max: 1000)
            try self.validate(self.actionPlanInstructions, name: "actionPlanInstructions", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, max: 300)
            try self.validate(self.actionPlanTitle, name: "actionPlanTitle", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.controlId, name: "controlId", parent: name, max: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, min: 36)
            try self.validate(self.controlId, name: "controlId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.controlMappingSources.forEach {
                try $0.validate(name: "\(name).controlMappingSources[]")
            }
            try self.validate(self.controlMappingSources, name: "controlMappingSources", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\\\]*$")
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, max: 1000)
            try self.validate(self.testingInformation, name: "testingInformation", parent: name, pattern: "^[\\w\\W\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionPlanInstructions
            case actionPlanTitle
            case controlMappingSources
            case description
            case name
            case testingInformation
        }
    }

    public struct UpdateControlResponse: AWSDecodableShape {
        ///  The name of the updated control set that the UpdateControl API returned.
        public let control: Control?

        public init(control: Control? = nil) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control
        }
    }

    public struct UpdateSettingsRequest: AWSEncodableShape {
        ///  The default storage destination for assessment reports.
        public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
        ///  A list of the default audit owners.
        public let defaultProcessOwners: [Role]?
        /// Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.  When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to deregister and then re-register Audit Manager.  Disabling evidence finder is permanent, so consider this decision carefully before you proceed. If youre using Audit Manager as a delegated administrator, keep in mind that this action applies to all member accounts in your organization.
        public let evidenceFinderEnabled: Bool?
        ///  The KMS key details.
        public let kmsKey: String?
        ///  The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to.
        public let snsTopic: String?

        public init(defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil, defaultProcessOwners: [Role]? = nil, evidenceFinderEnabled: Bool? = nil, kmsKey: String? = nil, snsTopic: String? = nil) {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.evidenceFinderEnabled = evidenceFinderEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }

        public func validate(name: String) throws {
            try self.defaultAssessmentReportsDestination?.validate(name: "\(name).defaultAssessmentReportsDestination")
            try self.defaultProcessOwners?.forEach {
                try $0.validate(name: "\(name).defaultProcessOwners[]")
            }
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^arn:.*:kms:.*|DEFAULT$")
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, max: 2048)
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, min: 4)
            try self.validate(self.snsTopic, name: "snsTopic", parent: name, pattern: "^arn:.*:sns:.*|NONE$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAssessmentReportsDestination
            case defaultProcessOwners
            case evidenceFinderEnabled
            case kmsKey
            case snsTopic
        }
    }

    public struct UpdateSettingsResponse: AWSDecodableShape {
        ///  The current list of settings.
        public let settings: Settings?

        public init(settings: Settings? = nil) {
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case settings
        }
    }

    public struct ValidateAssessmentReportIntegrityRequest: AWSEncodableShape {
        ///  The relative path of the Amazon S3 bucket that the assessment report is stored in.
        public let s3RelativePath: String

        public init(s3RelativePath: String) {
            self.s3RelativePath = s3RelativePath
        }

        public func validate(name: String) throws {
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, max: 1024)
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, min: 1)
            try self.validate(self.s3RelativePath, name: "s3RelativePath", parent: name, pattern: "^(S|s)3:\\/\\/[a-zA-Z0-9\\-\\.\\(\\)\\'\\*\\_\\!\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3RelativePath
        }
    }

    public struct ValidateAssessmentReportIntegrityResponse: AWSDecodableShape {
        ///  The signature algorithm that's used to code sign the assessment report file.
        public let signatureAlgorithm: String?
        ///  The date and time signature that specifies when the assessment report was created.
        public let signatureDateTime: String?
        ///  The unique identifier for the validation signature key.
        public let signatureKeyId: String?
        ///  Specifies whether the signature key is valid.
        public let signatureValid: Bool?
        ///  Represents any errors that occurred when validating the assessment report.
        public let validationErrors: [String]?

        public init(signatureAlgorithm: String? = nil, signatureDateTime: String? = nil, signatureKeyId: String? = nil, signatureValid: Bool? = nil, validationErrors: [String]? = nil) {
            self.signatureAlgorithm = signatureAlgorithm
            self.signatureDateTime = signatureDateTime
            self.signatureKeyId = signatureKeyId
            self.signatureValid = signatureValid
            self.validationErrors = validationErrors
        }

        private enum CodingKeys: String, CodingKey {
            case signatureAlgorithm
            case signatureDateTime
            case signatureKeyId
            case signatureValid
            case validationErrors
        }
    }
}

// MARK: - Errors

/// Error enum for AuditManager
public struct AuditManagerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AuditManager
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  Your account isn&#39;t registered with Audit Manager. Check the delegated administrator setup on the Audit Manager settings page, and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  An internal service error occurred during the processing of your request. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The resource that&#39;s specified in the request can&#39;t be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You&#39;ve reached your account quota for this resource type. To perform the requested action, delete some existing resources or request a quota increase from the Service Quotas console. For a list of Audit Manager service quotas, see Quotas and restrictions for Audit Manager.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The request has invalid or missing parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension AuditManagerErrorType: Equatable {
    public static func == (lhs: AuditManagerErrorType, rhs: AuditManagerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AuditManagerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
