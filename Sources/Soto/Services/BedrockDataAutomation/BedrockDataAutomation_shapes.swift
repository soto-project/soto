//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockDataAutomation {
    // MARK: Enums

    public enum AudioExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioContentModeration = "AUDIO_CONTENT_MODERATION"
        case topicContentModeration = "TOPIC_CONTENT_MODERATION"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum AudioStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioSummary = "AUDIO_SUMMARY"
        case iab = "IAB"
        case topicSummary = "TOPIC_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintStage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintStageFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStageFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DocumentExtractionGranularityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case document = "DOCUMENT"
        case element = "ELEMENT"
        case line = "LINE"
        case page = "PAGE"
        case word = "WORD"
        public var description: String { return self.rawValue }
    }

    public enum DocumentOutputTextFormatType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case html = "HTML"
        case markdown = "MARKDOWN"
        case plainText = "PLAIN_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum ImageExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentModeration = "CONTENT_MODERATION"
        case logos = "LOGOS"
        case textDetection = "TEXT_DETECTION"
        public var description: String { return self.rawValue }
    }

    public enum ImageStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iab = "IAB"
        case imageSummary = "IMAGE_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum ResourceOwner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VideoExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentModeration = "CONTENT_MODERATION"
        case logos = "LOGOS"
        case textDetection = "TEXT_DETECTION"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum VideoStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chapterSummary = "CHAPTER_SUMMARY"
        case iab = "IAB"
        case videoSummary = "VIDEO_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case document = "DOCUMENT"
        case image = "IMAGE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AudioExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [AudioExtractionCategoryType]?

        @inlinable
        public init(state: State, types: [AudioExtractionCategoryType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct AudioStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let category: AudioExtractionCategory

        @inlinable
        public init(category: AudioExtractionCategory) {
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
        }
    }

    public struct AudioStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [AudioStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [AudioStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct AudioStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: AudioStandardExtraction?
        public let generativeField: AudioStandardGenerativeField?

        @inlinable
        public init(extraction: AudioStandardExtraction? = nil, generativeField: AudioStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }

    public struct Blueprint: AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintName: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String?
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        public let schema: String
        public let type: `Type`

        @inlinable
        public init(blueprintArn: String, blueprintName: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil, creationTime: Date, kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date, schema: String, type: `Type`) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.schema = schema
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
            case creationTime = "creationTime"
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
            case lastModifiedTime = "lastModifiedTime"
            case schema = "schema"
            case type = "type"
        }
    }

    public struct BlueprintFilter: AWSEncodableShape {
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct BlueprintItem: AWSEncodableShape & AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct BlueprintSummary: AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintName: String?
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?

        @inlinable
        public init(blueprintArn: String, blueprintName: String? = nil, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil, creationTime: Date, lastModifiedTime: Date? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
            case creationTime = "creationTime"
            case lastModifiedTime = "lastModifiedTime"
        }
    }

    public struct CreateBlueprintRequest: AWSEncodableShape {
        public let blueprintName: String
        public let blueprintStage: BlueprintStage?
        public let clientToken: String?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let schema: String
        public let tags: [Tag]?
        public let type: `Type`

        @inlinable
        public init(blueprintName: String, blueprintStage: BlueprintStage? = nil, clientToken: String? = CreateBlueprintRequest.idempotencyToken(), encryptionConfiguration: EncryptionConfiguration? = nil, schema: String, tags: [Tag]? = nil, type: `Type`) {
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.clientToken = clientToken
            self.encryptionConfiguration = encryptionConfiguration
            self.schema = schema
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, max: 128)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, min: 1)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.schema, name: "schema", parent: name, max: 100000)
            try self.validate(self.schema, name: "schema", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case clientToken = "clientToken"
            case encryptionConfiguration = "encryptionConfiguration"
            case schema = "schema"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct CreateBlueprintVersionRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        public let clientToken: String?

        @inlinable
        public init(blueprintArn: String, clientToken: String? = CreateBlueprintVersionRequest.idempotencyToken()) {
            self.blueprintArn = blueprintArn
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct CreateBlueprintVersionResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct CreateDataAutomationProjectRequest: AWSEncodableShape {
        public let clientToken: String?
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let overrideConfiguration: OverrideConfiguration?
        public let projectDescription: String?
        public let projectName: String
        public let projectStage: DataAutomationProjectStage?
        public let standardOutputConfiguration: StandardOutputConfiguration
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateDataAutomationProjectRequest.idempotencyToken(), customOutputConfiguration: CustomOutputConfiguration? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, overrideConfiguration: OverrideConfiguration? = nil, projectDescription: String? = nil, projectName: String, projectStage: DataAutomationProjectStage? = nil, standardOutputConfiguration: StandardOutputConfiguration, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.customOutputConfiguration = customOutputConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.overrideConfiguration = overrideConfiguration
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.standardOutputConfiguration = standardOutputConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.customOutputConfiguration?.validate(name: "\(name).customOutputConfiguration")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 300)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 128)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customOutputConfiguration = "customOutputConfiguration"
            case encryptionConfiguration = "encryptionConfiguration"
            case overrideConfiguration = "overrideConfiguration"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case projectStage = "projectStage"
            case standardOutputConfiguration = "standardOutputConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
            case status = "status"
        }
    }

    public struct CustomOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let blueprints: [BlueprintItem]?

        @inlinable
        public init(blueprints: [BlueprintItem]? = nil) {
            self.blueprints = blueprints
        }

        public func validate(name: String) throws {
            try self.blueprints?.forEach {
                try $0.validate(name: "\(name).blueprints[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "blueprints"
        }
    }

    public struct DataAutomationProject: AWSDecodableShape {
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String?
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        public let overrideConfiguration: OverrideConfiguration?
        public let projectArn: String
        public let projectDescription: String?
        public let projectName: String
        public let projectStage: DataAutomationProjectStage?
        public let standardOutputConfiguration: StandardOutputConfiguration?
        public let status: DataAutomationProjectStatus

        @inlinable
        public init(creationTime: Date, customOutputConfiguration: CustomOutputConfiguration? = nil, kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date, overrideConfiguration: OverrideConfiguration? = nil, projectArn: String, projectDescription: String? = nil, projectName: String, projectStage: DataAutomationProjectStage? = nil, standardOutputConfiguration: StandardOutputConfiguration? = nil, status: DataAutomationProjectStatus) {
            self.creationTime = creationTime
            self.customOutputConfiguration = customOutputConfiguration
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.standardOutputConfiguration = standardOutputConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case customOutputConfiguration = "customOutputConfiguration"
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
            case lastModifiedTime = "lastModifiedTime"
            case overrideConfiguration = "overrideConfiguration"
            case projectArn = "projectArn"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case projectStage = "projectStage"
            case standardOutputConfiguration = "standardOutputConfiguration"
            case status = "status"
        }
    }

    public struct DataAutomationProjectFilter: AWSEncodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
        }
    }

    public struct DataAutomationProjectSummary: AWSDecodableShape {
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let projectArn: String
        public let projectName: String?
        public let projectStage: DataAutomationProjectStage?

        @inlinable
        public init(creationTime: Date, projectArn: String, projectName: String? = nil, projectStage: DataAutomationProjectStage? = nil) {
            self.creationTime = creationTime
            self.projectArn = projectArn
            self.projectName = projectName
            self.projectStage = projectStage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case projectArn = "projectArn"
            case projectName = "projectName"
            case projectStage = "projectStage"
        }
    }

    public struct DeleteBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        /// Optional field to delete a specific Blueprint version
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintVersion = blueprintVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            request.encodeQuery(self.blueprintVersion, key: "blueprintVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBlueprintResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataAutomationProjectRequest: AWSEncodableShape {
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String

        @inlinable
        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectArn, key: "projectArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case status = "status"
        }
    }

    public struct DocumentBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentExtractionGranularity: AWSEncodableShape & AWSDecodableShape {
        public let types: [DocumentExtractionGranularityType]?

        @inlinable
        public init(types: [DocumentExtractionGranularityType]? = nil) {
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case types = "types"
        }
    }

    public struct DocumentOutputAdditionalFileFormat: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentOutputFormat: AWSEncodableShape & AWSDecodableShape {
        public let additionalFileFormat: DocumentOutputAdditionalFileFormat
        public let textFormat: DocumentOutputTextFormat

        @inlinable
        public init(additionalFileFormat: DocumentOutputAdditionalFileFormat, textFormat: DocumentOutputTextFormat) {
            self.additionalFileFormat = additionalFileFormat
            self.textFormat = textFormat
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFileFormat = "additionalFileFormat"
            case textFormat = "textFormat"
        }
    }

    public struct DocumentOutputTextFormat: AWSEncodableShape & AWSDecodableShape {
        public let types: [DocumentOutputTextFormatType]?

        @inlinable
        public init(types: [DocumentOutputTextFormatType]? = nil) {
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case types = "types"
        }
    }

    public struct DocumentOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let splitter: SplitterConfiguration?

        @inlinable
        public init(splitter: SplitterConfiguration? = nil) {
            self.splitter = splitter
        }

        private enum CodingKeys: String, CodingKey {
            case splitter = "splitter"
        }
    }

    public struct DocumentStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: DocumentBoundingBox
        public let granularity: DocumentExtractionGranularity

        @inlinable
        public init(boundingBox: DocumentBoundingBox, granularity: DocumentExtractionGranularity) {
            self.boundingBox = boundingBox
            self.granularity = granularity
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case granularity = "granularity"
        }
    }

    public struct DocumentStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: DocumentStandardExtraction?
        public let generativeField: DocumentStandardGenerativeField?
        public let outputFormat: DocumentOutputFormat?

        @inlinable
        public init(extraction: DocumentStandardExtraction? = nil, generativeField: DocumentStandardGenerativeField? = nil, outputFormat: DocumentOutputFormat? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
            self.outputFormat = outputFormat
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
            case outputFormat = "outputFormat"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape {
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String

        @inlinable
        public init(kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String) {
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.kmsEncryptionContext?.forEach {
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, max: 2000)
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, min: 1)
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, pattern: "^.*\\S.*$")
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, max: 2000)
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^.*\\S.*$")
            }
            try self.validate(self.kmsEncryptionContext, name: "kmsEncryptionContext", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct GetBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        /// Optional field to get a specific Blueprint stage
        public let blueprintStage: BlueprintStage?
        /// Optional field to get a specific Blueprint version
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.blueprintStage, forKey: .blueprintStage)
            try container.encodeIfPresent(self.blueprintVersion, forKey: .blueprintVersion)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct GetBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct GetDataAutomationProjectRequest: AWSEncodableShape {
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String
        /// Optional field to delete a specific DataAutomationProject stage
        public let projectStage: DataAutomationProjectStage?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectArn, key: "projectArn")
            try container.encodeIfPresent(self.projectStage, forKey: .projectStage)
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectStage = "projectStage"
        }
    }

    public struct GetDataAutomationProjectResponse: AWSDecodableShape {
        public let project: DataAutomationProject

        @inlinable
        public init(project: DataAutomationProject) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct ImageBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct ImageExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [ImageExtractionCategoryType]?

        @inlinable
        public init(state: State, types: [ImageExtractionCategoryType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct ImageStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: ImageBoundingBox
        public let category: ImageExtractionCategory

        @inlinable
        public init(boundingBox: ImageBoundingBox, category: ImageExtractionCategory) {
            self.boundingBox = boundingBox
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case category = "category"
        }
    }

    public struct ImageStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [ImageStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [ImageStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct ImageStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: ImageStandardExtraction?
        public let generativeField: ImageStandardGenerativeField?

        @inlinable
        public init(extraction: ImageStandardExtraction? = nil, generativeField: ImageStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }

    public struct ListBlueprintsRequest: AWSEncodableShape {
        public let blueprintArn: String?
        public let blueprintStageFilter: BlueprintStageFilter?
        public let maxResults: Int?
        public let nextToken: String?
        public let projectFilter: DataAutomationProjectFilter?
        public let resourceOwner: ResourceOwner?

        @inlinable
        public init(blueprintArn: String? = nil, blueprintStageFilter: BlueprintStageFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectFilter: DataAutomationProjectFilter? = nil, resourceOwner: ResourceOwner? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStageFilter = blueprintStageFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectFilter = projectFilter
            self.resourceOwner = resourceOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.projectFilter?.validate(name: "\(name).projectFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStageFilter = "blueprintStageFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case projectFilter = "projectFilter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListBlueprintsResponse: AWSDecodableShape {
        public let blueprints: [BlueprintSummary]
        public let nextToken: String?

        @inlinable
        public init(blueprints: [BlueprintSummary], nextToken: String? = nil) {
            self.blueprints = blueprints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "blueprints"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataAutomationProjectsRequest: AWSEncodableShape {
        public let blueprintFilter: BlueprintFilter?
        public let maxResults: Int?
        public let nextToken: String?
        public let projectStageFilter: DataAutomationProjectStageFilter?
        public let resourceOwner: ResourceOwner?

        @inlinable
        public init(blueprintFilter: BlueprintFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectStageFilter: DataAutomationProjectStageFilter? = nil, resourceOwner: ResourceOwner? = nil) {
            self.blueprintFilter = blueprintFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectStageFilter = projectStageFilter
            self.resourceOwner = resourceOwner
        }

        public func validate(name: String) throws {
            try self.blueprintFilter?.validate(name: "\(name).blueprintFilter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintFilter = "blueprintFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case projectStageFilter = "projectStageFilter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListDataAutomationProjectsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let projects: [DataAutomationProjectSummary]

        @inlinable
        public init(nextToken: String? = nil, projects: [DataAutomationProjectSummary]) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projects = "projects"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project)/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct OverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let document: DocumentOverrideConfiguration?

        @inlinable
        public init(document: DocumentOverrideConfiguration? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct SplitterConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let state: State?

        @inlinable
        public init(state: State? = nil) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct StandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let audio: AudioStandardOutputConfiguration?
        public let document: DocumentStandardOutputConfiguration?
        public let image: ImageStandardOutputConfiguration?
        public let video: VideoStandardOutputConfiguration?

        @inlinable
        public init(audio: AudioStandardOutputConfiguration? = nil, document: DocumentStandardOutputConfiguration? = nil, image: ImageStandardOutputConfiguration? = nil, video: VideoStandardOutputConfiguration? = nil) {
            self.audio = audio
            self.document = document
            self.image = image
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "audio"
            case document = "document"
            case image = "image"
            case video = "video"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        public let key: String
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public let resourceARN: String
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project)/[a-zA-Z0-9-]{12,36}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public let resourceARN: String
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project)/[a-zA-Z0-9-]{12,36}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let schema: String

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, schema: String) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.encryptionConfiguration = encryptionConfiguration
            self.schema = schema
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.blueprintStage, forKey: .blueprintStage)
            try container.encodeIfPresent(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            try container.encode(self.schema, forKey: .schema)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.schema, name: "schema", parent: name, max: 100000)
            try self.validate(self.schema, name: "schema", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintStage = "blueprintStage"
            case encryptionConfiguration = "encryptionConfiguration"
            case schema = "schema"
        }
    }

    public struct UpdateBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct UpdateDataAutomationProjectRequest: AWSEncodableShape {
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let overrideConfiguration: OverrideConfiguration?
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String
        public let projectDescription: String?
        public let projectStage: DataAutomationProjectStage?
        public let standardOutputConfiguration: StandardOutputConfiguration

        @inlinable
        public init(customOutputConfiguration: CustomOutputConfiguration? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, overrideConfiguration: OverrideConfiguration? = nil, projectArn: String, projectDescription: String? = nil, projectStage: DataAutomationProjectStage? = nil, standardOutputConfiguration: StandardOutputConfiguration) {
            self.customOutputConfiguration = customOutputConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectStage = projectStage
            self.standardOutputConfiguration = standardOutputConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customOutputConfiguration, forKey: .customOutputConfiguration)
            try container.encodeIfPresent(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            try container.encodeIfPresent(self.overrideConfiguration, forKey: .overrideConfiguration)
            request.encodePath(self.projectArn, key: "projectArn")
            try container.encodeIfPresent(self.projectDescription, forKey: .projectDescription)
            try container.encodeIfPresent(self.projectStage, forKey: .projectStage)
            try container.encode(self.standardOutputConfiguration, forKey: .standardOutputConfiguration)
        }

        public func validate(name: String) throws {
            try self.customOutputConfiguration?.validate(name: "\(name).customOutputConfiguration")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case customOutputConfiguration = "customOutputConfiguration"
            case encryptionConfiguration = "encryptionConfiguration"
            case overrideConfiguration = "overrideConfiguration"
            case projectDescription = "projectDescription"
            case projectStage = "projectStage"
            case standardOutputConfiguration = "standardOutputConfiguration"
        }
    }

    public struct UpdateDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
            case status = "status"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil) {
            self.fieldList = fieldList
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        public let message: String
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VideoBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct VideoExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [VideoExtractionCategoryType]?

        @inlinable
        public init(state: State, types: [VideoExtractionCategoryType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct VideoStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: VideoBoundingBox
        public let category: VideoExtractionCategory

        @inlinable
        public init(boundingBox: VideoBoundingBox, category: VideoExtractionCategory) {
            self.boundingBox = boundingBox
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case category = "category"
        }
    }

    public struct VideoStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [VideoStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [VideoStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct VideoStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: VideoStandardExtraction?
        public let generativeField: VideoStandardGenerativeField?

        @inlinable
        public init(extraction: VideoStandardExtraction? = nil, generativeField: VideoStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockDataAutomation
public struct BedrockDataAutomationErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockDataAutomation
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the request's input validation fails
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockDataAutomationErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockDataAutomation.ValidationException.self
    ]
}

extension BedrockDataAutomationErrorType: Equatable {
    public static func == (lhs: BedrockDataAutomationErrorType, rhs: BedrockDataAutomationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockDataAutomationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
