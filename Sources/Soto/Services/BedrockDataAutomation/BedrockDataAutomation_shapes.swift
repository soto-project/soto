//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockDataAutomation {
    // MARK: Enums

    public enum AudioExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioContentModeration = "AUDIO_CONTENT_MODERATION"
        case topicContentModeration = "TOPIC_CONTENT_MODERATION"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum AudioGenerativeOutputLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case en = "EN"
        public var description: String { return self.rawValue }
    }

    public enum AudioStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioSummary = "AUDIO_SUMMARY"
        case iab = "IAB"
        case topicSummary = "TOPIC_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintOptimizationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clientError = "ClientError"
        case created = "Created"
        case inProgress = "InProgress"
        case serviceError = "ServiceError"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintStage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintStageFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStageFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case development = "DEVELOPMENT"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DataAutomationProjectType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `async` = "ASYNC"
        case sync = "SYNC"
        public var description: String { return self.rawValue }
    }

    public enum DesiredModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "AUDIO"
        case document = "DOCUMENT"
        case image = "IMAGE"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum DocumentExtractionGranularityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case document = "DOCUMENT"
        case element = "ELEMENT"
        case line = "LINE"
        case page = "PAGE"
        case word = "WORD"
        public var description: String { return self.rawValue }
    }

    public enum DocumentOutputTextFormatType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case html = "HTML"
        case markdown = "MARKDOWN"
        case plainText = "PLAIN_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum ImageExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentModeration = "CONTENT_MODERATION"
        case logos = "LOGOS"
        case textDetection = "TEXT_DETECTION"
        public var description: String { return self.rawValue }
    }

    public enum ImageStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iab = "IAB"
        case imageSummary = "IMAGE_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum Language: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cn = "CN"
        case de = "DE"
        case en = "EN"
        case es = "ES"
        case fr = "FR"
        case hk = "HK"
        case it = "IT"
        case ja = "JA"
        case ko = "KO"
        case pt = "PT"
        case tw = "TW"
        public var description: String { return self.rawValue }
    }

    public enum PIIEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// A physical address, such as '100 Main Street, Anytown, USA' or 'Suite #12, Building 123'
        case address = "ADDRESS"
        /// An individual's age, including the quantity and unit of time
        case age = "AGE"
        /// All supported PII entity types
        case all = "ALL"
        /// A unique identifier associated with AWS secret access key
        case awsAccessKey = "AWS_ACCESS_KEY"
        /// A unique identifier associated with AWS access key for signing programmatic requests
        case awsSecretKey = "AWS_SECRET_KEY"
        /// A Canadian Health Service Number - 10-digit unique identifier for healthcare benefits
        case caHealthNumber = "CA_HEALTH_NUMBER"
        /// A Canadian Social Insurance Number (SIN) - nine-digit unique identifier
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        /// A three-digit card verification code (CVV) for VISA, MasterCard, and Discover cards, or four-digit for American Express
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        /// The expiration date for a credit or debit card
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        /// The number for a credit or debit card
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        /// The number assigned to a driver's license
        case driverId = "DRIVER_ID"
        /// An email address, such as marymajor@email.com
        case email = "EMAIL"
        /// An International Bank Account Number with specific formats for each country
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        /// An IPv4 address, such as 198.51.100.0
        case ipAddress = "IP_ADDRESS"
        /// A license plate for a vehicle issued by the state or country where the vehicle is registered
        case licensePlate = "LICENSE_PLATE"
        /// A media access control (MAC) address - unique identifier for network interface controller
        case macAddress = "MAC_ADDRESS"
        /// An individual's name. Does not include titles such as Dr., Mr., Mrs., or Miss
        case name = "NAME"
        /// An alphanumeric string that is used as a password
        case password = "PASSWORD"
        /// A phone number. Also includes fax and pager numbers
        case phone = "PHONE"
        /// A four-digit personal identification number (PIN)
        case pin = "PIN"
        /// A SWIFT code - standard format of Bank Identifier Code (BIC)
        case swiftCode = "SWIFT_CODE"
        /// A UK National Health Service Number - 10-17 digit number
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        /// A UK National Insurance Number (NINO) for accessing National Insurance benefits
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        /// A UK Unique Taxpayer Reference (UTR) - 10-digit number identifying taxpayer or business
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        /// A web address, such as www.example.com
        case url = "URL"
        /// A US bank account number, typically 10 to 12 digits long
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        /// A US bank account routing number, typically nine digits long
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        /// A US Individual Taxpayer Identification Number (ITIN)
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        /// A US passport number, ranging from six to nine alphanumeric characters
        case usPassportNumber = "US_PASSPORT_NUMBER"
        /// A US Social Security Number (SSN) - nine-digit number for US citizens and residents
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        /// A user name that identifies an account, such as a login name, screen name, nick name, or handle
        case username = "USERNAME"
        /// A Vehicle Identification Number (VIN) that uniquely identifies a vehicle
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum PIIRedactionMaskMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Replace with specific entity type marker, e.g. [NAME]/[SSN] etc.
        case entityType = "ENTITY_TYPE"
        /// Replace with generic PII marker [PII]
        case pii = "PII"
        public var description: String { return self.rawValue }
    }

    public enum ResourceOwner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum SensitiveDataDetectionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Only detect sensitive data without redaction
        case detection = "DETECTION"
        /// Detect and redact sensitive data
        case detectionAndRedaction = "DETECTION_AND_REDACTION"
        public var description: String { return self.rawValue }
    }

    public enum SensitiveDataDetectionScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Custom PII detection
        case custom = "CUSTOM"
        /// Standard PII detection
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VideoExtractionCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentModeration = "CONTENT_MODERATION"
        case logos = "LOGOS"
        case textDetection = "TEXT_DETECTION"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum VideoStandardGenerativeFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chapterSummary = "CHAPTER_SUMMARY"
        case iab = "IAB"
        case videoSummary = "VIDEO_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "AUDIO"
        case document = "DOCUMENT"
        case image = "IMAGE"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AudioExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let typeConfiguration: AudioExtractionCategoryTypeConfiguration?
        public let types: [AudioExtractionCategoryType]?

        @inlinable
        public init(state: State, typeConfiguration: AudioExtractionCategoryTypeConfiguration? = nil, types: [AudioExtractionCategoryType]? = nil) {
            self.state = state
            self.typeConfiguration = typeConfiguration
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case typeConfiguration = "typeConfiguration"
            case types = "types"
        }
    }

    public struct AudioExtractionCategoryTypeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let transcript: TranscriptConfiguration?

        @inlinable
        public init(transcript: TranscriptConfiguration? = nil) {
            self.transcript = transcript
        }

        private enum CodingKeys: String, CodingKey {
            case transcript = "transcript"
        }
    }

    public struct AudioLanguageConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let generativeOutputLanguage: AudioGenerativeOutputLanguage?
        /// Enable multiple language identification in audio
        public let identifyMultipleLanguages: Bool?
        public let inputLanguages: [Language]?

        @inlinable
        public init(generativeOutputLanguage: AudioGenerativeOutputLanguage? = nil, identifyMultipleLanguages: Bool? = nil, inputLanguages: [Language]? = nil) {
            self.generativeOutputLanguage = generativeOutputLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.inputLanguages = inputLanguages
        }

        private enum CodingKeys: String, CodingKey {
            case generativeOutputLanguage = "generativeOutputLanguage"
            case identifyMultipleLanguages = "identifyMultipleLanguages"
            case inputLanguages = "inputLanguages"
        }
    }

    public struct AudioOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let languageConfiguration: AudioLanguageConfiguration?
        public let modalityProcessing: ModalityProcessingConfiguration?
        public let sensitiveDataConfiguration: SensitiveDataConfiguration?

        @inlinable
        public init(languageConfiguration: AudioLanguageConfiguration? = nil, modalityProcessing: ModalityProcessingConfiguration? = nil, sensitiveDataConfiguration: SensitiveDataConfiguration? = nil) {
            self.languageConfiguration = languageConfiguration
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }

        public func validate(name: String) throws {
            try self.sensitiveDataConfiguration?.validate(name: "\(name).sensitiveDataConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case languageConfiguration = "languageConfiguration"
            case modalityProcessing = "modalityProcessing"
            case sensitiveDataConfiguration = "sensitiveDataConfiguration"
        }
    }

    public struct AudioStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let category: AudioExtractionCategory

        @inlinable
        public init(category: AudioExtractionCategory) {
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
        }
    }

    public struct AudioStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [AudioStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [AudioStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct AudioStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: AudioStandardExtraction?
        public let generativeField: AudioStandardGenerativeField?

        @inlinable
        public init(extraction: AudioStandardExtraction? = nil, generativeField: AudioStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }

    public struct Blueprint: AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintName: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String?
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        public let optimizationSamples: [BlueprintOptimizationSample]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var optimizationTime: Date?
        public let schema: String
        public let type: `Type`

        @inlinable
        public init(blueprintArn: String, blueprintName: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil, creationTime: Date, kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date, optimizationSamples: [BlueprintOptimizationSample]? = nil, optimizationTime: Date? = nil, schema: String, type: `Type`) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.optimizationSamples = optimizationSamples
            self.optimizationTime = optimizationTime
            self.schema = schema
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
            case creationTime = "creationTime"
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
            case lastModifiedTime = "lastModifiedTime"
            case optimizationSamples = "optimizationSamples"
            case optimizationTime = "optimizationTime"
            case schema = "schema"
            case type = "type"
        }
    }

    public struct BlueprintFilter: AWSEncodableShape {
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct BlueprintItem: AWSEncodableShape & AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct BlueprintOptimizationObject: AWSEncodableShape {
        /// Arn of blueprint.
        public let blueprintArn: String
        /// Stage of blueprint.
        public let stage: BlueprintStage?

        @inlinable
        public init(blueprintArn: String, stage: BlueprintStage? = nil) {
            self.blueprintArn = blueprintArn
            self.stage = stage
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case stage = "stage"
        }
    }

    public struct BlueprintOptimizationOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// S3 object.
        public let s3Object: S3Object

        @inlinable
        public init(s3Object: S3Object) {
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.s3Object.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "s3Object"
        }
    }

    public struct BlueprintOptimizationSample: AWSEncodableShape & AWSDecodableShape {
        /// S3 Object of the asset
        public let assetS3Object: S3Object
        /// Ground truth for the Blueprint and Asset combination
        public let groundTruthS3Object: S3Object

        @inlinable
        public init(assetS3Object: S3Object, groundTruthS3Object: S3Object) {
            self.assetS3Object = assetS3Object
            self.groundTruthS3Object = groundTruthS3Object
        }

        public func validate(name: String) throws {
            try self.assetS3Object.validate(name: "\(name).assetS3Object")
            try self.groundTruthS3Object.validate(name: "\(name).groundTruthS3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case assetS3Object = "assetS3Object"
            case groundTruthS3Object = "groundTruthS3Object"
        }
    }

    public struct BlueprintSummary: AWSDecodableShape {
        public let blueprintArn: String
        public let blueprintName: String?
        public let blueprintStage: BlueprintStage?
        public let blueprintVersion: String?
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?

        @inlinable
        public init(blueprintArn: String, blueprintName: String? = nil, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil, creationTime: Date, lastModifiedTime: Date? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
            case creationTime = "creationTime"
            case lastModifiedTime = "lastModifiedTime"
        }
    }

    public struct ChannelLabelingConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct CopyBlueprintStageRequest: AWSEncodableShape {
        /// Blueprint to be copied
        public let blueprintArn: String
        /// Client token for idempotency
        public let clientToken: String?
        /// Source stage to copy from
        public let sourceStage: BlueprintStage
        /// Target stage to copy to
        public let targetStage: BlueprintStage

        @inlinable
        public init(blueprintArn: String, clientToken: String? = CopyBlueprintStageRequest.idempotencyToken(), sourceStage: BlueprintStage, targetStage: BlueprintStage) {
            self.blueprintArn = blueprintArn
            self.clientToken = clientToken
            self.sourceStage = sourceStage
            self.targetStage = targetStage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.sourceStage, forKey: .sourceStage)
            try container.encode(self.targetStage, forKey: .targetStage)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case sourceStage = "sourceStage"
            case targetStage = "targetStage"
        }
    }

    public struct CopyBlueprintStageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateBlueprintRequest: AWSEncodableShape {
        public let blueprintName: String
        public let blueprintStage: BlueprintStage?
        public let clientToken: String?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let schema: String
        public let tags: [Tag]?
        public let type: `Type`

        @inlinable
        public init(blueprintName: String, blueprintStage: BlueprintStage? = nil, clientToken: String? = CreateBlueprintRequest.idempotencyToken(), encryptionConfiguration: EncryptionConfiguration? = nil, schema: String, tags: [Tag]? = nil, type: `Type`) {
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.clientToken = clientToken
            self.encryptionConfiguration = encryptionConfiguration
            self.schema = schema
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, max: 128)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, min: 1)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.schema, name: "schema", parent: name, max: 100000)
            try self.validate(self.schema, name: "schema", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "blueprintName"
            case blueprintStage = "blueprintStage"
            case clientToken = "clientToken"
            case encryptionConfiguration = "encryptionConfiguration"
            case schema = "schema"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct CreateBlueprintVersionRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        public let clientToken: String?

        @inlinable
        public init(blueprintArn: String, clientToken: String? = CreateBlueprintVersionRequest.idempotencyToken()) {
            self.blueprintArn = blueprintArn
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct CreateBlueprintVersionResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct CreateDataAutomationProjectRequest: AWSEncodableShape {
        public let clientToken: String?
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let overrideConfiguration: OverrideConfiguration?
        public let projectDescription: String?
        public let projectName: String
        public let projectStage: DataAutomationProjectStage?
        public let projectType: DataAutomationProjectType?
        public let standardOutputConfiguration: StandardOutputConfiguration
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateDataAutomationProjectRequest.idempotencyToken(), customOutputConfiguration: CustomOutputConfiguration? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, overrideConfiguration: OverrideConfiguration? = nil, projectDescription: String? = nil, projectName: String, projectStage: DataAutomationProjectStage? = nil, projectType: DataAutomationProjectType? = nil, standardOutputConfiguration: StandardOutputConfiguration, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.customOutputConfiguration = customOutputConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.overrideConfiguration = overrideConfiguration
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.projectType = projectType
            self.standardOutputConfiguration = standardOutputConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.customOutputConfiguration?.validate(name: "\(name).customOutputConfiguration")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.overrideConfiguration?.validate(name: "\(name).overrideConfiguration")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 300)
            try self.validate(self.projectName, name: "projectName", parent: name, max: 128)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customOutputConfiguration = "customOutputConfiguration"
            case encryptionConfiguration = "encryptionConfiguration"
            case overrideConfiguration = "overrideConfiguration"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case projectStage = "projectStage"
            case projectType = "projectType"
            case standardOutputConfiguration = "standardOutputConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
            case status = "status"
        }
    }

    public struct CustomOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let blueprints: [BlueprintItem]?

        @inlinable
        public init(blueprints: [BlueprintItem]? = nil) {
            self.blueprints = blueprints
        }

        public func validate(name: String) throws {
            try self.blueprints?.forEach {
                try $0.validate(name: "\(name).blueprints[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "blueprints"
        }
    }

    public struct DataAutomationProject: AWSDecodableShape {
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String?
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        public let overrideConfiguration: OverrideConfiguration?
        public let projectArn: String
        public let projectDescription: String?
        public let projectName: String
        public let projectStage: DataAutomationProjectStage?
        public let projectType: DataAutomationProjectType?
        public let standardOutputConfiguration: StandardOutputConfiguration?
        public let status: DataAutomationProjectStatus

        @inlinable
        public init(creationTime: Date, customOutputConfiguration: CustomOutputConfiguration? = nil, kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String? = nil, lastModifiedTime: Date, overrideConfiguration: OverrideConfiguration? = nil, projectArn: String, projectDescription: String? = nil, projectName: String, projectStage: DataAutomationProjectStage? = nil, projectType: DataAutomationProjectType? = nil, standardOutputConfiguration: StandardOutputConfiguration? = nil, status: DataAutomationProjectStatus) {
            self.creationTime = creationTime
            self.customOutputConfiguration = customOutputConfiguration
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.projectType = projectType
            self.standardOutputConfiguration = standardOutputConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case customOutputConfiguration = "customOutputConfiguration"
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
            case lastModifiedTime = "lastModifiedTime"
            case overrideConfiguration = "overrideConfiguration"
            case projectArn = "projectArn"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case projectStage = "projectStage"
            case projectType = "projectType"
            case standardOutputConfiguration = "standardOutputConfiguration"
            case status = "status"
        }
    }

    public struct DataAutomationProjectFilter: AWSEncodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
        }
    }

    public struct DataAutomationProjectSummary: AWSDecodableShape {
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        public let projectArn: String
        public let projectName: String?
        public let projectStage: DataAutomationProjectStage?
        public let projectType: DataAutomationProjectType?

        @inlinable
        public init(creationTime: Date, projectArn: String, projectName: String? = nil, projectStage: DataAutomationProjectStage? = nil, projectType: DataAutomationProjectType? = nil) {
            self.creationTime = creationTime
            self.projectArn = projectArn
            self.projectName = projectName
            self.projectStage = projectStage
            self.projectType = projectType
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case projectArn = "projectArn"
            case projectName = "projectName"
            case projectStage = "projectStage"
            case projectType = "projectType"
        }
    }

    public struct DeleteBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        /// Optional field to delete a specific Blueprint version
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintVersion = blueprintVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            request.encodeQuery(self.blueprintVersion, key: "blueprintVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBlueprintResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataAutomationProjectRequest: AWSEncodableShape {
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String

        @inlinable
        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectArn, key: "projectArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case status = "status"
        }
    }

    public struct DocumentBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentExtractionGranularity: AWSEncodableShape & AWSDecodableShape {
        public let types: [DocumentExtractionGranularityType]?

        @inlinable
        public init(types: [DocumentExtractionGranularityType]? = nil) {
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case types = "types"
        }
    }

    public struct DocumentOutputAdditionalFileFormat: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentOutputFormat: AWSEncodableShape & AWSDecodableShape {
        public let additionalFileFormat: DocumentOutputAdditionalFileFormat
        public let textFormat: DocumentOutputTextFormat

        @inlinable
        public init(additionalFileFormat: DocumentOutputAdditionalFileFormat, textFormat: DocumentOutputTextFormat) {
            self.additionalFileFormat = additionalFileFormat
            self.textFormat = textFormat
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFileFormat = "additionalFileFormat"
            case textFormat = "textFormat"
        }
    }

    public struct DocumentOutputTextFormat: AWSEncodableShape & AWSDecodableShape {
        public let types: [DocumentOutputTextFormatType]?

        @inlinable
        public init(types: [DocumentOutputTextFormatType]? = nil) {
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case types = "types"
        }
    }

    public struct DocumentOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let modalityProcessing: ModalityProcessingConfiguration?
        public let sensitiveDataConfiguration: SensitiveDataConfiguration?
        public let splitter: SplitterConfiguration?

        @inlinable
        public init(modalityProcessing: ModalityProcessingConfiguration? = nil, sensitiveDataConfiguration: SensitiveDataConfiguration? = nil, splitter: SplitterConfiguration? = nil) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
            self.splitter = splitter
        }

        public func validate(name: String) throws {
            try self.sensitiveDataConfiguration?.validate(name: "\(name).sensitiveDataConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case modalityProcessing = "modalityProcessing"
            case sensitiveDataConfiguration = "sensitiveDataConfiguration"
            case splitter = "splitter"
        }
    }

    public struct DocumentStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: DocumentBoundingBox
        public let granularity: DocumentExtractionGranularity

        @inlinable
        public init(boundingBox: DocumentBoundingBox, granularity: DocumentExtractionGranularity) {
            self.boundingBox = boundingBox
            self.granularity = granularity
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case granularity = "granularity"
        }
    }

    public struct DocumentStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DocumentStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: DocumentStandardExtraction?
        public let generativeField: DocumentStandardGenerativeField?
        public let outputFormat: DocumentOutputFormat?

        @inlinable
        public init(extraction: DocumentStandardExtraction? = nil, generativeField: DocumentStandardGenerativeField? = nil, outputFormat: DocumentOutputFormat? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
            self.outputFormat = outputFormat
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
            case outputFormat = "outputFormat"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape {
        public let kmsEncryptionContext: [String: String]?
        public let kmsKeyId: String

        @inlinable
        public init(kmsEncryptionContext: [String: String]? = nil, kmsKeyId: String) {
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.kmsEncryptionContext?.forEach {
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, max: 2000)
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, min: 1)
                try validate($0.key, name: "kmsEncryptionContext.key", parent: name, pattern: "^.*\\S.*$")
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, max: 2000)
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "kmsEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^.*\\S.*$")
            }
            try self.validate(self.kmsEncryptionContext, name: "kmsEncryptionContext", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionContext = "kmsEncryptionContext"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct GetBlueprintOptimizationStatusRequest: AWSEncodableShape {
        /// Invocation arn.
        public let invocationArn: String

        @inlinable
        public init(invocationArn: String) {
            self.invocationArn = invocationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.invocationArn, key: "invocationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, max: 128)
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, min: 1)
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, pattern: "^arn:aws(|-cn|-iso|-iso-[a-z]|-us-gov):bedrock:[a-zA-Z0-9-]*:[0-9]{12}:blueprint-optimization-invocation/[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBlueprintOptimizationStatusResponse: AWSDecodableShape {
        /// Error Message.
        public let errorMessage: String?
        /// Error Type.
        public let errorType: String?
        /// Output configuration.
        public let outputConfiguration: BlueprintOptimizationOutputConfiguration?
        /// Job Status.
        public let status: BlueprintOptimizationJobStatus?

        @inlinable
        public init(errorMessage: String? = nil, errorType: String? = nil, outputConfiguration: BlueprintOptimizationOutputConfiguration? = nil, status: BlueprintOptimizationJobStatus? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.outputConfiguration = outputConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case errorType = "errorType"
            case outputConfiguration = "outputConfiguration"
            case status = "status"
        }
    }

    public struct GetBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        /// Optional field to get a specific Blueprint stage
        public let blueprintStage: BlueprintStage?
        /// Optional field to get a specific Blueprint version
        public let blueprintVersion: String?

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, blueprintVersion: String? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.blueprintStage, forKey: .blueprintStage)
            try container.encodeIfPresent(self.blueprintVersion, forKey: .blueprintVersion)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, max: 128)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, min: 1)
            try self.validate(self.blueprintVersion, name: "blueprintVersion", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintStage = "blueprintStage"
            case blueprintVersion = "blueprintVersion"
        }
    }

    public struct GetBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct GetDataAutomationProjectRequest: AWSEncodableShape {
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String
        /// Optional field to delete a specific DataAutomationProject stage
        public let projectStage: DataAutomationProjectStage?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectArn, key: "projectArn")
            try container.encodeIfPresent(self.projectStage, forKey: .projectStage)
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectStage = "projectStage"
        }
    }

    public struct GetDataAutomationProjectResponse: AWSDecodableShape {
        public let project: DataAutomationProject

        @inlinable
        public init(project: DataAutomationProject) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct ImageBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct ImageExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [ImageExtractionCategoryType]?

        @inlinable
        public init(state: State, types: [ImageExtractionCategoryType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct ImageOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let modalityProcessing: ModalityProcessingConfiguration?
        public let sensitiveDataConfiguration: SensitiveDataConfiguration?

        @inlinable
        public init(modalityProcessing: ModalityProcessingConfiguration? = nil, sensitiveDataConfiguration: SensitiveDataConfiguration? = nil) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }

        public func validate(name: String) throws {
            try self.sensitiveDataConfiguration?.validate(name: "\(name).sensitiveDataConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case modalityProcessing = "modalityProcessing"
            case sensitiveDataConfiguration = "sensitiveDataConfiguration"
        }
    }

    public struct ImageStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: ImageBoundingBox
        public let category: ImageExtractionCategory

        @inlinable
        public init(boundingBox: ImageBoundingBox, category: ImageExtractionCategory) {
            self.boundingBox = boundingBox
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case category = "category"
        }
    }

    public struct ImageStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [ImageStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [ImageStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct ImageStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: ImageStandardExtraction?
        public let generativeField: ImageStandardGenerativeField?

        @inlinable
        public init(extraction: ImageStandardExtraction? = nil, generativeField: ImageStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }

    public struct InvokeBlueprintOptimizationAsyncRequest: AWSEncodableShape {
        /// Blueprint to be optimized
        public let blueprint: BlueprintOptimizationObject
        /// Data automation profile ARN
        public let dataAutomationProfileArn: String
        /// Encryption configuration.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// Output configuration where the results should be placed
        public let outputConfiguration: BlueprintOptimizationOutputConfiguration
        /// List of Blueprint Optimization Samples
        public let samples: [BlueprintOptimizationSample]
        /// List of tags.
        public let tags: [Tag]?

        @inlinable
        public init(blueprint: BlueprintOptimizationObject, dataAutomationProfileArn: String, encryptionConfiguration: EncryptionConfiguration? = nil, outputConfiguration: BlueprintOptimizationOutputConfiguration, samples: [BlueprintOptimizationSample], tags: [Tag]? = nil) {
            self.blueprint = blueprint
            self.dataAutomationProfileArn = dataAutomationProfileArn
            self.encryptionConfiguration = encryptionConfiguration
            self.outputConfiguration = outputConfiguration
            self.samples = samples
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.blueprint.validate(name: "\(name).blueprint")
            try self.validate(self.dataAutomationProfileArn, name: "dataAutomationProfileArn", parent: name, max: 128)
            try self.validate(self.dataAutomationProfileArn, name: "dataAutomationProfileArn", parent: name, min: 1)
            try self.validate(self.dataAutomationProfileArn, name: "dataAutomationProfileArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-profile/[a-zA-Z0-9-_.]+$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
            try self.samples.forEach {
                try $0.validate(name: "\(name).samples[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
            case dataAutomationProfileArn = "dataAutomationProfileArn"
            case encryptionConfiguration = "encryptionConfiguration"
            case outputConfiguration = "outputConfiguration"
            case samples = "samples"
            case tags = "tags"
        }
    }

    public struct InvokeBlueprintOptimizationAsyncResponse: AWSDecodableShape {
        /// ARN of the blueprint optimization job
        public let invocationArn: String

        @inlinable
        public init(invocationArn: String) {
            self.invocationArn = invocationArn
        }

        private enum CodingKeys: String, CodingKey {
            case invocationArn = "invocationArn"
        }
    }

    public struct ListBlueprintsRequest: AWSEncodableShape {
        public let blueprintArn: String?
        public let blueprintStageFilter: BlueprintStageFilter?
        public let maxResults: Int?
        public let nextToken: String?
        public let projectFilter: DataAutomationProjectFilter?
        public let resourceOwner: ResourceOwner?

        @inlinable
        public init(blueprintArn: String? = nil, blueprintStageFilter: BlueprintStageFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectFilter: DataAutomationProjectFilter? = nil, resourceOwner: ResourceOwner? = nil) {
            self.blueprintArn = blueprintArn
            self.blueprintStageFilter = blueprintStageFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectFilter = projectFilter
            self.resourceOwner = resourceOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.projectFilter?.validate(name: "\(name).projectFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintArn = "blueprintArn"
            case blueprintStageFilter = "blueprintStageFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case projectFilter = "projectFilter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListBlueprintsResponse: AWSDecodableShape {
        public let blueprints: [BlueprintSummary]
        public let nextToken: String?

        @inlinable
        public init(blueprints: [BlueprintSummary], nextToken: String? = nil) {
            self.blueprints = blueprints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "blueprints"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataAutomationProjectsRequest: AWSEncodableShape {
        public let blueprintFilter: BlueprintFilter?
        public let maxResults: Int?
        public let nextToken: String?
        public let projectStageFilter: DataAutomationProjectStageFilter?
        public let resourceOwner: ResourceOwner?

        @inlinable
        public init(blueprintFilter: BlueprintFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectStageFilter: DataAutomationProjectStageFilter? = nil, resourceOwner: ResourceOwner? = nil) {
            self.blueprintFilter = blueprintFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectStageFilter = projectStageFilter
            self.resourceOwner = resourceOwner
        }

        public func validate(name: String) throws {
            try self.blueprintFilter?.validate(name: "\(name).blueprintFilter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintFilter = "blueprintFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case projectStageFilter = "projectStageFilter"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct ListDataAutomationProjectsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let projects: [DataAutomationProjectSummary]

        @inlinable
        public init(nextToken: String? = nil, projects: [DataAutomationProjectSummary]) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projects = "projects"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-iso|-iso-[a-z]|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project|blueprint-optimization-invocation)/[a-zA-Z0-9-]{12,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ModalityProcessingConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let state: State?

        @inlinable
        public init(state: State? = nil) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct ModalityRoutingConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let jpeg: DesiredModality?
        public let mov: DesiredModality?
        public let mp4: DesiredModality?
        public let png: DesiredModality?

        @inlinable
        public init(jpeg: DesiredModality? = nil, mov: DesiredModality? = nil, mp4: DesiredModality? = nil, png: DesiredModality? = nil) {
            self.jpeg = jpeg
            self.mov = mov
            self.mp4 = mp4
            self.png = png
        }

        private enum CodingKeys: String, CodingKey {
            case jpeg = "jpeg"
            case mov = "mov"
            case mp4 = "mp4"
            case png = "png"
        }
    }

    public struct OverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let audio: AudioOverrideConfiguration?
        public let document: DocumentOverrideConfiguration?
        public let image: ImageOverrideConfiguration?
        public let modalityRouting: ModalityRoutingConfiguration?
        public let video: VideoOverrideConfiguration?

        @inlinable
        public init(audio: AudioOverrideConfiguration? = nil, document: DocumentOverrideConfiguration? = nil, image: ImageOverrideConfiguration? = nil, modalityRouting: ModalityRoutingConfiguration? = nil, video: VideoOverrideConfiguration? = nil) {
            self.audio = audio
            self.document = document
            self.image = image
            self.modalityRouting = modalityRouting
            self.video = video
        }

        public func validate(name: String) throws {
            try self.audio?.validate(name: "\(name).audio")
            try self.document?.validate(name: "\(name).document")
            try self.image?.validate(name: "\(name).image")
            try self.video?.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "audio"
            case document = "document"
            case image = "image"
            case modalityRouting = "modalityRouting"
            case video = "video"
        }
    }

    public struct PIIEntitiesConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Types of PII entities to detect
        public let piiEntityTypes: [PIIEntityType]?
        /// Mode for redacting detected PII
        public let redactionMaskMode: PIIRedactionMaskMode?

        @inlinable
        public init(piiEntityTypes: [PIIEntityType]? = nil, redactionMaskMode: PIIRedactionMaskMode? = nil) {
            self.piiEntityTypes = piiEntityTypes
            self.redactionMaskMode = redactionMaskMode
        }

        public func validate(name: String) throws {
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, max: 32)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntityTypes = "piiEntityTypes"
            case redactionMaskMode = "redactionMaskMode"
        }
    }

    public struct S3Object: AWSEncodableShape & AWSDecodableShape {
        /// S3 uri.
        public let s3Uri: String
        /// S3 object version.
        public let version: String?

        @inlinable
        public init(s3Uri: String, version: String? = nil) {
            self.s3Uri = s3Uri
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
            case version = "version"
        }
    }

    public struct SensitiveDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Mode for sensitive data detection
        public let detectionMode: SensitiveDataDetectionMode
        /// Scope of detection - what types of sensitive data to detect
        public let detectionScope: [SensitiveDataDetectionScopeType]?
        /// Configuration for PII entities detection and redaction
        public let piiEntitiesConfiguration: PIIEntitiesConfiguration?

        @inlinable
        public init(detectionMode: SensitiveDataDetectionMode, detectionScope: [SensitiveDataDetectionScopeType]? = nil, piiEntitiesConfiguration: PIIEntitiesConfiguration? = nil) {
            self.detectionMode = detectionMode
            self.detectionScope = detectionScope
            self.piiEntitiesConfiguration = piiEntitiesConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.detectionScope, name: "detectionScope", parent: name, max: 2)
            try self.validate(self.detectionScope, name: "detectionScope", parent: name, min: 1)
            try self.piiEntitiesConfiguration?.validate(name: "\(name).piiEntitiesConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case detectionMode = "detectionMode"
            case detectionScope = "detectionScope"
            case piiEntitiesConfiguration = "piiEntitiesConfiguration"
        }
    }

    public struct SpeakerLabelingConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct SplitterConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let state: State?

        @inlinable
        public init(state: State? = nil) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct StandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let audio: AudioStandardOutputConfiguration?
        public let document: DocumentStandardOutputConfiguration?
        public let image: ImageStandardOutputConfiguration?
        public let video: VideoStandardOutputConfiguration?

        @inlinable
        public init(audio: AudioStandardOutputConfiguration? = nil, document: DocumentStandardOutputConfiguration? = nil, image: ImageStandardOutputConfiguration? = nil, video: VideoStandardOutputConfiguration? = nil) {
            self.audio = audio
            self.document = document
            self.image = image
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "audio"
            case document = "document"
            case image = "image"
            case video = "video"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        public let key: String
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public let resourceARN: String
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-iso|-iso-[a-z]|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project|blueprint-optimization-invocation)/[a-zA-Z0-9-]{12,36}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TranscriptConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let channelLabeling: ChannelLabelingConfiguration?
        public let speakerLabeling: SpeakerLabelingConfiguration?

        @inlinable
        public init(channelLabeling: ChannelLabelingConfiguration? = nil, speakerLabeling: SpeakerLabelingConfiguration? = nil) {
            self.channelLabeling = channelLabeling
            self.speakerLabeling = speakerLabeling
        }

        private enum CodingKeys: String, CodingKey {
            case channelLabeling = "channelLabeling"
            case speakerLabeling = "speakerLabeling"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public let resourceARN: String
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(|-cn|-iso|-iso-[a-z]|-us-gov):bedrock:[a-z0-9-]*:[0-9]{12}:(blueprint|data-automation-project|blueprint-optimization-invocation)/[a-zA-Z0-9-]{12,36}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBlueprintRequest: AWSEncodableShape {
        /// ARN generated at the server side when a Blueprint is created
        public let blueprintArn: String
        public let blueprintStage: BlueprintStage?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let schema: String

        @inlinable
        public init(blueprintArn: String, blueprintStage: BlueprintStage? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, schema: String) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.encryptionConfiguration = encryptionConfiguration
            self.schema = schema
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintArn, key: "blueprintArn")
            try container.encodeIfPresent(self.blueprintStage, forKey: .blueprintStage)
            try container.encodeIfPresent(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            try container.encode(self.schema, forKey: .schema)
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, max: 128)
            try self.validate(self.blueprintArn, name: "blueprintArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):blueprint/(bedrock-data-automation-public-[a-zA-Z0-9-_]{1,30}|[a-zA-Z0-9-]{12,36})$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.schema, name: "schema", parent: name, max: 100000)
            try self.validate(self.schema, name: "schema", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintStage = "blueprintStage"
            case encryptionConfiguration = "encryptionConfiguration"
            case schema = "schema"
        }
    }

    public struct UpdateBlueprintResponse: AWSDecodableShape {
        public let blueprint: Blueprint

        @inlinable
        public init(blueprint: Blueprint) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "blueprint"
        }
    }

    public struct UpdateDataAutomationProjectRequest: AWSEncodableShape {
        public let customOutputConfiguration: CustomOutputConfiguration?
        public let encryptionConfiguration: EncryptionConfiguration?
        public let overrideConfiguration: OverrideConfiguration?
        /// ARN generated at the server side when a DataAutomationProject is created
        public let projectArn: String
        public let projectDescription: String?
        public let projectStage: DataAutomationProjectStage?
        public let standardOutputConfiguration: StandardOutputConfiguration

        @inlinable
        public init(customOutputConfiguration: CustomOutputConfiguration? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, overrideConfiguration: OverrideConfiguration? = nil, projectArn: String, projectDescription: String? = nil, projectStage: DataAutomationProjectStage? = nil, standardOutputConfiguration: StandardOutputConfiguration) {
            self.customOutputConfiguration = customOutputConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectStage = projectStage
            self.standardOutputConfiguration = standardOutputConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customOutputConfiguration, forKey: .customOutputConfiguration)
            try container.encodeIfPresent(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            try container.encodeIfPresent(self.overrideConfiguration, forKey: .overrideConfiguration)
            request.encodePath(self.projectArn, key: "projectArn")
            try container.encodeIfPresent(self.projectDescription, forKey: .projectDescription)
            try container.encodeIfPresent(self.projectStage, forKey: .projectStage)
            try container.encode(self.standardOutputConfiguration, forKey: .standardOutputConfiguration)
        }

        public func validate(name: String) throws {
            try self.customOutputConfiguration?.validate(name: "\(name).customOutputConfiguration")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.overrideConfiguration?.validate(name: "\(name).overrideConfiguration")
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 128)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:(aws|[0-9]{12}):data-automation-project/[a-zA-Z0-9-]{12,36}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case customOutputConfiguration = "customOutputConfiguration"
            case encryptionConfiguration = "encryptionConfiguration"
            case overrideConfiguration = "overrideConfiguration"
            case projectDescription = "projectDescription"
            case projectStage = "projectStage"
            case standardOutputConfiguration = "standardOutputConfiguration"
        }
    }

    public struct UpdateDataAutomationProjectResponse: AWSDecodableShape {
        public let projectArn: String
        public let projectStage: DataAutomationProjectStage?
        public let status: DataAutomationProjectStatus?

        @inlinable
        public init(projectArn: String, projectStage: DataAutomationProjectStage? = nil, status: DataAutomationProjectStatus? = nil) {
            self.projectArn = projectArn
            self.projectStage = projectStage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectStage = "projectStage"
            case status = "status"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil) {
            self.fieldList = fieldList
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        public let message: String
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VideoBoundingBox: AWSEncodableShape & AWSDecodableShape {
        public let state: State

        @inlinable
        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct VideoExtractionCategory: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [VideoExtractionCategoryType]?

        @inlinable
        public init(state: State, types: [VideoExtractionCategoryType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct VideoOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let modalityProcessing: ModalityProcessingConfiguration?
        public let sensitiveDataConfiguration: SensitiveDataConfiguration?

        @inlinable
        public init(modalityProcessing: ModalityProcessingConfiguration? = nil, sensitiveDataConfiguration: SensitiveDataConfiguration? = nil) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }

        public func validate(name: String) throws {
            try self.sensitiveDataConfiguration?.validate(name: "\(name).sensitiveDataConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case modalityProcessing = "modalityProcessing"
            case sensitiveDataConfiguration = "sensitiveDataConfiguration"
        }
    }

    public struct VideoStandardExtraction: AWSEncodableShape & AWSDecodableShape {
        public let boundingBox: VideoBoundingBox
        public let category: VideoExtractionCategory

        @inlinable
        public init(boundingBox: VideoBoundingBox, category: VideoExtractionCategory) {
            self.boundingBox = boundingBox
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "boundingBox"
            case category = "category"
        }
    }

    public struct VideoStandardGenerativeField: AWSEncodableShape & AWSDecodableShape {
        public let state: State
        public let types: [VideoStandardGenerativeFieldType]?

        @inlinable
        public init(state: State, types: [VideoStandardGenerativeFieldType]? = nil) {
            self.state = state
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case types = "types"
        }
    }

    public struct VideoStandardOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let extraction: VideoStandardExtraction?
        public let generativeField: VideoStandardGenerativeField?

        @inlinable
        public init(extraction: VideoStandardExtraction? = nil, generativeField: VideoStandardGenerativeField? = nil) {
            self.extraction = extraction
            self.generativeField = generativeField
        }

        private enum CodingKeys: String, CodingKey {
            case extraction = "extraction"
            case generativeField = "generativeField"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockDataAutomation
public struct BedrockDataAutomationErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockDataAutomation
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the request's input validation fails
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockDataAutomationErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockDataAutomation.ValidationException.self
    ]
}

extension BedrockDataAutomationErrorType: Equatable {
    public static func == (lhs: BedrockDataAutomationErrorType, rhs: BedrockDataAutomationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockDataAutomationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
