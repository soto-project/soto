//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension ResilienceHub {
    ///  Lists the alarm recommendations for a AWS Resilience Hub application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAlarmRecommendationsPaginator<Result>(
        _ input: ListAlarmRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAlarmRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAlarmRecommendations,
            inputKey: \ListAlarmRecommendationsRequest.nextToken,
            outputKey: \ListAlarmRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAlarmRecommendationsPaginator(
        _ input: ListAlarmRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAlarmRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAlarmRecommendations,
            inputKey: \ListAlarmRecommendationsRequest.nextToken,
            outputKey: \ListAlarmRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the assessments for an AWS Resilience Hub application. You can use request parameters to refine the results for the response object.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppAssessmentsPaginator<Result>(
        _ input: ListAppAssessmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppAssessmentsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppAssessments,
            inputKey: \ListAppAssessmentsRequest.nextToken,
            outputKey: \ListAppAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppAssessmentsPaginator(
        _ input: ListAppAssessmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppAssessmentsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppAssessments,
            inputKey: \ListAppAssessmentsRequest.nextToken,
            outputKey: \ListAppAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the compliances for an AWS Resilience Hub component.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppComponentCompliancesPaginator<Result>(
        _ input: ListAppComponentCompliancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppComponentCompliancesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppComponentCompliances,
            inputKey: \ListAppComponentCompliancesRequest.nextToken,
            outputKey: \ListAppComponentCompliancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppComponentCompliancesPaginator(
        _ input: ListAppComponentCompliancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppComponentCompliancesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppComponentCompliances,
            inputKey: \ListAppComponentCompliancesRequest.nextToken,
            outputKey: \ListAppComponentCompliancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the recommendations for an AWS Resilience Hub component.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppComponentRecommendationsPaginator<Result>(
        _ input: ListAppComponentRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppComponentRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppComponentRecommendations,
            inputKey: \ListAppComponentRecommendationsRequest.nextToken,
            outputKey: \ListAppComponentRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppComponentRecommendationsPaginator(
        _ input: ListAppComponentRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppComponentRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppComponentRecommendations,
            inputKey: \ListAppComponentRecommendationsRequest.nextToken,
            outputKey: \ListAppComponentRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists how the resources in an application version are mapped/sourced from. Mappings can be physical resource identifiers, CloudFormation stacks, resource-groups, or an application registry app.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionResourceMappingsPaginator<Result>(
        _ input: ListAppVersionResourceMappingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionResourceMappingsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppVersionResourceMappings,
            inputKey: \ListAppVersionResourceMappingsRequest.nextToken,
            outputKey: \ListAppVersionResourceMappingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionResourceMappingsPaginator(
        _ input: ListAppVersionResourceMappingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionResourceMappingsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppVersionResourceMappings,
            inputKey: \ListAppVersionResourceMappingsRequest.nextToken,
            outputKey: \ListAppVersionResourceMappingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the resources in an application version.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionResourcesPaginator<Result>(
        _ input: ListAppVersionResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppVersionResources,
            inputKey: \ListAppVersionResourcesRequest.nextToken,
            outputKey: \ListAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionResourcesPaginator(
        _ input: ListAppVersionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppVersionResources,
            inputKey: \ListAppVersionResourcesRequest.nextToken,
            outputKey: \ListAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the different versions for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionsPaginator<Result>(
        _ input: ListAppVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAppVersions,
            inputKey: \ListAppVersionsRequest.nextToken,
            outputKey: \ListAppVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionsPaginator(
        _ input: ListAppVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAppVersions,
            inputKey: \ListAppVersionsRequest.nextToken,
            outputKey: \ListAppVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists your Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppsPaginator<Result>(
        _ input: ListAppsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listApps,
            inputKey: \ListAppsRequest.nextToken,
            outputKey: \ListAppsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppsPaginator(
        _ input: ListAppsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listApps,
            inputKey: \ListAppsRequest.nextToken,
            outputKey: \ListAppsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the recommendation templates for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRecommendationTemplatesPaginator<Result>(
        _ input: ListRecommendationTemplatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRecommendationTemplatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listRecommendationTemplates,
            inputKey: \ListRecommendationTemplatesRequest.nextToken,
            outputKey: \ListRecommendationTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRecommendationTemplatesPaginator(
        _ input: ListRecommendationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRecommendationTemplatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listRecommendationTemplates,
            inputKey: \ListRecommendationTemplatesRequest.nextToken,
            outputKey: \ListRecommendationTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resiliency policies for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResiliencyPoliciesPaginator<Result>(
        _ input: ListResiliencyPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listResiliencyPolicies,
            inputKey: \ListResiliencyPoliciesRequest.nextToken,
            outputKey: \ListResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResiliencyPoliciesPaginator(
        _ input: ListResiliencyPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listResiliencyPolicies,
            inputKey: \ListResiliencyPoliciesRequest.nextToken,
            outputKey: \ListResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSopRecommendationsPaginator<Result>(
        _ input: ListSopRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSopRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listSopRecommendations,
            inputKey: \ListSopRecommendationsRequest.nextToken,
            outputKey: \ListSopRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSopRecommendationsPaginator(
        _ input: ListSopRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSopRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listSopRecommendations,
            inputKey: \ListSopRecommendationsRequest.nextToken,
            outputKey: \ListSopRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the suggested resiliency policies for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSuggestedResiliencyPoliciesPaginator<Result>(
        _ input: ListSuggestedResiliencyPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSuggestedResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listSuggestedResiliencyPolicies,
            inputKey: \ListSuggestedResiliencyPoliciesRequest.nextToken,
            outputKey: \ListSuggestedResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSuggestedResiliencyPoliciesPaginator(
        _ input: ListSuggestedResiliencyPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSuggestedResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listSuggestedResiliencyPolicies,
            inputKey: \ListSuggestedResiliencyPoliciesRequest.nextToken,
            outputKey: \ListSuggestedResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the test recommendations for the Resilience Hub application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTestRecommendationsPaginator<Result>(
        _ input: ListTestRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTestRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTestRecommendations,
            inputKey: \ListTestRecommendationsRequest.nextToken,
            outputKey: \ListTestRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTestRecommendationsPaginator(
        _ input: ListTestRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTestRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTestRecommendations,
            inputKey: \ListTestRecommendationsRequest.nextToken,
            outputKey: \ListTestRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resources that are not currently supported in AWS Resilience Hub. An unsupported resource is a resource that exists in the object that was used to create an app, but is not supported by Resilience Hub.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listUnsupportedAppVersionResourcesPaginator<Result>(
        _ input: ListUnsupportedAppVersionResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListUnsupportedAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listUnsupportedAppVersionResources,
            inputKey: \ListUnsupportedAppVersionResourcesRequest.nextToken,
            outputKey: \ListUnsupportedAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listUnsupportedAppVersionResourcesPaginator(
        _ input: ListUnsupportedAppVersionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListUnsupportedAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listUnsupportedAppVersionResources,
            inputKey: \ListUnsupportedAppVersionResourcesRequest.nextToken,
            outputKey: \ListUnsupportedAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension ResilienceHub.ListAlarmRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAlarmRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListAppAssessmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppAssessmentsRequest {
        return .init(
            appArn: self.appArn,
            assessmentName: self.assessmentName,
            assessmentStatus: self.assessmentStatus,
            complianceStatus: self.complianceStatus,
            invoker: self.invoker,
            maxResults: self.maxResults,
            nextToken: token,
            reverseOrder: self.reverseOrder
        )
    }
}

extension ResilienceHub.ListAppComponentCompliancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppComponentCompliancesRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListAppComponentRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppComponentRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListAppVersionResourceMappingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppVersionResourceMappingsRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListAppVersionResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppVersionResourcesRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token,
            resolutionId: self.resolutionId
        )
    }
}

extension ResilienceHub.ListAppVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppVersionsRequest {
        return .init(
            appArn: self.appArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListAppsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListAppsRequest {
        return .init(
            appArn: self.appArn,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListRecommendationTemplatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListRecommendationTemplatesRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            recommendationTemplateArn: self.recommendationTemplateArn,
            reverseOrder: self.reverseOrder,
            status: self.status
        )
    }
}

extension ResilienceHub.ListResiliencyPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListResiliencyPoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyName: self.policyName
        )
    }
}

extension ResilienceHub.ListSopRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListSopRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListSuggestedResiliencyPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListSuggestedResiliencyPoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListTestRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListTestRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ResilienceHub.ListUnsupportedAppVersionResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ResilienceHub.ListUnsupportedAppVersionResourcesRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token,
            resolutionId: self.resolutionId
        )
    }
}
