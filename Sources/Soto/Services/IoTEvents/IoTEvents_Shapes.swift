//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension IoTEvents {
    // MARK: Enums

    public enum AlarmModelVersionStatus: String, CustomStringConvertible, Codable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisResultLevel: String, CustomStringConvertible, Codable {
        case error = "ERROR"
        case info = "INFO"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisStatus: String, CustomStringConvertible, Codable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable {
        case equal = "EQUAL"
        case greater = "GREATER"
        case greaterOrEqual = "GREATER_OR_EQUAL"
        case less = "LESS"
        case lessOrEqual = "LESS_OR_EQUAL"
        case notEqual = "NOT_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum DetectorModelVersionStatus: String, CustomStringConvertible, Codable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deprecated = "DEPRECATED"
        case draft = "DRAFT"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationMethod: String, CustomStringConvertible, Codable {
        case batch = "BATCH"
        case serial = "SERIAL"
        public var description: String { return self.rawValue }
    }

    public enum InputStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable {
        case debug = "DEBUG"
        case error = "ERROR"
        case info = "INFO"
        public var description: String { return self.rawValue }
    }

    public enum PayloadType: String, CustomStringConvertible, Codable {
        case json = "JSON"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcknowledgeFlow: AWSEncodableShape & AWSDecodableShape {
        /// The value must be TRUE or FALSE. If TRUE, you receive a notification when the alarm state changes. You must choose to acknowledge the notification before the alarm state can return to NORMAL. If FALSE, you won't receive notifications. The alarm automatically changes to the NORMAL state when the input property value returns to the specified range.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// Information needed to clear the timer.
        public let clearTimer: ClearTimerAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the payload. One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see Actions in AWS IoT Events Developer Guide.
        public let dynamoDB: DynamoDBAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the payload. A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. For more information, see Actions in AWS IoT Events Developer Guide.
        public let dynamoDBv2: DynamoDBv2Action?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
        public let firehose: FirehoseAction?
        /// Sends AWS IoT Events input, which passes information about the detector model instance and the event that triggered the action.
        public let iotEvents: IotEventsAction?
        /// Sends information about the detector model instance and the event that triggered the action to an asset property in AWS IoT SiteWise .
        public let iotSiteWise: IotSiteWiseAction?
        /// Publishes an MQTT message with the given topic to the AWS IoT message broker.
        public let iotTopicPublish: IotTopicPublishAction?
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public let lambda: LambdaAction?
        /// Information needed to reset the timer.
        public let resetTimer: ResetTimerAction?
        /// Information needed to set the timer.
        public let setTimer: SetTimerAction?
        /// Sets a variable to a specified value.
        public let setVariable: SetVariableAction?
        /// Sends an Amazon SNS message.
        public let sns: SNSTopicPublishAction?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
        public let sqs: SqsAction?

        public init(clearTimer: ClearTimerAction? = nil, dynamoDB: DynamoDBAction? = nil, dynamoDBv2: DynamoDBv2Action? = nil, firehose: FirehoseAction? = nil, iotEvents: IotEventsAction? = nil, iotSiteWise: IotSiteWiseAction? = nil, iotTopicPublish: IotTopicPublishAction? = nil, lambda: LambdaAction? = nil, resetTimer: ResetTimerAction? = nil, setTimer: SetTimerAction? = nil, setVariable: SetVariableAction? = nil, sns: SNSTopicPublishAction? = nil, sqs: SqsAction? = nil) {
            self.clearTimer = clearTimer
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.resetTimer = resetTimer
            self.setTimer = setTimer
            self.setVariable = setVariable
            self.sns = sns
            self.sqs = sqs
        }

        public func validate(name: String) throws {
            try self.clearTimer?.validate(name: "\(name).clearTimer")
            try self.dynamoDB?.validate(name: "\(name).dynamoDB")
            try self.dynamoDBv2?.validate(name: "\(name).dynamoDBv2")
            try self.firehose?.validate(name: "\(name).firehose")
            try self.iotEvents?.validate(name: "\(name).iotEvents")
            try self.iotTopicPublish?.validate(name: "\(name).iotTopicPublish")
            try self.lambda?.validate(name: "\(name).lambda")
            try self.resetTimer?.validate(name: "\(name).resetTimer")
            try self.setTimer?.validate(name: "\(name).setTimer")
            try self.setVariable?.validate(name: "\(name).setVariable")
            try self.sns?.validate(name: "\(name).sns")
            try self.sqs?.validate(name: "\(name).sqs")
        }

        private enum CodingKeys: String, CodingKey {
            case clearTimer
            case dynamoDB
            case dynamoDBv2
            case firehose
            case iotEvents
            case iotSiteWise
            case iotTopicPublish
            case lambda
            case resetTimer
            case setTimer
            case setVariable
            case sns
            case sqs
        }
    }

    public struct AlarmAction: AWSEncodableShape & AWSDecodableShape {
        public let dynamoDB: DynamoDBAction?
        public let dynamoDBv2: DynamoDBv2Action?
        public let firehose: FirehoseAction?
        public let iotEvents: IotEventsAction?
        public let iotSiteWise: IotSiteWiseAction?
        public let iotTopicPublish: IotTopicPublishAction?
        public let lambda: LambdaAction?
        public let sns: SNSTopicPublishAction?
        public let sqs: SqsAction?

        public init(dynamoDB: DynamoDBAction? = nil, dynamoDBv2: DynamoDBv2Action? = nil, firehose: FirehoseAction? = nil, iotEvents: IotEventsAction? = nil, iotSiteWise: IotSiteWiseAction? = nil, iotTopicPublish: IotTopicPublishAction? = nil, lambda: LambdaAction? = nil, sns: SNSTopicPublishAction? = nil, sqs: SqsAction? = nil) {
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.sns = sns
            self.sqs = sqs
        }

        public func validate(name: String) throws {
            try self.dynamoDB?.validate(name: "\(name).dynamoDB")
            try self.dynamoDBv2?.validate(name: "\(name).dynamoDBv2")
            try self.firehose?.validate(name: "\(name).firehose")
            try self.iotEvents?.validate(name: "\(name).iotEvents")
            try self.iotTopicPublish?.validate(name: "\(name).iotTopicPublish")
            try self.lambda?.validate(name: "\(name).lambda")
            try self.sns?.validate(name: "\(name).sns")
            try self.sqs?.validate(name: "\(name).sqs")
        }

        private enum CodingKeys: String, CodingKey {
            case dynamoDB
            case dynamoDBv2
            case firehose
            case iotEvents
            case iotSiteWise
            case iotTopicPublish
            case lambda
            case sns
            case sqs
        }
    }

    public struct AlarmCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to get notified for alarm state changes.
        public let acknowledgeFlow: AcknowledgeFlow?
        /// Specifies the default alarm state.
        /// The configuration applies to all alarms that were created based on this alarm model.
        public let initializationConfiguration: InitializationConfiguration?

        public init(acknowledgeFlow: AcknowledgeFlow? = nil, initializationConfiguration: InitializationConfiguration? = nil) {
            self.acknowledgeFlow = acknowledgeFlow
            self.initializationConfiguration = initializationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case acknowledgeFlow
            case initializationConfiguration
        }
    }

    public struct AlarmEventActions: AWSEncodableShape & AWSDecodableShape {
        /// Specifies one or more supported actions to receive notifications when the alarm state changes.
        public let alarmActions: [AlarmAction]?

        public init(alarmActions: [AlarmAction]? = nil) {
            self.alarmActions = alarmActions
        }

        public func validate(name: String) throws {
            try self.alarmActions?.forEach {
                try $0.validate(name: "\(name).alarmActions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case alarmActions
        }
    }

    public struct AlarmModelSummary: AWSDecodableShape {
        /// The description of the alarm model.
        public let alarmModelDescription: String?
        /// The name of the alarm model.
        public let alarmModelName: String?
        /// The time the alarm model was created, in the Unix epoch format.
        public let creationTime: Date?

        public init(alarmModelDescription: String? = nil, alarmModelName: String? = nil, creationTime: Date? = nil) {
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.creationTime = creationTime
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelDescription
            case alarmModelName
            case creationTime
        }
    }

    public struct AlarmModelVersionSummary: AWSDecodableShape {
        /// The ARN of the alarm model. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let alarmModelArn: String?
        /// The name of the alarm model.
        public let alarmModelName: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// The time the alarm model was created, in the Unix epoch format.
        public let creationTime: Date?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let roleArn: String?
        /// The status of the alarm model. The status can be one of the following values:    ACTIVE - The alarm model is active and it's ready to evaluate data.    ACTIVATING - AWS IoT Events is activating your alarm model.  Activating an alarm model can take up to a few minutes.    INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data.
        /// 	  Check your alarm model information and update the alarm model.    FAILED - You couldn't create or update the alarm model. Check your alarm model information  and try again.
        public let status: AlarmModelVersionStatus?
        ///  Contains information about the status of the alarm model version.
        public let statusMessage: String?

        public init(alarmModelArn: String? = nil, alarmModelName: String? = nil, alarmModelVersion: String? = nil, creationTime: Date? = nil, lastUpdateTime: Date? = nil, roleArn: String? = nil, status: AlarmModelVersionStatus? = nil, statusMessage: String? = nil) {
            self.alarmModelArn = alarmModelArn
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelArn
            case alarmModelName
            case alarmModelVersion
            case creationTime
            case lastUpdateTime
            case roleArn
            case status
            case statusMessage
        }
    }

    public struct AlarmNotification: AWSEncodableShape & AWSDecodableShape {
        /// Contains the notification settings of an alarm model.
        /// The settings apply to all alarms that were created based on this alarm model.
        public let notificationActions: [NotificationAction]?

        public init(notificationActions: [NotificationAction]? = nil) {
            self.notificationActions = notificationActions
        }

        public func validate(name: String) throws {
            try self.notificationActions?.forEach {
                try $0.validate(name: "\(name).notificationActions[]")
            }
            try self.validate(self.notificationActions, name: "notificationActions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notificationActions
        }
    }

    public struct AlarmRule: AWSEncodableShape & AWSDecodableShape {
        /// A rule that compares an input property value to a threshold value with a comparison operator.
        public let simpleRule: SimpleRule?

        public init(simpleRule: SimpleRule? = nil) {
            self.simpleRule = simpleRule
        }

        public func validate(name: String) throws {
            try self.simpleRule?.validate(name: "\(name).simpleRule")
        }

        private enum CodingKeys: String, CodingKey {
            case simpleRule
        }
    }

    public struct AnalysisResult: AWSDecodableShape {
        /// The severity level of the analysis result. Based on the severity level, analysis results fall into three general categories:    INFO - An information result tells you about a significant field in your detector model. This type of result usually doesn't require immediate action.    WARNING - A warning result draws special attention to fields that might cause issues for your detector model.  We recommend that you review warnings and take necessary actions before you use your detector model in production environments. Otherwise, the detector model might not work as expected.    ERROR - An error result notifies you about a problem found in your detector model. You must fix all errors before you can publish your detector model.
        public let level: AnalysisResultLevel?
        /// Contains one or more locations that you can use to locate the fields in your detector model that the analysis result references.
        public let locations: [AnalysisResultLocation]?
        /// Contains additional information about the analysis result.
        public let message: String?
        /// The type of the analysis result. Analyses fall into the following types based on the validators used to generate the analysis result:    supported-actions - You must specify AWS IoT Events supported actions that work with other AWS services in a supported AWS Region.    service-limits - Resources or API operations can't exceed service quotas (also known as limits). Update your detector model or request a quota increase.    structure - The detector model must follow a structure that AWS IoT Events supports.     expression-syntax - Your expression must follow the required syntax.    data-type - Data types referenced in the detector model must be compatible.    referenced-data - You must define the data referenced in your detector model before you can use the data.    referenced-resource - Resources that the detector model uses must be available.   For more information, see Running detector model analyses in the AWS IoT Events Developer Guide.
        public let type: String?

        public init(level: AnalysisResultLevel? = nil, locations: [AnalysisResultLocation]? = nil, message: String? = nil, type: String? = nil) {
            self.level = level
            self.locations = locations
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case level
            case locations
            case message
            case type
        }
    }

    public struct AnalysisResultLocation: AWSDecodableShape {
        /// A JsonPath expression that identifies the error field in your detector model.
        public let path: String?

        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path
        }
    }

    public struct AssetPropertyTimestamp: AWSEncodableShape & AWSDecodableShape {
        /// The nanosecond offset converted from timeInSeconds. The valid range is between 0-999999999.
        public let offsetInNanos: String?
        /// The timestamp, in seconds, in the Unix epoch format. The valid range is between 1-31556889864403199.
        public let timeInSeconds: String

        public init(offsetInNanos: String? = nil, timeInSeconds: String) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos
            case timeInSeconds
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// The quality of the asset property value. The value must be 'GOOD', 'BAD', or 'UNCERTAIN'.
        public let quality: String?
        /// The timestamp associated with the asset property value. The default is the current event time.
        public let timestamp: AssetPropertyTimestamp?
        /// The value to send to an asset property.
        public let value: AssetPropertyVariant?

        public init(quality: String? = nil, timestamp: AssetPropertyTimestamp? = nil, value: AssetPropertyVariant? = nil) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality
            case timestamp
            case value
        }
    }

    public struct AssetPropertyVariant: AWSEncodableShape & AWSDecodableShape {
        /// The asset property value is a Boolean value that must be 'TRUE' or 'FALSE'. You must use an expression, and the evaluated result should be a Boolean value.
        public let booleanValue: String?
        /// The asset property value is a double. You must use an expression, and the evaluated result should be a double.
        public let doubleValue: String?
        /// The asset property value is an integer. You must use an expression, and the evaluated result should be an integer.
        public let integerValue: String?
        /// The asset property value is a string. You must use an expression, and the evaluated result should be a string.
        public let stringValue: String?

        public init(booleanValue: String? = nil, doubleValue: String? = nil, integerValue: String? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case integerValue
            case stringValue
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (BatchPutMessage). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the condition expressions used by detectors.  Syntax: ....
        public let jsonPath: String

        public init(jsonPath: String) {
            self.jsonPath = jsonPath
        }

        public func validate(name: String) throws {
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, max: 128)
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, min: 1)
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, pattern: "^((`[\\w\\- ]+`)|([\\w\\-]+))(\\.((`[\\w- ]+`)|([\\w\\-]+)))*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath
        }
    }

    public struct ClearTimerAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the timer to clear.
        public let timerName: String

        public init(timerName: String) {
            self.timerName = timerName
        }

        public func validate(name: String) throws {
            try self.validate(self.timerName, name: "timerName", parent: name, max: 128)
            try self.validate(self.timerName, name: "timerName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timerName
        }
    }

    public struct CreateAlarmModelRequest: AWSEncodableShape {
        /// Contains the configuration information of alarm state changes.
        public let alarmCapabilities: AlarmCapabilities?
        /// Contains information about one or more alarm actions.
        public let alarmEventActions: AlarmEventActions?
        /// A description that tells you what the alarm model detects.
        public let alarmModelDescription: String?
        /// A unique name that helps you identify the alarm model. You can't change this name after you create the alarm model.
        public let alarmModelName: String
        /// Contains information about one or more notification actions.
        public let alarmNotification: AlarmNotification?
        /// Defines when your alarm is invoked.
        public let alarmRule: AlarmRule
        /// An input attribute used as a key to create an alarm.
        /// AWS IoT Events routes inputs
        /// associated with this key to the alarm.
        public let key: String?
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let roleArn: String
        /// A non-negative integer that reflects the severity level of the alarm.
        public let severity: Int?
        /// A list of key-value pairs that contain metadata for the alarm model. The tags help you manage the alarm model. For more information, see Tagging your AWS IoT Events resources in the AWS IoT Events Developer Guide. You can create up to 50 tags for one alarm model.
        public let tags: [Tag]?

        public init(alarmCapabilities: AlarmCapabilities? = nil, alarmEventActions: AlarmEventActions? = nil, alarmModelDescription: String? = nil, alarmModelName: String, alarmNotification: AlarmNotification? = nil, alarmRule: AlarmRule, key: String? = nil, roleArn: String, severity: Int? = nil, tags: [Tag]? = nil) {
            self.alarmCapabilities = alarmCapabilities
            self.alarmEventActions = alarmEventActions
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.alarmNotification = alarmNotification
            self.alarmRule = alarmRule
            self.key = key
            self.roleArn = roleArn
            self.severity = severity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.alarmEventActions?.validate(name: "\(name).alarmEventActions")
            try self.validate(self.alarmModelDescription, name: "alarmModelDescription", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.alarmNotification?.validate(name: "\(name).alarmNotification")
            try self.alarmRule.validate(name: "\(name).alarmRule")
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^((`[\\w\\- ]+`)|([\\w\\-]+))(\\.((`[\\w- ]+`)|([\\w\\-]+)))*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.severity, name: "severity", parent: name, max: 2_147_483_647)
            try self.validate(self.severity, name: "severity", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case alarmCapabilities
            case alarmEventActions
            case alarmModelDescription
            case alarmModelName
            case alarmNotification
            case alarmRule
            case key
            case roleArn
            case severity
            case tags
        }
    }

    public struct CreateAlarmModelResponse: AWSDecodableShape {
        /// The ARN of the alarm model. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let alarmModelArn: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// The time the alarm model was created, in the Unix epoch format.
        public let creationTime: Date?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// The status of the alarm model. The status can be one of the following values:    ACTIVE - The alarm model is active and it's ready to evaluate data.    ACTIVATING - AWS IoT Events is activating your alarm model.  Activating an alarm model can take up to a few minutes.    INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data.
        /// 	  Check your alarm model information and update the alarm model.    FAILED - You couldn't create or update the alarm model. Check your alarm model information  and try again.
        public let status: AlarmModelVersionStatus?

        public init(alarmModelArn: String? = nil, alarmModelVersion: String? = nil, creationTime: Date? = nil, lastUpdateTime: Date? = nil, status: AlarmModelVersionStatus? = nil) {
            self.alarmModelArn = alarmModelArn
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelArn
            case alarmModelVersion
            case creationTime
            case lastUpdateTime
            case status
        }
    }

    public struct CreateDetectorModelRequest: AWSEncodableShape {
        /// Information that defines how the detectors operate.
        public let detectorModelDefinition: DetectorModelDefinition
        /// A brief description of the detector model.
        public let detectorModelDescription: String?
        /// The name of the detector model.
        public let detectorModelName: String
        /// Information about the order in which events are evaluated and how actions are executed.
        public let evaluationMethod: EvaluationMethod?
        /// The input attribute key used to identify a device or system to create a detector (an instance of the detector model) and then to route each input received to the appropriate detector (instance). This parameter uses a JSON-path expression in the message payload of each input to specify the attribute-value pair that is used to identify the device associated with the input.
        public let key: String?
        /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
        public let roleArn: String
        /// Metadata that can be used to manage the detector model.
        public let tags: [Tag]?

        public init(detectorModelDefinition: DetectorModelDefinition, detectorModelDescription: String? = nil, detectorModelName: String, evaluationMethod: EvaluationMethod? = nil, key: String? = nil, roleArn: String, tags: [Tag]? = nil) {
            self.detectorModelDefinition = detectorModelDefinition
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.evaluationMethod = evaluationMethod
            self.key = key
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.detectorModelDefinition.validate(name: "\(name).detectorModelDefinition")
            try self.validate(self.detectorModelDescription, name: "detectorModelDescription", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^((`[\\w\\- ]+`)|([\\w\\-]+))(\\.((`[\\w- ]+`)|([\\w\\-]+)))*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelDefinition
            case detectorModelDescription
            case detectorModelName
            case evaluationMethod
            case key
            case roleArn
            case tags
        }
    }

    public struct CreateDetectorModelResponse: AWSDecodableShape {
        /// Information about how the detector model is configured.
        public let detectorModelConfiguration: DetectorModelConfiguration?

        public init(detectorModelConfiguration: DetectorModelConfiguration? = nil) {
            self.detectorModelConfiguration = detectorModelConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelConfiguration
        }
    }

    public struct CreateInputRequest: AWSEncodableShape {
        /// The definition of the input.
        public let inputDefinition: InputDefinition
        /// A brief description of the input.
        public let inputDescription: String?
        /// The name you want to give to the input.
        public let inputName: String
        /// Metadata that can be used to manage the input.
        public let tags: [Tag]?

        public init(inputDefinition: InputDefinition, inputDescription: String? = nil, inputName: String, tags: [Tag]? = nil) {
            self.inputDefinition = inputDefinition
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.inputDefinition.validate(name: "\(name).inputDefinition")
            try self.validate(self.inputDescription, name: "inputDescription", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputDefinition
            case inputDescription
            case inputName
            case tags
        }
    }

    public struct CreateInputResponse: AWSDecodableShape {
        /// Information about the configuration of the input.
        public let inputConfiguration: InputConfiguration?

        public init(inputConfiguration: InputConfiguration? = nil) {
            self.inputConfiguration = inputConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration
        }
    }

    public struct DeleteAlarmModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alarmModelName", location: .uri(locationName: "alarmModelName"))
        ]

        /// The name of the alarm model.
        public let alarmModelName: String

        public init(alarmModelName: String) {
            self.alarmModelName = alarmModelName
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAlarmModelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDetectorModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorModelName", location: .uri(locationName: "detectorModelName"))
        ]

        /// The name of the detector model to be deleted.
        public let detectorModelName: String

        public init(detectorModelName: String) {
            self.detectorModelName = detectorModelName
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDetectorModelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInputRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "inputName", location: .uri(locationName: "inputName"))
        ]

        /// The name of the input to delete.
        public let inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public func validate(name: String) throws {
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAlarmModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alarmModelName", location: .uri(locationName: "alarmModelName")),
            AWSMemberEncoding(label: "alarmModelVersion", location: .querystring(locationName: "version"))
        ]

        /// The name of the alarm model.
        public let alarmModelName: String
        /// The version of the alarm model.
        public let alarmModelVersion: String?

        public init(alarmModelName: String, alarmModelVersion: String? = nil) {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.alarmModelVersion, name: "alarmModelVersion", parent: name, max: 128)
            try self.validate(self.alarmModelVersion, name: "alarmModelVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlarmModelResponse: AWSDecodableShape {
        /// Contains the configuration information of alarm state changes.
        public let alarmCapabilities: AlarmCapabilities?
        /// Contains information about one or more alarm actions.
        public let alarmEventActions: AlarmEventActions?
        /// The ARN of the alarm model. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let alarmModelArn: String?
        /// The description of the alarm model.
        public let alarmModelDescription: String?
        /// The name of the alarm model.
        public let alarmModelName: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// Contains information about one or more notification actions.
        public let alarmNotification: AlarmNotification?
        /// Defines when your alarm is invoked.
        public let alarmRule: AlarmRule?
        /// The time the alarm model was created, in the Unix epoch format.
        public let creationTime: Date?
        /// An input attribute used as a key to create an alarm.
        /// AWS IoT Events routes inputs
        /// associated with this key to the alarm.
        public let key: String?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let roleArn: String?
        /// A non-negative integer that reflects the severity level of the alarm.
        public let severity: Int?
        /// The status of the alarm model. The status can be one of the following values:    ACTIVE - The alarm model is active and it's ready to evaluate data.    ACTIVATING - AWS IoT Events is activating your alarm model.  Activating an alarm model can take up to a few minutes.    INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data.
        /// 	  Check your alarm model information and update the alarm model.    FAILED - You couldn't create or update the alarm model. Check your alarm model information  and try again.
        public let status: AlarmModelVersionStatus?
        ///  Contains information about the status of the alarm model.
        public let statusMessage: String?

        public init(alarmCapabilities: AlarmCapabilities? = nil, alarmEventActions: AlarmEventActions? = nil, alarmModelArn: String? = nil, alarmModelDescription: String? = nil, alarmModelName: String? = nil, alarmModelVersion: String? = nil, alarmNotification: AlarmNotification? = nil, alarmRule: AlarmRule? = nil, creationTime: Date? = nil, key: String? = nil, lastUpdateTime: Date? = nil, roleArn: String? = nil, severity: Int? = nil, status: AlarmModelVersionStatus? = nil, statusMessage: String? = nil) {
            self.alarmCapabilities = alarmCapabilities
            self.alarmEventActions = alarmEventActions
            self.alarmModelArn = alarmModelArn
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.alarmNotification = alarmNotification
            self.alarmRule = alarmRule
            self.creationTime = creationTime
            self.key = key
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.severity = severity
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case alarmCapabilities
            case alarmEventActions
            case alarmModelArn
            case alarmModelDescription
            case alarmModelName
            case alarmModelVersion
            case alarmNotification
            case alarmRule
            case creationTime
            case key
            case lastUpdateTime
            case roleArn
            case severity
            case status
            case statusMessage
        }
    }

    public struct DescribeDetectorModelAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "analysisId"))
        ]

        /// The ID of the analysis result that you want to retrieve.
        public let analysisId: String

        public init(analysisId: String) {
            self.analysisId = analysisId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDetectorModelAnalysisResponse: AWSDecodableShape {
        /// The status of the analysis activity. The status can be one of the following values:    RUNNING - AWS IoT Events is analyzing your detector model. This process can take several minutes to complete.    COMPLETE - AWS IoT Events finished analyzing your detector model.    FAILED - AWS IoT Events couldn't analyze your detector model. Try again later.
        public let status: AnalysisStatus?

        public init(status: AnalysisStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct DescribeDetectorModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorModelName", location: .uri(locationName: "detectorModelName")),
            AWSMemberEncoding(label: "detectorModelVersion", location: .querystring(locationName: "version"))
        ]

        /// The name of the detector model.
        public let detectorModelName: String
        /// The version of the detector model.
        public let detectorModelVersion: String?

        public init(detectorModelName: String, detectorModelVersion: String? = nil) {
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.detectorModelVersion, name: "detectorModelVersion", parent: name, max: 128)
            try self.validate(self.detectorModelVersion, name: "detectorModelVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDetectorModelResponse: AWSDecodableShape {
        /// Information about the detector model.
        public let detectorModel: DetectorModel?

        public init(detectorModel: DetectorModel? = nil) {
            self.detectorModel = detectorModel
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModel
        }
    }

    public struct DescribeInputRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "inputName", location: .uri(locationName: "inputName"))
        ]

        /// The name of the input.
        public let inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public func validate(name: String) throws {
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInputResponse: AWSDecodableShape {
        /// Information about the input.
        public let input: Input?

        public init(input: Input? = nil) {
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case input
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {
        /// The current settings of the AWS IoT Events logging options.
        public let loggingOptions: LoggingOptions?

        public init(loggingOptions: LoggingOptions? = nil) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct DetectorDebugOption: AWSEncodableShape & AWSDecodableShape {
        /// The name of the detector model.
        public let detectorModelName: String
        /// The value of the input attribute key used to create the detector (the instance of the detector model).
        public let keyValue: String?

        public init(detectorModelName: String, keyValue: String? = nil) {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelName
            case keyValue
        }
    }

    public struct DetectorModel: AWSDecodableShape {
        /// Information about how the detector is configured.
        public let detectorModelConfiguration: DetectorModelConfiguration?
        /// Information that defines how a detector operates.
        public let detectorModelDefinition: DetectorModelDefinition?

        public init(detectorModelConfiguration: DetectorModelConfiguration? = nil, detectorModelDefinition: DetectorModelDefinition? = nil) {
            self.detectorModelConfiguration = detectorModelConfiguration
            self.detectorModelDefinition = detectorModelDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelConfiguration
            case detectorModelDefinition
        }
    }

    public struct DetectorModelConfiguration: AWSDecodableShape {
        /// The time the detector model was created.
        public let creationTime: Date?
        /// The ARN of the detector model.
        public let detectorModelArn: String?
        /// A brief description of the detector model.
        public let detectorModelDescription: String?
        /// The name of the detector model.
        public let detectorModelName: String?
        /// The version of the detector model.
        public let detectorModelVersion: String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public let evaluationMethod: EvaluationMethod?
        /// The value used to identify a detector instance. When a device or system sends input, a new detector instance with a unique key value is created. AWS IoT Events can continue to route input to its corresponding detector instance based on this identifying information.  This parameter uses a JSON-path expression to select the attribute-value pair in the message payload that is used for identification. To route the message to the correct detector instance, the device must send a message payload that contains the same attribute-value.
        public let key: String?
        /// The time the detector model was last updated.
        public let lastUpdateTime: Date?
        /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
        public let roleArn: String?
        /// The status of the detector model.
        public let status: DetectorModelVersionStatus?

        public init(creationTime: Date? = nil, detectorModelArn: String? = nil, detectorModelDescription: String? = nil, detectorModelName: String? = nil, detectorModelVersion: String? = nil, evaluationMethod: EvaluationMethod? = nil, key: String? = nil, lastUpdateTime: Date? = nil, roleArn: String? = nil, status: DetectorModelVersionStatus? = nil) {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.key = key
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case detectorModelArn
            case detectorModelDescription
            case detectorModelName
            case detectorModelVersion
            case evaluationMethod
            case key
            case lastUpdateTime
            case roleArn
            case status
        }
    }

    public struct DetectorModelDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The state that is entered at the creation of each detector (instance).
        public let initialStateName: String
        /// Information about the states of the detector.
        public let states: [State]

        public init(initialStateName: String, states: [State]) {
            self.initialStateName = initialStateName
            self.states = states
        }

        public func validate(name: String) throws {
            try self.validate(self.initialStateName, name: "initialStateName", parent: name, max: 128)
            try self.validate(self.initialStateName, name: "initialStateName", parent: name, min: 1)
            try self.states.forEach {
                try $0.validate(name: "\(name).states[]")
            }
            try self.validate(self.states, name: "states", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case initialStateName
            case states
        }
    }

    public struct DetectorModelSummary: AWSDecodableShape {
        /// The time the detector model was created.
        public let creationTime: Date?
        /// A brief description of the detector model.
        public let detectorModelDescription: String?
        /// The name of the detector model.
        public let detectorModelName: String?

        public init(creationTime: Date? = nil, detectorModelDescription: String? = nil, detectorModelName: String? = nil) {
            self.creationTime = creationTime
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case detectorModelDescription
            case detectorModelName
        }
    }

    public struct DetectorModelVersionSummary: AWSDecodableShape {
        /// The time the detector model version was created.
        public let creationTime: Date?
        /// The ARN of the detector model version.
        public let detectorModelArn: String?
        /// The name of the detector model.
        public let detectorModelName: String?
        /// The ID of the detector model version.
        public let detectorModelVersion: String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public let evaluationMethod: EvaluationMethod?
        /// The last time the detector model version was updated.
        public let lastUpdateTime: Date?
        /// The ARN of the role that grants the detector model permission to perform its tasks.
        public let roleArn: String?
        /// The status of the detector model version.
        public let status: DetectorModelVersionStatus?

        public init(creationTime: Date? = nil, detectorModelArn: String? = nil, detectorModelName: String? = nil, detectorModelVersion: String? = nil, evaluationMethod: EvaluationMethod? = nil, lastUpdateTime: Date? = nil, roleArn: String? = nil, status: DetectorModelVersionStatus? = nil) {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case detectorModelArn
            case detectorModelName
            case detectorModelVersion
            case evaluationMethod
            case lastUpdateTime
            case roleArn
            case status
        }
    }

    public struct DynamoDBAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the hash key (also called the partition key). The hashKeyField value must match the partition key of the target DynamoDB table.
        public let hashKeyField: String
        /// The data type for the hash key (also called the partition key). You can specify the following values:    'STRING' - The hash key is a string.    'NUMBER' - The hash key is a number.   If you don't specify hashKeyType, the default value is 'STRING'.
        public let hashKeyType: String?
        /// The value of the hash key (also called the partition key).
        public let hashKeyValue: String
        /// The type of operation to perform. You can specify the following values:     'INSERT' - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.    'UPDATE' - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.    'DELETE' - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.   If you don't specify this parameter, AWS IoT Events triggers the 'INSERT' operation.
        public let operation: String?
        public let payload: Payload?
        /// The name of the DynamoDB column that receives the action payload. If you don't specify this parameter, the name of the DynamoDB column is payload.
        public let payloadField: String?
        /// The name of the range key (also called the sort key). The rangeKeyField value must match the sort key of the target DynamoDB table.
        public let rangeKeyField: String?
        /// The data type for the range key (also called the sort key), You can specify the following values:    'STRING' - The range key is a string.    'NUMBER' - The range key is number.   If you don't specify rangeKeyField, the default value is 'STRING'.
        public let rangeKeyType: String?
        /// The value of the range key (also called the sort key).
        public let rangeKeyValue: String?
        /// The name of the DynamoDB table. The tableName value must match the table name of the target DynamoDB table.
        public let tableName: String

        public init(hashKeyField: String, hashKeyType: String? = nil, hashKeyValue: String, operation: String? = nil, payload: Payload? = nil, payloadField: String? = nil, rangeKeyField: String? = nil, rangeKeyType: String? = nil, rangeKeyValue: String? = nil, tableName: String) {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payload = payload
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case hashKeyField
            case hashKeyType
            case hashKeyValue
            case operation
            case payload
            case payloadField
            case rangeKeyField
            case rangeKeyType
            case rangeKeyValue
            case tableName
        }
    }

    public struct DynamoDBv2Action: AWSEncodableShape & AWSDecodableShape {
        public let payload: Payload?
        /// The name of the DynamoDB table.
        public let tableName: String

        public init(payload: Payload? = nil, tableName: String) {
            self.payload = payload
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case payload
            case tableName
        }
    }

    public struct EmailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the subject and message of an email.
        public let content: EmailContent?
        /// The email address that sends emails.  If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must verify the email address that sends emails in Amazon SES.
        public let from: String
        /// Contains the information of one or more recipients who receive the emails.  You must add the users that receive emails to your AWS SSO store.
        public let recipients: EmailRecipients

        public init(content: EmailContent? = nil, from: String, recipients: EmailRecipients) {
            self.content = content
            self.from = from
            self.recipients = recipients
        }

        public func validate(name: String) throws {
            try self.recipients.validate(name: "\(name).recipients")
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case from
            case recipients
        }
    }

    public struct EmailContent: AWSEncodableShape & AWSDecodableShape {
        /// The message that you want to send. The message can be up to 200 characters.
        public let additionalMessage: String?
        /// The subject of the email.
        public let subject: String?

        public init(additionalMessage: String? = nil, subject: String? = nil) {
            self.additionalMessage = additionalMessage
            self.subject = subject
        }

        private enum CodingKeys: String, CodingKey {
            case additionalMessage
            case subject
        }
    }

    public struct EmailRecipients: AWSEncodableShape & AWSDecodableShape {
        /// Specifies one or more recipients who receive the email.
        public let to: [RecipientDetail]?

        public init(to: [RecipientDetail]? = nil) {
            self.to = to
        }

        public func validate(name: String) throws {
            try self.validate(self.to, name: "to", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case to
        }
    }

    public struct Event: AWSEncodableShape & AWSDecodableShape {
        /// The actions to be performed.
        public let actions: [Action]?
        /// Optional. The Boolean expression that, when TRUE, causes the actions to be performed. If not present, the actions are performed (=TRUE). If the expression result is not a Boolean value, the actions are not performed (=FALSE).
        public let condition: String?
        /// The name of the event.
        public let eventName: String

        public init(actions: [Action]? = nil, condition: String? = nil, eventName: String) {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.condition, name: "condition", parent: name, max: 512)
            try self.validate(self.eventName, name: "eventName", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case condition
            case eventName
        }
    }

    public struct FirehoseAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Kinesis Data Firehose delivery stream where the data is written.
        public let deliveryStreamName: String
        /// You can configure the action payload when you send a message to an Amazon Kinesis Data Firehose delivery stream.
        public let payload: Payload?
        /// A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public let separator: String?

        public init(deliveryStreamName: String, payload: Payload? = nil, separator: String? = nil) {
            self.deliveryStreamName = deliveryStreamName
            self.payload = payload
            self.separator = separator
        }

        public func validate(name: String) throws {
            try self.payload?.validate(name: "\(name).payload")
            try self.validate(self.separator, name: "separator", parent: name, pattern: "^([\\n\\t])|(\\r\\n)|(,)$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStreamName
            case payload
            case separator
        }
    }

    public struct GetDetectorModelAnalysisResultsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "analysisId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The ID of the analysis result that you want to retrieve.
        public let analysisId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(analysisId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analysisId = analysisId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDetectorModelAnalysisResultsResponse: AWSDecodableShape {
        /// Contains information about one or more analysis results.
        public let analysisResults: [AnalysisResult]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(analysisResults: [AnalysisResult]? = nil, nextToken: String? = nil) {
            self.analysisResults = analysisResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analysisResults
            case nextToken
        }
    }

    public struct InitializationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The value must be TRUE or FALSE. If FALSE, all alarm instances created based on the alarm model are activated. The default value is TRUE.
        public let disabledOnInitialization: Bool

        public init(disabledOnInitialization: Bool) {
            self.disabledOnInitialization = disabledOnInitialization
        }

        private enum CodingKeys: String, CodingKey {
            case disabledOnInitialization
        }
    }

    public struct Input: AWSDecodableShape {
        /// Information about the configuration of an input.
        public let inputConfiguration: InputConfiguration?
        /// The definition of the input.
        public let inputDefinition: InputDefinition?

        public init(inputConfiguration: InputConfiguration? = nil, inputDefinition: InputDefinition? = nil) {
            self.inputConfiguration = inputConfiguration
            self.inputDefinition = inputDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration
            case inputDefinition
        }
    }

    public struct InputConfiguration: AWSDecodableShape {
        /// The time the input was created.
        public let creationTime: Date
        /// The ARN of the input.
        public let inputArn: String
        /// A brief description of the input.
        public let inputDescription: String?
        /// The name of the input.
        public let inputName: String
        /// The last time the input was updated.
        public let lastUpdateTime: Date
        /// The status of the input.
        public let status: InputStatus

        public init(creationTime: Date, inputArn: String, inputDescription: String? = nil, inputName: String, lastUpdateTime: Date, status: InputStatus) {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case inputArn
            case inputDescription
            case inputName
            case lastUpdateTime
            case status
        }
    }

    public struct InputDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using BatchPutMessage. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the condition expressions used by detectors that monitor this input.
        public let attributes: [Attribute]

        public init(attributes: [Attribute]) {
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 200)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes
        }
    }

    public struct InputIdentifier: AWSEncodableShape {
        ///  The identifier of the input routed to AWS IoT Events.
        public let iotEventsInputIdentifier: IotEventsInputIdentifier?
        ///  The identifer of the input routed from AWS IoT SiteWise.
        public let iotSiteWiseInputIdentifier: IotSiteWiseInputIdentifier?

        public init(iotEventsInputIdentifier: IotEventsInputIdentifier? = nil, iotSiteWiseInputIdentifier: IotSiteWiseInputIdentifier? = nil) {
            self.iotEventsInputIdentifier = iotEventsInputIdentifier
            self.iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier
        }

        public func validate(name: String) throws {
            try self.iotEventsInputIdentifier?.validate(name: "\(name).iotEventsInputIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case iotEventsInputIdentifier
            case iotSiteWiseInputIdentifier
        }
    }

    public struct InputSummary: AWSDecodableShape {
        /// The time the input was created.
        public let creationTime: Date?
        /// The ARN of the input.
        public let inputArn: String?
        /// A brief description of the input.
        public let inputDescription: String?
        /// The name of the input.
        public let inputName: String?
        /// The last time the input was updated.
        public let lastUpdateTime: Date?
        /// The status of the input.
        public let status: InputStatus?

        public init(creationTime: Date? = nil, inputArn: String? = nil, inputDescription: String? = nil, inputName: String? = nil, lastUpdateTime: Date? = nil, status: InputStatus? = nil) {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case inputArn
            case inputDescription
            case inputName
            case lastUpdateTime
            case status
        }
    }

    public struct IotEventsAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the AWS IoT Events input where the data is sent.
        public let inputName: String
        /// You can configure the action payload when you send a message to an AWS IoT Events input.
        public let payload: Payload?

        public init(inputName: String, payload: Payload? = nil) {
            self.inputName = inputName
            self.payload = payload
        }

        public func validate(name: String) throws {
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case inputName
            case payload
        }
    }

    public struct IotEventsInputIdentifier: AWSEncodableShape {
        ///  The name of the input routed to AWS IoT Events.
        public let inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public func validate(name: String) throws {
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputName
        }
    }

    public struct IotSiteWiseAction: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset that has the specified property.
        public let assetId: String?
        /// A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier.
        public let entryId: String?
        /// The alias of the asset property.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The value to send to the asset property. This value contains timestamp, quality, and value (TQV) information.
        public let propertyValue: AssetPropertyValue?

        public init(assetId: String? = nil, entryId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, propertyValue: AssetPropertyValue? = nil) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case entryId
            case propertyAlias
            case propertyId
            case propertyValue
        }
    }

    public struct IotSiteWiseAssetModelPropertyIdentifier: AWSEncodableShape {
        ///  The ID of the AWS IoT SiteWise asset model.
        public let assetModelId: String
        ///  The ID of the AWS IoT SiteWise asset property.
        public let propertyId: String

        public init(assetModelId: String, propertyId: String) {
            self.assetModelId = assetModelId
            self.propertyId = propertyId
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelId
            case propertyId
        }
    }

    public struct IotSiteWiseInputIdentifier: AWSEncodableShape {
        ///  The identifier of the AWS IoT SiteWise asset model property.
        public let iotSiteWiseAssetModelPropertyIdentifier: IotSiteWiseAssetModelPropertyIdentifier?

        public init(iotSiteWiseAssetModelPropertyIdentifier: IotSiteWiseAssetModelPropertyIdentifier? = nil) {
            self.iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case iotSiteWiseAssetModelPropertyIdentifier
        }
    }

    public struct IotTopicPublishAction: AWSEncodableShape & AWSDecodableShape {
        /// The MQTT topic of the message. You can use a string expression that includes variables ($variable.) and input values ($input..) as the topic string.
        public let mqttTopic: String
        /// You can configure the action payload when you publish a message to an AWS IoT Core topic.
        public let payload: Payload?

        public init(mqttTopic: String, payload: Payload? = nil) {
            self.mqttTopic = mqttTopic
            self.payload = payload
        }

        public func validate(name: String) throws {
            try self.validate(self.mqttTopic, name: "mqttTopic", parent: name, max: 128)
            try self.validate(self.mqttTopic, name: "mqttTopic", parent: name, min: 1)
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case mqttTopic
            case payload
        }
    }

    public struct LambdaAction: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function that is executed.
        public let functionArn: String
        /// You can configure the action payload when you send a message to a Lambda function.
        public let payload: Payload?

        public init(functionArn: String, payload: Payload? = nil) {
            self.functionArn = functionArn
            self.payload = payload
        }

        public func validate(name: String) throws {
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 2048)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn
            case payload
        }
    }

    public struct ListAlarmModelVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alarmModelName", location: .uri(locationName: "alarmModelName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The name of the alarm model.
        public let alarmModelName: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(alarmModelName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.alarmModelName = alarmModelName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAlarmModelVersionsResponse: AWSDecodableShape {
        /// A list that summarizes each alarm model version.
        public let alarmModelVersionSummaries: [AlarmModelVersionSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(alarmModelVersionSummaries: [AlarmModelVersionSummary]? = nil, nextToken: String? = nil) {
            self.alarmModelVersionSummaries = alarmModelVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelVersionSummaries
            case nextToken
        }
    }

    public struct ListAlarmModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAlarmModelsResponse: AWSDecodableShape {
        /// A list that summarizes each alarm model.
        public let alarmModelSummaries: [AlarmModelSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(alarmModelSummaries: [AlarmModelSummary]? = nil, nextToken: String? = nil) {
            self.alarmModelSummaries = alarmModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelSummaries
            case nextToken
        }
    }

    public struct ListDetectorModelVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorModelName", location: .uri(locationName: "detectorModelName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The name of the detector model whose versions are returned.
        public let detectorModelName: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(detectorModelName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorModelName = detectorModelName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDetectorModelVersionsResponse: AWSDecodableShape {
        /// Summary information about the detector model versions.
        public let detectorModelVersionSummaries: [DetectorModelVersionSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(detectorModelVersionSummaries: [DetectorModelVersionSummary]? = nil, nextToken: String? = nil) {
            self.detectorModelVersionSummaries = detectorModelVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelVersionSummaries
            case nextToken
        }
    }

    public struct ListDetectorModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDetectorModelsResponse: AWSDecodableShape {
        /// Summary information about the detector models.
        public let detectorModelSummaries: [DetectorModelSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(detectorModelSummaries: [DetectorModelSummary]? = nil, nextToken: String? = nil) {
            self.detectorModelSummaries = detectorModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelSummaries
            case nextToken
        }
    }

    public struct ListInputRoutingsRequest: AWSEncodableShape {
        ///  The identifer of the routed input.
        public let inputIdentifier: InputIdentifier
        ///  The maximum number of results to be returned per request.
        public let maxResults: Int?
        ///  The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(inputIdentifier: InputIdentifier, maxResults: Int? = nil, nextToken: String? = nil) {
            self.inputIdentifier = inputIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.inputIdentifier.validate(name: "\(name).inputIdentifier")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inputIdentifier
            case maxResults
            case nextToken
        }
    }

    public struct ListInputRoutingsResponse: AWSDecodableShape {
        ///  The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?
        ///  Summary information about the routed resources.
        public let routedResources: [RoutedResource]?

        public init(nextToken: String? = nil, routedResources: [RoutedResource]? = nil) {
            self.nextToken = nextToken
            self.routedResources = routedResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case routedResources
        }
    }

    public struct ListInputsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInputsResponse: AWSDecodableShape {
        /// Summary information about the inputs.
        public let inputSummaries: [InputSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(inputSummaries: [InputSummary]? = nil, nextToken: String? = nil) {
            self.inputSummaries = inputSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case inputSummaries
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags assigned to the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {
        /// Information that identifies those detector models and their detectors (instances) for which the logging level is given.
        public let detectorDebugOptions: [DetectorDebugOption]?
        /// If TRUE, logging is enabled for AWS IoT Events.
        public let enabled: Bool
        /// The logging level.
        public let level: LoggingLevel
        /// The ARN of the role that grants permission to AWS IoT Events to perform logging.
        public let roleArn: String

        public init(detectorDebugOptions: [DetectorDebugOption]? = nil, enabled: Bool, level: LoggingLevel, roleArn: String) {
            self.detectorDebugOptions = detectorDebugOptions
            self.enabled = enabled
            self.level = level
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.detectorDebugOptions?.forEach {
                try $0.validate(name: "\(name).detectorDebugOptions[]")
            }
            try self.validate(self.detectorDebugOptions, name: "detectorDebugOptions", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorDebugOptions
            case enabled
            case level
            case roleArn
        }
    }

    public struct NotificationAction: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an AWS Lambda function to manage alarm notifications.
        /// You can create one or use the AWS Lambda function provided by AWS IoT Events.
        public let action: NotificationTargetActions
        /// Contains the configuration information of email notifications.
        public let emailConfigurations: [EmailConfiguration]?
        /// Contains the configuration information of SMS notifications.
        public let smsConfigurations: [SMSConfiguration]?

        public init(action: NotificationTargetActions, emailConfigurations: [EmailConfiguration]? = nil, smsConfigurations: [SMSConfiguration]? = nil) {
            self.action = action
            self.emailConfigurations = emailConfigurations
            self.smsConfigurations = smsConfigurations
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.emailConfigurations?.forEach {
                try $0.validate(name: "\(name).emailConfigurations[]")
            }
            try self.validate(self.emailConfigurations, name: "emailConfigurations", parent: name, min: 1)
            try self.smsConfigurations?.forEach {
                try $0.validate(name: "\(name).smsConfigurations[]")
            }
            try self.validate(self.smsConfigurations, name: "smsConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case emailConfigurations
            case smsConfigurations
        }
    }

    public struct NotificationTargetActions: AWSEncodableShape & AWSDecodableShape {
        public let lambdaAction: LambdaAction?

        public init(lambdaAction: LambdaAction? = nil) {
            self.lambdaAction = lambdaAction
        }

        public func validate(name: String) throws {
            try self.lambdaAction?.validate(name: "\(name).lambdaAction")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaAction
        }
    }

    public struct OnEnterLifecycle: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the actions that are performed when the state is entered and the condition is TRUE.
        public let events: [Event]?

        public init(events: [Event]? = nil) {
            self.events = events
        }

        public func validate(name: String) throws {
            try self.events?.forEach {
                try $0.validate(name: "\(name).events[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case events
        }
    }

    public struct OnExitLifecycle: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the actions that are performed when the state is exited and the condition is TRUE.
        public let events: [Event]?

        public init(events: [Event]? = nil) {
            self.events = events
        }

        public func validate(name: String) throws {
            try self.events?.forEach {
                try $0.validate(name: "\(name).events[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case events
        }
    }

    public struct OnInputLifecycle: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the actions performed when the condition evaluates to TRUE.
        public let events: [Event]?
        /// Specifies the actions performed, and the next state entered, when a condition evaluates to TRUE.
        public let transitionEvents: [TransitionEvent]?

        public init(events: [Event]? = nil, transitionEvents: [TransitionEvent]? = nil) {
            self.events = events
            self.transitionEvents = transitionEvents
        }

        public func validate(name: String) throws {
            try self.events?.forEach {
                try $0.validate(name: "\(name).events[]")
            }
            try self.transitionEvents?.forEach {
                try $0.validate(name: "\(name).transitionEvents[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case events
            case transitionEvents
        }
    }

    public struct Payload: AWSEncodableShape & AWSDecodableShape {
        /// The content of the payload. You can use a string expression that includes quoted strings (''), variables ($variable.), input values ($input..), string concatenations, and quoted strings that contain ${} as the content. The recommended maximum size of a content expression is 1 KB.
        public let contentExpression: String
        /// The value of the payload type can be either STRING or JSON.
        public let type: PayloadType

        public init(contentExpression: String, type: PayloadType) {
            self.contentExpression = contentExpression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.contentExpression, name: "contentExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentExpression
            case type
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// The new values of the AWS IoT Events logging options.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        public func validate(name: String) throws {
            try self.loggingOptions.validate(name: "\(name).loggingOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct RecipientDetail: AWSEncodableShape & AWSDecodableShape {
        /// The AWS Single Sign-On (AWS SSO) authentication information.
        public let ssoIdentity: SSOIdentity?

        public init(ssoIdentity: SSOIdentity? = nil) {
            self.ssoIdentity = ssoIdentity
        }

        private enum CodingKeys: String, CodingKey {
            case ssoIdentity
        }
    }

    public struct ResetTimerAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the timer to reset.
        public let timerName: String

        public init(timerName: String) {
            self.timerName = timerName
        }

        public func validate(name: String) throws {
            try self.validate(self.timerName, name: "timerName", parent: name, max: 128)
            try self.validate(self.timerName, name: "timerName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timerName
        }
    }

    public struct RoutedResource: AWSDecodableShape {
        ///  The ARN of the routed resource. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        ///  The name of the routed resource.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case name
        }
    }

    public struct SMSConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The message that you want to send. The message can be up to 200 characters.
        public let additionalMessage: String?
        /// Specifies one or more recipients who receive the message.  You must add the users that receive SMS messages to your AWS SSO store.
        public let recipients: [RecipientDetail]
        /// The sender ID.
        public let senderId: String?

        public init(additionalMessage: String? = nil, recipients: [RecipientDetail], senderId: String? = nil) {
            self.additionalMessage = additionalMessage
            self.recipients = recipients
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.recipients, name: "recipients", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalMessage
            case recipients
            case senderId
        }
    }

    public struct SNSTopicPublishAction: AWSEncodableShape & AWSDecodableShape {
        /// You can configure the action payload when you send a message as an Amazon SNS push notification.
        public let payload: Payload?
        /// The ARN of the Amazon SNS target where the message is sent.
        public let targetArn: String

        public init(payload: Payload? = nil, targetArn: String) {
            self.payload = payload
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.payload?.validate(name: "\(name).payload")
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 2048)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case payload
            case targetArn
        }
    }

    public struct SSOIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the AWS SSO identity store.
        public let identityStoreId: String
        /// The user ID.
        public let userId: String?

        public init(identityStoreId: String, userId: String? = nil) {
            self.identityStoreId = identityStoreId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case userId
        }
    }

    public struct SetTimerAction: AWSEncodableShape & AWSDecodableShape {
        /// The duration of the timer, in seconds. You can use a string expression that includes numbers, variables ($variable.), and input values ($input..) as the duration. The range of the duration is 1-31622400 seconds. To ensure accuracy, the minimum duration is 60 seconds. The evaluated result of the duration is rounded down to the nearest whole number.
        public let durationExpression: String?
        /// The number of seconds until the timer expires. The minimum value is 60 seconds to ensure accuracy. The maximum value is 31622400 seconds.
        public let seconds: Int?
        /// The name of the timer.
        public let timerName: String

        public init(durationExpression: String? = nil, seconds: Int? = nil, timerName: String) {
            self.durationExpression = durationExpression
            self.seconds = seconds
            self.timerName = timerName
        }

        public func validate(name: String) throws {
            try self.validate(self.durationExpression, name: "durationExpression", parent: name, max: 1024)
            try self.validate(self.durationExpression, name: "durationExpression", parent: name, min: 1)
            try self.validate(self.seconds, name: "seconds", parent: name, max: 31_622_400)
            try self.validate(self.seconds, name: "seconds", parent: name, min: 1)
            try self.validate(self.timerName, name: "timerName", parent: name, max: 128)
            try self.validate(self.timerName, name: "timerName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case durationExpression
            case seconds
            case timerName
        }
    }

    public struct SetVariableAction: AWSEncodableShape & AWSDecodableShape {
        /// The new value of the variable.
        public let value: String
        /// The name of the variable.
        public let variableName: String

        public init(value: String, variableName: String) {
            self.value = value
            self.variableName = variableName
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.variableName, name: "variableName", parent: name, max: 128)
            try self.validate(self.variableName, name: "variableName", parent: name, min: 1)
            try self.validate(self.variableName, name: "variableName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case value
            case variableName
        }
    }

    public struct SimpleRule: AWSEncodableShape & AWSDecodableShape {
        /// The comparison operator.
        public let comparisonOperator: ComparisonOperator
        /// The value on the left side of the comparison operator. You can specify an AWS IoT Events input attribute as an input property.
        public let inputProperty: String
        /// The value on the right side of the comparison operator. You can enter a number or specify an AWS IoT Events input attribute.
        public let threshold: String

        public init(comparisonOperator: ComparisonOperator, inputProperty: String, threshold: String) {
            self.comparisonOperator = comparisonOperator
            self.inputProperty = inputProperty
            self.threshold = threshold
        }

        public func validate(name: String) throws {
            try self.validate(self.inputProperty, name: "inputProperty", parent: name, max: 512)
            try self.validate(self.inputProperty, name: "inputProperty", parent: name, min: 1)
            try self.validate(self.threshold, name: "threshold", parent: name, max: 512)
            try self.validate(self.threshold, name: "threshold", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator
            case inputProperty
            case threshold
        }
    }

    public struct SqsAction: AWSEncodableShape & AWSDecodableShape {
        /// You can configure the action payload when you send a message to an Amazon SQS queue.
        public let payload: Payload?
        /// The URL of the SQS queue where the data is written.
        public let queueUrl: String
        /// Set this to TRUE if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to FALSE.
        public let useBase64: Bool?

        public init(payload: Payload? = nil, queueUrl: String, useBase64: Bool? = nil) {
            self.payload = payload
            self.queueUrl = queueUrl
            self.useBase64 = useBase64
        }

        public func validate(name: String) throws {
            try self.payload?.validate(name: "\(name).payload")
        }

        private enum CodingKeys: String, CodingKey {
            case payload
            case queueUrl
            case useBase64
        }
    }

    public struct StartDetectorModelAnalysisRequest: AWSEncodableShape {
        public let detectorModelDefinition: DetectorModelDefinition

        public init(detectorModelDefinition: DetectorModelDefinition) {
            self.detectorModelDefinition = detectorModelDefinition
        }

        public func validate(name: String) throws {
            try self.detectorModelDefinition.validate(name: "\(name).detectorModelDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelDefinition
        }
    }

    public struct StartDetectorModelAnalysisResponse: AWSDecodableShape {
        /// The ID that you can use to retrieve the analysis result.
        public let analysisId: String?

        public init(analysisId: String? = nil) {
            self.analysisId = analysisId
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId
        }
    }

    public struct State: AWSEncodableShape & AWSDecodableShape {
        /// When entering this state, perform these actions if the condition is TRUE.
        public let onEnter: OnEnterLifecycle?
        /// When exiting this state, perform these actions if the specified condition is TRUE.
        public let onExit: OnExitLifecycle?
        /// When an input is received and the condition is TRUE, perform the specified actions.
        public let onInput: OnInputLifecycle?
        /// The name of the state.
        public let stateName: String

        public init(onEnter: OnEnterLifecycle? = nil, onExit: OnExitLifecycle? = nil, onInput: OnInputLifecycle? = nil, stateName: String) {
            self.onEnter = onEnter
            self.onExit = onExit
            self.onInput = onInput
            self.stateName = stateName
        }

        public func validate(name: String) throws {
            try self.onEnter?.validate(name: "\(name).onEnter")
            try self.onExit?.validate(name: "\(name).onExit")
            try self.onInput?.validate(name: "\(name).onInput")
            try self.validate(self.stateName, name: "stateName", parent: name, max: 128)
            try self.validate(self.stateName, name: "stateName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case onEnter
            case onExit
            case onInput
            case stateName
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag's key.
        public let key: String
        /// The tag's value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        /// The new or modified tags for the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TransitionEvent: AWSEncodableShape & AWSDecodableShape {
        /// The actions to be performed.
        public let actions: [Action]?
        /// Required. A Boolean expression that when TRUE causes the actions to be performed and the nextState to be entered.
        public let condition: String
        /// The name of the transition event.
        public let eventName: String
        /// The next state to enter.
        public let nextState: String

        public init(actions: [Action]? = nil, condition: String, eventName: String, nextState: String) {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
            self.nextState = nextState
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.condition, name: "condition", parent: name, max: 512)
            try self.validate(self.eventName, name: "eventName", parent: name, max: 128)
            try self.validate(self.nextState, name: "nextState", parent: name, max: 128)
            try self.validate(self.nextState, name: "nextState", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case condition
            case eventName
            case nextState
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        /// A list of the keys of the tags to be removed from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAlarmModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alarmModelName", location: .uri(locationName: "alarmModelName"))
        ]

        /// Contains the configuration information of alarm state changes.
        public let alarmCapabilities: AlarmCapabilities?
        /// Contains information about one or more alarm actions.
        public let alarmEventActions: AlarmEventActions?
        /// The description of the alarm model.
        public let alarmModelDescription: String?
        /// The name of the alarm model.
        public let alarmModelName: String
        /// Contains information about one or more notification actions.
        public let alarmNotification: AlarmNotification?
        /// Defines when your alarm is invoked.
        public let alarmRule: AlarmRule
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let roleArn: String
        /// A non-negative integer that reflects the severity level of the alarm.
        public let severity: Int?

        public init(alarmCapabilities: AlarmCapabilities? = nil, alarmEventActions: AlarmEventActions? = nil, alarmModelDescription: String? = nil, alarmModelName: String, alarmNotification: AlarmNotification? = nil, alarmRule: AlarmRule, roleArn: String, severity: Int? = nil) {
            self.alarmCapabilities = alarmCapabilities
            self.alarmEventActions = alarmEventActions
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.alarmNotification = alarmNotification
            self.alarmRule = alarmRule
            self.roleArn = roleArn
            self.severity = severity
        }

        public func validate(name: String) throws {
            try self.alarmEventActions?.validate(name: "\(name).alarmEventActions")
            try self.validate(self.alarmModelDescription, name: "alarmModelDescription", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.alarmNotification?.validate(name: "\(name).alarmNotification")
            try self.alarmRule.validate(name: "\(name).alarmRule")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.severity, name: "severity", parent: name, max: 2_147_483_647)
            try self.validate(self.severity, name: "severity", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alarmCapabilities
            case alarmEventActions
            case alarmModelDescription
            case alarmNotification
            case alarmRule
            case roleArn
            case severity
        }
    }

    public struct UpdateAlarmModelResponse: AWSDecodableShape {
        /// The ARN of the alarm model. For more information, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let alarmModelArn: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// The time the alarm model was created, in the Unix epoch format.
        public let creationTime: Date?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// The status of the alarm model. The status can be one of the following values:    ACTIVE - The alarm model is active and it's ready to evaluate data.    ACTIVATING - AWS IoT Events is activating your alarm model.  Activating an alarm model can take up to a few minutes.    INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data.
        /// 	  Check your alarm model information and update the alarm model.    FAILED - You couldn't create or update the alarm model. Check your alarm model information  and try again.
        public let status: AlarmModelVersionStatus?

        public init(alarmModelArn: String? = nil, alarmModelVersion: String? = nil, creationTime: Date? = nil, lastUpdateTime: Date? = nil, status: AlarmModelVersionStatus? = nil) {
            self.alarmModelArn = alarmModelArn
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelArn
            case alarmModelVersion
            case creationTime
            case lastUpdateTime
            case status
        }
    }

    public struct UpdateDetectorModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorModelName", location: .uri(locationName: "detectorModelName"))
        ]

        /// Information that defines how a detector operates.
        public let detectorModelDefinition: DetectorModelDefinition
        /// A brief description of the detector model.
        public let detectorModelDescription: String?
        /// The name of the detector model that is updated.
        public let detectorModelName: String
        /// Information about the order in which events are evaluated and how actions are executed.
        public let evaluationMethod: EvaluationMethod?
        /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
        public let roleArn: String

        public init(detectorModelDefinition: DetectorModelDefinition, detectorModelDescription: String? = nil, detectorModelName: String, evaluationMethod: EvaluationMethod? = nil, roleArn: String) {
            self.detectorModelDefinition = detectorModelDefinition
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.evaluationMethod = evaluationMethod
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.detectorModelDefinition.validate(name: "\(name).detectorModelDefinition")
            try self.validate(self.detectorModelDescription, name: "detectorModelDescription", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelDefinition
            case detectorModelDescription
            case evaluationMethod
            case roleArn
        }
    }

    public struct UpdateDetectorModelResponse: AWSDecodableShape {
        /// Information about how the detector model is configured.
        public let detectorModelConfiguration: DetectorModelConfiguration?

        public init(detectorModelConfiguration: DetectorModelConfiguration? = nil) {
            self.detectorModelConfiguration = detectorModelConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelConfiguration
        }
    }

    public struct UpdateInputRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "inputName", location: .uri(locationName: "inputName"))
        ]

        /// The definition of the input.
        public let inputDefinition: InputDefinition
        /// A brief description of the input.
        public let inputDescription: String?
        /// The name of the input you want to update.
        public let inputName: String

        public init(inputDefinition: InputDefinition, inputDescription: String? = nil, inputName: String) {
            self.inputDefinition = inputDefinition
            self.inputDescription = inputDescription
            self.inputName = inputName
        }

        public func validate(name: String) throws {
            try self.inputDefinition.validate(name: "\(name).inputDefinition")
            try self.validate(self.inputDescription, name: "inputDescription", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputDefinition
            case inputDescription
        }
    }

    public struct UpdateInputResponse: AWSDecodableShape {
        /// Information about the configuration of the input.
        public let inputConfiguration: InputConfiguration?

        public init(inputConfiguration: InputConfiguration? = nil) {
            self.inputConfiguration = inputConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration
        }
    }
}
