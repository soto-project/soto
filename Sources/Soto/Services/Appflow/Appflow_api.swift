//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Appflow service.
///
/// Welcome to the Amazon AppFlow API reference. This guide is for developers who need detailed information about the Amazon AppFlow API operations, data types, and errors.  Amazon AppFlow is a fully managed integration service that enables you to securely transfer data between software as a service (SaaS) applications like Salesforce, Marketo, Slack, and ServiceNow, and Amazon Web Services like Amazon S3 and Amazon Redshift.  Use the following links to get started on the Amazon AppFlow API:    Actions: An alphabetical list of all Amazon AppFlow API operations.    Data types: An alphabetical list of all Amazon AppFlow data types.    Common parameters: Parameters that all Query operations can use.    Common errors: Client and server errors that all operations can return.   If you're new to Amazon AppFlow, we recommend that you review the Amazon AppFlow User Guide. Amazon AppFlow API users can use vendor-specific mechanisms for OAuth, and include applicable OAuth attributes (such as auth-code and redirecturi) with the connector-specific ConnectorProfileProperties when creating a new connector profile using Amazon AppFlow API operations. For example, Salesforce users can refer to the  Authorize Apps with OAuth documentation.
public struct Appflow: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Appflow client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Appflow",
            serviceIdentifier: "appflow",
            serviceProtocol: .restjson,
            apiVersion: "2020-08-23",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: AppflowErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "appflow-fips.us-east-1.amazonaws.com",
            "us-east-2": "appflow-fips.us-east-2.amazonaws.com",
            "us-west-1": "appflow-fips.us-west-1.amazonaws.com",
            "us-west-2": "appflow-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Cancels active runs for a flow. You can cancel all of the active runs for a flow, or you can cancel specific runs by providing their IDs. You can cancel a flow run only when the run is in progress. You can't cancel a run that has already completed or failed. You also can't cancel a run that's scheduled to occur but hasn't started yet. To prevent a scheduled run, you can deactivate the flow with the StopFlow action. You cannot resume a run after you cancel it. When you send your request, the status for each run becomes CancelStarted. When the cancellation completes, the status becomes Canceled.  When you cancel a run, you still incur charges for any data that the run already processed before the cancellation. If the run had already written some data to the flow destination, then that data remains in the destination. If you configured the flow to use a batch API (such as the Salesforce Bulk API 2.0), then the run will finish reading or writing its entire batch of data after the cancellation. For these operations, the data processing charges for Amazon AppFlow apply. For the pricing information, see Amazon AppFlow pricing.
    @Sendable
    @inlinable
    public func cancelFlowExecutions(_ input: CancelFlowExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelFlowExecutionsResponse {
        try await self.client.execute(
            operation: "CancelFlowExecutions", 
            path: "/cancel-flow-executions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels active runs for a flow. You can cancel all of the active runs for a flow, or you can cancel specific runs by providing their IDs. You can cancel a flow run only when the run is in progress. You can't cancel a run that has already completed or failed. You also can't cancel a run that's scheduled to occur but hasn't started yet. To prevent a scheduled run, you can deactivate the flow with the StopFlow action. You cannot resume a run after you cancel it. When you send your request, the status for each run becomes CancelStarted. When the cancellation completes, the status becomes Canceled.  When you cancel a run, you still incur charges for any data that the run already processed before the cancellation. If the run had already written some data to the flow destination, then that data remains in the destination. If you configured the flow to use a batch API (such as the Salesforce Bulk API 2.0), then the run will finish reading or writing its entire batch of data after the cancellation. For these operations, the data processing charges for Amazon AppFlow apply. For the pricing information, see Amazon AppFlow pricing.
    ///
    /// Parameters:
    ///   - executionIds: The ID of each active run to cancel. These runs must belong to the flow you specify in your request. If you omit this parameter, your request ends all active runs that belong to the flow.
    ///   - flowName: The name of a flow with active runs that you want to cancel.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelFlowExecutions(
        executionIds: [String]? = nil,
        flowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelFlowExecutionsResponse {
        let input = CancelFlowExecutionsRequest(
            executionIds: executionIds, 
            flowName: flowName
        )
        return try await self.cancelFlowExecutions(input, logger: logger)
    }

    ///  Creates a new connector profile associated with your Amazon Web Services account. There is a soft quota of 100 connector profiles per Amazon Web Services account. If you need more connector profiles than this quota allows, you can submit a request to the Amazon AppFlow team through the Amazon AppFlow support channel. In each connector profile that you create, you can provide the credentials and properties for only one connector.
    @Sendable
    @inlinable
    public func createConnectorProfile(_ input: CreateConnectorProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateConnectorProfileResponse {
        try await self.client.execute(
            operation: "CreateConnectorProfile", 
            path: "/create-connector-profile", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a new connector profile associated with your Amazon Web Services account. There is a soft quota of 100 connector profiles per Amazon Web Services account. If you need more connector profiles than this quota allows, you can submit a request to the Amazon AppFlow team through the Amazon AppFlow support channel. In each connector profile that you create, you can provide the credentials and properties for only one connector.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your CreateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateConnectorProfile. The token is active for 8 hours.
    ///   - connectionMode:  Indicates the connection mode and specifies whether it is public or private. Private flows use Amazon Web Services PrivateLink to route data over Amazon Web Services infrastructure without exposing it to the public internet.
    ///   - connectorLabel: The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    ///   - connectorProfileConfig:  Defines the connector-specific configuration and credentials.
    ///   - connectorProfileName:  The name of the connector profile. The name is unique for each ConnectorProfile in your Amazon Web Services account.
    ///   - connectorType:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - kmsArn:  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createConnectorProfile(
        clientToken: String? = CreateConnectorProfileRequest.idempotencyToken(),
        connectionMode: ConnectionMode,
        connectorLabel: String? = nil,
        connectorProfileConfig: ConnectorProfileConfig,
        connectorProfileName: String,
        connectorType: ConnectorType,
        kmsArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateConnectorProfileResponse {
        let input = CreateConnectorProfileRequest(
            clientToken: clientToken, 
            connectionMode: connectionMode, 
            connectorLabel: connectorLabel, 
            connectorProfileConfig: connectorProfileConfig, 
            connectorProfileName: connectorProfileName, 
            connectorType: connectorType, 
            kmsArn: kmsArn
        )
        return try await self.createConnectorProfile(input, logger: logger)
    }

    ///  Enables your application to create a new flow using Amazon AppFlow. You must create a connector profile before calling this API. Please note that the Request Syntax below shows syntax for multiple destinations, however, you can only transfer data to one item in this list at a time. Amazon AppFlow does not currently support flows to multiple destinations at once.
    @Sendable
    @inlinable
    public func createFlow(_ input: CreateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFlowResponse {
        try await self.client.execute(
            operation: "CreateFlow", 
            path: "/create-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Enables your application to create a new flow using Amazon AppFlow. You must create a connector profile before calling this API. Please note that the Request Syntax below shows syntax for multiple destinations, however, you can only transfer data to one item in this list at a time. Amazon AppFlow does not currently support flows to multiple destinations at once.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your CreateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateFlow. The token is active for 8 hours.
    ///   - description:  A description of the flow you want to create.
    ///   - destinationFlowConfigList:  The configuration that controls how Amazon AppFlow places data in the destination connector.
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - kmsArn:  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    ///   - metadataCatalogConfig: Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    ///   - sourceFlowConfig:  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    ///   - tags:  The tags used to organize, track, or control access for your flow.
    ///   - tasks:  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    ///   - triggerConfig:  The trigger settings that determine how and when the flow runs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFlow(
        clientToken: String? = CreateFlowRequest.idempotencyToken(),
        description: String? = nil,
        destinationFlowConfigList: [DestinationFlowConfig],
        flowName: String,
        kmsArn: String? = nil,
        metadataCatalogConfig: MetadataCatalogConfig? = nil,
        sourceFlowConfig: SourceFlowConfig,
        tags: [String: String]? = nil,
        tasks: [Task],
        triggerConfig: TriggerConfig,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFlowResponse {
        let input = CreateFlowRequest(
            clientToken: clientToken, 
            description: description, 
            destinationFlowConfigList: destinationFlowConfigList, 
            flowName: flowName, 
            kmsArn: kmsArn, 
            metadataCatalogConfig: metadataCatalogConfig, 
            sourceFlowConfig: sourceFlowConfig, 
            tags: tags, 
            tasks: tasks, 
            triggerConfig: triggerConfig
        )
        return try await self.createFlow(input, logger: logger)
    }

    ///  Enables you to delete an existing connector profile.
    @Sendable
    @inlinable
    public func deleteConnectorProfile(_ input: DeleteConnectorProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteConnectorProfileResponse {
        try await self.client.execute(
            operation: "DeleteConnectorProfile", 
            path: "/delete-connector-profile", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Enables you to delete an existing connector profile.
    ///
    /// Parameters:
    ///   - connectorProfileName:  The name of the connector profile. The name is unique for each ConnectorProfile in your account.
    ///   - forceDelete:  Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteConnectorProfile(
        connectorProfileName: String,
        forceDelete: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteConnectorProfileResponse {
        let input = DeleteConnectorProfileRequest(
            connectorProfileName: connectorProfileName, 
            forceDelete: forceDelete
        )
        return try await self.deleteConnectorProfile(input, logger: logger)
    }

    ///  Enables your application to delete an existing flow. Before deleting the flow, Amazon AppFlow validates the request by checking the flow configuration and status. You can delete flows one at a time.
    @Sendable
    @inlinable
    public func deleteFlow(_ input: DeleteFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFlowResponse {
        try await self.client.execute(
            operation: "DeleteFlow", 
            path: "/delete-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Enables your application to delete an existing flow. Before deleting the flow, Amazon AppFlow validates the request by checking the flow configuration and status. You can delete flows one at a time.
    ///
    /// Parameters:
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - forceDelete:  Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFlow(
        flowName: String,
        forceDelete: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFlowResponse {
        let input = DeleteFlowRequest(
            flowName: flowName, 
            forceDelete: forceDelete
        )
        return try await self.deleteFlow(input, logger: logger)
    }

    /// Describes the given custom connector registered in your Amazon Web Services account. This API can be used for custom connectors that are registered in your account and also for Amazon authored connectors.
    @Sendable
    @inlinable
    public func describeConnector(_ input: DescribeConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorResponse {
        try await self.client.execute(
            operation: "DescribeConnector", 
            path: "/describe-connector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the given custom connector registered in your Amazon Web Services account. This API can be used for custom connectors that are registered in your account and also for Amazon authored connectors.
    ///
    /// Parameters:
    ///   - connectorLabel: The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    ///   - connectorType: The connector type, such as CUSTOMCONNECTOR, Saleforce, Marketo. Please choose CUSTOMCONNECTOR for Lambda based custom connectors.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnector(
        connectorLabel: String? = nil,
        connectorType: ConnectorType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorResponse {
        let input = DescribeConnectorRequest(
            connectorLabel: connectorLabel, 
            connectorType: connectorType
        )
        return try await self.describeConnector(input, logger: logger)
    }

    ///  Provides details regarding the entity used with the connector, with a description of the data model for each field in that entity.
    @Sendable
    @inlinable
    public func describeConnectorEntity(_ input: DescribeConnectorEntityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorEntityResponse {
        try await self.client.execute(
            operation: "DescribeConnectorEntity", 
            path: "/describe-connector-entity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Provides details regarding the entity used with the connector, with a description of the data model for each field in that entity.
    ///
    /// Parameters:
    ///   - apiVersion: The version of the API that's used by the connector.
    ///   - connectorEntityName:  The entity name for that connector.
    ///   - connectorProfileName:  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    ///   - connectorType:  The type of connector application, such as Salesforce, Amplitude, and so on.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnectorEntity(
        apiVersion: String? = nil,
        connectorEntityName: String,
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorEntityResponse {
        let input = DescribeConnectorEntityRequest(
            apiVersion: apiVersion, 
            connectorEntityName: connectorEntityName, 
            connectorProfileName: connectorProfileName, 
            connectorType: connectorType
        )
        return try await self.describeConnectorEntity(input, logger: logger)
    }

    ///  Returns a list of connector-profile details matching the provided connector-profile names and connector-types. Both input lists are optional, and you can use them to filter the result.  If no names or connector-types are provided, returns all connector profiles in a paginated form. If there is no match, this operation returns an empty list.
    @Sendable
    @inlinable
    public func describeConnectorProfiles(_ input: DescribeConnectorProfilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorProfilesResponse {
        try await self.client.execute(
            operation: "DescribeConnectorProfiles", 
            path: "/describe-connector-profiles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns a list of connector-profile details matching the provided connector-profile names and connector-types. Both input lists are optional, and you can use them to filter the result.  If no names or connector-types are provided, returns all connector profiles in a paginated form. If there is no match, this operation returns an empty list.
    ///
    /// Parameters:
    ///   - connectorLabel: The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    ///   - connectorProfileNames:  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    ///   - connectorType:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - nextToken:  The pagination token for the next page of data.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnectorProfiles(
        connectorLabel: String? = nil,
        connectorProfileNames: [String]? = nil,
        connectorType: ConnectorType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorProfilesResponse {
        let input = DescribeConnectorProfilesRequest(
            connectorLabel: connectorLabel, 
            connectorProfileNames: connectorProfileNames, 
            connectorType: connectorType, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeConnectorProfiles(input, logger: logger)
    }

    ///  Describes the connectors vended by Amazon AppFlow for specified connector types. If you don't specify a connector type, this operation describes all connectors vended by Amazon AppFlow. If there are more connectors than can be returned in one page, the response contains a nextToken object, which can be be passed in to the next call to the DescribeConnectors API operation to retrieve the next page.
    @Sendable
    @inlinable
    public func describeConnectors(_ input: DescribeConnectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorsResponse {
        try await self.client.execute(
            operation: "DescribeConnectors", 
            path: "/describe-connectors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Describes the connectors vended by Amazon AppFlow for specified connector types. If you don't specify a connector type, this operation describes all connectors vended by Amazon AppFlow. If there are more connectors than can be returned in one page, the response contains a nextToken object, which can be be passed in to the next call to the DescribeConnectors API operation to retrieve the next page.
    ///
    /// Parameters:
    ///   - connectorTypes:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - maxResults: The maximum number of items that should be returned in the result set. The default is 20.
    ///   - nextToken:  The pagination token for the next page of data.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnectors(
        connectorTypes: [ConnectorType]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorsResponse {
        let input = DescribeConnectorsRequest(
            connectorTypes: connectorTypes, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeConnectors(input, logger: logger)
    }

    ///  Provides a description of the specified flow.
    @Sendable
    @inlinable
    public func describeFlow(_ input: DescribeFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFlowResponse {
        try await self.client.execute(
            operation: "DescribeFlow", 
            path: "/describe-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Provides a description of the specified flow.
    ///
    /// Parameters:
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeFlow(
        flowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeFlowResponse {
        let input = DescribeFlowRequest(
            flowName: flowName
        )
        return try await self.describeFlow(input, logger: logger)
    }

    ///  Fetches the execution history of the flow.
    @Sendable
    @inlinable
    public func describeFlowExecutionRecords(_ input: DescribeFlowExecutionRecordsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFlowExecutionRecordsResponse {
        try await self.client.execute(
            operation: "DescribeFlowExecutionRecords", 
            path: "/describe-flow-execution-records", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Fetches the execution history of the flow.
    ///
    /// Parameters:
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - nextToken:  The pagination token for the next page of data.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeFlowExecutionRecords(
        flowName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeFlowExecutionRecordsResponse {
        let input = DescribeFlowExecutionRecordsRequest(
            flowName: flowName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeFlowExecutionRecords(input, logger: logger)
    }

    ///  Returns the list of available connector entities supported by Amazon AppFlow. For example, you can query Salesforce for Account and Opportunity entities, or query ServiceNow for the Incident entity.
    @Sendable
    @inlinable
    public func listConnectorEntities(_ input: ListConnectorEntitiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectorEntitiesResponse {
        try await self.client.execute(
            operation: "ListConnectorEntities", 
            path: "/list-connector-entities", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns the list of available connector entities supported by Amazon AppFlow. For example, you can query Salesforce for Account and Opportunity entities, or query ServiceNow for the Incident entity.
    ///
    /// Parameters:
    ///   - apiVersion: The version of the API that's used by the connector.
    ///   - connectorProfileName:  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account, and is used to query the downstream connector.
    ///   - connectorType:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - entitiesPath:  This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    ///   - maxResults: The maximum number of items that the operation returns in the response.
    ///   - nextToken: A token that was provided by your prior ListConnectorEntities operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectorEntities(
        apiVersion: String? = nil,
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        entitiesPath: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectorEntitiesResponse {
        let input = ListConnectorEntitiesRequest(
            apiVersion: apiVersion, 
            connectorProfileName: connectorProfileName, 
            connectorType: connectorType, 
            entitiesPath: entitiesPath, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectorEntities(input, logger: logger)
    }

    /// Returns the list of all registered custom connectors in your Amazon Web Services account. This API lists only custom connectors registered in this account, not the Amazon Web Services authored connectors.
    @Sendable
    @inlinable
    public func listConnectors(_ input: ListConnectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectorsResponse {
        try await self.client.execute(
            operation: "ListConnectors", 
            path: "/list-connectors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of all registered custom connectors in your Amazon Web Services account. This API lists only custom connectors registered in this account, not the Amazon Web Services authored connectors.
    ///
    /// Parameters:
    ///   - maxResults: Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - nextToken: The pagination token for the next page of data.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectors(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectorsResponse {
        let input = ListConnectorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectors(input, logger: logger)
    }

    ///  Lists all of the flows associated with your account.
    @Sendable
    @inlinable
    public func listFlows(_ input: ListFlowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFlowsResponse {
        try await self.client.execute(
            operation: "ListFlows", 
            path: "/list-flows", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all of the flows associated with your account.
    ///
    /// Parameters:
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set.
    ///   - nextToken:  The pagination token for next page of data.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFlows(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFlowsResponse {
        let input = ListFlowsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFlows(input, logger: logger)
    }

    ///  Retrieves the tags that are associated with a specified flow.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves the tags that are associated with a specified flow.
    ///
    /// Parameters:
    ///   - resourceArn:  The Amazon Resource Name (ARN) of the specified flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Registers a new custom connector with your Amazon Web Services account. Before you can register the connector, you must deploy the associated AWS lambda function in your account.
    @Sendable
    @inlinable
    public func registerConnector(_ input: RegisterConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterConnectorResponse {
        try await self.client.execute(
            operation: "RegisterConnector", 
            path: "/register-connector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Registers a new custom connector with your Amazon Web Services account. Before you can register the connector, you must deploy the associated AWS lambda function in your account.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your RegisterConnector request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to RegisterConnector. The token is active for 8 hours.
    ///   - connectorLabel:  The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account.
    ///   - connectorProvisioningConfig: The provisioning type of the connector. Currently the only supported value is LAMBDA.
    ///   - connectorProvisioningType: The provisioning type of the connector. Currently the only supported value is LAMBDA.
    ///   - description: A description about the connector that's being registered.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerConnector(
        clientToken: String? = RegisterConnectorRequest.idempotencyToken(),
        connectorLabel: String? = nil,
        connectorProvisioningConfig: ConnectorProvisioningConfig? = nil,
        connectorProvisioningType: ConnectorProvisioningType? = nil,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterConnectorResponse {
        let input = RegisterConnectorRequest(
            clientToken: clientToken, 
            connectorLabel: connectorLabel, 
            connectorProvisioningConfig: connectorProvisioningConfig, 
            connectorProvisioningType: connectorProvisioningType, 
            description: description
        )
        return try await self.registerConnector(input, logger: logger)
    }

    /// Resets metadata about your connector entities that Amazon AppFlow stored in its cache. Use this action when you want Amazon AppFlow to return the latest information about the data that you have in a source application. Amazon AppFlow returns metadata about your entities when you use the ListConnectorEntities or DescribeConnectorEntities actions. Following these actions, Amazon AppFlow caches the metadata to reduce the number of API requests that it must send to the source application. Amazon AppFlow automatically resets the cache once every hour, but you can use this action when you want to get the latest metadata right away.
    @Sendable
    @inlinable
    public func resetConnectorMetadataCache(_ input: ResetConnectorMetadataCacheRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ResetConnectorMetadataCacheResponse {
        try await self.client.execute(
            operation: "ResetConnectorMetadataCache", 
            path: "/reset-connector-metadata-cache", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Resets metadata about your connector entities that Amazon AppFlow stored in its cache. Use this action when you want Amazon AppFlow to return the latest information about the data that you have in a source application. Amazon AppFlow returns metadata about your entities when you use the ListConnectorEntities or DescribeConnectorEntities actions. Following these actions, Amazon AppFlow caches the metadata to reduce the number of API requests that it must send to the source application. Amazon AppFlow automatically resets the cache once every hour, but you can use this action when you want to get the latest metadata right away.
    ///
    /// Parameters:
    ///   - apiVersion: The API version that you specified in the connector profile that you’re resetting cached metadata for. You must use this parameter only if the connector supports multiple API versions or if the connector type is CustomConnector. To look up how many versions a connector supports, use the DescribeConnectors action. In the response, find the value that Amazon AppFlow returns for the connectorVersion parameter. To look up the connector type, use the DescribeConnectorProfiles action. In the response, find the value that Amazon AppFlow returns for the connectorType parameter. To look up the API version that you specified in a connector profile, use the DescribeConnectorProfiles action.
    ///   - connectorEntityName: Use this parameter if you want to reset cached metadata about the details for an individual entity. If you don't include this parameter in your request, Amazon AppFlow only resets cached metadata about entity names, not entity details.
    ///   - connectorProfileName: The name of the connector profile that you want to reset cached metadata for. You can omit this parameter if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you must include this parameter in your request.
    ///   - connectorType: The type of connector to reset cached metadata for. You must include this parameter in your request if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you can omit this parameter from your request.
    ///   - entitiesPath: Use this parameter only if you’re resetting the cached metadata about a nested entity. Only some connectors support nested entities. A nested entity is one that has another entity as a parent. To use this parameter, specify the name of the parent entity. To look up the parent-child relationship of entities, you can send a ListConnectorEntities request that omits the entitiesPath parameter. Amazon AppFlow will return a list of top-level entities. For each one, it indicates whether the entity has nested entities. Then, in a subsequent ListConnectorEntities request, you can specify a parent entity name for the entitiesPath parameter. Amazon AppFlow will return a list of the child entities for that parent.
    ///   - logger: Logger use during operation
    @inlinable
    public func resetConnectorMetadataCache(
        apiVersion: String? = nil,
        connectorEntityName: String? = nil,
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        entitiesPath: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ResetConnectorMetadataCacheResponse {
        let input = ResetConnectorMetadataCacheRequest(
            apiVersion: apiVersion, 
            connectorEntityName: connectorEntityName, 
            connectorProfileName: connectorProfileName, 
            connectorType: connectorType, 
            entitiesPath: entitiesPath
        )
        return try await self.resetConnectorMetadataCache(input, logger: logger)
    }

    ///  Activates an existing flow. For on-demand flows, this operation runs the flow immediately. For schedule and event-triggered flows, this operation activates the flow.
    @Sendable
    @inlinable
    public func startFlow(_ input: StartFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartFlowResponse {
        try await self.client.execute(
            operation: "StartFlow", 
            path: "/start-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Activates an existing flow. For on-demand flows, this operation runs the flow immediately. For schedule and event-triggered flows, this operation activates the flow.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your StartFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs for flows that run on a schedule or based on an event. However, the error doesn't occur for flows that run on demand. You set the conditions that initiate your flow for the triggerConfig parameter. If you use a different value for clientToken, Amazon AppFlow considers it a new call to StartFlow. The token is active for 8 hours.
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - logger: Logger use during operation
    @inlinable
    public func startFlow(
        clientToken: String? = StartFlowRequest.idempotencyToken(),
        flowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartFlowResponse {
        let input = StartFlowRequest(
            clientToken: clientToken, 
            flowName: flowName
        )
        return try await self.startFlow(input, logger: logger)
    }

    ///  Deactivates the existing flow. For on-demand flows, this operation returns an unsupportedOperationException error message. For schedule and event-triggered flows, this operation deactivates the flow.
    @Sendable
    @inlinable
    public func stopFlow(_ input: StopFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopFlowResponse {
        try await self.client.execute(
            operation: "StopFlow", 
            path: "/stop-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deactivates the existing flow. For on-demand flows, this operation returns an unsupportedOperationException error message. For schedule and event-triggered flows, this operation deactivates the flow.
    ///
    /// Parameters:
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopFlow(
        flowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopFlowResponse {
        let input = StopFlowRequest(
            flowName: flowName
        )
        return try await self.stopFlow(input, logger: logger)
    }

    ///  Applies a tag to the specified flow.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Applies a tag to the specified flow.
    ///
    /// Parameters:
    ///   - resourceArn:  The Amazon Resource Name (ARN) of the flow that you want to tag.
    ///   - tags:  The tags used to organize, track, or control access for your flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Unregisters the custom connector registered in your account that matches the connector label provided in the request.
    @Sendable
    @inlinable
    public func unregisterConnector(_ input: UnregisterConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UnregisterConnectorResponse {
        try await self.client.execute(
            operation: "UnregisterConnector", 
            path: "/unregister-connector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Unregisters the custom connector registered in your account that matches the connector label provided in the request.
    ///
    /// Parameters:
    ///   - connectorLabel: The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account.
    ///   - forceDelete: Indicates whether Amazon AppFlow should unregister the connector, even if it is currently in use in one or more connector profiles. The default value is false.
    ///   - logger: Logger use during operation
    @inlinable
    public func unregisterConnector(
        connectorLabel: String,
        forceDelete: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UnregisterConnectorResponse {
        let input = UnregisterConnectorRequest(
            connectorLabel: connectorLabel, 
            forceDelete: forceDelete
        )
        return try await self.unregisterConnector(input, logger: logger)
    }

    ///  Removes a tag from the specified flow.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Removes a tag from the specified flow.
    ///
    /// Parameters:
    ///   - resourceArn:  The Amazon Resource Name (ARN) of the flow that you want to untag.
    ///   - tagKeys:  The tag keys associated with the tag that you want to remove from your flow.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    ///  Updates a given connector profile associated with your account.
    @Sendable
    @inlinable
    public func updateConnectorProfile(_ input: UpdateConnectorProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConnectorProfileResponse {
        try await self.client.execute(
            operation: "UpdateConnectorProfile", 
            path: "/update-connector-profile", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a given connector profile associated with your account.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorProfile. The token is active for 8 hours.
    ///   - connectionMode:  Indicates the connection mode and if it is public or private.
    ///   - connectorProfileConfig:  Defines the connector-specific profile configuration and credentials.
    ///   - connectorProfileName:  The name of the connector profile and is unique for each ConnectorProfile in the Amazon Web Services account.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnectorProfile(
        clientToken: String? = UpdateConnectorProfileRequest.idempotencyToken(),
        connectionMode: ConnectionMode,
        connectorProfileConfig: ConnectorProfileConfig,
        connectorProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConnectorProfileResponse {
        let input = UpdateConnectorProfileRequest(
            clientToken: clientToken, 
            connectionMode: connectionMode, 
            connectorProfileConfig: connectorProfileConfig, 
            connectorProfileName: connectorProfileName
        )
        return try await self.updateConnectorProfile(input, logger: logger)
    }

    /// Updates a custom connector that you've previously registered. This operation updates the connector with one of the following:   The latest version of the AWS Lambda function that's assigned to the connector   A new AWS Lambda function that you specify
    @Sendable
    @inlinable
    public func updateConnectorRegistration(_ input: UpdateConnectorRegistrationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConnectorRegistrationResponse {
        try await self.client.execute(
            operation: "UpdateConnectorRegistration", 
            path: "/update-connector-registration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a custom connector that you've previously registered. This operation updates the connector with one of the following:   The latest version of the AWS Lambda function that's assigned to the connector   A new AWS Lambda function that you specify
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorRegistration request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorRegistration. The token is active for 8 hours.
    ///   - connectorLabel: The name of the connector. The name is unique for each connector registration in your AWS account.
    ///   - connectorProvisioningConfig: 
    ///   - description: A description about the update that you're applying to the connector.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnectorRegistration(
        clientToken: String? = UpdateConnectorRegistrationRequest.idempotencyToken(),
        connectorLabel: String,
        connectorProvisioningConfig: ConnectorProvisioningConfig? = nil,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConnectorRegistrationResponse {
        let input = UpdateConnectorRegistrationRequest(
            clientToken: clientToken, 
            connectorLabel: connectorLabel, 
            connectorProvisioningConfig: connectorProvisioningConfig, 
            description: description
        )
        return try await self.updateConnectorRegistration(input, logger: logger)
    }

    ///  Updates an existing flow.
    @Sendable
    @inlinable
    public func updateFlow(_ input: UpdateFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFlowResponse {
        try await self.client.execute(
            operation: "UpdateFlow", 
            path: "/update-flow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates an existing flow.
    ///
    /// Parameters:
    ///   - clientToken: The clientToken parameter is an idempotency token. It ensures that your UpdateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateFlow. The token is active for 8 hours.
    ///   - description:  A description of the flow.
    ///   - destinationFlowConfigList:  The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - metadataCatalogConfig: Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    ///   - sourceFlowConfig: 
    ///   - tasks:  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    ///   - triggerConfig:  The trigger settings that determine how and when the flow runs.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFlow(
        clientToken: String? = UpdateFlowRequest.idempotencyToken(),
        description: String? = nil,
        destinationFlowConfigList: [DestinationFlowConfig],
        flowName: String,
        metadataCatalogConfig: MetadataCatalogConfig? = nil,
        sourceFlowConfig: SourceFlowConfig,
        tasks: [Task],
        triggerConfig: TriggerConfig,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFlowResponse {
        let input = UpdateFlowRequest(
            clientToken: clientToken, 
            description: description, 
            destinationFlowConfigList: destinationFlowConfigList, 
            flowName: flowName, 
            metadataCatalogConfig: metadataCatalogConfig, 
            sourceFlowConfig: sourceFlowConfig, 
            tasks: tasks, 
            triggerConfig: triggerConfig
        )
        return try await self.updateFlow(input, logger: logger)
    }
}

extension Appflow {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Appflow, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Appflow {
    /// Return PaginatorSequence for operation ``describeConnectorProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeConnectorProfilesPaginator(
        _ input: DescribeConnectorProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeConnectorProfilesRequest, DescribeConnectorProfilesResponse> {
        return .init(
            input: input,
            command: self.describeConnectorProfiles,
            inputKey: \DescribeConnectorProfilesRequest.nextToken,
            outputKey: \DescribeConnectorProfilesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeConnectorProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - connectorLabel: The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    ///   - connectorProfileNames:  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    ///   - connectorType:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - logger: Logger used for logging
    @inlinable
    public func describeConnectorProfilesPaginator(
        connectorLabel: String? = nil,
        connectorProfileNames: [String]? = nil,
        connectorType: ConnectorType? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeConnectorProfilesRequest, DescribeConnectorProfilesResponse> {
        let input = DescribeConnectorProfilesRequest(
            connectorLabel: connectorLabel, 
            connectorProfileNames: connectorProfileNames, 
            connectorType: connectorType, 
            maxResults: maxResults
        )
        return self.describeConnectorProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeConnectorsPaginator(
        _ input: DescribeConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeConnectorsRequest, DescribeConnectorsResponse> {
        return .init(
            input: input,
            command: self.describeConnectors,
            inputKey: \DescribeConnectorsRequest.nextToken,
            outputKey: \DescribeConnectorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - connectorTypes:  The type of connector, such as Salesforce, Amplitude, and so on.
    ///   - maxResults: The maximum number of items that should be returned in the result set. The default is 20.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeConnectorsPaginator(
        connectorTypes: [ConnectorType]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeConnectorsRequest, DescribeConnectorsResponse> {
        let input = DescribeConnectorsRequest(
            connectorTypes: connectorTypes, 
            maxResults: maxResults
        )
        return self.describeConnectorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeFlowExecutionRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeFlowExecutionRecordsPaginator(
        _ input: DescribeFlowExecutionRecordsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFlowExecutionRecordsRequest, DescribeFlowExecutionRecordsResponse> {
        return .init(
            input: input,
            command: self.describeFlowExecutionRecords,
            inputKey: \DescribeFlowExecutionRecordsRequest.nextToken,
            outputKey: \DescribeFlowExecutionRecordsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeFlowExecutionRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - flowName:  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - logger: Logger used for logging
    @inlinable
    public func describeFlowExecutionRecordsPaginator(
        flowName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeFlowExecutionRecordsRequest, DescribeFlowExecutionRecordsResponse> {
        let input = DescribeFlowExecutionRecordsRequest(
            flowName: flowName, 
            maxResults: maxResults
        )
        return self.describeFlowExecutionRecordsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        _ input: ListConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        return .init(
            input: input,
            command: self.listConnectors,
            inputKey: \ListConnectorsRequest.nextToken,
            outputKey: \ListConnectorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        let input = ListConnectorsRequest(
            maxResults: maxResults
        )
        return self.listConnectorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowsPaginator(
        _ input: ListFlowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFlowsRequest, ListFlowsResponse> {
        return .init(
            input: input,
            command: self.listFlows,
            inputKey: \ListFlowsRequest.nextToken,
            outputKey: \ListFlowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  Specifies the maximum number of items that should be returned in the result set.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFlowsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFlowsRequest, ListFlowsResponse> {
        let input = ListFlowsRequest(
            maxResults: maxResults
        )
        return self.listFlowsPaginator(input, logger: logger)
    }
}

extension Appflow.DescribeConnectorProfilesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Appflow.DescribeConnectorProfilesRequest {
        return .init(
            connectorLabel: self.connectorLabel,
            connectorProfileNames: self.connectorProfileNames,
            connectorType: self.connectorType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Appflow.DescribeConnectorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Appflow.DescribeConnectorsRequest {
        return .init(
            connectorTypes: self.connectorTypes,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Appflow.DescribeFlowExecutionRecordsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Appflow.DescribeFlowExecutionRecordsRequest {
        return .init(
            flowName: self.flowName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Appflow.ListConnectorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Appflow.ListConnectorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Appflow.ListFlowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Appflow.ListFlowsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
