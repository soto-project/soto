//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Appflow {
    // MARK: Enums

    public enum AggregationType: String, CustomStringConvertible, Codable {
        case none = "None"
        case singlefile = "SingleFile"
        public var description: String { return self.rawValue }
    }

    public enum AmplitudeConnectorOperator: String, CustomStringConvertible, Codable {
        case between = "BETWEEN"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionMode: String, CustomStringConvertible, Codable {
        case `private` = "Private"
        case `public` = "Public"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorType: String, CustomStringConvertible, Codable {
        case amplitude = "Amplitude"
        case customerprofiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventbridge = "EventBridge"
        case googleanalytics = "Googleanalytics"
        case honeycode = "Honeycode"
        case infornexus = "Infornexus"
        case lookoutmetrics = "LookoutMetrics"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case servicenow = "Servicenow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
        public var description: String { return self.rawValue }
    }

    public enum DataPullMode: String, CustomStringConvertible, Codable {
        case complete = "Complete"
        case incremental = "Incremental"
        public var description: String { return self.rawValue }
    }

    public enum DatadogConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum DynatraceConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case error = "Error"
        case inprogress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum FlowStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case deleted = "Deleted"
        case deprecated = "Deprecated"
        case draft = "Draft"
        case errored = "Errored"
        case suspended = "Suspended"
        public var description: String { return self.rawValue }
    }

    public enum GoogleAnalyticsConnectorOperator: String, CustomStringConvertible, Codable {
        case between = "BETWEEN"
        case projection = "PROJECTION"
        public var description: String { return self.rawValue }
    }

    public enum InforNexusConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum MarketoConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum `Operator`: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum OperatorPropertiesKeys: String, CustomStringConvertible, Codable {
        case concatFormat = "CONCAT_FORMAT"
        case dataType = "DATA_TYPE"
        case destinationDataType = "DESTINATION_DATA_TYPE"
        case excludeSourceFieldsList = "EXCLUDE_SOURCE_FIELDS_LIST"
        case lowerBound = "LOWER_BOUND"
        case maskLength = "MASK_LENGTH"
        case maskValue = "MASK_VALUE"
        case mathOperationFieldsOrder = "MATH_OPERATION_FIELDS_ORDER"
        case sourceDataType = "SOURCE_DATA_TYPE"
        case subfieldCategoryMap = "SUBFIELD_CATEGORY_MAP"
        case truncateLength = "TRUNCATE_LENGTH"
        case upperBound = "UPPER_BOUND"
        case validationAction = "VALIDATION_ACTION"
        case value = "VALUE"
        case values = "VALUES"
        public var description: String { return self.rawValue }
    }

    public enum PrefixFormat: String, CustomStringConvertible, Codable {
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        case month = "MONTH"
        case year = "YEAR"
        public var description: String { return self.rawValue }
    }

    public enum PrefixType: String, CustomStringConvertible, Codable {
        case filename = "FILENAME"
        case path = "PATH"
        case pathAndFilename = "PATH_AND_FILENAME"
        public var description: String { return self.rawValue }
    }

    public enum S3ConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleFrequencyType: String, CustomStringConvertible, Codable {
        case byminute = "BYMINUTE"
        case daily = "DAILY"
        case hourly = "HOURLY"
        case monthly = "MONTHLY"
        case once = "ONCE"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNowConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SingularConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SlackConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable {
        case arithmetic = "Arithmetic"
        case filter = "Filter"
        case map = "Map"
        case mapAll = "Map_all"
        case mask = "Mask"
        case merge = "Merge"
        case truncate = "Truncate"
        case validate = "Validate"
        public var description: String { return self.rawValue }
    }

    public enum TrendmicroConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case event = "Event"
        case ondemand = "OnDemand"
        case scheduled = "Scheduled"
        public var description: String { return self.rawValue }
    }

    public enum VeevaConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum WriteOperationType: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case update = "UPDATE"
        case upsert = "UPSERT"
        public var description: String { return self.rawValue }
    }

    public enum ZendeskConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AggregationConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        public let aggregationType: AggregationType?

        public init(aggregationType: AggregationType? = nil) {
            self.aggregationType = aggregationType
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType
        }
    }

    public struct AmplitudeConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String
        ///  The Secret Access Key portion of the credentials.
        public let secretKey: String

        public init(apiKey: String, secretKey: String) {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "\\S+")
            try self.validate(self.secretKey, name: "secretKey", parent: name, max: 256)
            try self.validate(self.secretKey, name: "secretKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey
            case secretKey
        }
    }

    public struct AmplitudeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AmplitudeMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct AmplitudeSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Amplitude flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct ConnectorConfiguration: AWSDecodableShape {
        ///  Specifies whether the connector can be used as a destination.
        public let canUseAsDestination: Bool?
        ///  Specifies whether the connector can be used as a source.
        public let canUseAsSource: Bool?
        ///  Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
        public let connectorMetadata: ConnectorMetadata?
        ///  Specifies if PrivateLink is enabled for that connector.
        public let isPrivateLinkEnabled: Bool?
        ///  Specifies if a PrivateLink endpoint URL is required.
        public let isPrivateLinkEndpointUrlRequired: Bool?
        ///  Lists the connectors that are available for use as destinations.
        public let supportedDestinationConnectors: [ConnectorType]?
        ///  Specifies the supported flow frequency for that connector.
        public let supportedSchedulingFrequencies: [ScheduleFrequencyType]?
        ///  Specifies the supported trigger types for the flow.
        public let supportedTriggerTypes: [TriggerType]?

        public init(canUseAsDestination: Bool? = nil, canUseAsSource: Bool? = nil, connectorMetadata: ConnectorMetadata? = nil, isPrivateLinkEnabled: Bool? = nil, isPrivateLinkEndpointUrlRequired: Bool? = nil, supportedDestinationConnectors: [ConnectorType]? = nil, supportedSchedulingFrequencies: [ScheduleFrequencyType]? = nil, supportedTriggerTypes: [TriggerType]? = nil) {
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorMetadata = connectorMetadata
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
        }

        private enum CodingKeys: String, CodingKey {
            case canUseAsDestination
            case canUseAsSource
            case connectorMetadata
            case isPrivateLinkEnabled
            case isPrivateLinkEndpointUrlRequired
            case supportedDestinationConnectors
            case supportedSchedulingFrequencies
            case supportedTriggerTypes
        }
    }

    public struct ConnectorEntity: AWSDecodableShape {
        ///  Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        public let hasNestedEntities: Bool?
        ///  The label applied to the connector entity.
        public let label: String?
        ///  The name of the connector entity.
        public let name: String

        public init(hasNestedEntities: Bool? = nil, label: String? = nil, name: String) {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case hasNestedEntities
            case label
            case name
        }
    }

    public struct ConnectorEntityField: AWSDecodableShape {
        ///  A description of the connector entity field.
        public let description: String?
        ///  The properties applied to a field when the connector is being used as a destination.
        public let destinationProperties: DestinationFieldProperties?
        ///  The unique identifier of the connector field.
        public let identifier: String
        ///  The label applied to a connector entity field.
        public let label: String?
        ///  The properties that can be applied to a field when the connector is being used as a source.
        public let sourceProperties: SourceFieldProperties?
        ///  Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues.
        public let supportedFieldTypeDetails: SupportedFieldTypeDetails?

        public init(description: String? = nil, destinationProperties: DestinationFieldProperties? = nil, identifier: String, label: String? = nil, sourceProperties: SourceFieldProperties? = nil, supportedFieldTypeDetails: SupportedFieldTypeDetails? = nil) {
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.label = label
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case destinationProperties
            case identifier
            case label
            case sourceProperties
            case supportedFieldTypeDetails
        }
    }

    public struct ConnectorMetadata: AWSDecodableShape {
        ///  The connector metadata specific to Amplitude.
        public let amplitude: AmplitudeMetadata?
        ///  The connector metadata specific to Amazon Connect Customer Profiles.
        public let customerProfiles: CustomerProfilesMetadata?
        ///  The connector metadata specific to Datadog.
        public let datadog: DatadogMetadata?
        ///  The connector metadata specific to Dynatrace.
        public let dynatrace: DynatraceMetadata?
        ///  The connector metadata specific to Amazon EventBridge.
        public let eventBridge: EventBridgeMetadata?
        ///  The connector metadata specific to Google Analytics.
        public let googleAnalytics: GoogleAnalyticsMetadata?
        ///  The connector metadata specific to Amazon Honeycode.
        public let honeycode: HoneycodeMetadata?
        ///  The connector metadata specific to Infor Nexus.
        public let inforNexus: InforNexusMetadata?
        ///  The connector metadata specific to Marketo.
        public let marketo: MarketoMetadata?
        ///  The connector metadata specific to Amazon Redshift.
        public let redshift: RedshiftMetadata?
        ///  The connector metadata specific to Amazon S3.
        public let s3: S3Metadata?
        ///  The connector metadata specific to Salesforce.
        public let salesforce: SalesforceMetadata?
        ///  The connector metadata specific to ServiceNow.
        public let serviceNow: ServiceNowMetadata?
        ///  The connector metadata specific to Singular.
        public let singular: SingularMetadata?
        ///  The connector metadata specific to Slack.
        public let slack: SlackMetadata?
        ///  The connector metadata specific to Snowflake.
        public let snowflake: SnowflakeMetadata?
        ///  The connector metadata specific to Trend Micro.
        public let trendmicro: TrendmicroMetadata?
        ///  The connector metadata specific to Upsolver.
        public let upsolver: UpsolverMetadata?
        ///  The connector metadata specific to Veeva.
        public let veeva: VeevaMetadata?
        ///  The connector metadata specific to Zendesk.
        public let zendesk: ZendeskMetadata?

        public init(amplitude: AmplitudeMetadata? = nil, customerProfiles: CustomerProfilesMetadata? = nil, datadog: DatadogMetadata? = nil, dynatrace: DynatraceMetadata? = nil, eventBridge: EventBridgeMetadata? = nil, googleAnalytics: GoogleAnalyticsMetadata? = nil, honeycode: HoneycodeMetadata? = nil, inforNexus: InforNexusMetadata? = nil, marketo: MarketoMetadata? = nil, redshift: RedshiftMetadata? = nil, s3: S3Metadata? = nil, salesforce: SalesforceMetadata? = nil, serviceNow: ServiceNowMetadata? = nil, singular: SingularMetadata? = nil, slack: SlackMetadata? = nil, snowflake: SnowflakeMetadata? = nil, trendmicro: TrendmicroMetadata? = nil, upsolver: UpsolverMetadata? = nil, veeva: VeevaMetadata? = nil, zendesk: ZendeskMetadata? = nil) {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customerProfiles = "CustomerProfiles"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case eventBridge = "EventBridge"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case upsolver = "Upsolver"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorOAuthRequest: AWSEncodableShape {
        ///  The code provided by the connector when it has been authenticated via the connected app.
        public let authCode: String?
        ///  The URL to which the authentication server redirects the browser after authorization has been granted.
        public let redirectUri: String?

        public init(authCode: String? = nil, redirectUri: String? = nil) {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }

        public func validate(name: String) throws {
            try self.validate(self.authCode, name: "authCode", parent: name, max: 512)
            try self.validate(self.authCode, name: "authCode", parent: name, pattern: "\\S+")
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 512)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case authCode
            case redirectUri
        }
    }

    public struct ConnectorOperator: AWSEncodableShape & AWSDecodableShape {
        ///  The operation to be performed on the provided Amplitude source fields.
        public let amplitude: AmplitudeConnectorOperator?
        ///  The operation to be performed on the provided Datadog source fields.
        public let datadog: DatadogConnectorOperator?
        ///  The operation to be performed on the provided Dynatrace source fields.
        public let dynatrace: DynatraceConnectorOperator?
        ///  The operation to be performed on the provided Google Analytics source fields.
        public let googleAnalytics: GoogleAnalyticsConnectorOperator?
        ///  The operation to be performed on the provided Infor Nexus source fields.
        public let inforNexus: InforNexusConnectorOperator?
        ///  The operation to be performed on the provided Marketo source fields.
        public let marketo: MarketoConnectorOperator?
        ///  The operation to be performed on the provided Amazon S3 source fields.
        public let s3: S3ConnectorOperator?
        ///  The operation to be performed on the provided Salesforce source fields.
        public let salesforce: SalesforceConnectorOperator?
        ///  The operation to be performed on the provided ServiceNow source fields.
        public let serviceNow: ServiceNowConnectorOperator?
        ///  The operation to be performed on the provided Singular source fields.
        public let singular: SingularConnectorOperator?
        ///  The operation to be performed on the provided Slack source fields.
        public let slack: SlackConnectorOperator?
        ///  The operation to be performed on the provided Trend Micro source fields.
        public let trendmicro: TrendmicroConnectorOperator?
        ///  The operation to be performed on the provided Veeva source fields.
        public let veeva: VeevaConnectorOperator?
        ///  The operation to be performed on the provided Zendesk source fields.
        public let zendesk: ZendeskConnectorOperator?

        public init(amplitude: AmplitudeConnectorOperator? = nil, datadog: DatadogConnectorOperator? = nil, dynatrace: DynatraceConnectorOperator? = nil, googleAnalytics: GoogleAnalyticsConnectorOperator? = nil, inforNexus: InforNexusConnectorOperator? = nil, marketo: MarketoConnectorOperator? = nil, s3: S3ConnectorOperator? = nil, salesforce: SalesforceConnectorOperator? = nil, serviceNow: ServiceNowConnectorOperator? = nil, singular: SingularConnectorOperator? = nil, slack: SlackConnectorOperator? = nil, trendmicro: TrendmicroConnectorOperator? = nil, veeva: VeevaConnectorOperator? = nil, zendesk: ZendeskConnectorOperator? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfile: AWSDecodableShape {
        ///  Indicates the connection mode and if it is public or private.
        public let connectionMode: ConnectionMode?
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account.
        public let connectorProfileName: String?
        ///  The connector-specific properties of the profile configuration.
        public let connectorProfileProperties: ConnectorProfileProperties?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  Specifies when the connector profile was created.
        public let createdAt: Date?
        ///  The Amazon Resource Name (ARN) of the connector profile credentials.
        public let credentialsArn: String?
        ///  Specifies when the connector profile was last updated.
        public let lastUpdatedAt: Date?

        public init(connectionMode: ConnectionMode? = nil, connectorProfileArn: String? = nil, connectorProfileName: String? = nil, connectorProfileProperties: ConnectorProfileProperties? = nil, connectorType: ConnectorType? = nil, createdAt: Date? = nil, credentialsArn: String? = nil, lastUpdatedAt: Date? = nil) {
            self.connectionMode = connectionMode
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode
            case connectorProfileArn
            case connectorProfileName
            case connectorProfileProperties
            case connectorType
            case createdAt
            case credentialsArn
            case lastUpdatedAt
        }
    }

    public struct ConnectorProfileConfig: AWSEncodableShape {
        ///  The connector-specific credentials required by each connector.
        public let connectorProfileCredentials: ConnectorProfileCredentials
        ///  The connector-specific properties of the profile configuration.
        public let connectorProfileProperties: ConnectorProfileProperties

        public init(connectorProfileCredentials: ConnectorProfileCredentials, connectorProfileProperties: ConnectorProfileProperties) {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }

        public func validate(name: String) throws {
            try self.connectorProfileCredentials.validate(name: "\(name).connectorProfileCredentials")
            try self.connectorProfileProperties.validate(name: "\(name).connectorProfileProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileCredentials
            case connectorProfileProperties
        }
    }

    public struct ConnectorProfileCredentials: AWSEncodableShape {
        ///  The connector-specific credentials required when using Amplitude.
        public let amplitude: AmplitudeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Datadog.
        public let datadog: DatadogConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Dynatrace.
        public let dynatrace: DynatraceConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Google Analytics.
        public let googleAnalytics: GoogleAnalyticsConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Amazon Honeycode.
        public let honeycode: HoneycodeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Infor Nexus.
        public let inforNexus: InforNexusConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Marketo.
        public let marketo: MarketoConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Amazon Redshift.
        public let redshift: RedshiftConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Salesforce.
        public let salesforce: SalesforceConnectorProfileCredentials?
        ///  The connector-specific credentials required when using ServiceNow.
        public let serviceNow: ServiceNowConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Singular.
        public let singular: SingularConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Slack.
        public let slack: SlackConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Snowflake.
        public let snowflake: SnowflakeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Trend Micro.
        public let trendmicro: TrendmicroConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Veeva.
        public let veeva: VeevaConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Zendesk.
        public let zendesk: ZendeskConnectorProfileCredentials?

        public init(amplitude: AmplitudeConnectorProfileCredentials? = nil, datadog: DatadogConnectorProfileCredentials? = nil, dynatrace: DynatraceConnectorProfileCredentials? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileCredentials? = nil, honeycode: HoneycodeConnectorProfileCredentials? = nil, inforNexus: InforNexusConnectorProfileCredentials? = nil, marketo: MarketoConnectorProfileCredentials? = nil, redshift: RedshiftConnectorProfileCredentials? = nil, salesforce: SalesforceConnectorProfileCredentials? = nil, serviceNow: ServiceNowConnectorProfileCredentials? = nil, singular: SingularConnectorProfileCredentials? = nil, slack: SlackConnectorProfileCredentials? = nil, snowflake: SnowflakeConnectorProfileCredentials? = nil, trendmicro: TrendmicroConnectorProfileCredentials? = nil, veeva: VeevaConnectorProfileCredentials? = nil, zendesk: ZendeskConnectorProfileCredentials? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.honeycode?.validate(name: "\(name).honeycode")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The connector-specific properties required by Amplitude.
        public let amplitude: AmplitudeConnectorProfileProperties?
        ///  The connector-specific properties required by Datadog.
        public let datadog: DatadogConnectorProfileProperties?
        ///  The connector-specific properties required by Dynatrace.
        public let dynatrace: DynatraceConnectorProfileProperties?
        ///  The connector-specific properties required Google Analytics.
        public let googleAnalytics: GoogleAnalyticsConnectorProfileProperties?
        ///  The connector-specific properties required by Amazon Honeycode.
        public let honeycode: HoneycodeConnectorProfileProperties?
        ///  The connector-specific properties required by Infor Nexus.
        public let inforNexus: InforNexusConnectorProfileProperties?
        ///  The connector-specific properties required by Marketo.
        public let marketo: MarketoConnectorProfileProperties?
        ///  The connector-specific properties required by Amazon Redshift.
        public let redshift: RedshiftConnectorProfileProperties?
        ///  The connector-specific properties required by Salesforce.
        public let salesforce: SalesforceConnectorProfileProperties?
        ///  The connector-specific properties required by serviceNow.
        public let serviceNow: ServiceNowConnectorProfileProperties?
        ///  The connector-specific properties required by Singular.
        public let singular: SingularConnectorProfileProperties?
        ///  The connector-specific properties required by Slack.
        public let slack: SlackConnectorProfileProperties?
        ///  The connector-specific properties required by Snowflake.
        public let snowflake: SnowflakeConnectorProfileProperties?
        ///  The connector-specific properties required by Trend Micro.
        public let trendmicro: TrendmicroConnectorProfileProperties?
        ///  The connector-specific properties required by Veeva.
        public let veeva: VeevaConnectorProfileProperties?
        ///  The connector-specific properties required by Zendesk.
        public let zendesk: ZendeskConnectorProfileProperties?

        public init(amplitude: AmplitudeConnectorProfileProperties? = nil, datadog: DatadogConnectorProfileProperties? = nil, dynatrace: DynatraceConnectorProfileProperties? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileProperties? = nil, honeycode: HoneycodeConnectorProfileProperties? = nil, inforNexus: InforNexusConnectorProfileProperties? = nil, marketo: MarketoConnectorProfileProperties? = nil, redshift: RedshiftConnectorProfileProperties? = nil, salesforce: SalesforceConnectorProfileProperties? = nil, serviceNow: ServiceNowConnectorProfileProperties? = nil, singular: SingularConnectorProfileProperties? = nil, slack: SlackConnectorProfileProperties? = nil, snowflake: SnowflakeConnectorProfileProperties? = nil, trendmicro: TrendmicroConnectorProfileProperties? = nil, veeva: VeevaConnectorProfileProperties? = nil, zendesk: ZendeskConnectorProfileProperties? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct CreateConnectorProfileRequest: AWSEncodableShape {
        ///  Indicates the connection mode and specifies whether it is public or private. Private flows use AWS PrivateLink to route data over AWS infrastructure without exposing it to the public internet.
        public let connectionMode: ConnectionMode
        ///  Defines the connector-specific configuration and credentials.
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your AWS account.
        public let connectorProfileName: String
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?

        public init(connectionMode: ConnectionMode, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String, connectorType: ConnectorType, kmsArn: String? = nil) {
            self.connectionMode = connectionMode
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.kmsArn = kmsArn
        }

        public func validate(name: String) throws {
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "arn:aws:kms:.*:[0-9]+:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode
            case connectorProfileConfig
            case connectorProfileName
            case connectorType
            case kmsArn
        }
    }

    public struct CreateConnectorProfileResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?

        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn
        }
    }

    public struct CreateFlowRequest: AWSEncodableShape {
        ///  A description of the flow you want to create.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow places data in the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
        public let sourceFlowConfig: SourceFlowConfig
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig

        public init(description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, kmsArn: String? = nil, sourceFlowConfig: SourceFlowConfig, tags: [String: String]? = nil, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\w!@#\\-.?,\\s]*")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "arn:aws:kms:.*:[0-9]+:.*")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "[\\s\\w+-=\\.:/@]*")
            }
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case destinationFlowConfigList
            case flowName
            case kmsArn
            case sourceFlowConfig
            case tags
            case tasks
            case triggerConfig
        }
    }

    public struct CreateFlowResponse: AWSDecodableShape {
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn
            case flowStatus
        }
    }

    public struct CustomerProfilesDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The unique name of the Amazon Connect Customer Profiles domain.
        public let domainName: String
        ///  The object specified in the Amazon Connect Customer Profiles flow destination.
        public let objectTypeName: String?

        public init(domainName: String, objectTypeName: String? = nil) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S+")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName
            case objectTypeName
        }
    }

    public struct CustomerProfilesMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DatadogConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String
        ///  Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        public let applicationKey: String

        public init(apiKey: String, applicationKey: String) {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "\\S+")
            try self.validate(self.applicationKey, name: "applicationKey", parent: name, max: 512)
            try self.validate(self.applicationKey, name: "applicationKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey
            case applicationKey
        }
    }

    public struct DatadogConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Datadog resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct DatadogMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DatadogSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Datadog flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct DeleteConnectorProfileRequest: AWSEncodableShape {
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your account.
        public let connectorProfileName: String
        ///  Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
        public let forceDelete: Bool?

        public init(connectorProfileName: String, forceDelete: Bool? = nil) {
            self.connectorProfileName = connectorProfileName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName
            case forceDelete
        }
    }

    public struct DeleteConnectorProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
        public let forceDelete: Bool?

        public init(flowName: String, forceDelete: Bool? = nil) {
            self.flowName = flowName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName
            case forceDelete
        }
    }

    public struct DeleteFlowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeConnectorEntityRequest: AWSEncodableShape {
        ///  The entity name for that connector.
        public let connectorEntityName: String
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account.
        public let connectorProfileName: String?
        ///  The type of connector application, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?

        public init(connectorEntityName: String, connectorProfileName: String? = nil, connectorType: ConnectorType? = nil) {
            self.connectorEntityName = connectorEntityName
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, max: 128)
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, pattern: "\\S+")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityName
            case connectorProfileName
            case connectorType
        }
    }

    public struct DescribeConnectorEntityResponse: AWSDecodableShape {
        ///  Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on.
        public let connectorEntityFields: [ConnectorEntityField]

        public init(connectorEntityFields: [ConnectorEntityField]) {
            self.connectorEntityFields = connectorEntityFields
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityFields
        }
    }

    public struct DescribeConnectorProfilesRequest: AWSEncodableShape {
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account.
        public let connectorProfileNames: [String]?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
        public let maxResults: Int?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        public init(connectorProfileNames: [String]? = nil, connectorType: ConnectorType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorProfileNames = connectorProfileNames
            self.connectorType = connectorType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.connectorProfileNames?.forEach {
                try validate($0, name: "connectorProfileNames[]", parent: name, max: 256)
                try validate($0, name: "connectorProfileNames[]", parent: name, pattern: "[\\w/!@#+=.-]+")
            }
            try self.validate(self.connectorProfileNames, name: "connectorProfileNames", parent: name, max: 100)
            try self.validate(self.connectorProfileNames, name: "connectorProfileNames", parent: name, min: 0)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileNames
            case connectorType
            case maxResults
            case nextToken
        }
    }

    public struct DescribeConnectorProfilesResponse: AWSDecodableShape {
        ///  Returns information about the connector profiles associated with the flow.
        public let connectorProfileDetails: [ConnectorProfile]?
        ///  The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
        public let nextToken: String?

        public init(connectorProfileDetails: [ConnectorProfile]? = nil, nextToken: String? = nil) {
            self.connectorProfileDetails = connectorProfileDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileDetails
            case nextToken
        }
    }

    public struct DescribeConnectorsRequest: AWSEncodableShape {
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorTypes: [ConnectorType]?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        public init(connectorTypes: [ConnectorType]? = nil, nextToken: String? = nil) {
            self.connectorTypes = connectorTypes
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorTypes, name: "connectorTypes", parent: name, max: 100)
            try self.validate(self.connectorTypes, name: "connectorTypes", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorTypes
            case nextToken
        }
    }

    public struct DescribeConnectorsResponse: AWSDecodableShape {
        ///  The configuration that is applied to the connectors used in the flow.
        public let connectorConfigurations: [ConnectorType: ConnectorConfiguration]?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        public init(connectorConfigurations: [ConnectorType: ConnectorConfiguration]? = nil, nextToken: String? = nil) {
            self.connectorConfigurations = connectorConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorConfigurations
            case nextToken
        }
    }

    public struct DescribeFlowExecutionRecordsRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
        public let maxResults: Int?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        public init(flowName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowName = flowName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName
            case maxResults
            case nextToken
        }
    }

    public struct DescribeFlowExecutionRecordsResponse: AWSDecodableShape {
        ///  Returns a list of all instances when this flow was run.
        public let flowExecutions: [ExecutionRecord]?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        public init(flowExecutions: [ExecutionRecord]? = nil, nextToken: String? = nil) {
            self.flowExecutions = flowExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowExecutions
            case nextToken
        }
    }

    public struct DescribeFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName
        }
    }

    public struct DescribeFlowResponse: AWSDecodableShape {
        ///  Specifies when the flow was created.
        public let createdAt: Date?
        ///  The ARN of the user who created the flow.
        public let createdBy: String?
        ///  A description of the flow.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?
        ///  Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
        public let flowStatusMessage: String?
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?
        ///  Describes the details of the most recent flow run.
        public let lastRunExecutionDetails: ExecutionDetails?
        ///  Specifies when the flow was last updated.
        public let lastUpdatedAt: Date?
        ///  Specifies the user name of the account that performed the most recent update.
        public let lastUpdatedBy: String?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
        public let sourceFlowConfig: SourceFlowConfig?
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]?
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig]? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, flowStatusMessage: String? = nil, kmsArn: String? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, sourceFlowConfig: SourceFlowConfig? = nil, tags: [String: String]? = nil, tasks: [Task]? = nil, triggerConfig: TriggerConfig? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.flowStatusMessage = flowStatusMessage
            self.kmsArn = kmsArn
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case description
            case destinationFlowConfigList
            case flowArn
            case flowName
            case flowStatus
            case flowStatusMessage
            case kmsArn
            case lastRunExecutionDetails
            case lastUpdatedAt
            case lastUpdatedBy
            case sourceFlowConfig
            case tags
            case tasks
            case triggerConfig
        }
    }

    public struct DestinationConnectorProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The properties required to query Amazon Connect Customer Profiles.
        public let customerProfiles: CustomerProfilesDestinationProperties?
        ///  The properties required to query Amazon EventBridge.
        public let eventBridge: EventBridgeDestinationProperties?
        ///  The properties required to query Amazon Honeycode.
        public let honeycode: HoneycodeDestinationProperties?
        ///  The properties required to query Amazon Lookout for Metrics.
        public let lookoutMetrics: LookoutMetricsDestinationProperties?
        ///  The properties required to query Amazon Redshift.
        public let redshift: RedshiftDestinationProperties?
        ///  The properties required to query Amazon S3.
        public let s3: S3DestinationProperties?
        ///  The properties required to query Salesforce.
        public let salesforce: SalesforceDestinationProperties?
        ///  The properties required to query Snowflake.
        public let snowflake: SnowflakeDestinationProperties?
        ///  The properties required to query Upsolver.
        public let upsolver: UpsolverDestinationProperties?
        /// The properties required to query Zendesk.
        public let zendesk: ZendeskDestinationProperties?

        public init(customerProfiles: CustomerProfilesDestinationProperties? = nil, eventBridge: EventBridgeDestinationProperties? = nil, honeycode: HoneycodeDestinationProperties? = nil, lookoutMetrics: LookoutMetricsDestinationProperties? = nil, redshift: RedshiftDestinationProperties? = nil, s3: S3DestinationProperties? = nil, salesforce: SalesforceDestinationProperties? = nil, snowflake: SnowflakeDestinationProperties? = nil, upsolver: UpsolverDestinationProperties? = nil, zendesk: ZendeskDestinationProperties? = nil) {
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.customerProfiles?.validate(name: "\(name).customerProfiles")
            try self.eventBridge?.validate(name: "\(name).eventBridge")
            try self.honeycode?.validate(name: "\(name).honeycode")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.upsolver?.validate(name: "\(name).upsolver")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfiles = "CustomerProfiles"
            case eventBridge = "EventBridge"
            case honeycode = "Honeycode"
            case lookoutMetrics = "LookoutMetrics"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case snowflake = "Snowflake"
            case upsolver = "Upsolver"
            case zendesk = "Zendesk"
        }
    }

    public struct DestinationFieldProperties: AWSDecodableShape {
        ///  Specifies if the destination field can be created by the current user.
        public let isCreatable: Bool?
        ///  Specifies if the destination field can have a null value.
        public let isNullable: Bool?
        ///  Specifies whether the field can be updated during an UPDATE or UPSERT write operation.
        public let isUpdatable: Bool?
        ///  Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        public let isUpsertable: Bool?
        ///  A list of supported write operations. For each write operation listed, this field can be used in idFieldNames when that write operation is present as a destination option.
        public let supportedWriteOperations: [WriteOperationType]?

        public init(isCreatable: Bool? = nil, isNullable: Bool? = nil, isUpdatable: Bool? = nil, isUpsertable: Bool? = nil, supportedWriteOperations: [WriteOperationType]? = nil) {
            self.isCreatable = isCreatable
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }

        private enum CodingKeys: String, CodingKey {
            case isCreatable
            case isNullable
            case isUpdatable
            case isUpsertable
            case supportedWriteOperations
        }
    }

    public struct DestinationFlowConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the connector profile. This name must be unique for each connector profile in the AWS account.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  This stores the information that is required to query a particular connector.
        public let destinationConnectorProperties: DestinationConnectorProperties

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType, destinationConnectorProperties: DestinationConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.destinationConnectorProperties.validate(name: "\(name).destinationConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName
            case connectorType
            case destinationConnectorProperties
        }
    }

    public struct DynatraceConnectorProfileCredentials: AWSEncodableShape {
        ///  The API tokens used by Dynatrace API to authenticate various API calls.
        public let apiToken: String

        public init(apiToken: String) {
            self.apiToken = apiToken
        }

        public func validate(name: String) throws {
            try self.validate(self.apiToken, name: "apiToken", parent: name, max: 256)
            try self.validate(self.apiToken, name: "apiToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiToken
        }
    }

    public struct DynatraceConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Dynatrace resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct DynatraceMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DynatraceSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Dynatrace flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct ErrorHandlingConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the name of the Amazon S3 bucket.
        public let bucketName: String?
        ///  Specifies the Amazon S3 bucket prefix.
        public let bucketPrefix: String?
        ///  Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        public let failOnFirstDestinationError: Bool?

        public init(bucketName: String? = nil, bucketPrefix: String? = nil, failOnFirstDestinationError: Bool? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case bucketPrefix
            case failOnFirstDestinationError
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        ///  Specifies the error message that appears if a flow fails.
        public let executionMessage: String?
        ///  Specifies the failure count for the attempted flow.
        public let putFailuresCount: Int64?

        public init(executionMessage: String? = nil, putFailuresCount: Int64? = nil) {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }

        private enum CodingKeys: String, CodingKey {
            case executionMessage
            case putFailuresCount
        }
    }

    public struct EventBridgeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Amazon EventBridge flow destination.
        public let object: String

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig
            case object
        }
    }

    public struct EventBridgeMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct ExecutionDetails: AWSDecodableShape {
        ///  Describes the details of the most recent flow run.
        public let mostRecentExecutionMessage: String?
        ///  Specifies the status of the most recent flow run.
        public let mostRecentExecutionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent flow run.
        public let mostRecentExecutionTime: Date?

        public init(mostRecentExecutionMessage: String? = nil, mostRecentExecutionStatus: ExecutionStatus? = nil, mostRecentExecutionTime: Date? = nil) {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }

        private enum CodingKeys: String, CodingKey {
            case mostRecentExecutionMessage
            case mostRecentExecutionStatus
            case mostRecentExecutionTime
        }
    }

    public struct ExecutionRecord: AWSDecodableShape {
        ///  The timestamp that indicates the last new or updated record to be transferred in the flow run.
        public let dataPullEndTime: Date?
        ///  The timestamp that determines the first new or updated record to be transferred in the flow run.
        public let dataPullStartTime: Date?
        ///  Specifies the identifier of the given flow run.
        public let executionId: String?
        ///  Describes the result of the given flow run.
        public let executionResult: ExecutionResult?
        ///  Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        public let executionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent update.
        public let lastUpdatedAt: Date?
        ///  Specifies the start time of the flow run.
        public let startedAt: Date?

        public init(dataPullEndTime: Date? = nil, dataPullStartTime: Date? = nil, executionId: String? = nil, executionResult: ExecutionResult? = nil, executionStatus: ExecutionStatus? = nil, lastUpdatedAt: Date? = nil, startedAt: Date? = nil) {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.startedAt = startedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullEndTime
            case dataPullStartTime
            case executionId
            case executionResult
            case executionStatus
            case lastUpdatedAt
            case startedAt
        }
    }

    public struct ExecutionResult: AWSDecodableShape {
        ///  The total number of bytes processed by the flow run.
        public let bytesProcessed: Int64?
        ///  The total number of bytes written as a result of the flow run.
        public let bytesWritten: Int64?
        ///  Provides any error message information related to the flow run.
        public let errorInfo: ErrorInfo?
        ///  The number of records processed in the flow run.
        public let recordsProcessed: Int64?

        public init(bytesProcessed: Int64? = nil, bytesWritten: Int64? = nil, errorInfo: ErrorInfo? = nil, recordsProcessed: Int64? = nil) {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.recordsProcessed = recordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case bytesProcessed
            case bytesWritten
            case errorInfo
            case recordsProcessed
        }
    }

    public struct FieldTypeDetails: AWSDecodableShape {
        ///  The type of field, such as string, integer, date, and so on.
        public let fieldType: String
        ///  The list of operators supported by a field.
        public let filterOperators: [Operator]
        ///  The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false".
        public let supportedValues: [String]?

        public init(fieldType: String, filterOperators: [Operator], supportedValues: [String]? = nil) {
            self.fieldType = fieldType
            self.filterOperators = filterOperators
            self.supportedValues = supportedValues
        }

        private enum CodingKeys: String, CodingKey {
            case fieldType
            case filterOperators
            case supportedValues
        }
    }

    public struct FlowDefinition: AWSDecodableShape {
        ///  Specifies when the flow was created.
        public let createdAt: Date?
        ///  The ARN of the user who created the flow.
        public let createdBy: String?
        ///  A user-entered description of the flow.
        public let description: String?
        ///  Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public let destinationConnectorType: ConnectorType?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?
        ///  Describes the details of the most recent flow run.
        public let lastRunExecutionDetails: ExecutionDetails?
        ///  Specifies when the flow was last updated.
        public let lastUpdatedAt: Date?
        ///  Specifies the account user name that most recently updated the flow.
        public let lastUpdatedBy: String?
        ///  Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public let sourceConnectorType: ConnectorType?
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public let triggerType: TriggerType?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, destinationConnectorType: ConnectorType? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, sourceConnectorType: ConnectorType? = nil, tags: [String: String]? = nil, triggerType: TriggerType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case description
            case destinationConnectorType
            case flowArn
            case flowName
            case flowStatus
            case lastRunExecutionDetails
            case lastUpdatedAt
            case lastUpdatedBy
            case sourceConnectorType
            case tags
            case triggerType
        }
    }

    public struct GoogleAnalyticsConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Google Analytics resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        public let refreshToken: String?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "\\S+")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 512)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case clientId
            case clientSecret
            case oAuthRequest
            case refreshToken
        }
    }

    public struct GoogleAnalyticsConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct GoogleAnalyticsMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Google Analytics account.
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes
        }
    }

    public struct GoogleAnalyticsSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Google Analytics flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct HoneycodeConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Amazon Honeycode resources.
        public let accessToken: String?
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens.
        public let refreshToken: String?

        public init(accessToken: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 512)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case oAuthRequest
            case refreshToken
        }
    }

    public struct HoneycodeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct HoneycodeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Amazon Honeycode flow destination.
        public let object: String

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig
            case object
        }
    }

    public struct HoneycodeMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Amazon Honeycode account.
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes
        }
    }

    public struct IncrementalPullConfig: AWSEncodableShape & AWSDecodableShape {
        ///  A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public let datetimeTypeFieldName: String?

        public init(datetimeTypeFieldName: String? = nil) {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }

        public func validate(name: String) throws {
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, max: 256)
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case datetimeTypeFieldName
        }
    }

    public struct InforNexusConnectorProfileCredentials: AWSEncodableShape {
        ///  The Access Key portion of the credentials.
        public let accessKeyId: String
        ///  The encryption keys used to encrypt data.
        public let datakey: String
        ///  The secret key used to sign requests.
        public let secretAccessKey: String
        ///  The identifier for the user.
        public let userId: String

        public init(accessKeyId: String, datakey: String, secretAccessKey: String, userId: String) {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, max: 256)
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, pattern: "\\S+")
            try self.validate(self.datakey, name: "datakey", parent: name, max: 512)
            try self.validate(self.datakey, name: "datakey", parent: name, pattern: "\\S+")
            try self.validate(self.secretAccessKey, name: "secretAccessKey", parent: name, max: 512)
            try self.validate(self.secretAccessKey, name: "secretAccessKey", parent: name, pattern: "\\S+")
            try self.validate(self.userId, name: "userId", parent: name, max: 512)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case datakey
            case secretAccessKey
            case userId
        }
    }

    public struct InforNexusConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Infor Nexus resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct InforNexusMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct InforNexusSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Infor Nexus flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct ListConnectorEntitiesRequest: AWSEncodableShape {
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account, and is used to query the downstream connector.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
        public let entitiesPath: String?

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType? = nil, entitiesPath: String? = nil) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.entitiesPath = entitiesPath
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, max: 256)
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, pattern: "[\\s\\w/!@#+=.-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName
            case connectorType
            case entitiesPath
        }
    }

    public struct ListConnectorEntitiesResponse: AWSDecodableShape {
        ///  The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
        public let connectorEntityMap: [String: [ConnectorEntity]]

        public init(connectorEntityMap: [String: [ConnectorEntity]]) {
            self.connectorEntityMap = connectorEntityMap
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityMap
        }
    }

    public struct ListFlowsRequest: AWSEncodableShape {
        ///  Specifies the maximum number of items that should be returned in the result set.
        public let maxResults: Int?
        ///  The pagination token for next page of data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListFlowsResponse: AWSDecodableShape {
        ///  The list of flows associated with your account.
        public let flows: [FlowDefinition]?
        ///  The pagination token for next page of data.
        public let nextToken: String?

        public init(flows: [FlowDefinition]? = nil, nextToken: String? = nil) {
            self.flows = flows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flows
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the specified flow.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LookoutMetricsDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct MarketoConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Marketo resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "\\S+")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case clientId
            case clientSecret
            case oAuthRequest
        }
    }

    public struct MarketoConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Marketo resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct MarketoMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct MarketoSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Marketo flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct PrefixConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Determines the level of granularity that's included in the prefix.
        public let prefixFormat: PrefixFormat?
        ///  Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        public let prefixType: PrefixType?

        public init(prefixFormat: PrefixFormat? = nil, prefixType: PrefixType? = nil) {
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }

        private enum CodingKeys: String, CodingKey {
            case prefixFormat
            case prefixType
        }
    }

    public struct RedshiftConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password
            case username
        }
    }

    public struct RedshiftConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  A name for the associated Amazon S3 bucket.
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        ///  The JDBC URL of the Amazon Redshift cluster.
        public let databaseUrl: String
        ///  The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String

        public init(bucketName: String, bucketPrefix: String? = nil, databaseUrl: String, roleArn: String) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.databaseUrl = databaseUrl
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.validate(self.databaseUrl, name: "databaseUrl", parent: name, max: 512)
            try self.validate(self.databaseUrl, name: "databaseUrl", parent: name, pattern: "\\S+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:aws:iam:.*:[0-9]+:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case bucketPrefix
            case databaseUrl
            case roleArn
        }
    }

    public struct RedshiftDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object key for the bucket in which Amazon AppFlow places the destination files.
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        public let intermediateBucketName: String
        ///  The object specified in the Amazon Redshift flow destination.
        public let object: String

        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, max: 63)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, min: 3)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, pattern: "\\S+")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix
            case errorHandlingConfig
            case intermediateBucketName
            case object
        }
    }

    public struct RedshiftMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct S3DestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        public let s3OutputFormatConfig: S3OutputFormatConfig?

        public init(bucketName: String, bucketPrefix: String? = nil, s3OutputFormatConfig: S3OutputFormatConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case bucketPrefix
            case s3OutputFormatConfig
        }
    }

    public struct S3Metadata: AWSDecodableShape {
        public init() {}
    }

    public struct S3OutputFormatConfig: AWSEncodableShape & AWSDecodableShape {
        public let aggregationConfig: AggregationConfig?
        ///  Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        public let fileType: FileType?
        ///  Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        public let prefixConfig: PrefixConfig?

        public init(aggregationConfig: AggregationConfig? = nil, fileType: FileType? = nil, prefixConfig: PrefixConfig? = nil) {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationConfig
            case fileType
            case prefixConfig
        }
    }

    public struct S3SourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon S3 bucket name where the source files are stored.
        public let bucketName: String
        ///  The object key for the Amazon S3 bucket in which the source files are stored.
        public let bucketPrefix: String?

        public init(bucketName: String, bucketPrefix: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case bucketPrefix
        }
    }

    public struct SalesforceConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Salesforce resources.
        public let accessToken: String?
        ///  The secret manager ARN, which contains the client ID and client secret of the connected app.
        public let clientCredentialsArn: String?
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens.
        public let refreshToken: String?

        public init(accessToken: String? = nil, clientCredentialsArn: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, max: 2048)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, min: 20)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, pattern: "arn:aws:secretsmanager:.*:[0-9]+:.*")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 512)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case clientCredentialsArn
            case oAuthRequest
            case refreshToken
        }
    }

    public struct SalesforceConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Salesforce resource.
        public let instanceUrl: String?
        ///  Indicates whether the connector profile applies to a sandbox or production environment.
        public let isSandboxEnvironment: Bool?

        public init(instanceUrl: String? = nil, isSandboxEnvironment: Bool? = nil) {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
            case isSandboxEnvironment
        }
    }

    public struct SalesforceDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        public let idFieldNames: [String]?
        ///  The object specified in the Salesforce flow destination.
        public let object: String
        ///  This specifies the type of write operation to be performed in Salesforce. When the value is UPSERT, then idFieldNames is required.
        public let writeOperationType: WriteOperationType?

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, object: String, writeOperationType: WriteOperationType? = nil) {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "\\S+")
            }
            try self.validate(self.idFieldNames, name: "idFieldNames", parent: name, max: 1)
            try self.validate(self.idFieldNames, name: "idFieldNames", parent: name, min: 0)
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig
            case idFieldNames
            case object
            case writeOperationType
        }
    }

    public struct SalesforceMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Salesforce account.
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes
        }
    }

    public struct SalesforceSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public let enableDynamicFieldUpdate: Bool?
        ///  Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public let includeDeletedRecords: Bool?
        ///  The object specified in the Salesforce flow source.
        public let object: String

        public init(enableDynamicFieldUpdate: Bool? = nil, includeDeletedRecords: Bool? = nil, object: String) {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case enableDynamicFieldUpdate
            case includeDeletedRecords
            case object
        }
    }

    public struct ScheduledTriggerProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public let dataPullMode: DataPullMode?
        ///  Specifies the date range for the records to import from the connector in the first flow run.
        public let firstExecutionFrom: Date?
        ///  Specifies the scheduled end time for a schedule-triggered flow.
        public let scheduleEndTime: Date?
        ///  The scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
        public let scheduleExpression: String
        ///  Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public let scheduleOffset: Int64?
        ///  Specifies the scheduled start time for a schedule-triggered flow.
        public let scheduleStartTime: Date?
        ///  Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public let timezone: String?

        public init(dataPullMode: DataPullMode? = nil, firstExecutionFrom: Date? = nil, scheduleEndTime: Date? = nil, scheduleExpression: String, scheduleOffset: Int64? = nil, scheduleStartTime: Date? = nil, timezone: String? = nil) {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: ".*")
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, max: 36000)
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, min: 0)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 256)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullMode
            case firstExecutionFrom
            case scheduleEndTime
            case scheduleExpression
            case scheduleOffset
            case scheduleStartTime
            case timezone
        }
    }

    public struct ServiceNowConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password
            case username
        }
    }

    public struct ServiceNowConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the ServiceNow resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct ServiceNowMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceNowSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the ServiceNow flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct SingularConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String

        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey
        }
    }

    public struct SingularConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct SingularMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct SingularSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Singular flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct SlackConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Slack resources.
        public let accessToken: String?
        ///  The identifier for the client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "\\S+")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case clientId
            case clientSecret
            case oAuthRequest
        }
    }

    public struct SlackConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Slack resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct SlackMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Slack account.
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes
        }
    }

    public struct SlackSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Slack flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct SnowflakeConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password
            case username
        }
    }

    public struct SnowflakeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the account.
        public let accountName: String?
        ///  The name of the Amazon S3 bucket associated with Snowflake.
        public let bucketName: String
        ///  The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        public let bucketPrefix: String?
        ///  The Snowflake Private Link service name to be used for private data transfers.
        public let privateLinkServiceName: String?
        ///  The AWS Region of the Snowflake account.
        public let region: String?
        ///  The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: &lt; Database&gt;&lt; Schema&gt;&lt;Stage Name&gt;.
        public let stage: String
        ///  The name of the Snowflake warehouse.
        public let warehouse: String

        public init(accountName: String? = nil, bucketName: String, bucketPrefix: String? = nil, privateLinkServiceName: String? = nil, region: String? = nil, stage: String, warehouse: String) {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try self.validate(self.accountName, name: "accountName", parent: name, max: 512)
            try self.validate(self.accountName, name: "accountName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, max: 512)
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, pattern: "\\S+")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S+")
            try self.validate(self.stage, name: "stage", parent: name, max: 512)
            try self.validate(self.stage, name: "stage", parent: name, pattern: "\\S+")
            try self.validate(self.warehouse, name: "warehouse", parent: name, max: 512)
            try self.validate(self.warehouse, name: "warehouse", parent: name, pattern: "[\\s\\w/!@#+=.-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountName
            case bucketName
            case bucketPrefix
            case privateLinkServiceName
            case region
            case stage
            case warehouse
        }
    }

    public struct SnowflakeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        public let intermediateBucketName: String
        ///  The object specified in the Snowflake flow destination.
        public let object: String

        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, max: 63)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, min: 3)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, pattern: "\\S+")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix
            case errorHandlingConfig
            case intermediateBucketName
            case object
        }
    }

    public struct SnowflakeMetadata: AWSDecodableShape {
        ///  Specifies the supported AWS Regions when using Snowflake.
        public let supportedRegions: [String]?

        public init(supportedRegions: [String]? = nil) {
            self.supportedRegions = supportedRegions
        }

        private enum CodingKeys: String, CodingKey {
            case supportedRegions
        }
    }

    public struct SourceConnectorProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the information that is required for querying Amplitude.
        public let amplitude: AmplitudeSourceProperties?
        ///  Specifies the information that is required for querying Datadog.
        public let datadog: DatadogSourceProperties?
        ///  Specifies the information that is required for querying Dynatrace.
        public let dynatrace: DynatraceSourceProperties?
        ///  Specifies the information that is required for querying Google Analytics.
        public let googleAnalytics: GoogleAnalyticsSourceProperties?
        ///  Specifies the information that is required for querying Infor Nexus.
        public let inforNexus: InforNexusSourceProperties?
        ///  Specifies the information that is required for querying Marketo.
        public let marketo: MarketoSourceProperties?
        ///  Specifies the information that is required for querying Amazon S3.
        public let s3: S3SourceProperties?
        ///  Specifies the information that is required for querying Salesforce.
        public let salesforce: SalesforceSourceProperties?
        ///  Specifies the information that is required for querying ServiceNow.
        public let serviceNow: ServiceNowSourceProperties?
        ///  Specifies the information that is required for querying Singular.
        public let singular: SingularSourceProperties?
        ///  Specifies the information that is required for querying Slack.
        public let slack: SlackSourceProperties?
        ///  Specifies the information that is required for querying Trend Micro.
        public let trendmicro: TrendmicroSourceProperties?
        ///  Specifies the information that is required for querying Veeva.
        public let veeva: VeevaSourceProperties?
        ///  Specifies the information that is required for querying Zendesk.
        public let zendesk: ZendeskSourceProperties?

        public init(amplitude: AmplitudeSourceProperties? = nil, datadog: DatadogSourceProperties? = nil, dynatrace: DynatraceSourceProperties? = nil, googleAnalytics: GoogleAnalyticsSourceProperties? = nil, inforNexus: InforNexusSourceProperties? = nil, marketo: MarketoSourceProperties? = nil, s3: S3SourceProperties? = nil, salesforce: SalesforceSourceProperties? = nil, serviceNow: ServiceNowSourceProperties? = nil, singular: SingularSourceProperties? = nil, slack: SlackSourceProperties? = nil, trendmicro: TrendmicroSourceProperties? = nil, veeva: VeevaSourceProperties? = nil, zendesk: ZendeskSourceProperties? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct SourceFieldProperties: AWSDecodableShape {
        ///  Indicates if the field can be queried.
        public let isQueryable: Bool?
        ///  Indicates whether the field can be returned in a search result.
        public let isRetrievable: Bool?

        public init(isQueryable: Bool? = nil, isRetrievable: Bool? = nil) {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
        }

        private enum CodingKeys: String, CodingKey {
            case isQueryable
            case isRetrievable
        }
    }

    public struct SourceFlowConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the connector profile. This name must be unique for each connector profile in the AWS account.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public let incrementalPullConfig: IncrementalPullConfig?
        ///  Specifies the information that is required to query a particular source connector.
        public let sourceConnectorProperties: SourceConnectorProperties

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType, incrementalPullConfig: IncrementalPullConfig? = nil, sourceConnectorProperties: SourceConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.incrementalPullConfig?.validate(name: "\(name).incrementalPullConfig")
            try self.sourceConnectorProperties.validate(name: "\(name).sourceConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName
            case connectorType
            case incrementalPullConfig
            case sourceConnectorProperties
        }
    }

    public struct StartFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName
        }
    }

    public struct StartFlowResponse: AWSDecodableShape {
        ///  Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
        public let executionId: String?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        public init(executionId: String? = nil, flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.executionId = executionId
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case executionId
            case flowArn
            case flowStatus
        }
    }

    public struct StopFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName
        }
    }

    public struct StopFlowResponse: AWSDecodableShape {
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn
            case flowStatus
        }
    }

    public struct SupportedFieldTypeDetails: AWSDecodableShape {
        ///  The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced.
        public let v1: FieldTypeDetails

        public init(v1: FieldTypeDetails) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the flow that you want to tag.
        public let resourceArn: String
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "[\\s\\w+-=\\.:/@]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Task: AWSEncodableShape & AWSDecodableShape {
        ///  The operation to be performed on the provided source fields.
        public let connectorOperator: ConnectorOperator?
        ///  A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public let destinationField: String?
        ///  The source fields to which a particular task is applied.
        public let sourceFields: [String]
        ///  A map used to store task-related information. The execution service looks for particular information based on the TaskType.
        public let taskProperties: [OperatorPropertiesKeys: String]?
        ///  Specifies the particular task implementation that Amazon AppFlow performs.
        public let taskType: TaskType

        public init(connectorOperator: ConnectorOperator? = nil, destinationField: String? = nil, sourceFields: [String], taskProperties: [OperatorPropertiesKeys: String]? = nil, taskType: TaskType) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationField, name: "destinationField", parent: name, max: 256)
            try self.validate(self.destinationField, name: "destinationField", parent: name, pattern: ".*")
            try self.sourceFields.forEach {
                try validate($0, name: "sourceFields[]", parent: name, max: 2048)
                try validate($0, name: "sourceFields[]", parent: name, pattern: ".*")
            }
            try self.taskProperties?.forEach {
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, pattern: ".+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectorOperator
            case destinationField
            case sourceFields
            case taskProperties
            case taskType
        }
    }

    public struct TrendmicroConnectorProfileCredentials: AWSEncodableShape {
        ///  The Secret Access Key portion of the credentials.
        public let apiSecretKey: String

        public init(apiSecretKey: String) {
            self.apiSecretKey = apiSecretKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, max: 256)
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiSecretKey
        }
    }

    public struct TrendmicroConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct TrendmicroMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct TrendmicroSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Trend Micro flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct TriggerConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
        public let triggerProperties: TriggerProperties?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public let triggerType: TriggerType

        public init(triggerProperties: TriggerProperties? = nil, triggerType: TriggerType) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }

        public func validate(name: String) throws {
            try self.triggerProperties?.validate(name: "\(name).triggerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case triggerProperties
            case triggerType
        }
    }

    public struct TriggerProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user.
        public let scheduled: ScheduledTriggerProperties?

        public init(scheduled: ScheduledTriggerProperties? = nil) {
            self.scheduled = scheduled
        }

        public func validate(name: String) throws {
            try self.scheduled?.validate(name: "\(name).scheduled")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduled = "Scheduled"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        ///  The Amazon Resource Name (ARN) of the flow that you want to untag.
        public let resourceArn: String
        ///  The tag keys associated with the tag that you want to remove from your flow.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectorProfileRequest: AWSEncodableShape {
        ///  Indicates the connection mode and if it is public or private.
        public let connectionMode: ConnectionMode
        ///  Defines the connector-specific profile configuration and credentials.
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile and is unique for each ConnectorProfile in the AWS Account.
        public let connectorProfileName: String

        public init(connectionMode: ConnectionMode, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String) {
            self.connectionMode = connectionMode
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
        }

        public func validate(name: String) throws {
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode
            case connectorProfileConfig
            case connectorProfileName
        }
    }

    public struct UpdateConnectorProfileResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?

        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn
        }
    }

    public struct UpdateFlowRequest: AWSEncodableShape {
        ///  A description of the flow.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        public let sourceFlowConfig: SourceFlowConfig?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig

        public init(description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, sourceFlowConfig: SourceFlowConfig? = nil, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\w!@#\\-.?,\\s]*")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.sourceFlowConfig?.validate(name: "\(name).sourceFlowConfig")
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case destinationFlowConfigList
            case flowName
            case sourceFlowConfig
            case tasks
            case triggerConfig
        }
    }

    public struct UpdateFlowResponse: AWSDecodableShape {
        /// Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        public init(flowStatus: FlowStatus? = nil) {
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowStatus
        }
    }

    public struct UpsolverDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        public let bucketName: String
        ///  The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        ///  The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        public let s3OutputFormatConfig: UpsolverS3OutputFormatConfig

        public init(bucketName: String, bucketPrefix: String? = nil, s3OutputFormatConfig: UpsolverS3OutputFormatConfig) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 16)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^(upsolver-appflow)\\S*")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case bucketPrefix
            case s3OutputFormatConfig
        }
    }

    public struct UpsolverMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct UpsolverS3OutputFormatConfig: AWSEncodableShape & AWSDecodableShape {
        public let aggregationConfig: AggregationConfig?
        ///  Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        public let fileType: FileType?
        public let prefixConfig: PrefixConfig

        public init(aggregationConfig: AggregationConfig? = nil, fileType: FileType? = nil, prefixConfig: PrefixConfig) {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationConfig
            case fileType
            case prefixConfig
        }
    }

    public struct VeevaConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password
            case username
        }
    }

    public struct VeevaConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Veeva resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct VeevaMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct VeevaSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Veeva flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }

    public struct ZendeskConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Zendesk resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 512)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "\\S+")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "\\S+")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken
            case clientId
            case clientSecret
            case oAuthRequest
        }
    }

    public struct ZendeskConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Zendesk resource.
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl
        }
    }

    public struct ZendeskDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        public let idFieldNames: [String]?
        /// The object specified in the Zendesk flow destination.
        public let object: String
        public let writeOperationType: WriteOperationType?

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, object: String, writeOperationType: WriteOperationType? = nil) {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "\\S+")
            }
            try self.validate(self.idFieldNames, name: "idFieldNames", parent: name, max: 1)
            try self.validate(self.idFieldNames, name: "idFieldNames", parent: name, min: 0)
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig
            case idFieldNames
            case object
            case writeOperationType
        }
    }

    public struct ZendeskMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Zendesk account.
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes
        }
    }

    public struct ZendeskSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Zendesk flow source.
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object
        }
    }
}
