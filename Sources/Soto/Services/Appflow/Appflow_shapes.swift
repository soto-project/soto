//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Appflow {
    // MARK: Enums

    public enum AggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "None"
        case singleFile = "SingleFile"
        public var description: String { return self.rawValue }
    }

    public enum AmplitudeConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apikey = "APIKEY"
        case basic = "BASIC"
        case custom = "CUSTOM"
        case oauth2 = "OAUTH2"
        public var description: String { return self.rawValue }
    }

    public enum CatalogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case glue = "GLUE"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "Private"
        case `public` = "Public"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorProvisioningType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amplitude = "Amplitude"
        case customconnector = "CustomConnector"
        case customerprofiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventbridge = "EventBridge"
        case googleanalytics = "Googleanalytics"
        case honeycode = "Honeycode"
        case infornexus = "Infornexus"
        case lookoutmetrics = "LookoutMetrics"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case sapodata = "SAPOData"
        case servicenow = "Servicenow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
        public var description: String { return self.rawValue }
    }

    public enum DataPullMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "Complete"
        case incremental = "Incremental"
        public var description: String { return self.rawValue }
    }

    public enum DataTransferApiType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `async` = "ASYNC"
        case automatic = "AUTOMATIC"
        case sync = "SYNC"
        public var description: String { return self.rawValue }
    }

    public enum DatadogConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum DynatraceConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case cancelstarted = "CancelStarted"
        case error = "Error"
        case inprogress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum FlowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case deleted = "Deleted"
        case deprecated = "Deprecated"
        case draft = "Draft"
        case errored = "Errored"
        case suspended = "Suspended"
        public var description: String { return self.rawValue }
    }

    public enum GoogleAnalyticsConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case projection = "PROJECTION"
        public var description: String { return self.rawValue }
    }

    public enum InforNexusConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum MarketoConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum OAuth2CustomPropType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authUrl = "AUTH_URL"
        case tokenUrl = "TOKEN_URL"
        public var description: String { return self.rawValue }
    }

    public enum OAuth2GrantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authorizationCode = "AUTHORIZATION_CODE"
        case clientCredentials = "CLIENT_CREDENTIALS"
        case jwtBearer = "JWT_BEARER"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum OperatorPropertiesKeys: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concatFormat = "CONCAT_FORMAT"
        case dataType = "DATA_TYPE"
        case destinationDataType = "DESTINATION_DATA_TYPE"
        case excludeSourceFieldsList = "EXCLUDE_SOURCE_FIELDS_LIST"
        case includeNewFields = "INCLUDE_NEW_FIELDS"
        case lowerBound = "LOWER_BOUND"
        case maskLength = "MASK_LENGTH"
        case maskValue = "MASK_VALUE"
        case mathOperationFieldsOrder = "MATH_OPERATION_FIELDS_ORDER"
        case orderedPartitionKeysList = "ORDERED_PARTITION_KEYS_LIST"
        case sourceDataType = "SOURCE_DATA_TYPE"
        case subfieldCategoryMap = "SUBFIELD_CATEGORY_MAP"
        case truncateLength = "TRUNCATE_LENGTH"
        case upperBound = "UPPER_BOUND"
        case validationAction = "VALIDATION_ACTION"
        case value = "VALUE"
        case values = "VALUES"
        public var description: String { return self.rawValue }
    }

    public enum Operators: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum PardotConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum PathPrefix: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executionId = "EXECUTION_ID"
        case schemaVersion = "SCHEMA_VERSION"
        public var description: String { return self.rawValue }
    }

    public enum PrefixFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        case month = "MONTH"
        case year = "YEAR"
        public var description: String { return self.rawValue }
    }

    public enum PrefixType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case filename = "FILENAME"
        case path = "PATH"
        case pathAndFilename = "PATH_AND_FILENAME"
        public var description: String { return self.rawValue }
    }

    public enum PrivateConnectionProvisioningFailureCause: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case connectorAuthentication = "CONNECTOR_AUTHENTICATION"
        case connectorServer = "CONNECTOR_SERVER"
        case internalServer = "INTERNAL_SERVER"
        case validation = "VALIDATION"
        public var description: String { return self.rawValue }
    }

    public enum PrivateConnectionProvisioningStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum S3ConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum S3InputFileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum SAPODataConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceDataTransferApi: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case bulkv2 = "BULKV2"
        case restSync = "REST_SYNC"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleFrequencyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byminute = "BYMINUTE"
        case daily = "DAILY"
        case hourly = "HOURLY"
        case monthly = "MONTHLY"
        case once = "ONCE"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNowConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SingularConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SlackConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SupportedDataTransferType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case file = "FILE"
        case record = "RECORD"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arithmetic = "Arithmetic"
        case filter = "Filter"
        case map = "Map"
        case mapAll = "Map_all"
        case mask = "Mask"
        case merge = "Merge"
        case partition = "Partition"
        case passthrough = "Passthrough"
        case truncate = "Truncate"
        case validate = "Validate"
        public var description: String { return self.rawValue }
    }

    public enum TrendmicroConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "Event"
        case ondemand = "OnDemand"
        case scheduled = "Scheduled"
        public var description: String { return self.rawValue }
    }

    public enum VeevaConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum WriteOperationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case insert = "INSERT"
        case update = "UPDATE"
        case upsert = "UPSERT"
        public var description: String { return self.rawValue }
    }

    public enum ZendeskConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AggregationConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        public let aggregationType: AggregationType?
        /// The desired file size, in MB, for each output file that Amazon AppFlow writes to the flow destination. For each file, Amazon AppFlow attempts to achieve the size that you specify. The actual file sizes might differ from this target based on the number and size of the records that each file contains.
        public let targetFileSize: Int64?

        @inlinable
        public init(aggregationType: AggregationType? = nil, targetFileSize: Int64? = nil) {
            self.aggregationType = aggregationType
            self.targetFileSize = targetFileSize
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType = "aggregationType"
            case targetFileSize = "targetFileSize"
        }
    }

    public struct AmplitudeConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String
        ///  The Secret Access Key portion of the credentials.
        public let secretKey: String

        @inlinable
        public init(apiKey: String, secretKey: String) {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "^\\S+$")
            try self.validate(self.secretKey, name: "secretKey", parent: name, max: 256)
            try self.validate(self.secretKey, name: "secretKey", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case secretKey = "secretKey"
        }
    }

    public struct AmplitudeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AmplitudeMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct AmplitudeSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Amplitude flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ApiKeyCredentials: AWSEncodableShape {
        /// The API key required for API key authentication.
        public let apiKey: String
        /// The API secret key required for API key authentication.
        public let apiSecretKey: String?

        @inlinable
        public init(apiKey: String, apiSecretKey: String? = nil) {
            self.apiKey = apiKey
            self.apiSecretKey = apiSecretKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "^\\S+$")
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, max: 256)
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case apiSecretKey = "apiSecretKey"
        }
    }

    public struct AuthParameter: AWSDecodableShape {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public let connectorSuppliedValues: [String]?
        /// A description about the authentication parameter.
        public let description: String?
        /// Indicates whether this authentication parameter is required.
        public let isRequired: Bool?
        /// Indicates whether this authentication parameter is a sensitive field.
        public let isSensitiveField: Bool?
        /// The authentication key required to authenticate with the connector.
        public let key: String?
        /// Label used for authentication parameter.
        public let label: String?

        @inlinable
        public init(connectorSuppliedValues: [String]? = nil, description: String? = nil, isRequired: Bool? = nil, isSensitiveField: Bool? = nil, key: String? = nil, label: String? = nil) {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case connectorSuppliedValues = "connectorSuppliedValues"
            case description = "description"
            case isRequired = "isRequired"
            case isSensitiveField = "isSensitiveField"
            case key = "key"
            case label = "label"
        }
    }

    public struct AuthenticationConfig: AWSDecodableShape {
        /// Contains information required for custom authentication.
        public let customAuthConfigs: [CustomAuthConfig]?
        /// Indicates whether API key authentication is supported by the connector
        public let isApiKeyAuthSupported: Bool?
        /// Indicates whether basic authentication is supported by the connector.
        public let isBasicAuthSupported: Bool?
        /// Indicates whether custom authentication is supported by the connector
        public let isCustomAuthSupported: Bool?
        /// Indicates whether OAuth 2.0 authentication is supported by the connector.
        public let isOAuth2Supported: Bool?
        /// Contains the default values required for OAuth 2.0 authentication.
        public let oAuth2Defaults: OAuth2Defaults?

        @inlinable
        public init(customAuthConfigs: [CustomAuthConfig]? = nil, isApiKeyAuthSupported: Bool? = nil, isBasicAuthSupported: Bool? = nil, isCustomAuthSupported: Bool? = nil, isOAuth2Supported: Bool? = nil, oAuth2Defaults: OAuth2Defaults? = nil) {
            self.customAuthConfigs = customAuthConfigs
            self.isApiKeyAuthSupported = isApiKeyAuthSupported
            self.isBasicAuthSupported = isBasicAuthSupported
            self.isCustomAuthSupported = isCustomAuthSupported
            self.isOAuth2Supported = isOAuth2Supported
            self.oAuth2Defaults = oAuth2Defaults
        }

        private enum CodingKeys: String, CodingKey {
            case customAuthConfigs = "customAuthConfigs"
            case isApiKeyAuthSupported = "isApiKeyAuthSupported"
            case isBasicAuthSupported = "isBasicAuthSupported"
            case isCustomAuthSupported = "isCustomAuthSupported"
            case isOAuth2Supported = "isOAuth2Supported"
            case oAuth2Defaults = "oAuth2Defaults"
        }
    }

    public struct BasicAuthCredentials: AWSEncodableShape {
        ///  The password to use to connect to a resource.
        public let password: String
        ///  The username to use to connect to a resource.
        public let username: String

        @inlinable
        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct CancelFlowExecutionsRequest: AWSEncodableShape {
        /// The ID of each active run to cancel. These runs must belong to the flow you specify in your request. If you omit this parameter, your request ends all active runs that belong to the flow.
        public let executionIds: [String]?
        /// The name of a flow with active runs that you want to cancel.
        public let flowName: String

        @inlinable
        public init(executionIds: [String]? = nil, flowName: String) {
            self.executionIds = executionIds
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.executionIds?.forEach {
                try validate($0, name: "executionIds[]", parent: name, max: 256)
                try validate($0, name: "executionIds[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.executionIds, name: "executionIds", parent: name, max: 100)
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionIds = "executionIds"
            case flowName = "flowName"
        }
    }

    public struct CancelFlowExecutionsResponse: AWSDecodableShape {
        /// The IDs of runs that Amazon AppFlow couldn't cancel. These runs might be ineligible for canceling because they haven't started yet or have already completed.
        public let invalidExecutions: [String]?

        @inlinable
        public init(invalidExecutions: [String]? = nil) {
            self.invalidExecutions = invalidExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case invalidExecutions = "invalidExecutions"
        }
    }

    public struct ConnectorConfiguration: AWSDecodableShape {
        /// The authentication config required for the connector.
        public let authenticationConfig: AuthenticationConfig?
        ///  Specifies whether the connector can be used as a destination.
        public let canUseAsDestination: Bool?
        ///  Specifies whether the connector can be used as a source.
        public let canUseAsSource: Bool?
        /// The Amazon Resource Name (ARN) for the registered connector.
        public let connectorArn: String?
        /// A description about the connector.
        public let connectorDescription: String?
        /// The label used for registering the connector.
        public let connectorLabel: String?
        ///  Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
        public let connectorMetadata: ConnectorMetadata?
        /// The connection modes that the connector supports.
        public let connectorModes: [String]?
        /// The connector name.
        public let connectorName: String?
        /// The owner who developed the connector.
        public let connectorOwner: String?
        /// The configuration required for registering the connector.
        public let connectorProvisioningConfig: ConnectorProvisioningConfig?
        /// The provisioning type used to register the connector.
        public let connectorProvisioningType: ConnectorProvisioningType?
        /// The required connector runtime settings.
        public let connectorRuntimeSettings: [ConnectorRuntimeSetting]?
        /// The connector type.
        public let connectorType: ConnectorType?
        /// The connector version.
        public let connectorVersion: String?
        ///  Specifies if PrivateLink is enabled for that connector.
        public let isPrivateLinkEnabled: Bool?
        ///  Specifies if a PrivateLink endpoint URL is required.
        public let isPrivateLinkEndpointUrlRequired: Bool?
        /// Logo URL of the connector.
        public let logoURL: String?
        /// The date on which the connector was registered.
        public let registeredAt: Date?
        /// Information about who registered the connector.
        public let registeredBy: String?
        /// A list of API versions that are supported by the connector.
        public let supportedApiVersions: [String]?
        /// The APIs of the connector application that Amazon AppFlow can use to transfer your data.
        public let supportedDataTransferApis: [DataTransferApi]?
        /// The data transfer types that the connector supports.  RECORD  Structured records.  FILE  Files or binary data.
        public let supportedDataTransferTypes: [SupportedDataTransferType]?
        ///  Lists the connectors that are available for use as destinations.
        public let supportedDestinationConnectors: [ConnectorType]?
        /// A list of operators supported by the connector.
        public let supportedOperators: [Operators]?
        ///  Specifies the supported flow frequency for that connector.
        public let supportedSchedulingFrequencies: [ScheduleFrequencyType]?
        ///  Specifies the supported trigger types for the flow.
        public let supportedTriggerTypes: [TriggerType]?
        /// A list of write operations supported by the connector.
        public let supportedWriteOperations: [WriteOperationType]?

        @inlinable
        public init(authenticationConfig: AuthenticationConfig? = nil, canUseAsDestination: Bool? = nil, canUseAsSource: Bool? = nil, connectorArn: String? = nil, connectorDescription: String? = nil, connectorLabel: String? = nil, connectorMetadata: ConnectorMetadata? = nil, connectorModes: [String]? = nil, connectorName: String? = nil, connectorOwner: String? = nil, connectorProvisioningConfig: ConnectorProvisioningConfig? = nil, connectorProvisioningType: ConnectorProvisioningType? = nil, connectorRuntimeSettings: [ConnectorRuntimeSetting]? = nil, connectorType: ConnectorType? = nil, connectorVersion: String? = nil, isPrivateLinkEnabled: Bool? = nil, isPrivateLinkEndpointUrlRequired: Bool? = nil, logoURL: String? = nil, registeredAt: Date? = nil, registeredBy: String? = nil, supportedApiVersions: [String]? = nil, supportedDataTransferApis: [DataTransferApi]? = nil, supportedDataTransferTypes: [SupportedDataTransferType]? = nil, supportedDestinationConnectors: [ConnectorType]? = nil, supportedOperators: [Operators]? = nil, supportedSchedulingFrequencies: [ScheduleFrequencyType]? = nil, supportedTriggerTypes: [TriggerType]? = nil, supportedWriteOperations: [WriteOperationType]? = nil) {
            self.authenticationConfig = authenticationConfig
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorMetadata = connectorMetadata
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningConfig = connectorProvisioningConfig
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorRuntimeSettings = connectorRuntimeSettings
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.logoURL = logoURL
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedApiVersions = supportedApiVersions
            self.supportedDataTransferApis = supportedDataTransferApis
            self.supportedDataTransferTypes = supportedDataTransferTypes
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedOperators = supportedOperators
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
            self.supportedWriteOperations = supportedWriteOperations
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfig = "authenticationConfig"
            case canUseAsDestination = "canUseAsDestination"
            case canUseAsSource = "canUseAsSource"
            case connectorArn = "connectorArn"
            case connectorDescription = "connectorDescription"
            case connectorLabel = "connectorLabel"
            case connectorMetadata = "connectorMetadata"
            case connectorModes = "connectorModes"
            case connectorName = "connectorName"
            case connectorOwner = "connectorOwner"
            case connectorProvisioningConfig = "connectorProvisioningConfig"
            case connectorProvisioningType = "connectorProvisioningType"
            case connectorRuntimeSettings = "connectorRuntimeSettings"
            case connectorType = "connectorType"
            case connectorVersion = "connectorVersion"
            case isPrivateLinkEnabled = "isPrivateLinkEnabled"
            case isPrivateLinkEndpointUrlRequired = "isPrivateLinkEndpointUrlRequired"
            case logoURL = "logoURL"
            case registeredAt = "registeredAt"
            case registeredBy = "registeredBy"
            case supportedApiVersions = "supportedApiVersions"
            case supportedDataTransferApis = "supportedDataTransferApis"
            case supportedDataTransferTypes = "supportedDataTransferTypes"
            case supportedDestinationConnectors = "supportedDestinationConnectors"
            case supportedOperators = "supportedOperators"
            case supportedSchedulingFrequencies = "supportedSchedulingFrequencies"
            case supportedTriggerTypes = "supportedTriggerTypes"
            case supportedWriteOperations = "supportedWriteOperations"
        }
    }

    public struct ConnectorDetail: AWSDecodableShape {
        /// The application type of the connector.
        public let applicationType: String?
        /// A description about the registered connector.
        public let connectorDescription: String?
        /// A label used for the connector.
        public let connectorLabel: String?
        /// The connection mode that the connector supports.
        public let connectorModes: [String]?
        /// The name of the connector.
        public let connectorName: String?
        /// The owner of the connector.
        public let connectorOwner: String?
        /// The provisioning type that the connector uses.
        public let connectorProvisioningType: ConnectorProvisioningType?
        /// The connector type.
        public let connectorType: ConnectorType?
        /// The connector version.
        public let connectorVersion: String?
        /// The time at which the connector was registered.
        public let registeredAt: Date?
        /// The user who registered the connector.
        public let registeredBy: String?
        /// The data transfer types that the connector supports.  RECORD  Structured records.  FILE  Files or binary data.
        public let supportedDataTransferTypes: [SupportedDataTransferType]?

        @inlinable
        public init(applicationType: String? = nil, connectorDescription: String? = nil, connectorLabel: String? = nil, connectorModes: [String]? = nil, connectorName: String? = nil, connectorOwner: String? = nil, connectorProvisioningType: ConnectorProvisioningType? = nil, connectorType: ConnectorType? = nil, connectorVersion: String? = nil, registeredAt: Date? = nil, registeredBy: String? = nil, supportedDataTransferTypes: [SupportedDataTransferType]? = nil) {
            self.applicationType = applicationType
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedDataTransferTypes = supportedDataTransferTypes
        }

        private enum CodingKeys: String, CodingKey {
            case applicationType = "applicationType"
            case connectorDescription = "connectorDescription"
            case connectorLabel = "connectorLabel"
            case connectorModes = "connectorModes"
            case connectorName = "connectorName"
            case connectorOwner = "connectorOwner"
            case connectorProvisioningType = "connectorProvisioningType"
            case connectorType = "connectorType"
            case connectorVersion = "connectorVersion"
            case registeredAt = "registeredAt"
            case registeredBy = "registeredBy"
            case supportedDataTransferTypes = "supportedDataTransferTypes"
        }
    }

    public struct ConnectorEntity: AWSDecodableShape {
        ///  Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        public let hasNestedEntities: Bool?
        ///  The label applied to the connector entity.
        public let label: String?
        ///  The name of the connector entity.
        public let name: String

        @inlinable
        public init(hasNestedEntities: Bool? = nil, label: String? = nil, name: String) {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case hasNestedEntities = "hasNestedEntities"
            case label = "label"
            case name = "name"
        }
    }

    public struct ConnectorEntityField: AWSDecodableShape {
        /// A map that has specific properties related to the ConnectorEntityField.
        public let customProperties: [String: String]?
        /// Default value that can be assigned to this field.
        public let defaultValue: String?
        ///  A description of the connector entity field.
        public let description: String?
        ///  The properties applied to a field when the connector is being used as a destination.
        public let destinationProperties: DestinationFieldProperties?
        ///  The unique identifier of the connector field.
        public let identifier: String
        /// Booelan value that indicates whether this field is deprecated or not.
        public let isDeprecated: Bool?
        /// Booelan value that indicates whether this field can be used as a primary key.
        public let isPrimaryKey: Bool?
        ///  The label applied to a connector entity field.
        public let label: String?
        /// The parent identifier of the connector field.
        public let parentIdentifier: String?
        ///  The properties that can be applied to a field when the connector is being used as a source.
        public let sourceProperties: SourceFieldProperties?
        ///  Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues.
        public let supportedFieldTypeDetails: SupportedFieldTypeDetails?

        @inlinable
        public init(customProperties: [String: String]? = nil, defaultValue: String? = nil, description: String? = nil, destinationProperties: DestinationFieldProperties? = nil, identifier: String, isDeprecated: Bool? = nil, isPrimaryKey: Bool? = nil, label: String? = nil, parentIdentifier: String? = nil, sourceProperties: SourceFieldProperties? = nil, supportedFieldTypeDetails: SupportedFieldTypeDetails? = nil) {
            self.customProperties = customProperties
            self.defaultValue = defaultValue
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.isDeprecated = isDeprecated
            self.isPrimaryKey = isPrimaryKey
            self.label = label
            self.parentIdentifier = parentIdentifier
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "customProperties"
            case defaultValue = "defaultValue"
            case description = "description"
            case destinationProperties = "destinationProperties"
            case identifier = "identifier"
            case isDeprecated = "isDeprecated"
            case isPrimaryKey = "isPrimaryKey"
            case label = "label"
            case parentIdentifier = "parentIdentifier"
            case sourceProperties = "sourceProperties"
            case supportedFieldTypeDetails = "supportedFieldTypeDetails"
        }
    }

    public struct ConnectorMetadata: AWSDecodableShape {
        ///  The connector metadata specific to Amplitude.
        public let amplitude: AmplitudeMetadata?
        ///  The connector metadata specific to Amazon Connect Customer Profiles.
        public let customerProfiles: CustomerProfilesMetadata?
        ///  The connector metadata specific to Datadog.
        public let datadog: DatadogMetadata?
        ///  The connector metadata specific to Dynatrace.
        public let dynatrace: DynatraceMetadata?
        ///  The connector metadata specific to Amazon EventBridge.
        public let eventBridge: EventBridgeMetadata?
        ///  The connector metadata specific to Google Analytics.
        public let googleAnalytics: GoogleAnalyticsMetadata?
        ///  The connector metadata specific to Amazon Honeycode.
        public let honeycode: HoneycodeMetadata?
        ///  The connector metadata specific to Infor Nexus.
        public let inforNexus: InforNexusMetadata?
        ///  The connector metadata specific to Marketo.
        public let marketo: MarketoMetadata?
        /// The connector metadata specific to Salesforce Pardot.
        public let pardot: PardotMetadata?
        ///  The connector metadata specific to Amazon Redshift.
        public let redshift: RedshiftMetadata?
        ///  The connector metadata specific to Amazon S3.
        public let s3: S3Metadata?
        ///  The connector metadata specific to Salesforce.
        public let salesforce: SalesforceMetadata?
        public let sapoData: SAPODataMetadata?
        ///  The connector metadata specific to ServiceNow.
        public let serviceNow: ServiceNowMetadata?
        ///  The connector metadata specific to Singular.
        public let singular: SingularMetadata?
        ///  The connector metadata specific to Slack.
        public let slack: SlackMetadata?
        ///  The connector metadata specific to Snowflake.
        public let snowflake: SnowflakeMetadata?
        ///  The connector metadata specific to Trend Micro.
        public let trendmicro: TrendmicroMetadata?
        ///  The connector metadata specific to Upsolver.
        public let upsolver: UpsolverMetadata?
        ///  The connector metadata specific to Veeva.
        public let veeva: VeevaMetadata?
        ///  The connector metadata specific to Zendesk.
        public let zendesk: ZendeskMetadata?

        @inlinable
        public init(amplitude: AmplitudeMetadata? = nil, customerProfiles: CustomerProfilesMetadata? = nil, datadog: DatadogMetadata? = nil, dynatrace: DynatraceMetadata? = nil, eventBridge: EventBridgeMetadata? = nil, googleAnalytics: GoogleAnalyticsMetadata? = nil, honeycode: HoneycodeMetadata? = nil, inforNexus: InforNexusMetadata? = nil, marketo: MarketoMetadata? = nil, pardot: PardotMetadata? = nil, redshift: RedshiftMetadata? = nil, s3: S3Metadata? = nil, salesforce: SalesforceMetadata? = nil, sapoData: SAPODataMetadata? = nil, serviceNow: ServiceNowMetadata? = nil, singular: SingularMetadata? = nil, slack: SlackMetadata? = nil, snowflake: SnowflakeMetadata? = nil, trendmicro: TrendmicroMetadata? = nil, upsolver: UpsolverMetadata? = nil, veeva: VeevaMetadata? = nil, zendesk: ZendeskMetadata? = nil) {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customerProfiles = "CustomerProfiles"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case eventBridge = "EventBridge"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case pardot = "Pardot"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case upsolver = "Upsolver"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorOAuthRequest: AWSEncodableShape {
        ///  The code provided by the connector when it has been authenticated via the connected app.
        public let authCode: String?
        ///  The URL to which the authentication server redirects the browser after authorization has been granted.
        public let redirectUri: String?

        @inlinable
        public init(authCode: String? = nil, redirectUri: String? = nil) {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }

        public func validate(name: String) throws {
            try self.validate(self.authCode, name: "authCode", parent: name, max: 4096)
            try self.validate(self.authCode, name: "authCode", parent: name, pattern: "^\\S+$")
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 512)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authCode = "authCode"
            case redirectUri = "redirectUri"
        }
    }

    public struct ConnectorOperator: AWSEncodableShape & AWSDecodableShape {
        ///  The operation to be performed on the provided Amplitude source fields.
        public let amplitude: AmplitudeConnectorOperator?
        /// Operators supported by the custom connector.
        public let customConnector: Operator?
        ///  The operation to be performed on the provided Datadog source fields.
        public let datadog: DatadogConnectorOperator?
        ///  The operation to be performed on the provided Dynatrace source fields.
        public let dynatrace: DynatraceConnectorOperator?
        ///  The operation to be performed on the provided Google Analytics source fields.
        public let googleAnalytics: GoogleAnalyticsConnectorOperator?
        ///  The operation to be performed on the provided Infor Nexus source fields.
        public let inforNexus: InforNexusConnectorOperator?
        ///  The operation to be performed on the provided Marketo source fields.
        public let marketo: MarketoConnectorOperator?
        /// The operation to be performed on the provided Salesforce Pardot source fields.
        public let pardot: PardotConnectorOperator?
        ///  The operation to be performed on the provided Amazon S3 source fields.
        public let s3: S3ConnectorOperator?
        ///  The operation to be performed on the provided Salesforce source fields.
        public let salesforce: SalesforceConnectorOperator?
        ///  The operation to be performed on the provided SAPOData source fields.
        public let sapoData: SAPODataConnectorOperator?
        ///  The operation to be performed on the provided ServiceNow source fields.
        public let serviceNow: ServiceNowConnectorOperator?
        ///  The operation to be performed on the provided Singular source fields.
        public let singular: SingularConnectorOperator?
        ///  The operation to be performed on the provided Slack source fields.
        public let slack: SlackConnectorOperator?
        ///  The operation to be performed on the provided Trend Micro source fields.
        public let trendmicro: TrendmicroConnectorOperator?
        ///  The operation to be performed on the provided Veeva source fields.
        public let veeva: VeevaConnectorOperator?
        ///  The operation to be performed on the provided Zendesk source fields.
        public let zendesk: ZendeskConnectorOperator?

        @inlinable
        public init(amplitude: AmplitudeConnectorOperator? = nil, customConnector: Operator? = nil, datadog: DatadogConnectorOperator? = nil, dynatrace: DynatraceConnectorOperator? = nil, googleAnalytics: GoogleAnalyticsConnectorOperator? = nil, inforNexus: InforNexusConnectorOperator? = nil, marketo: MarketoConnectorOperator? = nil, pardot: PardotConnectorOperator? = nil, s3: S3ConnectorOperator? = nil, salesforce: SalesforceConnectorOperator? = nil, sapoData: SAPODataConnectorOperator? = nil, serviceNow: ServiceNowConnectorOperator? = nil, singular: SingularConnectorOperator? = nil, slack: SlackConnectorOperator? = nil, trendmicro: TrendmicroConnectorOperator? = nil, veeva: VeevaConnectorOperator? = nil, zendesk: ZendeskConnectorOperator? = nil) {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customConnector = "CustomConnector"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case pardot = "Pardot"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfile: AWSDecodableShape {
        ///  Indicates the connection mode and if it is public or private.
        public let connectionMode: ConnectionMode?
        /// The label for the connector profile being created.
        public let connectorLabel: String?
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public let connectorProfileName: String?
        ///  The connector-specific properties of the profile configuration.
        public let connectorProfileProperties: ConnectorProfileProperties?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  Specifies when the connector profile was created.
        public let createdAt: Date?
        ///  The Amazon Resource Name (ARN) of the connector profile credentials.
        public let credentialsArn: String?
        ///  Specifies when the connector profile was last updated.
        public let lastUpdatedAt: Date?
        ///  Specifies the private connection provisioning state.
        public let privateConnectionProvisioningState: PrivateConnectionProvisioningState?

        @inlinable
        public init(connectionMode: ConnectionMode? = nil, connectorLabel: String? = nil, connectorProfileArn: String? = nil, connectorProfileName: String? = nil, connectorProfileProperties: ConnectorProfileProperties? = nil, connectorType: ConnectorType? = nil, createdAt: Date? = nil, credentialsArn: String? = nil, lastUpdatedAt: Date? = nil, privateConnectionProvisioningState: PrivateConnectionProvisioningState? = nil) {
            self.connectionMode = connectionMode
            self.connectorLabel = connectorLabel
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
            self.privateConnectionProvisioningState = privateConnectionProvisioningState
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode = "connectionMode"
            case connectorLabel = "connectorLabel"
            case connectorProfileArn = "connectorProfileArn"
            case connectorProfileName = "connectorProfileName"
            case connectorProfileProperties = "connectorProfileProperties"
            case connectorType = "connectorType"
            case createdAt = "createdAt"
            case credentialsArn = "credentialsArn"
            case lastUpdatedAt = "lastUpdatedAt"
            case privateConnectionProvisioningState = "privateConnectionProvisioningState"
        }
    }

    public struct ConnectorProfileConfig: AWSEncodableShape {
        ///  The connector-specific credentials required by each connector.
        public let connectorProfileCredentials: ConnectorProfileCredentials?
        ///  The connector-specific properties of the profile configuration.
        public let connectorProfileProperties: ConnectorProfileProperties

        @inlinable
        public init(connectorProfileCredentials: ConnectorProfileCredentials? = nil, connectorProfileProperties: ConnectorProfileProperties) {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }

        public func validate(name: String) throws {
            try self.connectorProfileCredentials?.validate(name: "\(name).connectorProfileCredentials")
            try self.connectorProfileProperties.validate(name: "\(name).connectorProfileProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileCredentials = "connectorProfileCredentials"
            case connectorProfileProperties = "connectorProfileProperties"
        }
    }

    public struct ConnectorProfileCredentials: AWSEncodableShape {
        ///  The connector-specific credentials required when using Amplitude.
        public let amplitude: AmplitudeConnectorProfileCredentials?
        public let customConnector: CustomConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Datadog.
        public let datadog: DatadogConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Dynatrace.
        public let dynatrace: DynatraceConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Google Analytics.
        public let googleAnalytics: GoogleAnalyticsConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Amazon Honeycode.
        public let honeycode: HoneycodeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Infor Nexus.
        public let inforNexus: InforNexusConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Marketo.
        public let marketo: MarketoConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce Pardot.
        public let pardot: PardotConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Amazon Redshift.
        public let redshift: RedshiftConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Salesforce.
        public let salesforce: SalesforceConnectorProfileCredentials?
        public let sapoData: SAPODataConnectorProfileCredentials?
        ///  The connector-specific credentials required when using ServiceNow.
        public let serviceNow: ServiceNowConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Singular.
        public let singular: SingularConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Slack.
        public let slack: SlackConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Snowflake.
        public let snowflake: SnowflakeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Trend Micro.
        public let trendmicro: TrendmicroConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Veeva.
        public let veeva: VeevaConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Zendesk.
        public let zendesk: ZendeskConnectorProfileCredentials?

        @inlinable
        public init(amplitude: AmplitudeConnectorProfileCredentials? = nil, customConnector: CustomConnectorProfileCredentials? = nil, datadog: DatadogConnectorProfileCredentials? = nil, dynatrace: DynatraceConnectorProfileCredentials? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileCredentials? = nil, honeycode: HoneycodeConnectorProfileCredentials? = nil, inforNexus: InforNexusConnectorProfileCredentials? = nil, marketo: MarketoConnectorProfileCredentials? = nil, pardot: PardotConnectorProfileCredentials? = nil, redshift: RedshiftConnectorProfileCredentials? = nil, salesforce: SalesforceConnectorProfileCredentials? = nil, sapoData: SAPODataConnectorProfileCredentials? = nil, serviceNow: ServiceNowConnectorProfileCredentials? = nil, singular: SingularConnectorProfileCredentials? = nil, slack: SlackConnectorProfileCredentials? = nil, snowflake: SnowflakeConnectorProfileCredentials? = nil, trendmicro: TrendmicroConnectorProfileCredentials? = nil, veeva: VeevaConnectorProfileCredentials? = nil, zendesk: ZendeskConnectorProfileCredentials? = nil) {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.customConnector?.validate(name: "\(name).customConnector")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.honeycode?.validate(name: "\(name).honeycode")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.pardot?.validate(name: "\(name).pardot")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.sapoData?.validate(name: "\(name).sapoData")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customConnector = "CustomConnector"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case pardot = "Pardot"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The connector-specific properties required by Amplitude.
        public let amplitude: AmplitudeConnectorProfileProperties?
        /// The properties required by the custom connector.
        public let customConnector: CustomConnectorProfileProperties?
        ///  The connector-specific properties required by Datadog.
        public let datadog: DatadogConnectorProfileProperties?
        ///  The connector-specific properties required by Dynatrace.
        public let dynatrace: DynatraceConnectorProfileProperties?
        ///  The connector-specific properties required Google Analytics.
        public let googleAnalytics: GoogleAnalyticsConnectorProfileProperties?
        ///  The connector-specific properties required by Amazon Honeycode.
        public let honeycode: HoneycodeConnectorProfileProperties?
        ///  The connector-specific properties required by Infor Nexus.
        public let inforNexus: InforNexusConnectorProfileProperties?
        ///  The connector-specific properties required by Marketo.
        public let marketo: MarketoConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce Pardot.
        public let pardot: PardotConnectorProfileProperties?
        ///  The connector-specific properties required by Amazon Redshift.
        public let redshift: RedshiftConnectorProfileProperties?
        ///  The connector-specific properties required by Salesforce.
        public let salesforce: SalesforceConnectorProfileProperties?
        public let sapoData: SAPODataConnectorProfileProperties?
        ///  The connector-specific properties required by serviceNow.
        public let serviceNow: ServiceNowConnectorProfileProperties?
        ///  The connector-specific properties required by Singular.
        public let singular: SingularConnectorProfileProperties?
        ///  The connector-specific properties required by Slack.
        public let slack: SlackConnectorProfileProperties?
        ///  The connector-specific properties required by Snowflake.
        public let snowflake: SnowflakeConnectorProfileProperties?
        ///  The connector-specific properties required by Trend Micro.
        public let trendmicro: TrendmicroConnectorProfileProperties?
        ///  The connector-specific properties required by Veeva.
        public let veeva: VeevaConnectorProfileProperties?
        ///  The connector-specific properties required by Zendesk.
        public let zendesk: ZendeskConnectorProfileProperties?

        @inlinable
        public init(amplitude: AmplitudeConnectorProfileProperties? = nil, customConnector: CustomConnectorProfileProperties? = nil, datadog: DatadogConnectorProfileProperties? = nil, dynatrace: DynatraceConnectorProfileProperties? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileProperties? = nil, honeycode: HoneycodeConnectorProfileProperties? = nil, inforNexus: InforNexusConnectorProfileProperties? = nil, marketo: MarketoConnectorProfileProperties? = nil, pardot: PardotConnectorProfileProperties? = nil, redshift: RedshiftConnectorProfileProperties? = nil, salesforce: SalesforceConnectorProfileProperties? = nil, sapoData: SAPODataConnectorProfileProperties? = nil, serviceNow: ServiceNowConnectorProfileProperties? = nil, singular: SingularConnectorProfileProperties? = nil, slack: SlackConnectorProfileProperties? = nil, snowflake: SnowflakeConnectorProfileProperties? = nil, trendmicro: TrendmicroConnectorProfileProperties? = nil, veeva: VeevaConnectorProfileProperties? = nil, zendesk: ZendeskConnectorProfileProperties? = nil) {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.customConnector?.validate(name: "\(name).customConnector")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.pardot?.validate(name: "\(name).pardot")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.sapoData?.validate(name: "\(name).sapoData")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customConnector = "CustomConnector"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case honeycode = "Honeycode"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case pardot = "Pardot"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProvisioningConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about the configuration of the lambda which is being registered as the connector.
        public let lambda: LambdaConnectorProvisioningConfig?

        @inlinable
        public init(lambda: LambdaConnectorProvisioningConfig? = nil) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
        }
    }

    public struct ConnectorRuntimeSetting: AWSDecodableShape {
        /// Contains default values for the connector runtime setting that are supplied by the connector.
        public let connectorSuppliedValueOptions: [String]?
        /// Data type of the connector runtime setting.
        public let dataType: String?
        /// A description about the connector runtime setting.
        public let description: String?
        /// Indicates whether this connector runtime setting is required.
        public let isRequired: Bool?
        /// Contains value information about the connector runtime setting.
        public let key: String?
        /// A label used for connector runtime setting.
        public let label: String?
        /// Indicates the scope of the connector runtime setting.
        public let scope: String?

        @inlinable
        public init(connectorSuppliedValueOptions: [String]? = nil, dataType: String? = nil, description: String? = nil, isRequired: Bool? = nil, key: String? = nil, label: String? = nil, scope: String? = nil) {
            self.connectorSuppliedValueOptions = connectorSuppliedValueOptions
            self.dataType = dataType
            self.description = description
            self.isRequired = isRequired
            self.key = key
            self.label = label
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case connectorSuppliedValueOptions = "connectorSuppliedValueOptions"
            case dataType = "dataType"
            case description = "description"
            case isRequired = "isRequired"
            case key = "key"
            case label = "label"
            case scope = "scope"
        }
    }

    public struct CreateConnectorProfileRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your CreateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateConnectorProfile. The token is active for 8 hours.
        public let clientToken: String?
        ///  Indicates the connection mode and specifies whether it is public or private. Private flows use Amazon Web Services PrivateLink to route data over Amazon Web Services infrastructure without exposing it to the public internet.
        public let connectionMode: ConnectionMode
        /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
        public let connectorLabel: String?
        ///  Defines the connector-specific configuration and credentials.
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your Amazon Web Services account.
        public let connectorProfileName: String
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?

        @inlinable
        public init(clientToken: String? = CreateConnectorProfileRequest.idempotencyToken(), connectionMode: ConnectionMode, connectorLabel: String? = nil, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String, connectorType: ConnectorType, kmsArn: String? = nil) {
            self.clientToken = clientToken
            self.connectionMode = connectionMode
            self.connectorLabel = connectorLabel
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.kmsArn = kmsArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case connectionMode = "connectionMode"
            case connectorLabel = "connectorLabel"
            case connectorProfileConfig = "connectorProfileConfig"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case kmsArn = "kmsArn"
        }
    }

    public struct CreateConnectorProfileResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?

        @inlinable
        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn = "connectorProfileArn"
        }
    }

    public struct CreateFlowRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your CreateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateFlow. The token is active for 8 hours.
        public let clientToken: String?
        ///  A description of the flow you want to create.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow places data in the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
        public let metadataCatalogConfig: MetadataCatalogConfig?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
        public let sourceFlowConfig: SourceFlowConfig
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig

        @inlinable
        public init(clientToken: String? = CreateFlowRequest.idempotencyToken(), description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, kmsArn: String? = nil, metadataCatalogConfig: MetadataCatalogConfig? = nil, sourceFlowConfig: SourceFlowConfig, tags: [String: String]? = nil, tasks: [Task], triggerConfig: TriggerConfig) {
            self.clientToken = clientToken
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.metadataCatalogConfig = metadataCatalogConfig
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w!@#\\-.?,\\s]*$")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:")
            try self.metadataCatalogConfig?.validate(name: "\(name).metadataCatalogConfig")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowName = "flowName"
            case kmsArn = "kmsArn"
            case metadataCatalogConfig = "metadataCatalogConfig"
            case sourceFlowConfig = "sourceFlowConfig"
            case tags = "tags"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct CreateFlowResponse: AWSDecodableShape {
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        @inlinable
        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct CustomAuthConfig: AWSDecodableShape {
        /// Information about authentication parameters required for authentication.
        public let authParameters: [AuthParameter]?
        /// The authentication type that the custom connector uses.
        public let customAuthenticationType: String?

        @inlinable
        public init(authParameters: [AuthParameter]? = nil, customAuthenticationType: String? = nil) {
            self.authParameters = authParameters
            self.customAuthenticationType = customAuthenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case authParameters = "authParameters"
            case customAuthenticationType = "customAuthenticationType"
        }
    }

    public struct CustomAuthCredentials: AWSEncodableShape {
        /// A map that holds custom authentication credentials.
        public let credentialsMap: [String: String]?
        /// The custom authentication type that the connector uses.
        public let customAuthenticationType: String

        @inlinable
        public init(credentialsMap: [String: String]? = nil, customAuthenticationType: String) {
            self.credentialsMap = credentialsMap
            self.customAuthenticationType = customAuthenticationType
        }

        public func validate(name: String) throws {
            try self.credentialsMap?.forEach {
                try validate($0.key, name: "credentialsMap.key", parent: name, max: 128)
                try validate($0.key, name: "credentialsMap.key", parent: name, min: 1)
                try validate($0.key, name: "credentialsMap.key", parent: name, pattern: "^[\\w]+$")
                try validate($0.value, name: "credentialsMap[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "credentialsMap[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.credentialsMap, name: "credentialsMap", parent: name, max: 50)
            try self.validate(self.customAuthenticationType, name: "customAuthenticationType", parent: name, max: 256)
            try self.validate(self.customAuthenticationType, name: "customAuthenticationType", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsMap = "credentialsMap"
            case customAuthenticationType = "customAuthenticationType"
        }
    }

    public struct CustomConnectorDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        /// The custom properties that are specific to the connector when it's used as a destination in the flow.
        public let customProperties: [String: String]?
        /// The entity specified in the custom connector as a destination in the flow.
        public let entityName: String
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination.
        public let errorHandlingConfig: ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        public let idFieldNames: [String]?
        /// Specifies the type of write operation to be performed in the custom connector when it's used as destination.
        public let writeOperationType: WriteOperationType?

        @inlinable
        public init(customProperties: [String: String]? = nil, entityName: String, errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, writeOperationType: WriteOperationType? = nil) {
            self.customProperties = customProperties
            self.entityName = entityName
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.customProperties?.forEach {
                try validate($0.key, name: "customProperties.key", parent: name, max: 128)
                try validate($0.key, name: "customProperties.key", parent: name, min: 1)
                try validate($0.key, name: "customProperties.key", parent: name, pattern: "^[\\w]+$")
                try validate($0.value, name: "customProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customProperties[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.customProperties, name: "customProperties", parent: name, max: 50)
            try self.validate(self.entityName, name: "entityName", parent: name, max: 1024)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^\\S+$")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "^\\S+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "customProperties"
            case entityName = "entityName"
            case errorHandlingConfig = "errorHandlingConfig"
            case idFieldNames = "idFieldNames"
            case writeOperationType = "writeOperationType"
        }
    }

    public struct CustomConnectorProfileCredentials: AWSEncodableShape {
        /// The API keys required for the authentication of the user.
        public let apiKey: ApiKeyCredentials?
        /// The authentication type that the custom connector uses for authenticating while creating a connector profile.
        public let authenticationType: AuthenticationType
        /// The basic credentials that are required for the authentication of the user.
        public let basic: BasicAuthCredentials?
        /// If the connector uses the custom authentication mechanism, this holds the required credentials.
        public let custom: CustomAuthCredentials?
        /// The OAuth 2.0 credentials required for the authentication of the user.
        public let oauth2: OAuth2Credentials?

        @inlinable
        public init(apiKey: ApiKeyCredentials? = nil, authenticationType: AuthenticationType, basic: BasicAuthCredentials? = nil, custom: CustomAuthCredentials? = nil, oauth2: OAuth2Credentials? = nil) {
            self.apiKey = apiKey
            self.authenticationType = authenticationType
            self.basic = basic
            self.custom = custom
            self.oauth2 = oauth2
        }

        public func validate(name: String) throws {
            try self.apiKey?.validate(name: "\(name).apiKey")
            try self.basic?.validate(name: "\(name).basic")
            try self.custom?.validate(name: "\(name).custom")
            try self.oauth2?.validate(name: "\(name).oauth2")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case authenticationType = "authenticationType"
            case basic = "basic"
            case custom = "custom"
            case oauth2 = "oauth2"
        }
    }

    public struct CustomConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public let oAuth2Properties: OAuth2Properties?
        /// A map of properties that are required to create a profile for the custom connector.
        public let profileProperties: [String: String]?

        @inlinable
        public init(oAuth2Properties: OAuth2Properties? = nil, profileProperties: [String: String]? = nil) {
            self.oAuth2Properties = oAuth2Properties
            self.profileProperties = profileProperties
        }

        public func validate(name: String) throws {
            try self.oAuth2Properties?.validate(name: "\(name).oAuth2Properties")
            try self.profileProperties?.forEach {
                try validate($0.key, name: "profileProperties.key", parent: name, max: 128)
                try validate($0.key, name: "profileProperties.key", parent: name, min: 1)
                try validate($0.key, name: "profileProperties.key", parent: name, pattern: "^[\\w]+$")
                try validate($0.value, name: "profileProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "profileProperties[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.profileProperties, name: "profileProperties", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case oAuth2Properties = "oAuth2Properties"
            case profileProperties = "profileProperties"
        }
    }

    public struct CustomConnectorSourceProperties: AWSEncodableShape & AWSDecodableShape {
        /// Custom properties that are required to use the custom connector as a source.
        public let customProperties: [String: String]?
        /// The API of the connector application that Amazon AppFlow uses to transfer your data.
        public let dataTransferApi: DataTransferApi?
        /// The entity specified in the custom connector as a source in the flow.
        public let entityName: String

        @inlinable
        public init(customProperties: [String: String]? = nil, dataTransferApi: DataTransferApi? = nil, entityName: String) {
            self.customProperties = customProperties
            self.dataTransferApi = dataTransferApi
            self.entityName = entityName
        }

        public func validate(name: String) throws {
            try self.customProperties?.forEach {
                try validate($0.key, name: "customProperties.key", parent: name, max: 128)
                try validate($0.key, name: "customProperties.key", parent: name, min: 1)
                try validate($0.key, name: "customProperties.key", parent: name, pattern: "^[\\w]+$")
                try validate($0.value, name: "customProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customProperties[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.customProperties, name: "customProperties", parent: name, max: 50)
            try self.dataTransferApi?.validate(name: "\(name).dataTransferApi")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 1024)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "customProperties"
            case dataTransferApi = "dataTransferApi"
            case entityName = "entityName"
        }
    }

    public struct CustomerProfilesDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The unique name of the Amazon Connect Customer Profiles domain.
        public let domainName: String
        ///  The object specified in the Amazon Connect Customer Profiles flow destination.
        public let objectTypeName: String?

        @inlinable
        public init(domainName: String, objectTypeName: String? = nil) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^\\S+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case objectTypeName = "objectTypeName"
        }
    }

    public struct CustomerProfilesMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DataTransferApi: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connector application API.
        public let name: String?
        /// You can specify one of the following types:  AUTOMATIC  The default. Optimizes a flow for datasets that fluctuate in size from small to large. For each flow run, Amazon AppFlow chooses to use the SYNC or ASYNC API type based on the amount of data that the run transfers.  SYNC  A synchronous API. This type of API optimizes a flow for small to medium-sized datasets.  ASYNC  An asynchronous API. This type of API optimizes a flow for large datasets.
        public let type: DataTransferApiType?

        @inlinable
        public init(name: String? = nil, type: DataTransferApiType? = nil) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DatadogConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String
        ///  Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        public let applicationKey: String

        @inlinable
        public init(apiKey: String, applicationKey: String) {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "^\\S+$")
            try self.validate(self.applicationKey, name: "applicationKey", parent: name, max: 512)
            try self.validate(self.applicationKey, name: "applicationKey", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case applicationKey = "applicationKey"
        }
    }

    public struct DatadogConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Datadog resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct DatadogMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DatadogSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Datadog flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct DeleteConnectorProfileRequest: AWSEncodableShape {
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your account.
        public let connectorProfileName: String
        ///  Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
        public let forceDelete: Bool?

        @inlinable
        public init(connectorProfileName: String, forceDelete: Bool? = nil) {
            self.connectorProfileName = connectorProfileName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "connectorProfileName"
            case forceDelete = "forceDelete"
        }
    }

    public struct DeleteConnectorProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
        public let forceDelete: Bool?

        @inlinable
        public init(flowName: String, forceDelete: Bool? = nil) {
            self.flowName = flowName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
            case forceDelete = "forceDelete"
        }
    }

    public struct DeleteFlowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeConnectorEntityRequest: AWSEncodableShape {
        /// The version of the API that's used by the connector.
        public let apiVersion: String?
        ///  The entity name for that connector.
        public let connectorEntityName: String
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public let connectorProfileName: String?
        ///  The type of connector application, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?

        @inlinable
        public init(apiVersion: String? = nil, connectorEntityName: String, connectorProfileName: String? = nil, connectorType: ConnectorType? = nil) {
            self.apiVersion = apiVersion
            self.connectorEntityName = connectorEntityName
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
        }

        public func validate(name: String) throws {
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, max: 256)
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, max: 1024)
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case connectorEntityName = "connectorEntityName"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
        }
    }

    public struct DescribeConnectorEntityResponse: AWSDecodableShape {
        ///  Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on.
        public let connectorEntityFields: [ConnectorEntityField]

        @inlinable
        public init(connectorEntityFields: [ConnectorEntityField]) {
            self.connectorEntityFields = connectorEntityFields
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityFields = "connectorEntityFields"
        }
    }

    public struct DescribeConnectorProfilesRequest: AWSEncodableShape {
        /// The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
        public let connectorLabel: String?
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public let connectorProfileNames: [String]?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
        public let maxResults: Int?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(connectorLabel: String? = nil, connectorProfileNames: [String]? = nil, connectorType: ConnectorType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorLabel = connectorLabel
            self.connectorProfileNames = connectorProfileNames
            self.connectorType = connectorType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.connectorProfileNames?.forEach {
                try validate($0, name: "connectorProfileNames[]", parent: name, max: 256)
                try validate($0, name: "connectorProfileNames[]", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            }
            try self.validate(self.connectorProfileNames, name: "connectorProfileNames", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorLabel = "connectorLabel"
            case connectorProfileNames = "connectorProfileNames"
            case connectorType = "connectorType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorProfilesResponse: AWSDecodableShape {
        ///  Returns information about the connector profiles associated with the flow.
        public let connectorProfileDetails: [ConnectorProfile]?
        ///  The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
        public let nextToken: String?

        @inlinable
        public init(connectorProfileDetails: [ConnectorProfile]? = nil, nextToken: String? = nil) {
            self.connectorProfileDetails = connectorProfileDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileDetails = "connectorProfileDetails"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorRequest: AWSEncodableShape {
        /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
        public let connectorLabel: String?
        /// The connector type, such as CUSTOMCONNECTOR, Saleforce, Marketo. Please choose CUSTOMCONNECTOR for Lambda based custom connectors.
        public let connectorType: ConnectorType

        @inlinable
        public init(connectorLabel: String? = nil, connectorType: ConnectorType) {
            self.connectorLabel = connectorLabel
            self.connectorType = connectorType
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorLabel = "connectorLabel"
            case connectorType = "connectorType"
        }
    }

    public struct DescribeConnectorResponse: AWSDecodableShape {
        /// Configuration info of all the connectors that the user requested.
        public let connectorConfiguration: ConnectorConfiguration?

        @inlinable
        public init(connectorConfiguration: ConnectorConfiguration? = nil) {
            self.connectorConfiguration = connectorConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case connectorConfiguration = "connectorConfiguration"
        }
    }

    public struct DescribeConnectorsRequest: AWSEncodableShape {
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorTypes: [ConnectorType]?
        /// The maximum number of items that should be returned in the result set. The default is 20.
        public let maxResults: Int?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(connectorTypes: [ConnectorType]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorTypes = connectorTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorTypes, name: "connectorTypes", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorTypes = "connectorTypes"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorsResponse: AWSDecodableShape {
        ///  The configuration that is applied to the connectors used in the flow.
        public let connectorConfigurations: [ConnectorType: ConnectorConfiguration]?
        /// Information about the connectors supported in Amazon AppFlow.
        public let connectors: [ConnectorDetail]?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(connectorConfigurations: [ConnectorType: ConnectorConfiguration]? = nil, connectors: [ConnectorDetail]? = nil, nextToken: String? = nil) {
            self.connectorConfigurations = connectorConfigurations
            self.connectors = connectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorConfigurations = "connectorConfigurations"
            case connectors = "connectors"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowExecutionRecordsRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
        public let maxResults: Int?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(flowName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowName = flowName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowExecutionRecordsResponse: AWSDecodableShape {
        ///  Returns a list of all instances when this flow was run.
        public let flowExecutions: [ExecutionRecord]?
        ///  The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(flowExecutions: [ExecutionRecord]? = nil, nextToken: String? = nil) {
            self.flowExecutions = flowExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowExecutions = "flowExecutions"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        @inlinable
        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
        }
    }

    public struct DescribeFlowResponse: AWSDecodableShape {
        ///  Specifies when the flow was created.
        public let createdAt: Date?
        ///  The ARN of the user who created the flow.
        public let createdBy: String?
        ///  A description of the flow.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?
        ///  Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
        public let flowStatusMessage: String?
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
        public let kmsArn: String?
        ///  Describes the details of the most recent flow run.
        public let lastRunExecutionDetails: ExecutionDetails?
        /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
        public let lastRunMetadataCatalogDetails: [MetadataCatalogDetail]?
        ///  Specifies when the flow was last updated.
        public let lastUpdatedAt: Date?
        ///  Specifies the user name of the account that performed the most recent update.
        public let lastUpdatedBy: String?
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
        public let metadataCatalogConfig: MetadataCatalogConfig?
        /// The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:   Source-to-destination field mappings   Field data types   Partition keys
        public let schemaVersion: Int64?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
        public let sourceFlowConfig: SourceFlowConfig?
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]?
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig]? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, flowStatusMessage: String? = nil, kmsArn: String? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastRunMetadataCatalogDetails: [MetadataCatalogDetail]? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, metadataCatalogConfig: MetadataCatalogConfig? = nil, schemaVersion: Int64? = nil, sourceFlowConfig: SourceFlowConfig? = nil, tags: [String: String]? = nil, tasks: [Task]? = nil, triggerConfig: TriggerConfig? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.flowStatusMessage = flowStatusMessage
            self.kmsArn = kmsArn
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastRunMetadataCatalogDetails = lastRunMetadataCatalogDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.metadataCatalogConfig = metadataCatalogConfig
            self.schemaVersion = schemaVersion
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowArn = "flowArn"
            case flowName = "flowName"
            case flowStatus = "flowStatus"
            case flowStatusMessage = "flowStatusMessage"
            case kmsArn = "kmsArn"
            case lastRunExecutionDetails = "lastRunExecutionDetails"
            case lastRunMetadataCatalogDetails = "lastRunMetadataCatalogDetails"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case metadataCatalogConfig = "metadataCatalogConfig"
            case schemaVersion = "schemaVersion"
            case sourceFlowConfig = "sourceFlowConfig"
            case tags = "tags"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct DestinationConnectorProperties: AWSEncodableShape & AWSDecodableShape {
        /// The properties that are required to query the custom Connector.
        public let customConnector: CustomConnectorDestinationProperties?
        ///  The properties required to query Amazon Connect Customer Profiles.
        public let customerProfiles: CustomerProfilesDestinationProperties?
        ///  The properties required to query Amazon EventBridge.
        public let eventBridge: EventBridgeDestinationProperties?
        ///  The properties required to query Amazon Honeycode.
        public let honeycode: HoneycodeDestinationProperties?
        ///  The properties required to query Amazon Lookout for Metrics.
        public let lookoutMetrics: LookoutMetricsDestinationProperties?
        /// The properties required to query Marketo.
        public let marketo: MarketoDestinationProperties?
        ///  The properties required to query Amazon Redshift.
        public let redshift: RedshiftDestinationProperties?
        ///  The properties required to query Amazon S3.
        public let s3: S3DestinationProperties?
        ///  The properties required to query Salesforce.
        public let salesforce: SalesforceDestinationProperties?
        /// The properties required to query SAPOData.
        public let sapoData: SAPODataDestinationProperties?
        ///  The properties required to query Snowflake.
        public let snowflake: SnowflakeDestinationProperties?
        ///  The properties required to query Upsolver.
        public let upsolver: UpsolverDestinationProperties?
        /// The properties required to query Zendesk.
        public let zendesk: ZendeskDestinationProperties?

        @inlinable
        public init(customConnector: CustomConnectorDestinationProperties? = nil, customerProfiles: CustomerProfilesDestinationProperties? = nil, eventBridge: EventBridgeDestinationProperties? = nil, honeycode: HoneycodeDestinationProperties? = nil, lookoutMetrics: LookoutMetricsDestinationProperties? = nil, marketo: MarketoDestinationProperties? = nil, redshift: RedshiftDestinationProperties? = nil, s3: S3DestinationProperties? = nil, salesforce: SalesforceDestinationProperties? = nil, sapoData: SAPODataDestinationProperties? = nil, snowflake: SnowflakeDestinationProperties? = nil, upsolver: UpsolverDestinationProperties? = nil, zendesk: ZendeskDestinationProperties? = nil) {
            self.customConnector = customConnector
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.customConnector?.validate(name: "\(name).customConnector")
            try self.customerProfiles?.validate(name: "\(name).customerProfiles")
            try self.eventBridge?.validate(name: "\(name).eventBridge")
            try self.honeycode?.validate(name: "\(name).honeycode")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.sapoData?.validate(name: "\(name).sapoData")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.upsolver?.validate(name: "\(name).upsolver")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case customConnector = "CustomConnector"
            case customerProfiles = "CustomerProfiles"
            case eventBridge = "EventBridge"
            case honeycode = "Honeycode"
            case lookoutMetrics = "LookoutMetrics"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case snowflake = "Snowflake"
            case upsolver = "Upsolver"
            case zendesk = "Zendesk"
        }
    }

    public struct DestinationFieldProperties: AWSDecodableShape {
        ///  Specifies if the destination field can be created by the current user.
        public let isCreatable: Bool?
        /// Specifies whether the field can use the default value during a Create operation.
        public let isDefaultedOnCreate: Bool?
        ///  Specifies if the destination field can have a null value.
        public let isNullable: Bool?
        ///  Specifies whether the field can be updated during an UPDATE or UPSERT write operation.
        public let isUpdatable: Bool?
        ///  Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        public let isUpsertable: Bool?
        ///  A list of supported write operations. For each write operation listed, this field can be used in idFieldNames when that write operation is present as a destination option.
        public let supportedWriteOperations: [WriteOperationType]?

        @inlinable
        public init(isCreatable: Bool? = nil, isDefaultedOnCreate: Bool? = nil, isNullable: Bool? = nil, isUpdatable: Bool? = nil, isUpsertable: Bool? = nil, supportedWriteOperations: [WriteOperationType]? = nil) {
            self.isCreatable = isCreatable
            self.isDefaultedOnCreate = isDefaultedOnCreate
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }

        private enum CodingKeys: String, CodingKey {
            case isCreatable = "isCreatable"
            case isDefaultedOnCreate = "isDefaultedOnCreate"
            case isNullable = "isNullable"
            case isUpdatable = "isUpdatable"
            case isUpsertable = "isUpsertable"
            case supportedWriteOperations = "supportedWriteOperations"
        }
    }

    public struct DestinationFlowConfig: AWSEncodableShape & AWSDecodableShape {
        /// The API version that the destination connector uses.
        public let apiVersion: String?
        ///  The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  This stores the information that is required to query a particular connector.
        public let destinationConnectorProperties: DestinationConnectorProperties

        @inlinable
        public init(apiVersion: String? = nil, connectorProfileName: String? = nil, connectorType: ConnectorType, destinationConnectorProperties: DestinationConnectorProperties) {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, max: 256)
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.destinationConnectorProperties.validate(name: "\(name).destinationConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case destinationConnectorProperties = "destinationConnectorProperties"
        }
    }

    public struct DynatraceConnectorProfileCredentials: AWSEncodableShape {
        ///  The API tokens used by Dynatrace API to authenticate various API calls.
        public let apiToken: String

        @inlinable
        public init(apiToken: String) {
            self.apiToken = apiToken
        }

        public func validate(name: String) throws {
            try self.validate(self.apiToken, name: "apiToken", parent: name, max: 256)
            try self.validate(self.apiToken, name: "apiToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiToken = "apiToken"
        }
    }

    public struct DynatraceConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Dynatrace resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct DynatraceMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct DynatraceSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Dynatrace flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ErrorHandlingConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the name of the Amazon S3 bucket.
        public let bucketName: String?
        ///  Specifies the Amazon S3 bucket prefix.
        public let bucketPrefix: String?
        ///  Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        public let failOnFirstDestinationError: Bool?

        @inlinable
        public init(bucketName: String? = nil, bucketPrefix: String? = nil, failOnFirstDestinationError: Bool? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case failOnFirstDestinationError = "failOnFirstDestinationError"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        ///  Specifies the error message that appears if a flow fails.
        public let executionMessage: String?
        ///  Specifies the failure count for the attempted flow.
        public let putFailuresCount: Int64?

        @inlinable
        public init(executionMessage: String? = nil, putFailuresCount: Int64? = nil) {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }

        private enum CodingKeys: String, CodingKey {
            case executionMessage = "executionMessage"
            case putFailuresCount = "putFailuresCount"
        }
    }

    public struct EventBridgeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Amazon EventBridge flow destination.
        public let object: String

        @inlinable
        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case object = "object"
        }
    }

    public struct EventBridgeMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct ExecutionDetails: AWSDecodableShape {
        ///  Describes the details of the most recent flow run.
        public let mostRecentExecutionMessage: String?
        ///  Specifies the status of the most recent flow run.
        public let mostRecentExecutionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent flow run.
        public let mostRecentExecutionTime: Date?

        @inlinable
        public init(mostRecentExecutionMessage: String? = nil, mostRecentExecutionStatus: ExecutionStatus? = nil, mostRecentExecutionTime: Date? = nil) {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }

        private enum CodingKeys: String, CodingKey {
            case mostRecentExecutionMessage = "mostRecentExecutionMessage"
            case mostRecentExecutionStatus = "mostRecentExecutionStatus"
            case mostRecentExecutionTime = "mostRecentExecutionTime"
        }
    }

    public struct ExecutionRecord: AWSDecodableShape {
        ///  The timestamp that indicates the last new or updated record to be transferred in the flow run.
        public let dataPullEndTime: Date?
        ///  The timestamp that determines the first new or updated record to be transferred in the flow run.
        public let dataPullStartTime: Date?
        ///  Specifies the identifier of the given flow run.
        public let executionId: String?
        ///  Describes the result of the given flow run.
        public let executionResult: ExecutionResult?
        ///  Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        public let executionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent update.
        public let lastUpdatedAt: Date?
        /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
        public let metadataCatalogDetails: [MetadataCatalogDetail]?
        ///  Specifies the start time of the flow run.
        public let startedAt: Date?

        @inlinable
        public init(dataPullEndTime: Date? = nil, dataPullStartTime: Date? = nil, executionId: String? = nil, executionResult: ExecutionResult? = nil, executionStatus: ExecutionStatus? = nil, lastUpdatedAt: Date? = nil, metadataCatalogDetails: [MetadataCatalogDetail]? = nil, startedAt: Date? = nil) {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.metadataCatalogDetails = metadataCatalogDetails
            self.startedAt = startedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullEndTime = "dataPullEndTime"
            case dataPullStartTime = "dataPullStartTime"
            case executionId = "executionId"
            case executionResult = "executionResult"
            case executionStatus = "executionStatus"
            case lastUpdatedAt = "lastUpdatedAt"
            case metadataCatalogDetails = "metadataCatalogDetails"
            case startedAt = "startedAt"
        }
    }

    public struct ExecutionResult: AWSDecodableShape {
        ///  The total number of bytes processed by the flow run.
        public let bytesProcessed: Int64?
        ///  The total number of bytes written as a result of the flow run.
        public let bytesWritten: Int64?
        ///  Provides any error message information related to the flow run.
        public let errorInfo: ErrorInfo?
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application.
        public let maxPageSize: Int64?
        /// The number of processes that Amazon AppFlow ran at the same time when it retrieved your data.
        public let numParallelProcesses: Int64?
        ///  The number of records processed in the flow run.
        public let recordsProcessed: Int64?

        @inlinable
        public init(bytesProcessed: Int64? = nil, bytesWritten: Int64? = nil, errorInfo: ErrorInfo? = nil, maxPageSize: Int64? = nil, numParallelProcesses: Int64? = nil, recordsProcessed: Int64? = nil) {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.maxPageSize = maxPageSize
            self.numParallelProcesses = numParallelProcesses
            self.recordsProcessed = recordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case bytesProcessed = "bytesProcessed"
            case bytesWritten = "bytesWritten"
            case errorInfo = "errorInfo"
            case maxPageSize = "maxPageSize"
            case numParallelProcesses = "numParallelProcesses"
            case recordsProcessed = "recordsProcessed"
        }
    }

    public struct FieldTypeDetails: AWSDecodableShape {
        /// This is the allowable length range for this field's value.
        public let fieldLengthRange: Range?
        ///  The type of field, such as string, integer, date, and so on.
        public let fieldType: String
        /// The range of values this field can hold.
        public let fieldValueRange: Range?
        ///  The list of operators supported by a field.
        public let filterOperators: [Operator]
        /// The date format that the field supports.
        public let supportedDateFormat: String?
        ///  The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false".
        public let supportedValues: [String]?
        /// The regular expression pattern for the field name.
        public let valueRegexPattern: String?

        @inlinable
        public init(fieldLengthRange: Range? = nil, fieldType: String, fieldValueRange: Range? = nil, filterOperators: [Operator], supportedDateFormat: String? = nil, supportedValues: [String]? = nil, valueRegexPattern: String? = nil) {
            self.fieldLengthRange = fieldLengthRange
            self.fieldType = fieldType
            self.fieldValueRange = fieldValueRange
            self.filterOperators = filterOperators
            self.supportedDateFormat = supportedDateFormat
            self.supportedValues = supportedValues
            self.valueRegexPattern = valueRegexPattern
        }

        private enum CodingKeys: String, CodingKey {
            case fieldLengthRange = "fieldLengthRange"
            case fieldType = "fieldType"
            case fieldValueRange = "fieldValueRange"
            case filterOperators = "filterOperators"
            case supportedDateFormat = "supportedDateFormat"
            case supportedValues = "supportedValues"
            case valueRegexPattern = "valueRegexPattern"
        }
    }

    public struct FlowDefinition: AWSDecodableShape {
        ///  Specifies when the flow was created.
        public let createdAt: Date?
        ///  The ARN of the user who created the flow.
        public let createdBy: String?
        ///  A user-entered description of the flow.
        public let description: String?
        /// The label of the destination connector in the flow.
        public let destinationConnectorLabel: String?
        ///  Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public let destinationConnectorType: ConnectorType?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?
        ///  Describes the details of the most recent flow run.
        public let lastRunExecutionDetails: ExecutionDetails?
        ///  Specifies when the flow was last updated.
        public let lastUpdatedAt: Date?
        ///  Specifies the account user name that most recently updated the flow.
        public let lastUpdatedBy: String?
        /// The label of the source connector in the flow.
        public let sourceConnectorLabel: String?
        ///  Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public let sourceConnectorType: ConnectorType?
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public let triggerType: TriggerType?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, destinationConnectorLabel: String? = nil, destinationConnectorType: ConnectorType? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, sourceConnectorLabel: String? = nil, sourceConnectorType: ConnectorType? = nil, tags: [String: String]? = nil, triggerType: TriggerType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorLabel = destinationConnectorLabel
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorLabel = sourceConnectorLabel
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case destinationConnectorLabel = "destinationConnectorLabel"
            case destinationConnectorType = "destinationConnectorType"
            case flowArn = "flowArn"
            case flowName = "flowName"
            case flowStatus = "flowStatus"
            case lastRunExecutionDetails = "lastRunExecutionDetails"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case sourceConnectorLabel = "sourceConnectorLabel"
            case sourceConnectorType = "sourceConnectorType"
            case tags = "tags"
            case triggerType = "triggerType"
        }
    }

    public struct GlueDataCatalogConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Data Catalog database that stores the metadata tables that Amazon AppFlow creates in your Amazon Web Services account. These tables contain metadata for the data that's transferred by the flow that you configure with this parameter.  When you configure a new flow with this parameter, you must specify an existing database.
        public let databaseName: String
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon AppFlow the permissions it needs to create Data Catalog tables, databases, and partitions. For an example IAM policy that has the required permissions, see Identity-based policy examples for Amazon AppFlow.
        public let roleArn: String
        /// A naming prefix for each Data Catalog table that Amazon AppFlow creates for the flow that you configure with this setting. Amazon AppFlow adds the prefix to the beginning of the each table name.
        public let tablePrefix: String

        @inlinable
        public init(databaseName: String, roleArn: String, tablePrefix: String) {
            self.databaseName = databaseName
            self.roleArn = roleArn
            self.tablePrefix = tablePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, max: 128)
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case roleArn = "roleArn"
            case tablePrefix = "tablePrefix"
        }
    }

    public struct GoogleAnalyticsConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Google Analytics resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct GoogleAnalyticsConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct GoogleAnalyticsMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Google Analytics account.
        public let oAuthScopes: [String]?

        @inlinable
        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct GoogleAnalyticsSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Google Analytics flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct HoneycodeConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Amazon Honeycode resources.
        public let accessToken: String?
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct HoneycodeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct HoneycodeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Amazon Honeycode flow destination.
        public let object: String

        @inlinable
        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case object = "object"
        }
    }

    public struct HoneycodeMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Amazon Honeycode account.
        public let oAuthScopes: [String]?

        @inlinable
        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct IncrementalPullConfig: AWSEncodableShape & AWSDecodableShape {
        ///  A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public let datetimeTypeFieldName: String?

        @inlinable
        public init(datetimeTypeFieldName: String? = nil) {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }

        public func validate(name: String) throws {
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, max: 256)
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case datetimeTypeFieldName = "datetimeTypeFieldName"
        }
    }

    public struct InforNexusConnectorProfileCredentials: AWSEncodableShape {
        ///  The Access Key portion of the credentials.
        public let accessKeyId: String
        ///  The encryption keys used to encrypt data.
        public let datakey: String
        ///  The secret key used to sign requests.
        public let secretAccessKey: String
        ///  The identifier for the user.
        public let userId: String

        @inlinable
        public init(accessKeyId: String, datakey: String, secretAccessKey: String, userId: String) {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, max: 256)
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, pattern: "^\\S+$")
            try self.validate(self.datakey, name: "datakey", parent: name, max: 512)
            try self.validate(self.datakey, name: "datakey", parent: name, pattern: "^\\S+$")
            try self.validate(self.secretAccessKey, name: "secretAccessKey", parent: name, max: 512)
            try self.validate(self.secretAccessKey, name: "secretAccessKey", parent: name, pattern: "^\\S+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 512)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case datakey = "datakey"
            case secretAccessKey = "secretAccessKey"
            case userId = "userId"
        }
    }

    public struct InforNexusConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Infor Nexus resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct InforNexusMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct InforNexusSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Infor Nexus flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct LambdaConnectorProvisioningConfig: AWSEncodableShape & AWSDecodableShape {
        /// Lambda ARN of the connector being registered.
        public let lambdaArn: String

        @inlinable
        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 512)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:aws:.*:.*:[0-9]+:")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
        }
    }

    public struct ListConnectorEntitiesRequest: AWSEncodableShape {
        /// The version of the API that's used by the connector.
        public let apiVersion: String?
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account, and is used to query the downstream connector.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType?
        ///  This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
        public let entitiesPath: String?
        /// The maximum number of items that the operation returns in the response.
        public let maxResults: Int?
        /// A token that was provided by your prior ListConnectorEntities operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.
        public let nextToken: String?

        @inlinable
        public init(apiVersion: String? = nil, connectorProfileName: String? = nil, connectorType: ConnectorType? = nil, entitiesPath: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.entitiesPath = entitiesPath
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, max: 256)
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, max: 256)
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, pattern: "^[\\s\\w/!@#+=,.-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case entitiesPath = "entitiesPath"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectorEntitiesResponse: AWSDecodableShape {
        ///  The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
        public let connectorEntityMap: [String: [ConnectorEntity]]
        /// A token that you specify in your next ListConnectorEntities operation to get the next page of results in paginated response. The ListConnectorEntities operation provides this token if the response is too big for the page size.
        public let nextToken: String?

        @inlinable
        public init(connectorEntityMap: [String: [ConnectorEntity]], nextToken: String? = nil) {
            self.connectorEntityMap = connectorEntityMap
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityMap = "connectorEntityMap"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectorsRequest: AWSEncodableShape {
        /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
        public let maxResults: Int?
        /// The pagination token for the next page of data.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectorsResponse: AWSDecodableShape {
        /// Contains information about the connectors supported by Amazon AppFlow.
        public let connectors: [ConnectorDetail]?
        /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
        public let nextToken: String?

        @inlinable
        public init(connectors: [ConnectorDetail]? = nil, nextToken: String? = nil) {
            self.connectors = connectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectors = "connectors"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowsRequest: AWSEncodableShape {
        ///  Specifies the maximum number of items that should be returned in the result set.
        public let maxResults: Int?
        ///  The pagination token for next page of data.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowsResponse: AWSDecodableShape {
        ///  The list of flows associated with your account.
        public let flows: [FlowDefinition]?
        ///  The pagination token for next page of data.
        public let nextToken: String?

        @inlinable
        public init(flows: [FlowDefinition]? = nil, nextToken: String? = nil) {
            self.flows = flows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flows = "flows"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the specified flow.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:.*:.*:[0-9]+:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LookoutMetricsDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct MarketoConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Marketo resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        @inlinable
        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct MarketoConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Marketo resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct MarketoDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        /// The object specified in the Marketo flow destination.
        public let object: String

        @inlinable
        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case object = "object"
        }
    }

    public struct MarketoMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct MarketoSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Marketo flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct MetadataCatalogConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data with the Glue Data Catalog.
        public let glueDataCatalog: GlueDataCatalogConfig?

        @inlinable
        public init(glueDataCatalog: GlueDataCatalogConfig? = nil) {
            self.glueDataCatalog = glueDataCatalog
        }

        public func validate(name: String) throws {
            try self.glueDataCatalog?.validate(name: "\(name).glueDataCatalog")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalog = "glueDataCatalog"
        }
    }

    public struct MetadataCatalogDetail: AWSDecodableShape {
        /// The type of metadata catalog that Amazon AppFlow used for the associated flow run. This parameter returns the following value:  GLUE  The metadata catalog is provided by the Glue Data Catalog. Glue includes the Glue Data Catalog as a component.
        public let catalogType: CatalogType?
        /// Describes the status of the attempt from Amazon AppFlow to register the data partitions with the metadata catalog. The data partitions organize the flow output into a hierarchical path, such as a folder path in an S3 bucket. Amazon AppFlow creates the partitions (if they don't already exist) based on your flow configuration.
        public let partitionRegistrationOutput: RegistrationOutput?
        /// The name of the table that stores the metadata for the associated flow run. The table stores metadata that represents the data that the flow transferred. Amazon AppFlow stores the table in the metadata catalog.
        public let tableName: String?
        /// Describes the status of the attempt from Amazon AppFlow to register the metadata table with the metadata catalog. Amazon AppFlow creates or updates this table for the associated flow run.
        public let tableRegistrationOutput: RegistrationOutput?

        @inlinable
        public init(catalogType: CatalogType? = nil, partitionRegistrationOutput: RegistrationOutput? = nil, tableName: String? = nil, tableRegistrationOutput: RegistrationOutput? = nil) {
            self.catalogType = catalogType
            self.partitionRegistrationOutput = partitionRegistrationOutput
            self.tableName = tableName
            self.tableRegistrationOutput = tableRegistrationOutput
        }

        private enum CodingKeys: String, CodingKey {
            case catalogType = "catalogType"
            case partitionRegistrationOutput = "partitionRegistrationOutput"
            case tableName = "tableName"
            case tableRegistrationOutput = "tableRegistrationOutput"
        }
    }

    public struct OAuth2Credentials: AWSEncodableShape {
        /// The access token used to access the connector on your behalf.
        public let accessToken: String?
        /// The identifier for the desired client.
        public let clientId: String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String?
        public let oAuthRequest: ConnectorOAuthRequest?
        /// The refresh token used to refresh an expired access token.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, clientId: String? = nil, clientSecret: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct OAuth2CustomParameter: AWSDecodableShape {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public let connectorSuppliedValues: [String]?
        /// A description about the custom parameter used for OAuth 2.0 authentication.
        public let description: String?
        /// Indicates whether the custom parameter for OAuth 2.0 authentication is required.
        public let isRequired: Bool?
        /// Indicates whether this authentication custom parameter is a sensitive field.
        public let isSensitiveField: Bool?
        /// The key of the custom parameter required for OAuth 2.0 authentication.
        public let key: String?
        /// The label of the custom parameter used for OAuth 2.0 authentication.
        public let label: String?
        /// Indicates whether custom parameter is used with TokenUrl or AuthUrl.
        public let type: OAuth2CustomPropType?

        @inlinable
        public init(connectorSuppliedValues: [String]? = nil, description: String? = nil, isRequired: Bool? = nil, isSensitiveField: Bool? = nil, key: String? = nil, label: String? = nil, type: OAuth2CustomPropType? = nil) {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case connectorSuppliedValues = "connectorSuppliedValues"
            case description = "description"
            case isRequired = "isRequired"
            case isSensitiveField = "isSensitiveField"
            case key = "key"
            case label = "label"
            case type = "type"
        }
    }

    public struct OAuth2Defaults: AWSDecodableShape {
        /// Auth code URLs that can be used for OAuth 2.0 authentication.
        public let authCodeUrls: [String]?
        /// List of custom parameters required for OAuth 2.0 authentication.
        public let oauth2CustomProperties: [OAuth2CustomParameter]?
        /// OAuth 2.0 grant types supported by the connector.
        public let oauth2GrantTypesSupported: [OAuth2GrantType]?
        /// OAuth 2.0 scopes that the connector supports.
        public let oauthScopes: [String]?
        /// Token URLs that can be used for OAuth 2.0 authentication.
        public let tokenUrls: [String]?

        @inlinable
        public init(authCodeUrls: [String]? = nil, oauth2CustomProperties: [OAuth2CustomParameter]? = nil, oauth2GrantTypesSupported: [OAuth2GrantType]? = nil, oauthScopes: [String]? = nil, tokenUrls: [String]? = nil) {
            self.authCodeUrls = authCodeUrls
            self.oauth2CustomProperties = oauth2CustomProperties
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
            self.oauthScopes = oauthScopes
            self.tokenUrls = tokenUrls
        }

        private enum CodingKeys: String, CodingKey {
            case authCodeUrls = "authCodeUrls"
            case oauth2CustomProperties = "oauth2CustomProperties"
            case oauth2GrantTypesSupported = "oauth2GrantTypesSupported"
            case oauthScopes = "oauthScopes"
            case tokenUrls = "tokenUrls"
        }
    }

    public struct OAuth2Properties: AWSEncodableShape & AWSDecodableShape {
        /// The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication.
        public let oAuth2GrantType: OAuth2GrantType
        /// The token URL required for OAuth 2.0 authentication.
        public let tokenUrl: String
        /// Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        public let tokenUrlCustomProperties: [String: String]?

        @inlinable
        public init(oAuth2GrantType: OAuth2GrantType, tokenUrl: String, tokenUrlCustomProperties: [String: String]? = nil) {
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlCustomProperties = tokenUrlCustomProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, max: 256)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, pattern: "^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.tokenUrlCustomProperties?.forEach {
                try validate($0.key, name: "tokenUrlCustomProperties.key", parent: name, max: 128)
                try validate($0.key, name: "tokenUrlCustomProperties.key", parent: name, min: 1)
                try validate($0.key, name: "tokenUrlCustomProperties.key", parent: name, pattern: "^[\\w]+$")
                try validate($0.value, name: "tokenUrlCustomProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "tokenUrlCustomProperties[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.tokenUrlCustomProperties, name: "tokenUrlCustomProperties", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case oAuth2GrantType = "oAuth2GrantType"
            case tokenUrl = "tokenUrl"
            case tokenUrlCustomProperties = "tokenUrlCustomProperties"
        }
    }

    public struct OAuthCredentials: AWSEncodableShape {
        ///  The access token used to access protected SAPOData resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The refresh token used to refresh expired access token.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct OAuthProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        public let authCodeUrl: String
        ///  The OAuth scopes required for OAuth type authentication.
        public let oAuthScopes: [String]
        ///  The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        public let tokenUrl: String

        @inlinable
        public init(authCodeUrl: String, oAuthScopes: [String], tokenUrl: String) {
            self.authCodeUrl = authCodeUrl
            self.oAuthScopes = oAuthScopes
            self.tokenUrl = tokenUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.authCodeUrl, name: "authCodeUrl", parent: name, max: 256)
            try self.validate(self.authCodeUrl, name: "authCodeUrl", parent: name, pattern: "^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.oAuthScopes.forEach {
                try validate($0, name: "oAuthScopes[]", parent: name, max: 128)
                try validate($0, name: "oAuthScopes[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, max: 256)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, pattern: "^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
        }

        private enum CodingKeys: String, CodingKey {
            case authCodeUrl = "authCodeUrl"
            case oAuthScopes = "oAuthScopes"
            case tokenUrl = "tokenUrl"
        }
    }

    public struct PardotConnectorProfileCredentials: AWSEncodableShape {
        /// The credentials used to access protected Salesforce Pardot resources.
        public let accessToken: String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public let clientCredentialsArn: String?
        public let oAuthRequest: ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, clientCredentialsArn: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, max: 2048)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, min: 20)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, pattern: "^arn:aws:secretsmanager:.*:[0-9]+:")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientCredentialsArn = "clientCredentialsArn"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct PardotConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        /// The business unit id of Salesforce Pardot instance.
        public let businessUnitId: String?
        /// The location of the Salesforce Pardot resource.
        public let instanceUrl: String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public let isSandboxEnvironment: Bool?

        @inlinable
        public init(businessUnitId: String? = nil, instanceUrl: String? = nil, isSandboxEnvironment: Bool? = nil) {
            self.businessUnitId = businessUnitId
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }

        public func validate(name: String) throws {
            try self.validate(self.businessUnitId, name: "businessUnitId", parent: name, max: 18)
            try self.validate(self.businessUnitId, name: "businessUnitId", parent: name, pattern: "^\\S+$")
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case businessUnitId = "businessUnitId"
            case instanceUrl = "instanceUrl"
            case isSandboxEnvironment = "isSandboxEnvironment"
        }
    }

    public struct PardotMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct PardotSourceProperties: AWSEncodableShape & AWSDecodableShape {
        /// The object specified in the Salesforce Pardot flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct PrefixConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the destination file path includes either or both of the following elements:  EXECUTION_ID  The ID that Amazon AppFlow assigns to the flow run.  SCHEMA_VERSION  The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:   Source-to-destination field mappings   Field data types   Partition keys
        public let pathPrefixHierarchy: [PathPrefix]?
        /// Determines the level of granularity for the date and time that's included in the prefix.
        public let prefixFormat: PrefixFormat?
        /// Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        public let prefixType: PrefixType?

        @inlinable
        public init(pathPrefixHierarchy: [PathPrefix]? = nil, prefixFormat: PrefixFormat? = nil, prefixType: PrefixType? = nil) {
            self.pathPrefixHierarchy = pathPrefixHierarchy
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }

        private enum CodingKeys: String, CodingKey {
            case pathPrefixHierarchy = "pathPrefixHierarchy"
            case prefixFormat = "prefixFormat"
            case prefixType = "prefixType"
        }
    }

    public struct PrivateConnectionProvisioningState: AWSDecodableShape {
        ///  Specifies the private connection provisioning failure cause.
        public let failureCause: PrivateConnectionProvisioningFailureCause?
        ///  Specifies the private connection provisioning failure reason.
        public let failureMessage: String?
        ///  Specifies the private connection provisioning status.
        public let status: PrivateConnectionProvisioningStatus?

        @inlinable
        public init(failureCause: PrivateConnectionProvisioningFailureCause? = nil, failureMessage: String? = nil, status: PrivateConnectionProvisioningStatus? = nil) {
            self.failureCause = failureCause
            self.failureMessage = failureMessage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureCause = "failureCause"
            case failureMessage = "failureMessage"
            case status = "status"
        }
    }

    public struct Range: AWSDecodableShape {
        /// Maximum value supported by the field.
        public let maximum: Double?
        /// Minimum value supported by the field.
        public let minimum: Double?

        @inlinable
        public init(maximum: Double? = nil, minimum: Double? = nil) {
            self.maximum = maximum
            self.minimum = minimum
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "maximum"
            case minimum = "minimum"
        }
    }

    public struct RedshiftConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String?
        ///  The name of the user.
        public let username: String?

        @inlinable
        public init(password: String? = nil, username: String? = nil) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 2048)
            try self.validate(self.username, name: "username", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct RedshiftConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  A name for the associated Amazon S3 bucket.
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        /// The unique ID that's assigned to an Amazon Redshift cluster.
        public let clusterIdentifier: String?
        /// The Amazon Resource Name (ARN) of an IAM role that permits Amazon AppFlow to access your Amazon Redshift database through the Data API. For more information, and for the polices that you attach to this role, see Allow Amazon AppFlow to access Amazon Redshift databases with the Data API.
        public let dataApiRoleArn: String?
        /// The name of an Amazon Redshift database.
        public let databaseName: String?
        ///  The JDBC URL of the Amazon Redshift cluster.
        public let databaseUrl: String?
        /// Indicates whether the connector profile defines a connection to an Amazon Redshift Serverless data warehouse.
        public let isRedshiftServerless: Bool?
        ///  The Amazon Resource Name (ARN) of IAM role that grants Amazon Redshift read-only access to Amazon S3. For more information, and for the polices that you attach to this role, see Allow Amazon Redshift to access your Amazon AppFlow data in Amazon S3.
        public let roleArn: String
        /// The name of an Amazon Redshift workgroup.
        public let workgroupName: String?

        @inlinable
        public init(bucketName: String, bucketPrefix: String? = nil, clusterIdentifier: String? = nil, dataApiRoleArn: String? = nil, databaseName: String? = nil, databaseUrl: String? = nil, isRedshiftServerless: Bool? = nil, roleArn: String, workgroupName: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.clusterIdentifier = clusterIdentifier
            self.dataApiRoleArn = dataApiRoleArn
            self.databaseName = databaseName
            self.databaseUrl = databaseUrl
            self.isRedshiftServerless = isRedshiftServerless
            self.roleArn = roleArn
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, max: 512)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^\\S+$")
            try self.validate(self.dataApiRoleArn, name: "dataApiRoleArn", parent: name, max: 512)
            try self.validate(self.dataApiRoleArn, name: "dataApiRoleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 512)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^\\S+$")
            try self.validate(self.databaseUrl, name: "databaseUrl", parent: name, max: 512)
            try self.validate(self.databaseUrl, name: "databaseUrl", parent: name, pattern: "^\\S+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 512)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case clusterIdentifier = "clusterIdentifier"
            case dataApiRoleArn = "dataApiRoleArn"
            case databaseName = "databaseName"
            case databaseUrl = "databaseUrl"
            case isRedshiftServerless = "isRedshiftServerless"
            case roleArn = "roleArn"
            case workgroupName = "workgroupName"
        }
    }

    public struct RedshiftDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object key for the bucket in which Amazon AppFlow places the destination files.
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        public let intermediateBucketName: String
        ///  The object specified in the Amazon Redshift flow destination.
        public let object: String

        @inlinable
        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, max: 63)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, min: 3)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix = "bucketPrefix"
            case errorHandlingConfig = "errorHandlingConfig"
            case intermediateBucketName = "intermediateBucketName"
            case object = "object"
        }
    }

    public struct RedshiftMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterConnectorRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your RegisterConnector request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to RegisterConnector. The token is active for 8 hours.
        public let clientToken: String?
        ///  The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account.
        public let connectorLabel: String?
        /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
        public let connectorProvisioningConfig: ConnectorProvisioningConfig?
        /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
        public let connectorProvisioningType: ConnectorProvisioningType?
        /// A description about the connector that's being registered.
        public let description: String?

        @inlinable
        public init(clientToken: String? = RegisterConnectorRequest.idempotencyToken(), connectorLabel: String? = nil, connectorProvisioningConfig: ConnectorProvisioningConfig? = nil, connectorProvisioningType: ConnectorProvisioningType? = nil, description: String? = nil) {
            self.clientToken = clientToken
            self.connectorLabel = connectorLabel
            self.connectorProvisioningConfig = connectorProvisioningConfig
            self.connectorProvisioningType = connectorProvisioningType
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.connectorProvisioningConfig?.validate(name: "\(name).connectorProvisioningConfig")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\w/!@#+=.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case connectorLabel = "connectorLabel"
            case connectorProvisioningConfig = "connectorProvisioningConfig"
            case connectorProvisioningType = "connectorProvisioningType"
            case description = "description"
        }
    }

    public struct RegisterConnectorResponse: AWSDecodableShape {
        /// The ARN of the connector being registered.
        public let connectorArn: String?

        @inlinable
        public init(connectorArn: String? = nil) {
            self.connectorArn = connectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
        }
    }

    public struct RegistrationOutput: AWSDecodableShape {
        /// Explains the status of the registration attempt from Amazon AppFlow. If the attempt fails, the message explains why.
        public let message: String?
        /// Indicates the number of resources that Amazon AppFlow created or updated. Possible resources include metadata tables and data partitions.
        public let result: String?
        /// Indicates the status of the registration attempt from Amazon AppFlow.
        public let status: ExecutionStatus?

        @inlinable
        public init(message: String? = nil, result: String? = nil, status: ExecutionStatus? = nil) {
            self.message = message
            self.result = result
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case result = "result"
            case status = "status"
        }
    }

    public struct ResetConnectorMetadataCacheRequest: AWSEncodableShape {
        /// The API version that you specified in the connector profile that youre resetting cached metadata for. You must use this parameter only if the connector supports multiple API versions or if the connector type is CustomConnector. To look up how many versions a connector supports, use the DescribeConnectors action. In the response, find the value that Amazon AppFlow returns for the connectorVersion parameter. To look up the connector type, use the DescribeConnectorProfiles action. In the response, find the value that Amazon AppFlow returns for the connectorType parameter. To look up the API version that you specified in a connector profile, use the DescribeConnectorProfiles action.
        public let apiVersion: String?
        /// Use this parameter if you want to reset cached metadata about the details for an individual entity. If you don't include this parameter in your request, Amazon AppFlow only resets cached metadata about entity names, not entity details.
        public let connectorEntityName: String?
        /// The name of the connector profile that you want to reset cached metadata for. You can omit this parameter if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you must include this parameter in your request.
        public let connectorProfileName: String?
        /// The type of connector to reset cached metadata for. You must include this parameter in your request if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you can omit this parameter from your request.
        public let connectorType: ConnectorType?
        /// Use this parameter only if youre resetting the cached metadata about a nested entity. Only some connectors support nested entities. A nested entity is one that has another entity as a parent. To use this parameter, specify the name of the parent entity. To look up the parent-child relationship of entities, you can send a ListConnectorEntities request that omits the entitiesPath parameter. Amazon AppFlow will return a list of top-level entities. For each one, it indicates whether the entity has nested entities. Then, in a subsequent ListConnectorEntities request, you can specify a parent entity name for the entitiesPath parameter. Amazon AppFlow will return a list of the child entities for that parent.
        public let entitiesPath: String?

        @inlinable
        public init(apiVersion: String? = nil, connectorEntityName: String? = nil, connectorProfileName: String? = nil, connectorType: ConnectorType? = nil, entitiesPath: String? = nil) {
            self.apiVersion = apiVersion
            self.connectorEntityName = connectorEntityName
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.entitiesPath = entitiesPath
        }

        public func validate(name: String) throws {
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, max: 256)
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, max: 1024)
            try self.validate(self.connectorEntityName, name: "connectorEntityName", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, max: 256)
            try self.validate(self.entitiesPath, name: "entitiesPath", parent: name, pattern: "^[\\s\\w/!@#+=,.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case connectorEntityName = "connectorEntityName"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case entitiesPath = "entitiesPath"
        }
    }

    public struct ResetConnectorMetadataCacheResponse: AWSDecodableShape {
        public init() {}
    }

    public struct S3DestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        public let s3OutputFormatConfig: S3OutputFormatConfig?

        @inlinable
        public init(bucketName: String, bucketPrefix: String? = nil, s3OutputFormatConfig: S3OutputFormatConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case s3OutputFormatConfig = "s3OutputFormatConfig"
        }
    }

    public struct S3InputFormatConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The file type that Amazon AppFlow gets from your Amazon S3 bucket.
        public let s3InputFileType: S3InputFileType?

        @inlinable
        public init(s3InputFileType: S3InputFileType? = nil) {
            self.s3InputFileType = s3InputFileType
        }

        private enum CodingKeys: String, CodingKey {
            case s3InputFileType = "s3InputFileType"
        }
    }

    public struct S3Metadata: AWSDecodableShape {
        public init() {}
    }

    public struct S3OutputFormatConfig: AWSEncodableShape & AWSDecodableShape {
        public let aggregationConfig: AggregationConfig?
        ///  Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        public let fileType: FileType?
        ///  Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        public let prefixConfig: PrefixConfig?
        /// If your file output format is Parquet, use this parameter to set whether Amazon AppFlow preserves the data types in your source data when it writes the output to Amazon S3.     true: Amazon AppFlow preserves the data types when it writes to Amazon S3. For example, an integer or 1 in your source data is still an integer in your output.    false: Amazon AppFlow converts all of the source data into strings when it writes to Amazon S3. For example, an integer of 1 in your source data becomes the string "1" in the output.
        public let preserveSourceDataTyping: Bool?

        @inlinable
        public init(aggregationConfig: AggregationConfig? = nil, fileType: FileType? = nil, prefixConfig: PrefixConfig? = nil, preserveSourceDataTyping: Bool? = nil) {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
            self.preserveSourceDataTyping = preserveSourceDataTyping
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationConfig = "aggregationConfig"
            case fileType = "fileType"
            case prefixConfig = "prefixConfig"
            case preserveSourceDataTyping = "preserveSourceDataTyping"
        }
    }

    public struct S3SourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon S3 bucket name where the source files are stored.
        public let bucketName: String
        ///  The object key for the Amazon S3 bucket in which the source files are stored.
        public let bucketPrefix: String?
        public let s3InputFormatConfig: S3InputFormatConfig?

        @inlinable
        public init(bucketName: String, bucketPrefix: String? = nil, s3InputFormatConfig: S3InputFormatConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3InputFormatConfig = s3InputFormatConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case s3InputFormatConfig = "s3InputFormatConfig"
        }
    }

    public struct SAPODataConnectorProfileCredentials: AWSEncodableShape {
        ///  The SAPOData basic authentication credentials.
        public let basicAuthCredentials: BasicAuthCredentials?
        ///  The SAPOData OAuth type authentication credentials.
        public let oAuthCredentials: OAuthCredentials?

        @inlinable
        public init(basicAuthCredentials: BasicAuthCredentials? = nil, oAuthCredentials: OAuthCredentials? = nil) {
            self.basicAuthCredentials = basicAuthCredentials
            self.oAuthCredentials = oAuthCredentials
        }

        public func validate(name: String) throws {
            try self.basicAuthCredentials?.validate(name: "\(name).basicAuthCredentials")
            try self.oAuthCredentials?.validate(name: "\(name).oAuthCredentials")
        }

        private enum CodingKeys: String, CodingKey {
            case basicAuthCredentials = "basicAuthCredentials"
            case oAuthCredentials = "oAuthCredentials"
        }
    }

    public struct SAPODataConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the SAPOData resource.
        public let applicationHostUrl: String
        ///  The application path to catalog service.
        public let applicationServicePath: String
        ///  The client number for the client creating the connection.
        public let clientNumber: String
        /// If you set this parameter to true, Amazon AppFlow bypasses the single sign-on (SSO) settings in your SAP account when it accesses your SAP OData instance. Whether you need this option depends on the types of credentials that you applied to your SAP OData connection profile. If your profile uses basic authentication credentials, SAP SSO can prevent Amazon AppFlow from connecting to your account with your username and password. In this case, bypassing SSO makes it possible for Amazon AppFlow to connect successfully. However, if your profile uses OAuth credentials, this parameter has no affect.
        public let disableSSO: Bool?
        ///  The logon language of SAPOData instance.
        public let logonLanguage: String?
        ///  The SAPOData OAuth properties required for OAuth type authentication.
        public let oAuthProperties: OAuthProperties?
        ///  The port number of the SAPOData instance.
        public let portNumber: Int
        ///  The SAPOData Private Link service name to be used for private data transfers.
        public let privateLinkServiceName: String?

        @inlinable
        public init(applicationHostUrl: String, applicationServicePath: String, clientNumber: String, disableSSO: Bool? = nil, logonLanguage: String? = nil, oAuthProperties: OAuthProperties? = nil, portNumber: Int, privateLinkServiceName: String? = nil) {
            self.applicationHostUrl = applicationHostUrl
            self.applicationServicePath = applicationServicePath
            self.clientNumber = clientNumber
            self.disableSSO = disableSSO
            self.logonLanguage = logonLanguage
            self.oAuthProperties = oAuthProperties
            self.portNumber = portNumber
            self.privateLinkServiceName = privateLinkServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationHostUrl, name: "applicationHostUrl", parent: name, max: 256)
            try self.validate(self.applicationHostUrl, name: "applicationHostUrl", parent: name, pattern: "^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.validate(self.applicationServicePath, name: "applicationServicePath", parent: name, max: 512)
            try self.validate(self.applicationServicePath, name: "applicationServicePath", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientNumber, name: "clientNumber", parent: name, max: 3)
            try self.validate(self.clientNumber, name: "clientNumber", parent: name, min: 3)
            try self.validate(self.clientNumber, name: "clientNumber", parent: name, pattern: "^\\d{3}$")
            try self.validate(self.logonLanguage, name: "logonLanguage", parent: name, max: 2)
            try self.validate(self.logonLanguage, name: "logonLanguage", parent: name, pattern: "^[a-zA-Z0-9_]*$")
            try self.oAuthProperties?.validate(name: "\(name).oAuthProperties")
            try self.validate(self.portNumber, name: "portNumber", parent: name, max: 65535)
            try self.validate(self.portNumber, name: "portNumber", parent: name, min: 1)
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, max: 512)
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, pattern: "^$|com.amazonaws.vpce.[\\w/!:@#.\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationHostUrl = "applicationHostUrl"
            case applicationServicePath = "applicationServicePath"
            case clientNumber = "clientNumber"
            case disableSSO = "disableSSO"
            case logonLanguage = "logonLanguage"
            case oAuthProperties = "oAuthProperties"
            case portNumber = "portNumber"
            case privateLinkServiceName = "privateLinkServiceName"
        }
    }

    public struct SAPODataDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        public let idFieldNames: [String]?
        /// The object path specified in the SAPOData flow destination.
        public let objectPath: String
        /// Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. For example, this setting would determine where to write the response from a destination connector upon a successful insert operation.
        public let successResponseHandlingConfig: SuccessResponseHandlingConfig?
        public let writeOperationType: WriteOperationType?

        @inlinable
        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, objectPath: String, successResponseHandlingConfig: SuccessResponseHandlingConfig? = nil, writeOperationType: WriteOperationType? = nil) {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.objectPath = objectPath
            self.successResponseHandlingConfig = successResponseHandlingConfig
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.objectPath, name: "objectPath", parent: name, max: 512)
            try self.validate(self.objectPath, name: "objectPath", parent: name, pattern: "^\\S+$")
            try self.successResponseHandlingConfig?.validate(name: "\(name).successResponseHandlingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case idFieldNames = "idFieldNames"
            case objectPath = "objectPath"
            case successResponseHandlingConfig = "successResponseHandlingConfig"
            case writeOperationType = "writeOperationType"
        }
    }

    public struct SAPODataMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct SAPODataPaginationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application. For transfers of OData records, the maximum page size is 3,000. For transfers of data that comes from an ODP provider, the maximum page size is 10,000.
        public let maxPageSize: Int

        @inlinable
        public init(maxPageSize: Int) {
            self.maxPageSize = maxPageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.maxPageSize, name: "maxPageSize", parent: name, max: 10000)
            try self.validate(self.maxPageSize, name: "maxPageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxPageSize = "maxPageSize"
        }
    }

    public struct SAPODataParallelismConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of processes that Amazon AppFlow runs at the same time when it retrieves your data from your SAP application.
        public let maxParallelism: Int

        @inlinable
        public init(maxParallelism: Int) {
            self.maxParallelism = maxParallelism
        }

        public func validate(name: String) throws {
            try self.validate(self.maxParallelism, name: "maxParallelism", parent: name, max: 10)
            try self.validate(self.maxParallelism, name: "maxParallelism", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxParallelism = "maxParallelism"
        }
    }

    public struct SAPODataSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object path specified in the SAPOData flow source.
        public let objectPath: String?
        /// Sets the page size for each concurrent process that transfers OData records from your SAP instance.
        public let paginationConfig: SAPODataPaginationConfig?
        /// Sets the number of concurrent processes that transfers OData records from your SAP instance.
        public let parallelismConfig: SAPODataParallelismConfig?

        @inlinable
        public init(objectPath: String? = nil, paginationConfig: SAPODataPaginationConfig? = nil, parallelismConfig: SAPODataParallelismConfig? = nil) {
            self.objectPath = objectPath
            self.paginationConfig = paginationConfig
            self.parallelismConfig = parallelismConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.objectPath, name: "objectPath", parent: name, max: 512)
            try self.validate(self.objectPath, name: "objectPath", parent: name, pattern: "^\\S+$")
            try self.paginationConfig?.validate(name: "\(name).paginationConfig")
            try self.parallelismConfig?.validate(name: "\(name).parallelismConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case objectPath = "objectPath"
            case paginationConfig = "paginationConfig"
            case parallelismConfig = "parallelismConfig"
        }
    }

    public struct SalesforceConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Salesforce resources.
        public let accessToken: String?
        ///  The secret manager ARN, which contains the client ID and client secret of the connected app.
        public let clientCredentialsArn: String?
        /// A JSON web token (JWT) that authorizes Amazon AppFlow to access your Salesforce records.
        public let jwtToken: String?
        /// Specifies the OAuth 2.0 grant type that Amazon AppFlow uses when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records. You can specify one of the following values:  AUTHORIZATION_CODE  Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records.  JWT_BEARER  Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records.    The CLIENT_CREDENTIALS value is not supported for Salesforce.
        public let oAuth2GrantType: OAuth2GrantType?
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens.
        public let refreshToken: String?

        @inlinable
        public init(accessToken: String? = nil, clientCredentialsArn: String? = nil, jwtToken: String? = nil, oAuth2GrantType: OAuth2GrantType? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.jwtToken = jwtToken
            self.oAuth2GrantType = oAuth2GrantType
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, max: 2048)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, min: 20)
            try self.validate(self.clientCredentialsArn, name: "clientCredentialsArn", parent: name, pattern: "^arn:aws:secretsmanager:.*:[0-9]+:")
            try self.validate(self.jwtToken, name: "jwtToken", parent: name, max: 8000)
            try self.validate(self.jwtToken, name: "jwtToken", parent: name, pattern: "^([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_\\-\\+\\/=]*)$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientCredentialsArn = "clientCredentialsArn"
            case jwtToken = "jwtToken"
            case oAuth2GrantType = "oAuth2GrantType"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct SalesforceConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Salesforce resource.
        public let instanceUrl: String?
        ///  Indicates whether the connector profile applies to a sandbox or production environment.
        public let isSandboxEnvironment: Bool?
        /// If the connection mode for the connector profile is private, this parameter sets whether Amazon AppFlow uses the private network to send metadata and authorization calls to Salesforce. Amazon AppFlow sends private calls through Amazon Web Services PrivateLink. These calls travel through Amazon Web Services infrastructure without being exposed to the public internet. Set either of the following values:  true  Amazon AppFlow sends all calls to Salesforce over the private network. These private calls are:   Calls to get metadata about your Salesforce records. This metadata describes your Salesforce objects and their fields.   Calls to get or refresh access tokens that allow Amazon AppFlow to access your Salesforce records.   Calls to transfer your Salesforce records as part of a flow run.    false  The default value. Amazon AppFlow sends some calls to Salesforce privately and other calls over the public internet. The public calls are:    Calls to get metadata about your Salesforce records.   Calls to get or refresh access tokens.   The private calls are:   Calls to transfer your Salesforce records as part of a flow run.
        public let usePrivateLinkForMetadataAndAuthorization: Bool?

        @inlinable
        public init(instanceUrl: String? = nil, isSandboxEnvironment: Bool? = nil, usePrivateLinkForMetadataAndAuthorization: Bool? = nil) {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
            self.usePrivateLinkForMetadataAndAuthorization = usePrivateLinkForMetadataAndAuthorization
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
            case isSandboxEnvironment = "isSandboxEnvironment"
            case usePrivateLinkForMetadataAndAuthorization = "usePrivateLinkForMetadataAndAuthorization"
        }
    }

    public struct SalesforceDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data to Salesforce.  AUTOMATIC  The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers to Salesforce. If your flow transfers fewer than 1,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900 records, and it might use Bulk API 2.0 on the next day to transfer 1,100 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output.  BULKV2  Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields.  REST_SYNC  Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail with a timed out error.
        public let dataTransferApi: SalesforceDataTransferApi?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        public let idFieldNames: [String]?
        ///  The object specified in the Salesforce flow destination.
        public let object: String
        ///  This specifies the type of write operation to be performed in Salesforce. When the value is UPSERT, then idFieldNames is required.
        public let writeOperationType: WriteOperationType?

        @inlinable
        public init(dataTransferApi: SalesforceDataTransferApi? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, object: String, writeOperationType: WriteOperationType? = nil) {
            self.dataTransferApi = dataTransferApi
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataTransferApi = "dataTransferApi"
            case errorHandlingConfig = "errorHandlingConfig"
            case idFieldNames = "idFieldNames"
            case object = "object"
            case writeOperationType = "writeOperationType"
        }
    }

    public struct SalesforceMetadata: AWSDecodableShape {
        /// The Salesforce APIs that you can have Amazon AppFlow use when your flows transfers data to or from Salesforce.
        public let dataTransferApis: [SalesforceDataTransferApi]?
        /// The OAuth 2.0 grant types that Amazon AppFlow can use when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records.  AUTHORIZATION_CODE  Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records.  JWT_BEARER  Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records.    The CLIENT_CREDENTIALS value is not supported for Salesforce.
        public let oauth2GrantTypesSupported: [OAuth2GrantType]?
        ///  The desired authorization scope for the Salesforce account.
        public let oAuthScopes: [String]?

        @inlinable
        public init(dataTransferApis: [SalesforceDataTransferApi]? = nil, oauth2GrantTypesSupported: [OAuth2GrantType]? = nil, oAuthScopes: [String]? = nil) {
            self.dataTransferApis = dataTransferApis
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case dataTransferApis = "dataTransferApis"
            case oauth2GrantTypesSupported = "oauth2GrantTypesSupported"
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct SalesforceSourceProperties: AWSEncodableShape & AWSDecodableShape {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data from Salesforce.  AUTOMATIC  The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers from Salesforce. If your flow transfers fewer than 1,000,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900,000 records, and it might use Bulk API 2.0 on the next day to transfer 1,100,000 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output.  BULKV2  Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields.  REST_SYNC  Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail wituh a timed out error.
        public let dataTransferApi: SalesforceDataTransferApi?
        ///  The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public let enableDynamicFieldUpdate: Bool?
        ///  Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public let includeDeletedRecords: Bool?
        ///  The object specified in the Salesforce flow source.
        public let object: String

        @inlinable
        public init(dataTransferApi: SalesforceDataTransferApi? = nil, enableDynamicFieldUpdate: Bool? = nil, includeDeletedRecords: Bool? = nil, object: String) {
            self.dataTransferApi = dataTransferApi
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataTransferApi = "dataTransferApi"
            case enableDynamicFieldUpdate = "enableDynamicFieldUpdate"
            case includeDeletedRecords = "includeDeletedRecords"
            case object = "object"
        }
    }

    public struct ScheduledTriggerProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public let dataPullMode: DataPullMode?
        ///  Specifies the date range for the records to import from the connector in the first flow run.
        public let firstExecutionFrom: Date?
        /// Defines how many times a scheduled flow fails consecutively before Amazon AppFlow deactivates it.
        public let flowErrorDeactivationThreshold: Int?
        /// The time at which the scheduled flow ends. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-27T13:00:00-07:00.
        public let scheduleEndTime: Date?
        ///  The scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
        public let scheduleExpression: String
        ///  Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public let scheduleOffset: Int64?
        /// The time at which the scheduled flow starts. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-26T13:00:00-07:00.
        public let scheduleStartTime: Date?
        /// Specifies the time zone used when referring to the dates and times of a scheduled flow, such as America/New_York. This time zone is only a descriptive label. It doesn't affect how Amazon AppFlow interprets the timestamps that you specify to schedule the flow. If you want to schedule a flow by using times in a particular time zone, indicate the time zone as a UTC offset in your timestamps. For example, the UTC offsets for the America/New_York timezone are -04:00 EDT and -05:00 EST.
        public let timezone: String?

        @inlinable
        public init(dataPullMode: DataPullMode? = nil, firstExecutionFrom: Date? = nil, flowErrorDeactivationThreshold: Int? = nil, scheduleEndTime: Date? = nil, scheduleExpression: String, scheduleOffset: Int64? = nil, scheduleStartTime: Date? = nil, timezone: String? = nil) {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.flowErrorDeactivationThreshold = flowErrorDeactivationThreshold
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.flowErrorDeactivationThreshold, name: "flowErrorDeactivationThreshold", parent: name, max: 100)
            try self.validate(self.flowErrorDeactivationThreshold, name: "flowErrorDeactivationThreshold", parent: name, min: 1)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: ".*")
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, max: 36000)
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, min: 0)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 256)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullMode = "dataPullMode"
            case firstExecutionFrom = "firstExecutionFrom"
            case flowErrorDeactivationThreshold = "flowErrorDeactivationThreshold"
            case scheduleEndTime = "scheduleEndTime"
            case scheduleExpression = "scheduleExpression"
            case scheduleOffset = "scheduleOffset"
            case scheduleStartTime = "scheduleStartTime"
            case timezone = "timezone"
        }
    }

    public struct ServiceNowConnectorProfileCredentials: AWSEncodableShape {
        ///  The OAuth 2.0 credentials required to authenticate the user.
        public let oAuth2Credentials: OAuth2Credentials?
        ///  The password that corresponds to the user name.
        public let password: String?
        ///  The name of the user.
        public let username: String?

        @inlinable
        public init(oAuth2Credentials: OAuth2Credentials? = nil, password: String? = nil, username: String? = nil) {
            self.oAuth2Credentials = oAuth2Credentials
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.oAuth2Credentials?.validate(name: "\(name).oAuth2Credentials")
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case oAuth2Credentials = "oAuth2Credentials"
            case password = "password"
            case username = "username"
        }
    }

    public struct ServiceNowConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the ServiceNow resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct ServiceNowMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceNowSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the ServiceNow flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SingularConnectorProfileCredentials: AWSEncodableShape {
        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        public let apiKey: String

        @inlinable
        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 256)
            try self.validate(self.apiKey, name: "apiKey", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct SingularConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct SingularMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct SingularSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Singular flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SlackConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Slack resources.
        public let accessToken: String?
        ///  The identifier for the client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        @inlinable
        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct SlackConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Slack resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct SlackMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Slack account.
        public let oAuthScopes: [String]?

        @inlinable
        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct SlackSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Slack flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SnowflakeConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        @inlinable
        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct SnowflakeConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the account.
        public let accountName: String?
        ///  The name of the Amazon S3 bucket associated with Snowflake.
        public let bucketName: String
        ///  The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        public let bucketPrefix: String?
        ///  The Snowflake Private Link service name to be used for private data transfers.
        public let privateLinkServiceName: String?
        ///  The Amazon Web Services Region of the Snowflake account.
        public let region: String?
        ///  The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: .
        public let stage: String
        ///  The name of the Snowflake warehouse.
        public let warehouse: String

        @inlinable
        public init(accountName: String? = nil, bucketName: String, bucketPrefix: String? = nil, privateLinkServiceName: String? = nil, region: String? = nil, stage: String, warehouse: String) {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try self.validate(self.accountName, name: "accountName", parent: name, max: 512)
            try self.validate(self.accountName, name: "accountName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, max: 512)
            try self.validate(self.privateLinkServiceName, name: "privateLinkServiceName", parent: name, pattern: "^$|com.amazonaws.vpce.[\\w/!:@#.\\-]+$")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, pattern: "^\\S+$")
            try self.validate(self.stage, name: "stage", parent: name, max: 512)
            try self.validate(self.stage, name: "stage", parent: name, pattern: "^\\S+$")
            try self.validate(self.warehouse, name: "warehouse", parent: name, max: 512)
            try self.validate(self.warehouse, name: "warehouse", parent: name, pattern: "^[\\s\\w/!@#+=.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "accountName"
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case privateLinkServiceName = "privateLinkServiceName"
            case region = "region"
            case stage = "stage"
            case warehouse = "warehouse"
        }
    }

    public struct SnowflakeDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object key for the destination bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        public let intermediateBucketName: String
        ///  The object specified in the Snowflake flow destination.
        public let object: String

        @inlinable
        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, max: 63)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, min: 3)
            try self.validate(self.intermediateBucketName, name: "intermediateBucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix = "bucketPrefix"
            case errorHandlingConfig = "errorHandlingConfig"
            case intermediateBucketName = "intermediateBucketName"
            case object = "object"
        }
    }

    public struct SnowflakeMetadata: AWSDecodableShape {
        ///  Specifies the supported Amazon Web Services Regions when using Snowflake.
        public let supportedRegions: [String]?

        @inlinable
        public init(supportedRegions: [String]? = nil) {
            self.supportedRegions = supportedRegions
        }

        private enum CodingKeys: String, CodingKey {
            case supportedRegions = "supportedRegions"
        }
    }

    public struct SourceConnectorProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the information that is required for querying Amplitude.
        public let amplitude: AmplitudeSourceProperties?
        public let customConnector: CustomConnectorSourceProperties?
        ///  Specifies the information that is required for querying Datadog.
        public let datadog: DatadogSourceProperties?
        ///  Specifies the information that is required for querying Dynatrace.
        public let dynatrace: DynatraceSourceProperties?
        ///  Specifies the information that is required for querying Google Analytics.
        public let googleAnalytics: GoogleAnalyticsSourceProperties?
        ///  Specifies the information that is required for querying Infor Nexus.
        public let inforNexus: InforNexusSourceProperties?
        ///  Specifies the information that is required for querying Marketo.
        public let marketo: MarketoSourceProperties?
        /// Specifies the information that is required for querying Salesforce Pardot.
        public let pardot: PardotSourceProperties?
        ///  Specifies the information that is required for querying Amazon S3.
        public let s3: S3SourceProperties?
        ///  Specifies the information that is required for querying Salesforce.
        public let salesforce: SalesforceSourceProperties?
        public let sapoData: SAPODataSourceProperties?
        ///  Specifies the information that is required for querying ServiceNow.
        public let serviceNow: ServiceNowSourceProperties?
        ///  Specifies the information that is required for querying Singular.
        public let singular: SingularSourceProperties?
        ///  Specifies the information that is required for querying Slack.
        public let slack: SlackSourceProperties?
        ///  Specifies the information that is required for querying Trend Micro.
        public let trendmicro: TrendmicroSourceProperties?
        ///  Specifies the information that is required for querying Veeva.
        public let veeva: VeevaSourceProperties?
        ///  Specifies the information that is required for querying Zendesk.
        public let zendesk: ZendeskSourceProperties?

        @inlinable
        public init(amplitude: AmplitudeSourceProperties? = nil, customConnector: CustomConnectorSourceProperties? = nil, datadog: DatadogSourceProperties? = nil, dynatrace: DynatraceSourceProperties? = nil, googleAnalytics: GoogleAnalyticsSourceProperties? = nil, inforNexus: InforNexusSourceProperties? = nil, marketo: MarketoSourceProperties? = nil, pardot: PardotSourceProperties? = nil, s3: S3SourceProperties? = nil, salesforce: SalesforceSourceProperties? = nil, sapoData: SAPODataSourceProperties? = nil, serviceNow: ServiceNowSourceProperties? = nil, singular: SingularSourceProperties? = nil, slack: SlackSourceProperties? = nil, trendmicro: TrendmicroSourceProperties? = nil, veeva: VeevaSourceProperties? = nil, zendesk: ZendeskSourceProperties? = nil) {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.customConnector?.validate(name: "\(name).customConnector")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.pardot?.validate(name: "\(name).pardot")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.sapoData?.validate(name: "\(name).sapoData")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case customConnector = "CustomConnector"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case pardot = "Pardot"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case sapoData = "SAPOData"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct SourceFieldProperties: AWSDecodableShape {
        ///  Indicates if the field can be queried.
        public let isQueryable: Bool?
        ///  Indicates whether the field can be returned in a search result.
        public let isRetrievable: Bool?
        /// Indicates if this timestamp field can be used for incremental queries.
        public let isTimestampFieldForIncrementalQueries: Bool?

        @inlinable
        public init(isQueryable: Bool? = nil, isRetrievable: Bool? = nil, isTimestampFieldForIncrementalQueries: Bool? = nil) {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
            self.isTimestampFieldForIncrementalQueries = isTimestampFieldForIncrementalQueries
        }

        private enum CodingKeys: String, CodingKey {
            case isQueryable = "isQueryable"
            case isRetrievable = "isRetrievable"
            case isTimestampFieldForIncrementalQueries = "isTimestampFieldForIncrementalQueries"
        }
    }

    public struct SourceFlowConfig: AWSEncodableShape & AWSDecodableShape {
        /// The API version of the connector when it's used as a source in the flow.
        public let apiVersion: String?
        ///  The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on.
        public let connectorType: ConnectorType
        ///  Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public let incrementalPullConfig: IncrementalPullConfig?
        ///  Specifies the information that is required to query a particular source connector.
        public let sourceConnectorProperties: SourceConnectorProperties

        @inlinable
        public init(apiVersion: String? = nil, connectorProfileName: String? = nil, connectorType: ConnectorType, incrementalPullConfig: IncrementalPullConfig? = nil, sourceConnectorProperties: SourceConnectorProperties) {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, max: 256)
            try self.validate(self.apiVersion, name: "apiVersion", parent: name, pattern: "^\\S+$")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.incrementalPullConfig?.validate(name: "\(name).incrementalPullConfig")
            try self.sourceConnectorProperties.validate(name: "\(name).sourceConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case apiVersion = "apiVersion"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case incrementalPullConfig = "incrementalPullConfig"
            case sourceConnectorProperties = "sourceConnectorProperties"
        }
    }

    public struct StartFlowRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your StartFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs for flows that run on a schedule or based on an event. However, the error doesn't occur for flows that run on demand. You set the conditions that initiate your flow for the triggerConfig parameter. If you use a different value for clientToken, Amazon AppFlow considers it a new call to StartFlow. The token is active for 8 hours.
        public let clientToken: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        @inlinable
        public init(clientToken: String? = StartFlowRequest.idempotencyToken(), flowName: String) {
            self.clientToken = clientToken
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case flowName = "flowName"
        }
    }

    public struct StartFlowResponse: AWSDecodableShape {
        ///  Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
        public let executionId: String?
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        @inlinable
        public init(executionId: String? = nil, flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.executionId = executionId
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct StopFlowRequest: AWSEncodableShape {
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String

        @inlinable
        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
        }
    }

    public struct StopFlowResponse: AWSDecodableShape {
        ///  The flow's Amazon Resource Name (ARN).
        public let flowArn: String?
        ///  Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        @inlinable
        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct SuccessResponseHandlingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket.
        public let bucketName: String?
        /// The Amazon S3 bucket prefix.
        public let bucketPrefix: String?

        @inlinable
        public init(bucketName: String? = nil, bucketPrefix: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
        }
    }

    public struct SupportedFieldTypeDetails: AWSDecodableShape {
        ///  The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced.
        public let v1: FieldTypeDetails

        @inlinable
        public init(v1: FieldTypeDetails) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the flow that you want to tag.
        public let resourceArn: String
        ///  The tags used to organize, track, or control access for your flow.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:.*:.*:[0-9]+:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Task: AWSEncodableShape & AWSDecodableShape {
        ///  The operation to be performed on the provided source fields.
        public let connectorOperator: ConnectorOperator?
        ///  A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public let destinationField: String?
        ///  The source fields to which a particular task is applied.
        public let sourceFields: [String]
        ///  A map used to store task-related information. The execution service looks for particular information based on the TaskType.
        public let taskProperties: [OperatorPropertiesKeys: String]?
        ///  Specifies the particular task implementation that Amazon AppFlow performs.
        public let taskType: TaskType

        @inlinable
        public init(connectorOperator: ConnectorOperator? = nil, destinationField: String? = nil, sourceFields: [String], taskProperties: [OperatorPropertiesKeys: String]? = nil, taskType: TaskType) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationField, name: "destinationField", parent: name, max: 256)
            try self.validate(self.destinationField, name: "destinationField", parent: name, pattern: ".*")
            try self.sourceFields.forEach {
                try validate($0, name: "sourceFields[]", parent: name, max: 2048)
                try validate($0, name: "sourceFields[]", parent: name, pattern: ".*")
            }
            try self.taskProperties?.forEach {
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, pattern: "^.+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectorOperator = "connectorOperator"
            case destinationField = "destinationField"
            case sourceFields = "sourceFields"
            case taskProperties = "taskProperties"
            case taskType = "taskType"
        }
    }

    public struct TrendmicroConnectorProfileCredentials: AWSEncodableShape {
        ///  The Secret Access Key portion of the credentials.
        public let apiSecretKey: String

        @inlinable
        public init(apiSecretKey: String) {
            self.apiSecretKey = apiSecretKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, max: 256)
            try self.validate(self.apiSecretKey, name: "apiSecretKey", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiSecretKey = "apiSecretKey"
        }
    }

    public struct TrendmicroConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct TrendmicroMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct TrendmicroSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Trend Micro flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct TriggerConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
        public let triggerProperties: TriggerProperties?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public let triggerType: TriggerType

        @inlinable
        public init(triggerProperties: TriggerProperties? = nil, triggerType: TriggerType) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }

        public func validate(name: String) throws {
            try self.triggerProperties?.validate(name: "\(name).triggerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case triggerProperties = "triggerProperties"
            case triggerType = "triggerType"
        }
    }

    public struct TriggerProperties: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user.
        public let scheduled: ScheduledTriggerProperties?

        @inlinable
        public init(scheduled: ScheduledTriggerProperties? = nil) {
            self.scheduled = scheduled
        }

        public func validate(name: String) throws {
            try self.scheduled?.validate(name: "\(name).scheduled")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduled = "Scheduled"
        }
    }

    public struct UnregisterConnectorRequest: AWSEncodableShape {
        /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account.
        public let connectorLabel: String
        /// Indicates whether Amazon AppFlow should unregister the connector, even if it is currently in use in one or more connector profiles. The default value is false.
        public let forceDelete: Bool?

        @inlinable
        public init(connectorLabel: String, forceDelete: Bool? = nil) {
            self.connectorLabel = connectorLabel
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorLabel = "connectorLabel"
            case forceDelete = "forceDelete"
        }
    }

    public struct UnregisterConnectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the flow that you want to untag.
        public let resourceArn: String
        ///  The tag keys associated with the tag that you want to remove from your flow.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:.*:.*:[0-9]+:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectorProfileRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorProfile. The token is active for 8 hours.
        public let clientToken: String?
        ///  Indicates the connection mode and if it is public or private.
        public let connectionMode: ConnectionMode
        ///  Defines the connector-specific profile configuration and credentials.
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile and is unique for each ConnectorProfile in the Amazon Web Services account.
        public let connectorProfileName: String

        @inlinable
        public init(clientToken: String? = UpdateConnectorProfileRequest.idempotencyToken(), connectionMode: ConnectionMode, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String) {
            self.clientToken = clientToken
            self.connectionMode = connectionMode
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case connectionMode = "connectionMode"
            case connectorProfileConfig = "connectorProfileConfig"
            case connectorProfileName = "connectorProfileName"
        }
    }

    public struct UpdateConnectorProfileResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the connector profile.
        public let connectorProfileArn: String?

        @inlinable
        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn = "connectorProfileArn"
        }
    }

    public struct UpdateConnectorRegistrationRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorRegistration request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorRegistration. The token is active for 8 hours.
        public let clientToken: String?
        /// The name of the connector. The name is unique for each connector registration in your AWS account.
        public let connectorLabel: String
        public let connectorProvisioningConfig: ConnectorProvisioningConfig?
        /// A description about the update that you're applying to the connector.
        public let description: String?

        @inlinable
        public init(clientToken: String? = UpdateConnectorRegistrationRequest.idempotencyToken(), connectorLabel: String, connectorProvisioningConfig: ConnectorProvisioningConfig? = nil, description: String? = nil) {
            self.clientToken = clientToken
            self.connectorLabel = connectorLabel
            self.connectorProvisioningConfig = connectorProvisioningConfig
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, max: 256)
            try self.validate(self.connectorLabel, name: "connectorLabel", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.connectorProvisioningConfig?.validate(name: "\(name).connectorProvisioningConfig")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\w/!@#+=.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case connectorLabel = "connectorLabel"
            case connectorProvisioningConfig = "connectorProvisioningConfig"
            case description = "description"
        }
    }

    public struct UpdateConnectorRegistrationResponse: AWSDecodableShape {
        /// The ARN of the connector being updated.
        public let connectorArn: String?

        @inlinable
        public init(connectorArn: String? = nil) {
            self.connectorArn = connectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
        }
    }

    public struct UpdateFlowRequest: AWSEncodableShape {
        /// The clientToken parameter is an idempotency token. It ensures that your UpdateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateFlow. The token is active for 8 hours.
        public let clientToken: String?
        ///  A description of the flow.
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector.
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public let flowName: String
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
        public let metadataCatalogConfig: MetadataCatalogConfig?
        public let sourceFlowConfig: SourceFlowConfig
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig

        @inlinable
        public init(clientToken: String? = UpdateFlowRequest.idempotencyToken(), description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, metadataCatalogConfig: MetadataCatalogConfig? = nil, sourceFlowConfig: SourceFlowConfig, tasks: [Task], triggerConfig: TriggerConfig) {
            self.clientToken = clientToken
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.metadataCatalogConfig = metadataCatalogConfig
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w!@#\\-.?,\\s]*$")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.metadataCatalogConfig?.validate(name: "\(name).metadataCatalogConfig")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowName = "flowName"
            case metadataCatalogConfig = "metadataCatalogConfig"
            case sourceFlowConfig = "sourceFlowConfig"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct UpdateFlowResponse: AWSDecodableShape {
        /// Indicates the current status of the flow.
        public let flowStatus: FlowStatus?

        @inlinable
        public init(flowStatus: FlowStatus? = nil) {
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowStatus = "flowStatus"
        }
    }

    public struct UpsolverDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        public let bucketName: String
        ///  The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        public let bucketPrefix: String?
        ///  The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        public let s3OutputFormatConfig: UpsolverS3OutputFormatConfig

        @inlinable
        public init(bucketName: String, bucketPrefix: String? = nil, s3OutputFormatConfig: UpsolverS3OutputFormatConfig) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 16)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^(upsolver-appflow)\\S*$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case s3OutputFormatConfig = "s3OutputFormatConfig"
        }
    }

    public struct UpsolverMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct UpsolverS3OutputFormatConfig: AWSEncodableShape & AWSDecodableShape {
        public let aggregationConfig: AggregationConfig?
        ///  Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        public let fileType: FileType?
        public let prefixConfig: PrefixConfig

        @inlinable
        public init(aggregationConfig: AggregationConfig? = nil, fileType: FileType? = nil, prefixConfig: PrefixConfig) {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationConfig = "aggregationConfig"
            case fileType = "fileType"
            case prefixConfig = "prefixConfig"
        }
    }

    public struct VeevaConnectorProfileCredentials: AWSEncodableShape {
        ///  The password that corresponds to the user name.
        public let password: String
        ///  The name of the user.
        public let username: String

        @inlinable
        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct VeevaConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Veeva resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct VeevaMetadata: AWSDecodableShape {
        public init() {}
    }

    public struct VeevaSourceProperties: AWSEncodableShape & AWSDecodableShape {
        /// The document type specified in the Veeva document extract flow.
        public let documentType: String?
        /// Boolean value to include All Versions of files in Veeva document extract flow.
        public let includeAllVersions: Bool?
        /// Boolean value to include file renditions in Veeva document extract flow.
        public let includeRenditions: Bool?
        /// Boolean value to include source files in Veeva document extract flow.
        public let includeSourceFiles: Bool?
        ///  The object specified in the Veeva flow source.
        public let object: String

        @inlinable
        public init(documentType: String? = nil, includeAllVersions: Bool? = nil, includeRenditions: Bool? = nil, includeSourceFiles: Bool? = nil, object: String) {
            self.documentType = documentType
            self.includeAllVersions = includeAllVersions
            self.includeRenditions = includeRenditions
            self.includeSourceFiles = includeSourceFiles
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.documentType, name: "documentType", parent: name, max: 512)
            try self.validate(self.documentType, name: "documentType", parent: name, pattern: "^[\\s\\w_-]+$")
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentType = "documentType"
            case includeAllVersions = "includeAllVersions"
            case includeRenditions = "includeRenditions"
            case includeSourceFiles = "includeSourceFiles"
            case object = "object"
        }
    }

    public struct ZendeskConnectorProfileCredentials: AWSEncodableShape {
        ///  The credentials used to access protected Zendesk resources.
        public let accessToken: String?
        ///  The identifier for the desired client.
        public let clientId: String
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        public let clientSecret: String
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        public let oAuthRequest: ConnectorOAuthRequest?

        @inlinable
        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientId, name: "clientId", parent: name, max: 512)
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 512)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, pattern: "^\\S+$")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct ZendeskConnectorProfileProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The location of the Zendesk resource.
        public let instanceUrl: String

        @inlinable
        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, max: 256)
            try self.validate(self.instanceUrl, name: "instanceUrl", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct ZendeskDestinationProperties: AWSEncodableShape & AWSDecodableShape {
        public let errorHandlingConfig: ErrorHandlingConfig?
        public let idFieldNames: [String]?
        /// The object specified in the Zendesk flow destination.
        public let object: String
        public let writeOperationType: WriteOperationType?

        @inlinable
        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, idFieldNames: [String]? = nil, object: String, writeOperationType: WriteOperationType? = nil) {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try self.idFieldNames?.forEach {
                try validate($0, name: "idFieldNames[]", parent: name, max: 128)
                try validate($0, name: "idFieldNames[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case idFieldNames = "idFieldNames"
            case object = "object"
            case writeOperationType = "writeOperationType"
        }
    }

    public struct ZendeskMetadata: AWSDecodableShape {
        ///  The desired authorization scope for the Zendesk account.
        public let oAuthScopes: [String]?

        @inlinable
        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct ZendeskSourceProperties: AWSEncodableShape & AWSDecodableShape {
        ///  The object specified in the Zendesk flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }
}

// MARK: - Errors

/// Error enum for Appflow
public struct AppflowErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case connectorAuthenticationException = "ConnectorAuthenticationException"
        case connectorServerException = "ConnectorServerException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unsupportedOperationException = "UnsupportedOperationException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Appflow
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// AppFlow/Requester has invalid or missing permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
    public static var conflictException: Self { .init(.conflictException) }
    ///  An error occurred when authenticating with the connector endpoint.
    public static var connectorAuthenticationException: Self { .init(.connectorAuthenticationException) }
    ///  An error occurred when retrieving data from the connector endpoint.
    public static var connectorServerException: Self { .init(.connectorServerException) }
    ///  An internal service error occurred during the processing of your request. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The resource specified in the request (such as the source or destination connector profile) is not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The request would cause a service quota (such as the number of flows) to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// API calls have exceeded the maximum allowed API request rate per account and per Region.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The requested operation is not supported for the current flow.
    public static var unsupportedOperationException: Self { .init(.unsupportedOperationException) }
    ///  The request has invalid or missing parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension AppflowErrorType: Equatable {
    public static func == (lhs: AppflowErrorType, rhs: AppflowErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppflowErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
