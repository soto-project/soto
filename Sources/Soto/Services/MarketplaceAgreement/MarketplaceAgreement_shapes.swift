//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MarketplaceAgreement {
    // MARK: Enums

    public enum AgreementStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case cancelled = "CANCELLED"
        case expired = "EXPIRED"
        case renewed = "RENEWED"
        case replaced = "REPLACED"
        case rolledBack = "ROLLED_BACK"
        case superseded = "SUPERSEDED"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agreement = "Agreement"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalidAgreementId = "INVALID_AGREEMENT_ID"
        case invalidCatalog = "INVALID_CATALOG"
        case invalidFilterName = "INVALID_FILTER_NAME"
        case invalidFilterValues = "INVALID_FILTER_VALUES"
        case invalidMaxResults = "INVALID_MAX_RESULTS"
        case invalidNextToken = "INVALID_NEXT_TOKEN"
        case invalidSortBy = "INVALID_SORT_BY"
        case invalidSortOrder = "INVALID_SORT_ORDER"
        case missingAgreementId = "MISSING_AGREEMENT_ID"
        case other = "OTHER"
        case unsupportedFilters = "UNSUPPORTED_FILTERS"
        public var description: String { return self.rawValue }
    }

    public enum AcceptedTerm: AWSDecodableShape, Sendable {
        /// Enables you and your customers to move your existing agreements to AWS Marketplace. The customer won't be charged for product usage in AWS Marketplace because they already paid for the product outside of AWS Marketplace.
        case byolPricingTerm(ByolPricingTerm)
        /// Defines a prepaid payment model that allows buyers to configure the entitlements they want to purchase and the duration.
        case configurableUpfrontPricingTerm(ConfigurableUpfrontPricingTerm)
        /// Defines a pre-paid pricing model where the customers are charged a fixed upfront amount.
        case fixedUpfrontPricingTerm(FixedUpfrontPricingTerm)
        /// Defines a short-term free pricing model where the buyers aren’t charged anything within a specified limit.
        case freeTrialPricingTerm(FreeTrialPricingTerm)
        /// Defines the list of text agreements proposed to the acceptors. An example is the end user license agreement (EULA).
        case legalTerm(LegalTerm)
        /// Defines an installment-based pricing model where customers are charged a fixed price on different dates during the agreement validity period. This is used most commonly for flexible payment schedule pricing.
        case paymentScheduleTerm(PaymentScheduleTerm)
        /// Defines a pricing model where customers are charged a fixed recurring price at the end of each billing period.
        case recurringPaymentTerm(RecurringPaymentTerm)
        /// Defines that on graceful expiration of the agreement (when the agreement ends on its pre-defined end date), a new agreement will be created using the accepted terms on the existing agreement. In other words, the agreement will be renewed. Presence of RenewalTerm in the offer document means that auto-renewal is allowed. Buyers will have the option to accept or decline auto-renewal at the offer acceptance/agreement creation. Buyers can also change this flag from True to False or False to True at anytime during the agreement's lifecycle.
        case renewalTerm(RenewalTerm)
        /// Defines the customer support available for the acceptors when they purchase the software.
        case supportTerm(SupportTerm)
        /// Defines a usage-based pricing model (typically, pay-as-you-go pricing), where the customers are charged based on product usage.
        case usageBasedPricingTerm(UsageBasedPricingTerm)
        /// Defines the conditions that will keep an agreement created from this offer valid.
        case validityTerm(ValidityTerm)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .byolPricingTerm:
                let value = try container.decode(ByolPricingTerm.self, forKey: .byolPricingTerm)
                self = .byolPricingTerm(value)
            case .configurableUpfrontPricingTerm:
                let value = try container.decode(ConfigurableUpfrontPricingTerm.self, forKey: .configurableUpfrontPricingTerm)
                self = .configurableUpfrontPricingTerm(value)
            case .fixedUpfrontPricingTerm:
                let value = try container.decode(FixedUpfrontPricingTerm.self, forKey: .fixedUpfrontPricingTerm)
                self = .fixedUpfrontPricingTerm(value)
            case .freeTrialPricingTerm:
                let value = try container.decode(FreeTrialPricingTerm.self, forKey: .freeTrialPricingTerm)
                self = .freeTrialPricingTerm(value)
            case .legalTerm:
                let value = try container.decode(LegalTerm.self, forKey: .legalTerm)
                self = .legalTerm(value)
            case .paymentScheduleTerm:
                let value = try container.decode(PaymentScheduleTerm.self, forKey: .paymentScheduleTerm)
                self = .paymentScheduleTerm(value)
            case .recurringPaymentTerm:
                let value = try container.decode(RecurringPaymentTerm.self, forKey: .recurringPaymentTerm)
                self = .recurringPaymentTerm(value)
            case .renewalTerm:
                let value = try container.decode(RenewalTerm.self, forKey: .renewalTerm)
                self = .renewalTerm(value)
            case .supportTerm:
                let value = try container.decode(SupportTerm.self, forKey: .supportTerm)
                self = .supportTerm(value)
            case .usageBasedPricingTerm:
                let value = try container.decode(UsageBasedPricingTerm.self, forKey: .usageBasedPricingTerm)
                self = .usageBasedPricingTerm(value)
            case .validityTerm:
                let value = try container.decode(ValidityTerm.self, forKey: .validityTerm)
                self = .validityTerm(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case byolPricingTerm = "byolPricingTerm"
            case configurableUpfrontPricingTerm = "configurableUpfrontPricingTerm"
            case fixedUpfrontPricingTerm = "fixedUpfrontPricingTerm"
            case freeTrialPricingTerm = "freeTrialPricingTerm"
            case legalTerm = "legalTerm"
            case paymentScheduleTerm = "paymentScheduleTerm"
            case recurringPaymentTerm = "recurringPaymentTerm"
            case renewalTerm = "renewalTerm"
            case supportTerm = "supportTerm"
            case usageBasedPricingTerm = "usageBasedPricingTerm"
            case validityTerm = "validityTerm"
        }
    }

    // MARK: Shapes

    public struct Acceptor: AWSDecodableShape {
        /// The AWS account ID of the acceptor.
        public let accountId: String?

        @inlinable
        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String?
        /// The unique identifier for the error.
        public let requestId: String?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil) {
            self.message = message
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case requestId = "requestId"
        }
    }

    public struct AgreementViewSummary: AWSDecodableShape {
        /// The date and time that the agreement was accepted.
        public let acceptanceTime: Date?
        /// Details of the party accepting the agreement terms. This is commonly the buyer for PurchaseAgreement.
        public let acceptor: Acceptor?
        /// The unique identifier of the agreement.
        public let agreementId: String?
        /// The type of agreement. Values are PurchaseAgreement or VendorInsightsAgreement.
        public let agreementType: String?
        /// The date and time when the agreement ends. The field is null for pay-as-you-go agreements, which don’t have end dates.
        public let endTime: Date?
        /// A summary of the proposal
        public let proposalSummary: ProposalSummary?
        /// Details of the party proposing the agreement terms, most commonly the seller for PurchaseAgreement.
        public let proposer: Proposer?
        /// The date and time when the agreement starts.
        public let startTime: Date?
        /// The current status of the agreement.
        public let status: AgreementStatus?

        @inlinable
        public init(acceptanceTime: Date? = nil, acceptor: Acceptor? = nil, agreementId: String? = nil, agreementType: String? = nil, endTime: Date? = nil, proposalSummary: ProposalSummary? = nil, proposer: Proposer? = nil, startTime: Date? = nil, status: AgreementStatus? = nil) {
            self.acceptanceTime = acceptanceTime
            self.acceptor = acceptor
            self.agreementId = agreementId
            self.agreementType = agreementType
            self.endTime = endTime
            self.proposalSummary = proposalSummary
            self.proposer = proposer
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceTime = "acceptanceTime"
            case acceptor = "acceptor"
            case agreementId = "agreementId"
            case agreementType = "agreementType"
            case endTime = "endTime"
            case proposalSummary = "proposalSummary"
            case proposer = "proposer"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct ByolPricingTerm: AWSDecodableShape {
        /// Type of the term being updated.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ConfigurableUpfrontPricingTerm: AWSDecodableShape {
        /// Additional parameters specified by the acceptor while accepting the term.
        public let configuration: ConfigurableUpfrontPricingTermConfiguration?
        /// Defines the currency for the prices mentioned in the term.
        public let currencyCode: String?
        /// A rate card defines the per unit rates for product dimensions.
        public let rateCards: [ConfigurableUpfrontRateCardItem]?
        /// Category of selector.
        public let type: String?

        @inlinable
        public init(configuration: ConfigurableUpfrontPricingTermConfiguration? = nil, currencyCode: String? = nil, rateCards: [ConfigurableUpfrontRateCardItem]? = nil, type: String? = nil) {
            self.configuration = configuration
            self.currencyCode = currencyCode
            self.rateCards = rateCards
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case currencyCode = "currencyCode"
            case rateCards = "rateCards"
            case type = "type"
        }
    }

    public struct ConfigurableUpfrontPricingTermConfiguration: AWSDecodableShape {
        /// Defines the dimensions that the acceptor has purchased from the overall set of dimensions presented in the rate card.
        public let dimensions: [Dimension]
        /// Defines the length of time for which the particular pricing/dimension is being purchased by the acceptor.
        public let selectorValue: String

        @inlinable
        public init(dimensions: [Dimension], selectorValue: String) {
            self.dimensions = dimensions
            self.selectorValue = selectorValue
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "dimensions"
            case selectorValue = "selectorValue"
        }
    }

    public struct ConfigurableUpfrontRateCardItem: AWSDecodableShape {
        /// Defines limits on how the term can be configured by acceptors.
        public let constraints: Constraints?
        /// Defines the per unit rates for product dimensions.
        public let rateCard: [RateCardItem]?
        /// Differentiates between the mutually exclusive rate cards in the same pricing term to be selected by the buyer.
        public let selector: Selector?

        @inlinable
        public init(constraints: Constraints? = nil, rateCard: [RateCardItem]? = nil, selector: Selector? = nil) {
            self.constraints = constraints
            self.rateCard = rateCard
            self.selector = selector
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "constraints"
            case rateCard = "rateCard"
            case selector = "selector"
        }
    }

    public struct Constraints: AWSDecodableShape {
        /// Determines if buyers are allowed to select multiple dimensions in the rate card. The possible values are Allowed and Disallowed. The default value is Allowed.
        public let multipleDimensionSelection: String?
        /// Determines if acceptors are allowed to configure quantity for each dimension in rate card. The possible values are Allowed and Disallowed. The default value is Allowed.
        public let quantityConfiguration: String?

        @inlinable
        public init(multipleDimensionSelection: String? = nil, quantityConfiguration: String? = nil) {
            self.multipleDimensionSelection = multipleDimensionSelection
            self.quantityConfiguration = quantityConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case multipleDimensionSelection = "multipleDimensionSelection"
            case quantityConfiguration = "quantityConfiguration"
        }
    }

    public struct DescribeAgreementInput: AWSEncodableShape {
        /// The unique identifier of the agreement.
        public let agreementId: String

        @inlinable
        public init(agreementId: String) {
            self.agreementId = agreementId
        }

        public func validate(name: String) throws {
            try self.validate(self.agreementId, name: "agreementId", parent: name, max: 64)
            try self.validate(self.agreementId, name: "agreementId", parent: name, min: 1)
            try self.validate(self.agreementId, name: "agreementId", parent: name, pattern: "^[A-Za-z0-9_/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agreementId = "agreementId"
        }
    }

    public struct DescribeAgreementOutput: AWSDecodableShape {
        /// The date and time the offer was accepted or the agreement was created.   AcceptanceTime and StartTime can differ for future dated agreements (FDAs).
        public let acceptanceTime: Date?
        /// The details of the party accepting the agreement terms. This is commonly the buyer for PurchaseAgreement.
        public let acceptor: Acceptor?
        /// The unique identifier of the agreement.
        public let agreementId: String?
        /// The type of agreement. Values are PurchaseAgreement or VendorInsightsAgreement.
        public let agreementType: String?
        /// The date and time when the agreement ends. The field is null for pay-as-you-go agreements, which don’t have end dates.
        public let endTime: Date?
        /// The estimated cost of the agreement.
        public let estimatedCharges: EstimatedCharges?
        /// A summary of the proposal received from the proposer.
        public let proposalSummary: ProposalSummary?
        /// The details of the party proposing the agreement terms. This is commonly the seller for PurchaseAgreement.
        public let proposer: Proposer?
        /// The date and time when the agreement starts.
        public let startTime: Date?
        /// The current status of the agreement. Statuses include:    ACTIVE – The terms of the agreement are active.    ARCHIVED – The agreement ended without a specified reason.    CANCELLED – The acceptor ended the agreement before the defined end date.    EXPIRED – The agreement ended on the defined end date.    RENEWED – The agreement was renewed into a new agreement (for example, an auto-renewal).    REPLACED – The agreement was replaced using an agreement replacement offer.    ROLLED_BACK (Only applicable to inactive agreement revisions) – The agreement revision has been rolled back because of an error. An earlier revision is now active.    SUPERCEDED (Only applicable to inactive agreement revisions) – The agreement revision is no longer active and another agreement revision is now active.    TERMINATED – The agreement ended before the defined end date because of an AWS termination (for example, a payment failure).
        public let status: AgreementStatus?

        @inlinable
        public init(acceptanceTime: Date? = nil, acceptor: Acceptor? = nil, agreementId: String? = nil, agreementType: String? = nil, endTime: Date? = nil, estimatedCharges: EstimatedCharges? = nil, proposalSummary: ProposalSummary? = nil, proposer: Proposer? = nil, startTime: Date? = nil, status: AgreementStatus? = nil) {
            self.acceptanceTime = acceptanceTime
            self.acceptor = acceptor
            self.agreementId = agreementId
            self.agreementType = agreementType
            self.endTime = endTime
            self.estimatedCharges = estimatedCharges
            self.proposalSummary = proposalSummary
            self.proposer = proposer
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceTime = "acceptanceTime"
            case acceptor = "acceptor"
            case agreementId = "agreementId"
            case agreementType = "agreementType"
            case endTime = "endTime"
            case estimatedCharges = "estimatedCharges"
            case proposalSummary = "proposalSummary"
            case proposer = "proposer"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct Dimension: AWSDecodableShape {
        /// The name of key value of the dimension.
        public let dimensionKey: String
        /// The number of units of the dimension the acceptor has purchased.  For Agreements with ConfigurableUpfrontPricingTerm, the RateCard section will define the prices and dimensions defined by the seller (proposer), whereas the Configuration section will define the actual dimensions, prices, and units the buyer has chosen to accept.
        public let dimensionValue: Int

        @inlinable
        public init(dimensionKey: String, dimensionValue: Int) {
            self.dimensionKey = dimensionKey
            self.dimensionValue = dimensionValue
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKey = "dimensionKey"
            case dimensionValue = "dimensionValue"
        }
    }

    public struct DocumentItem: AWSDecodableShape {
        /// Category of the document. Document types include:    CustomEula – A custom EULA provided by you as seller. A URL for a EULA stored in an accessible Amazon S3 bucket is required for this document type.    CustomDsa – A custom Data Subscription Agreement (DSA) provided by you as seller. A URL for a DSA stored in an accessible Amazon S3 bucket is required for this document type.    StandardEula – The Standard Contract for AWS Marketplace (SCMP). For more information about SCMP, see the AWS Marketplace Seller Guide. You don’t provide a URL for this type because it’s managed by AWS Marketplace.    StandardDsa – DSA for AWS Marketplace. For more information about the DSA, see the AWS Data Exchange User Guide. You don’t provide a URL for this type because it’s managed by AWS Marketplace.
        public let type: String?
        /// A URL to the legal document for buyers to read. Required when Type is CustomEula.
        public let url: String?
        /// Version of standard contracts provided by AWS Marketplace. Required when Type is StandardEula or StandardDsa.
        public let version: String?

        @inlinable
        public init(type: String? = nil, url: String? = nil, version: String? = nil) {
            self.type = type
            self.url = url
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case url = "url"
            case version = "version"
        }
    }

    public struct EstimatedCharges: AWSDecodableShape {
        /// The total known amount customer has to pay across the lifecycle of the agreement.  This is the total contract value if accepted terms contain ConfigurableUpfrontPricingTerm or FixedUpfrontPricingTerm. In the case of pure contract pricing, this will be the total value of the contract. In the case of contracts with consumption pricing, this will only include the committed value and not include any overages that occur. If the accepted terms contain PaymentScheduleTerm, it will be the total payment schedule amount. This occurs when flexible payment schedule is used, and is the sum of all invoice charges in the payment schedule. In case a customer has amended an agreement, by purchasing more units of any dimension, this will include both the original cost as well as the added cost incurred due to addition of new units.  This is 0 if the accepted terms contain UsageBasedPricingTerm without ConfigurableUpfrontPricingTerm or RecurringPaymentTerm. This occurs for usage-based pricing (such as SaaS metered or AMI/container hourly or monthly), because the exact usage is not known upfront.
        public let agreementValue: String?
        /// Defines the currency code for the charge.
        public let currencyCode: String?

        @inlinable
        public init(agreementValue: String? = nil, currencyCode: String? = nil) {
            self.agreementValue = agreementValue
            self.currencyCode = currencyCode
        }

        private enum CodingKeys: String, CodingKey {
            case agreementValue = "agreementValue"
            case currencyCode = "currencyCode"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter.
        public let name: String?
        /// The filter value.
        public let values: [String]?

        @inlinable
        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z_]+$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 64)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9+:_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct FixedUpfrontPricingTerm: AWSDecodableShape {
        /// Defines the currency for the prices mentioned in this term.
        public let currencyCode: String?
        /// Contract duration for the terms.
        public let duration: String?
        /// Entitlements granted to the acceptor of fixed upfront as part of agreement execution.
        public let grants: [GrantItem]?
        /// Fixed amount to be charged to the customer when this term is accepted.
        public let price: String?
        /// Category of the term being updated.
        public let type: String?

        @inlinable
        public init(currencyCode: String? = nil, duration: String? = nil, grants: [GrantItem]? = nil, price: String? = nil, type: String? = nil) {
            self.currencyCode = currencyCode
            self.duration = duration
            self.grants = grants
            self.price = price
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "currencyCode"
            case duration = "duration"
            case grants = "grants"
            case price = "price"
            case type = "type"
        }
    }

    public struct FreeTrialPricingTerm: AWSDecodableShape {
        /// Duration of the free trial period (5–31 days).
        public let duration: String?
        /// Entitlements granted to the acceptor of a free trial as part of an agreement execution.
        public let grants: [GrantItem]?
        /// Category of the term.
        public let type: String?

        @inlinable
        public init(duration: String? = nil, grants: [GrantItem]? = nil, type: String? = nil) {
            self.duration = duration
            self.grants = grants
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "duration"
            case grants = "grants"
            case type = "type"
        }
    }

    public struct GetAgreementTermsInput: AWSEncodableShape {
        /// The unique identifier of the agreement.
        public let agreementId: String
        /// The maximum number of agreements to return in the response.
        public let maxResults: Int?
        /// A token to specify where to start pagination
        public let nextToken: String?

        @inlinable
        public init(agreementId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agreementId = agreementId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.agreementId, name: "agreementId", parent: name, max: 64)
            try self.validate(self.agreementId, name: "agreementId", parent: name, min: 1)
            try self.validate(self.agreementId, name: "agreementId", parent: name, pattern: "^[A-Za-z0-9_/-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agreementId = "agreementId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetAgreementTermsOutput: AWSDecodableShape {
        /// A subset of terms proposed by the proposer that have been accepted by the acceptor as part of the agreement creation.
        public let acceptedTerms: [AcceptedTerm]?
        /// A token to specify where to start pagination
        public let nextToken: String?

        @inlinable
        public init(acceptedTerms: [AcceptedTerm]? = nil, nextToken: String? = nil) {
            self.acceptedTerms = acceptedTerms
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedTerms = "acceptedTerms"
            case nextToken = "nextToken"
        }
    }

    public struct GrantItem: AWSDecodableShape {
        /// Unique dimension key defined in the product document. Dimensions represent categories of capacity in a product and are specified when the product is listed in AWS Marketplace.
        public let dimensionKey: String?
        /// Maximum amount of capacity that the buyer can be entitled to the given dimension of the product. If MaxQuantity is not provided, the buyer will be able to use an unlimited amount of the given dimension.
        public let maxQuantity: Int?

        @inlinable
        public init(dimensionKey: String? = nil, maxQuantity: Int? = nil) {
            self.dimensionKey = dimensionKey
            self.maxQuantity = maxQuantity
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKey = "dimensionKey"
            case maxQuantity = "maxQuantity"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String?
        /// The unique identifier for the error.
        public let requestId: String?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil) {
            self.message = message
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case requestId = "requestId"
        }
    }

    public struct LegalTerm: AWSDecodableShape {
        /// List of references to legal resources proposed to the buyers. An example is the EULA.
        public let documents: [DocumentItem]?
        /// Category of the term being updated.
        public let type: String?

        @inlinable
        public init(documents: [DocumentItem]? = nil, type: String? = nil) {
            self.documents = documents
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case documents = "documents"
            case type = "type"
        }
    }

    public struct PaymentScheduleTerm: AWSDecodableShape {
        /// Defines the currency for the prices mentioned in the term.
        public let currencyCode: String?
        /// List of the payment schedule where each element defines one installment of payment. It contains the information necessary for calculating the price.
        public let schedule: [ScheduleItem]?
        /// Type of the term.
        public let type: String?

        @inlinable
        public init(currencyCode: String? = nil, schedule: [ScheduleItem]? = nil, type: String? = nil) {
            self.currencyCode = currencyCode
            self.schedule = schedule
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "currencyCode"
            case schedule = "schedule"
            case type = "type"
        }
    }

    public struct ProposalSummary: AWSDecodableShape {
        /// The unique identifier of the offer in AWS Marketplace.
        public let offerId: String?
        /// The list of resources involved in the agreement.
        public let resources: [Resource]?

        @inlinable
        public init(offerId: String? = nil, resources: [Resource]? = nil) {
            self.offerId = offerId
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case offerId = "offerId"
            case resources = "resources"
        }
    }

    public struct Proposer: AWSDecodableShape {
        /// The AWS account ID of the proposer.
        public let accountId: String?

        @inlinable
        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct RateCardItem: AWSDecodableShape {
        /// Dimension for which the given entitlement applies. Dimensions represent categories of capacity in a product and are specified when the product is listed in AWS Marketplace.
        public let dimensionKey: String?
        /// Per unit price for the product dimension that’s used for calculating the amount to be charged.
        public let price: String?

        @inlinable
        public init(dimensionKey: String? = nil, price: String? = nil) {
            self.dimensionKey = dimensionKey
            self.price = price
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKey = "dimensionKey"
            case price = "price"
        }
    }

    public struct RecurringPaymentTerm: AWSDecodableShape {
        /// Defines the recurrence at which buyers are charged.
        public let billingPeriod: String?
        /// Defines the currency for the prices mentioned in this term.
        public let currencyCode: String?
        /// Amount charged to the buyer every billing period.
        public let price: String?
        /// Type of the term being updated.
        public let type: String?

        @inlinable
        public init(billingPeriod: String? = nil, currencyCode: String? = nil, price: String? = nil, type: String? = nil) {
            self.billingPeriod = billingPeriod
            self.currencyCode = currencyCode
            self.price = price
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "billingPeriod"
            case currencyCode = "currencyCode"
            case price = "price"
            case type = "type"
        }
    }

    public struct RenewalTerm: AWSDecodableShape {
        /// Additional parameters specified by the acceptor while accepting the term.
        public let configuration: RenewalTermConfiguration?
        /// Category of the term being updated.
        public let type: String?

        @inlinable
        public init(configuration: RenewalTermConfiguration? = nil, type: String? = nil) {
            self.configuration = configuration
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case type = "type"
        }
    }

    public struct RenewalTermConfiguration: AWSDecodableShape {
        /// Defines whether the acceptor has chosen to auto-renew the agreement at the end of its lifecycle. Can be set to True or False.
        public let enableAutoRenew: Bool

        @inlinable
        public init(enableAutoRenew: Bool) {
            self.enableAutoRenew = enableAutoRenew
        }

        private enum CodingKeys: String, CodingKey {
            case enableAutoRenew = "enableAutoRenew"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The unique identifier of the resource.  We mention the term resource, which is most commonly a product, so a resourceId is also a productId.
        public let id: String?
        /// Type of the resource, which is the product. Values include SaaSProduct or AmiProduct.
        public let type: String?

        @inlinable
        public init(id: String? = nil, type: String? = nil) {
            self.id = id
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case type = "type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The unique identifier for the error.
        public let requestId: String?
        /// The unique identifier for the resource.
        public let resourceId: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.requestId = requestId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case requestId = "requestId"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ScheduleItem: AWSDecodableShape {
        /// The price that the customer would pay on the scheduled date (chargeDate).
        public let chargeAmount: String?
        /// The date that the customer would pay the price defined in this payment schedule term. Invoices are generated on the date provided.
        public let chargeDate: Date?

        @inlinable
        public init(chargeAmount: String? = nil, chargeDate: Date? = nil) {
            self.chargeAmount = chargeAmount
            self.chargeDate = chargeDate
        }

        private enum CodingKeys: String, CodingKey {
            case chargeAmount = "chargeAmount"
            case chargeDate = "chargeDate"
        }
    }

    public struct SearchAgreementsInput: AWSEncodableShape {
        /// The catalog in which the agreement was created.
        public let catalog: String?
        /// The filter name and value pair used to return a specific list of results. The following filters are supported:    ResourceIdentifier – The unique identifier of the resource.    ResourceType – Type of the resource, which is the product (AmiProduct, ContainerProduct, or SaaSProduct).    PartyType – The party type (either Acceptor or Proposer) of the caller. For agreements where the caller is the proposer, use the Proposer filter. For agreements where the caller is the acceptor, use the Acceptor filter.    AcceptorAccountId – The AWS account ID of the party accepting the agreement terms.    OfferId – The unique identifier of the offer in which the terms are registered in the agreement token.    Status – The current status of the agreement. Values include ACTIVE, ARCHIVED, CANCELLED, EXPIRED, RENEWED, REPLACED, and TERMINATED.    BeforeEndTime – A date used to filter agreements with a date before the endTime of an agreement.    AfterEndTime – A date used to filter agreements with a date after the endTime of an agreement.    AgreementType – The type of agreement. Values include PurchaseAgreement or VendorInsightsAgreement.
        public let filters: [Filter]?
        /// The maximum number of agreements to return in the response.
        public let maxResults: Int?
        /// A token to specify where to start pagination.
        public let nextToken: String?
        /// An object that contains the SortBy and SortOrder attributes.
        public let sort: Sort?

        @inlinable
        public init(catalog: String? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: Sort? = nil) {
            self.catalog = catalog
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=]+$")
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct SearchAgreementsOutput: AWSDecodableShape {
        /// A summary of the agreement, including top-level attributes (for example, the agreement ID, version, proposer, and acceptor).
        public let agreementViewSummaries: [AgreementViewSummary]?
        /// The token used for pagination. The field is null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(agreementViewSummaries: [AgreementViewSummary]? = nil, nextToken: String? = nil) {
            self.agreementViewSummaries = agreementViewSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agreementViewSummaries = "agreementViewSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct Selector: AWSDecodableShape {
        /// Category of selector.
        public let type: String?
        /// Contract duration. This field supports the ISO 8601 format.
        public let value: String?

        @inlinable
        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct Sort: AWSEncodableShape {
        /// The attribute on which the data is grouped, which can be by StartTime and EndTime. The default value is EndTime.
        public let sortBy: String?
        /// The sorting order, which can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public let sortOrder: SortOrder?

        @inlinable
        public init(sortBy: String? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.sortBy, name: "sortBy", parent: name, max: 255)
            try self.validate(self.sortBy, name: "sortBy", parent: name, min: 1)
            try self.validate(self.sortBy, name: "sortBy", parent: name, pattern: "^[A-Za-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct SupportTerm: AWSDecodableShape {
        /// Free-text field about the refund policy description that will be shown to customers as is on the website and console.
        public let refundPolicy: String?
        /// Category of the term being updated.
        public let type: String?

        @inlinable
        public init(refundPolicy: String? = nil, type: String? = nil) {
            self.refundPolicy = refundPolicy
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case refundPolicy = "refundPolicy"
            case type = "type"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String?
        /// The unique identifier for the error.
        public let requestId: String?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil) {
            self.message = message
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case requestId = "requestId"
        }
    }

    public struct UsageBasedPricingTerm: AWSDecodableShape {
        /// Defines the currency for the prices mentioned in the term.
        public let currencyCode: String?
        /// List of rate cards.
        public let rateCards: [UsageBasedRateCardItem]?
        /// Category of the term.
        public let type: String?

        @inlinable
        public init(currencyCode: String? = nil, rateCards: [UsageBasedRateCardItem]? = nil, type: String? = nil) {
            self.currencyCode = currencyCode
            self.rateCards = rateCards
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "currencyCode"
            case rateCards = "rateCards"
            case type = "type"
        }
    }

    public struct UsageBasedRateCardItem: AWSDecodableShape {
        /// Defines the per unit rates for product dimensions.
        public let rateCard: [RateCardItem]?

        @inlinable
        public init(rateCard: [RateCardItem]? = nil) {
            self.rateCard = rateCard
        }

        private enum CodingKeys: String, CodingKey {
            case rateCard = "rateCard"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields associated with the error.
        public let fields: [ValidationExceptionField]?
        public let message: String?
        /// The reason associated with the error.
        public let reason: ValidationExceptionReason?
        /// The unique identifier associated with the error.
        public let requestId: String?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil, requestId: String? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case message = "message"
            case reason = "reason"
            case requestId = "requestId"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// See applicable actions.
        public let message: String
        /// The name of the field associated with the error.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct ValidityTerm: AWSDecodableShape {
        /// Defines the duration that the agreement remains active. If AgreementStartDate isn’t provided, the agreement duration is relative to the agreement signature time. The duration is represented in the ISO_8601 format.
        public let agreementDuration: String?
        /// Defines the date when the agreement ends. The agreement ends at 23:59:59.999 UTC on the date provided. If AgreementEndDate isn’t provided, the agreement end date is determined by the validity of individual terms.
        public let agreementEndDate: Date?
        /// Defines the date when agreement starts. The agreement starts at 00:00:00.000 UTC on the date provided. If AgreementStartDate isn’t provided, the agreement start date is determined based on agreement signature time.
        public let agreementStartDate: Date?
        /// Category of the term being updated.
        public let type: String?

        @inlinable
        public init(agreementDuration: String? = nil, agreementEndDate: Date? = nil, agreementStartDate: Date? = nil, type: String? = nil) {
            self.agreementDuration = agreementDuration
            self.agreementEndDate = agreementEndDate
            self.agreementStartDate = agreementStartDate
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case agreementDuration = "agreementDuration"
            case agreementEndDate = "agreementEndDate"
            case agreementStartDate = "agreementStartDate"
            case type = "type"
        }
    }
}

// MARK: - Errors

/// Error enum for MarketplaceAgreement
public struct MarketplaceAgreementErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MarketplaceAgreement
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension MarketplaceAgreementErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": MarketplaceAgreement.AccessDeniedException.self,
        "InternalServerException": MarketplaceAgreement.InternalServerException.self,
        "ResourceNotFoundException": MarketplaceAgreement.ResourceNotFoundException.self,
        "ThrottlingException": MarketplaceAgreement.ThrottlingException.self,
        "ValidationException": MarketplaceAgreement.ValidationException.self
    ]
}

extension MarketplaceAgreementErrorType: Equatable {
    public static func == (lhs: MarketplaceAgreementErrorType, rhs: MarketplaceAgreementErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MarketplaceAgreementErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
