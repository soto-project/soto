//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Signin {
    // MARK: Enums

    public enum OAuth2ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Authorization code has expired
        case authcodeExpired = "AUTHCODE_EXPIRED"
        /// Insufficient permissions to perform this operation
        case insufficientPermissions = "INSUFFICIENT_PERMISSIONS"
        /// The request is missing a required parameter, includes an invalid parameter value, or is otherwise malformed
        case invalidRequest = "INVALID_REQUEST"
        /// Internal server error occurred
        case serverError = "server_error"
        /// Token has expired and needs to be refreshed
        case tokenExpired = "TOKEN_EXPIRED"
        /// User credentials have been changed
        case userCredentialsChanged = "USER_CREDENTIALS_CHANGED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        /// OAuth 2.0 error code indicating the specific type of access denial
        /// Can be TOKEN_EXPIRED, AUTHCODE_EXPIRED, USER_CREDENTIALS_CHANGED, or INSUFFICIENT_PERMISSIONS
        public let error: OAuth2ErrorCode
        /// Detailed message explaining the access denial
        /// Provides specific information about why access was denied
        public let message: String

        @inlinable
        public init(error: OAuth2ErrorCode, message: String) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct AccessToken: AWSDecodableShape {
        /// AWS access key ID for temporary credentials
        public let accessKeyId: String
        /// AWS secret access key for temporary credentials
        public let secretAccessKey: String
        /// AWS session token for temporary credentials
        public let sessionToken: String

        @inlinable
        public init(accessKeyId: String, secretAccessKey: String, sessionToken: String) {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case secretAccessKey = "secretAccessKey"
            case sessionToken = "sessionToken"
        }
    }

    public struct CreateOAuth2TokenRequest: AWSEncodableShape {
        /// Flattened token operation inputs
        /// The specific operation is determined by grant_type in the request body
        public let tokenInput: CreateOAuth2TokenRequestBody

        @inlinable
        public init(tokenInput: CreateOAuth2TokenRequestBody) {
            self.tokenInput = tokenInput
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            try container.encode(self.tokenInput)
        }

        public func validate(name: String) throws {
            try self.tokenInput.validate(name: "\(name).tokenInput")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateOAuth2TokenRequestBody: AWSEncodableShape {
        /// The client identifier (ARN) used during Sign-In onboarding
        /// Required for both authorization code and refresh token flows
        public let clientId: String
        /// The authorization code received from /v1/authorize
        /// Required only when grant_type=authorization_code
        public let code: String?
        /// PKCE code verifier to prove possession of the original code challenge
        /// Required only when grant_type=authorization_code
        public let codeVerifier: String?
        /// OAuth 2.0 grant type - determines which flow is used
        /// Must be "authorization_code" or "refresh_token"
        public let grantType: String
        /// The redirect URI that must match the original authorization request
        /// Required only when grant_type=authorization_code
        public let redirectUri: String?
        /// The refresh token returned from auth_code redemption
        /// Required only when grant_type=refresh_token
        public let refreshToken: String?

        @inlinable
        public init(clientId: String, code: String? = nil, codeVerifier: String? = nil, grantType: String, redirectUri: String? = nil, refreshToken: String? = nil) {
            self.clientId = clientId
            self.code = code
            self.codeVerifier = codeVerifier
            self.grantType = grantType
            self.redirectUri = redirectUri
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^arn:aws:signin:::devtools/(cross-device|same-device)$")
            try self.validate(self.code, name: "code", parent: name, max: 512)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.codeVerifier, name: "codeVerifier", parent: name, max: 128)
            try self.validate(self.codeVerifier, name: "codeVerifier", parent: name, min: 43)
            try self.validate(self.codeVerifier, name: "codeVerifier", parent: name, pattern: "^[A-Za-z0-9\\-._~]+$")
            try self.validate(self.grantType, name: "grantType", parent: name, pattern: "^(authorization_code|refresh_token)$")
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 2048)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, min: 1)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 2048)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case code = "code"
            case codeVerifier = "codeVerifier"
            case grantType = "grantType"
            case redirectUri = "redirectUri"
            case refreshToken = "refreshToken"
        }
    }

    public struct CreateOAuth2TokenResponse: AWSDecodableShape {
        /// Flattened token operation outputs
        /// The specific response fields depend on the grant_type used in the request
        public let tokenOutput: CreateOAuth2TokenResponseBody

        @inlinable
        public init(tokenOutput: CreateOAuth2TokenResponseBody) {
            self.tokenOutput = tokenOutput
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.tokenOutput = try container.decode(CreateOAuth2TokenResponseBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateOAuth2TokenResponseBody: AWSDecodableShape {
        /// Scoped-down AWS credentials (15 minute duration)
        /// Present for both authorization code redemption and token refresh
        public let accessToken: AccessToken
        /// Time to expiry in seconds (maximum 900)
        /// Present for both authorization code redemption and token refresh
        public let expiresIn: Int
        /// ID token containing user identity information
        /// Present only in authorization code redemption response (grant_type=authorization_code)
        /// Not included in token refresh responses
        public let idToken: String?
        /// Encrypted refresh token with cnf.jkt (SHA-256 thumbprint of presented jwk)
        /// Always present in responses (required for both flows)
        public let refreshToken: String
        /// Token type indicating this is AWS SigV4 credentials
        /// Value is "aws_sigv4" for both flows
        public let tokenType: String

        @inlinable
        public init(accessToken: AccessToken, expiresIn: Int, idToken: String? = nil, refreshToken: String, tokenType: String) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.tokenType = tokenType
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case expiresIn = "expiresIn"
            case idToken = "idToken"
            case refreshToken = "refreshToken"
            case tokenType = "tokenType"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        /// OAuth 2.0 error code indicating server error
        /// Will be SERVER_ERROR for internal server errors
        public let error: OAuth2ErrorCode
        /// Detailed message explaining the server error
        /// May include error details for debugging purposes
        public let message: String

        @inlinable
        public init(error: OAuth2ErrorCode, message: String) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct TooManyRequestsError: AWSErrorShape {
        /// OAuth 2.0 error code indicating the specific type of error
        /// Will be INVALID_REQUEST for rate limiting scenarios
        public let error: OAuth2ErrorCode
        /// Detailed message about the rate limiting
        /// May include retry-after information or rate limit details
        public let message: String

        @inlinable
        public init(error: OAuth2ErrorCode, message: String) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// OAuth 2.0 error code indicating validation failure
        /// Will be INVALID_REQUEST for validation errors
        public let error: OAuth2ErrorCode
        /// Detailed message explaining the validation failure
        /// Provides specific information about which validation failed
        public let message: String

        @inlinable
        public init(error: OAuth2ErrorCode, message: String) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }
}

// MARK: - Errors

/// Error enum for Signin
public struct SigninErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case tooManyRequestsError = "TooManyRequestsError"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Signin
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Error thrown for access denied scenarios with flexible HTTP status mapping
    /// Runtime HTTP Status Code Mapping:
    /// - HTTP 401 (Unauthorized): TOKEN_EXPIRED, AUTHCODE_EXPIRED
    /// - HTTP 403 (Forbidden): USER_CREDENTIALS_CHANGED, INSUFFICIENT_PERMISSIONS
    /// The specific HTTP status code is determined at runtime based on the error enum value.
    /// Consumers should use the error field to determine the specific access denial reason.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Error thrown when an internal server error occurs
    /// HTTP Status Code: 500 Internal Server Error
    /// Used for unexpected server-side errors that prevent request processing.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Error thrown when rate limit is exceeded
    /// HTTP Status Code: 429 Too Many Requests
    /// Possible OAuth2ErrorCode values:
    /// - INVALID_REQUEST: Rate limiting, too many requests, abuse prevention
    /// Possible causes:
    /// - Too many token requests from the same client
    /// - Rate limiting based on client_id or IP address
    /// - Abuse prevention mechanisms triggered
    /// - Service protection against excessive token generation
    public static var tooManyRequestsError: Self { .init(.tooManyRequestsError) }
    /// Error thrown when request validation fails
    /// HTTP Status Code: 400 Bad Request
    /// Used for request validation errors such as malformed parameters,
    /// missing required fields, or invalid parameter values.
    public static var validationException: Self { .init(.validationException) }
}

extension SigninErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": Signin.AccessDeniedException.self,
        "InternalServerException": Signin.InternalServerException.self,
        "TooManyRequestsError": Signin.TooManyRequestsError.self,
        "ValidationException": Signin.ValidationException.self
    ]
}

extension SigninErrorType: Equatable {
    public static func == (lhs: SigninErrorType, rhs: SigninErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SigninErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
