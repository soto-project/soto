//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS IoTAnalytics service.
///
/// IoT Analytics allows you to collect large amounts of device data, process messages, and store them.  You can then query the data and run sophisticated analytics on it.  IoT Analytics enables advanced  data exploration through integration with Jupyter Notebooks and data visualization through integration  with Amazon QuickSight. Traditional analytics and business intelligence tools are designed to process structured data. IoT data  often comes from devices that record noisy processes (such as temperature, motion, or sound). As a result  the data from these devices can have significant gaps, corrupted messages, and false readings that must be  cleaned up before analysis can occur. Also, IoT data is often only meaningful in the context of other data  from external sources.  IoT Analytics automates the steps required to analyze data from IoT devices. IoT Analytics  filters, transforms, and enriches IoT data before storing it in a time-series data store for analysis. You  can set up the service to collect only the data you need from your devices, apply mathematical transforms  to process the data, and enrich the data with device-specific metadata such as device type and location  before storing it. Then, you can analyze your data by running queries using the built-in SQL query engine,  or perform more complex analytics and machine learning inference. IoT Analytics includes pre-built models  for common IoT use cases so you can answer questions like which devices are about to fail or which customers  are at risk of abandoning their wearable devices.
public struct IoTAnalytics: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the IoTAnalytics client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "IoTAnalytics",
            serviceIdentifier: "iotanalytics",
            serviceProtocol: .restjson,
            apiVersion: "2017-11-27",
            endpoint: endpoint,
            errorType: IoTAnalyticsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Sends messages to a channel.
    @Sendable
    @inlinable
    public func batchPutMessage(_ input: BatchPutMessageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchPutMessageResponse {
        try await self.client.execute(
            operation: "BatchPutMessage", 
            path: "/messages/batch", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sends messages to a channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel where the messages are sent.
    ///   - messages: The list of messages to be sent. Each message has the format: { "messageId": "string", "payload": "string"}. The field names of message payloads (data) that you send to IoT Analytics:   Must contain only alphanumeric characters and undescores (_). No other special characters are allowed.   Must begin with an alphabetic character or single underscore (_).   Cannot contain hyphens (-).   In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$".    Cannot be more than 255 characters.   Are case insensitive. (Fields named foo and FOO in the same payload are considered duplicates.)   For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29}, {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchPutMessage(
        channelName: String,
        messages: [Message],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchPutMessageResponse {
        let input = BatchPutMessageRequest(
            channelName: channelName, 
            messages: messages
        )
        return try await self.batchPutMessage(input, logger: logger)
    }

    /// Cancels the reprocessing of data through the pipeline.
    @Sendable
    @inlinable
    public func cancelPipelineReprocessing(_ input: CancelPipelineReprocessingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelPipelineReprocessingResponse {
        try await self.client.execute(
            operation: "CancelPipelineReprocessing", 
            path: "/pipelines/{pipelineName}/reprocessing/{reprocessingId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the reprocessing of data through the pipeline.
    ///
    /// Parameters:
    ///   - pipelineName: The name of pipeline for which data reprocessing is canceled.
    ///   - reprocessingId: The ID of the reprocessing task (returned by StartPipelineReprocessing).
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelPipelineReprocessing(
        pipelineName: String,
        reprocessingId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelPipelineReprocessingResponse {
        let input = CancelPipelineReprocessingRequest(
            pipelineName: pipelineName, 
            reprocessingId: reprocessingId
        )
        return try await self.cancelPipelineReprocessing(input, logger: logger)
    }

    /// Used to create a channel. A channel collects data from an MQTT topic and archives the raw, unprocessed messages before publishing the data to a pipeline.
    @Sendable
    @inlinable
    public func createChannel(_ input: CreateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateChannelResponse {
        try await self.client.execute(
            operation: "CreateChannel", 
            path: "/channels", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to create a channel. A channel collects data from an MQTT topic and archives the raw, unprocessed messages before publishing the data to a pipeline.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - channelStorage: Where channel data is stored. You can choose one of serviceManagedS3 or customerManagedS3 storage. If not specified, the default is serviceManagedS3. You can't change this storage option after the channel is created.
    ///   - retentionPeriod: How long, in days, message data is kept for the channel. When customerManagedS3 storage is selected, this parameter is ignored.
    ///   - tags: Metadata which can be used to manage the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func createChannel(
        channelName: String,
        channelStorage: ChannelStorage? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateChannelResponse {
        let input = CreateChannelRequest(
            channelName: channelName, 
            channelStorage: channelStorage, 
            retentionPeriod: retentionPeriod, 
            tags: tags
        )
        return try await self.createChannel(input, logger: logger)
    }

    /// Used to create a dataset. A dataset stores data retrieved from a data store by applying a queryAction (a SQL query) or a containerAction (executing a containerized application). This operation creates the skeleton of a dataset. The dataset can be populated manually by calling CreateDatasetContent or automatically according to a trigger you specify.
    @Sendable
    @inlinable
    public func createDataset(_ input: CreateDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatasetResponse {
        try await self.client.execute(
            operation: "CreateDataset", 
            path: "/datasets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to create a dataset. A dataset stores data retrieved from a data store by applying a queryAction (a SQL query) or a containerAction (executing a containerized application). This operation creates the skeleton of a dataset. The dataset can be populated manually by calling CreateDatasetContent or automatically according to a trigger you specify.
    ///
    /// Parameters:
    ///   - actions: A list of actions that create the dataset contents.
    ///   - contentDeliveryRules: When dataset contents are created, they are delivered to destinations specified here.
    ///   - datasetName: The name of the dataset.
    ///   - lateDataRules: A list of data rules that send notifications to CloudWatch, when data arrives late. To specify lateDataRules, the dataset must use a DeltaTimer filter.
    ///   - retentionPeriod: Optional. How long, in days, versions of dataset contents are kept for the dataset. If not specified or set to null, versions of dataset contents are retained for at most 90 days. The number of versions of dataset contents retained is determined by the versioningConfiguration parameter. For more information, see  Keeping Multiple Versions of IoT Analytics datasets in the IoT Analytics User Guide.
    ///   - tags: Metadata which can be used to manage the dataset.
    ///   - triggers: A list of triggers. A trigger causes dataset contents to be populated at a specified time interval or when another dataset's contents are created. The list of triggers can be empty or contain up to five DataSetTrigger objects.
    ///   - versioningConfiguration: Optional. How many versions of dataset contents are kept. If not specified or set to null, only the latest version plus the latest succeeded version (if they are different) are kept for the time period specified by the retentionPeriod parameter. For more information, see Keeping Multiple Versions of IoT Analytics datasets in the IoT Analytics User Guide.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataset(
        actions: [DatasetAction],
        contentDeliveryRules: [DatasetContentDeliveryRule]? = nil,
        datasetName: String,
        lateDataRules: [LateDataRule]? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil,
        triggers: [DatasetTrigger]? = nil,
        versioningConfiguration: VersioningConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatasetResponse {
        let input = CreateDatasetRequest(
            actions: actions, 
            contentDeliveryRules: contentDeliveryRules, 
            datasetName: datasetName, 
            lateDataRules: lateDataRules, 
            retentionPeriod: retentionPeriod, 
            tags: tags, 
            triggers: triggers, 
            versioningConfiguration: versioningConfiguration
        )
        return try await self.createDataset(input, logger: logger)
    }

    /// Creates the content of a dataset by applying a queryAction (a SQL query) or a containerAction (executing a containerized application).
    @Sendable
    @inlinable
    public func createDatasetContent(_ input: CreateDatasetContentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatasetContentResponse {
        try await self.client.execute(
            operation: "CreateDatasetContent", 
            path: "/datasets/{datasetName}/content", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates the content of a dataset by applying a queryAction (a SQL query) or a containerAction (executing a containerized application).
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset.
    ///   - versionId: The version ID of the dataset content. To specify versionId for a dataset content, the dataset must use a DeltaTimer filter.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDatasetContent(
        datasetName: String,
        versionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatasetContentResponse {
        let input = CreateDatasetContentRequest(
            datasetName: datasetName, 
            versionId: versionId
        )
        return try await self.createDatasetContent(input, logger: logger)
    }

    /// Creates a data store, which is a repository for messages.
    @Sendable
    @inlinable
    public func createDatastore(_ input: CreateDatastoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatastoreResponse {
        try await self.client.execute(
            operation: "CreateDatastore", 
            path: "/datastores", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a data store, which is a repository for messages.
    ///
    /// Parameters:
    ///   - datastoreName: The name of the data store.
    ///   - datastorePartitions:  Contains information about the partition dimensions in a data store.
    ///   - datastoreStorage: Where data in a data store is stored.. You can choose serviceManagedS3 storage, customerManagedS3 storage, or iotSiteWiseMultiLayerStorage storage. The default is serviceManagedS3. You can't change the choice of Amazon S3 storage after your data store is created.
    ///   - fileFormatConfiguration: Contains the configuration information of file formats.  IoT Analytics data stores support JSON and Parquet. The default file format is JSON. You can specify only one format. You can't change the file format after you create the data store.
    ///   - retentionPeriod: How long, in days, message data is kept for the data store. When customerManagedS3 storage is selected, this parameter is ignored.
    ///   - tags: Metadata which can be used to manage the data store.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDatastore(
        datastoreName: String,
        datastorePartitions: DatastorePartitions? = nil,
        datastoreStorage: DatastoreStorage? = nil,
        fileFormatConfiguration: FileFormatConfiguration? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatastoreResponse {
        let input = CreateDatastoreRequest(
            datastoreName: datastoreName, 
            datastorePartitions: datastorePartitions, 
            datastoreStorage: datastoreStorage, 
            fileFormatConfiguration: fileFormatConfiguration, 
            retentionPeriod: retentionPeriod, 
            tags: tags
        )
        return try await self.createDatastore(input, logger: logger)
    }

    /// Creates a pipeline. A pipeline consumes messages from a channel and allows you to process the messages before storing them in a data store. You must specify both a channel and a datastore activity and, optionally, as many as 23 additional activities in the pipelineActivities array.
    @Sendable
    @inlinable
    public func createPipeline(_ input: CreatePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePipelineResponse {
        try await self.client.execute(
            operation: "CreatePipeline", 
            path: "/pipelines", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a pipeline. A pipeline consumes messages from a channel and allows you to process the messages before storing them in a data store. You must specify both a channel and a datastore activity and, optionally, as many as 23 additional activities in the pipelineActivities array.
    ///
    /// Parameters:
    ///   - pipelineActivities: A list of PipelineActivity objects. Activities perform transformations on your messages, such as removing, renaming or adding message attributes; filtering messages based on attribute values; invoking your Lambda unctions on messages for advanced processing; or performing mathematical transformations to normalize device data. The list can be 2-25 PipelineActivity objects and must contain both a channel and a datastore activity. Each entry in the list must contain only one activity. For example:  pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ... ]
    ///   - pipelineName: The name of the pipeline.
    ///   - tags: Metadata which can be used to manage the pipeline.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPipeline(
        pipelineActivities: [PipelineActivity],
        pipelineName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePipelineResponse {
        let input = CreatePipelineRequest(
            pipelineActivities: pipelineActivities, 
            pipelineName: pipelineName, 
            tags: tags
        )
        return try await self.createPipeline(input, logger: logger)
    }

    /// Deletes the specified channel.
    @Sendable
    @inlinable
    public func deleteChannel(_ input: DeleteChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteChannel", 
            path: "/channels/{channelName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteChannel(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteChannelRequest(
            channelName: channelName
        )
        return try await self.deleteChannel(input, logger: logger)
    }

    /// Deletes the specified dataset. You do not have to delete the content of the dataset before you perform this operation.
    @Sendable
    @inlinable
    public func deleteDataset(_ input: DeleteDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteDataset", 
            path: "/datasets/{datasetName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified dataset. You do not have to delete the content of the dataset before you perform this operation.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataset(
        datasetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteDatasetRequest(
            datasetName: datasetName
        )
        return try await self.deleteDataset(input, logger: logger)
    }

    /// Deletes the content of the specified dataset.
    @Sendable
    @inlinable
    public func deleteDatasetContent(_ input: DeleteDatasetContentRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteDatasetContent", 
            path: "/datasets/{datasetName}/content", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the content of the specified dataset.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset whose content is deleted.
    ///   - versionId: The version of the dataset whose content is deleted. You can also use the strings "$LATEST" or "$LATEST_SUCCEEDED" to delete the latest or latest successfully completed data set. If not specified, "$LATEST_SUCCEEDED" is the default.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDatasetContent(
        datasetName: String,
        versionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteDatasetContentRequest(
            datasetName: datasetName, 
            versionId: versionId
        )
        return try await self.deleteDatasetContent(input, logger: logger)
    }

    /// Deletes the specified data store.
    @Sendable
    @inlinable
    public func deleteDatastore(_ input: DeleteDatastoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteDatastore", 
            path: "/datastores/{datastoreName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified data store.
    ///
    /// Parameters:
    ///   - datastoreName: The name of the data store to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDatastore(
        datastoreName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteDatastoreRequest(
            datastoreName: datastoreName
        )
        return try await self.deleteDatastore(input, logger: logger)
    }

    /// Deletes the specified pipeline.
    @Sendable
    @inlinable
    public func deletePipeline(_ input: DeletePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeletePipeline", 
            path: "/pipelines/{pipelineName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified pipeline.
    ///
    /// Parameters:
    ///   - pipelineName: The name of the pipeline to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePipeline(
        pipelineName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeletePipelineRequest(
            pipelineName: pipelineName
        )
        return try await self.deletePipeline(input, logger: logger)
    }

    /// Retrieves information about a channel.
    @Sendable
    @inlinable
    public func describeChannel(_ input: DescribeChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeChannelResponse {
        try await self.client.execute(
            operation: "DescribeChannel", 
            path: "/channels/{channelName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel whose information is retrieved.
    ///   - includeStatistics: If true, additional statistical information about the channel is included in the response. This feature can't be used with a channel whose S3 storage is customer-managed.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeChannel(
        channelName: String,
        includeStatistics: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeChannelResponse {
        let input = DescribeChannelRequest(
            channelName: channelName, 
            includeStatistics: includeStatistics
        )
        return try await self.describeChannel(input, logger: logger)
    }

    /// Retrieves information about a dataset.
    @Sendable
    @inlinable
    public func describeDataset(_ input: DescribeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDatasetResponse {
        try await self.client.execute(
            operation: "DescribeDataset", 
            path: "/datasets/{datasetName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a dataset.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset whose information is retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDataset(
        datasetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDatasetResponse {
        let input = DescribeDatasetRequest(
            datasetName: datasetName
        )
        return try await self.describeDataset(input, logger: logger)
    }

    /// Retrieves information about a data store.
    @Sendable
    @inlinable
    public func describeDatastore(_ input: DescribeDatastoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDatastoreResponse {
        try await self.client.execute(
            operation: "DescribeDatastore", 
            path: "/datastores/{datastoreName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a data store.
    ///
    /// Parameters:
    ///   - datastoreName: The name of the data store
    ///   - includeStatistics: If true, additional statistical information about the data store is included in the response. This feature can't be used with a data store whose S3 storage is customer-managed.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDatastore(
        datastoreName: String,
        includeStatistics: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDatastoreResponse {
        let input = DescribeDatastoreRequest(
            datastoreName: datastoreName, 
            includeStatistics: includeStatistics
        )
        return try await self.describeDatastore(input, logger: logger)
    }

    /// Retrieves the current settings of the IoT Analytics logging options.
    @Sendable
    @inlinable
    public func describeLoggingOptions(_ input: DescribeLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLoggingOptionsResponse {
        try await self.client.execute(
            operation: "DescribeLoggingOptions", 
            path: "/logging", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the current settings of the IoT Analytics logging options.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLoggingOptions(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLoggingOptionsResponse {
        let input = DescribeLoggingOptionsRequest(
        )
        return try await self.describeLoggingOptions(input, logger: logger)
    }

    /// Retrieves information about a pipeline.
    @Sendable
    @inlinable
    public func describePipeline(_ input: DescribePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePipelineResponse {
        try await self.client.execute(
            operation: "DescribePipeline", 
            path: "/pipelines/{pipelineName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a pipeline.
    ///
    /// Parameters:
    ///   - pipelineName: The name of the pipeline whose information is retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func describePipeline(
        pipelineName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribePipelineResponse {
        let input = DescribePipelineRequest(
            pipelineName: pipelineName
        )
        return try await self.describePipeline(input, logger: logger)
    }

    /// Retrieves the contents of a dataset as presigned URIs.
    @Sendable
    @inlinable
    public func getDatasetContent(_ input: GetDatasetContentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDatasetContentResponse {
        try await self.client.execute(
            operation: "GetDatasetContent", 
            path: "/datasets/{datasetName}/content", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the contents of a dataset as presigned URIs.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset whose contents are retrieved.
    ///   - versionId: The version of the dataset whose contents are retrieved. You can also use the strings "$LATEST" or "$LATEST_SUCCEEDED" to retrieve the contents of the latest or latest successfully completed dataset. If not specified, "$LATEST_SUCCEEDED" is the default.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDatasetContent(
        datasetName: String,
        versionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDatasetContentResponse {
        let input = GetDatasetContentRequest(
            datasetName: datasetName, 
            versionId: versionId
        )
        return try await self.getDatasetContent(input, logger: logger)
    }

    /// Retrieves a list of channels.
    @Sendable
    @inlinable
    public func listChannels(_ input: ListChannelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListChannelsResponse {
        try await self.client.execute(
            operation: "ListChannels", 
            path: "/channels", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of channels.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listChannels(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListChannelsResponse {
        let input = ListChannelsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listChannels(input, logger: logger)
    }

    /// Lists information about dataset contents that have been created.
    @Sendable
    @inlinable
    public func listDatasetContents(_ input: ListDatasetContentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDatasetContentsResponse {
        try await self.client.execute(
            operation: "ListDatasetContents", 
            path: "/datasets/{datasetName}/contents", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about dataset contents that have been created.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset whose contents information you want to list.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: The token for the next set of results.
    ///   - scheduledBefore: A filter to limit results to those dataset contents whose creation is scheduled before the given time. See the field triggers.schedule in the CreateDataset request. (timestamp)
    ///   - scheduledOnOrAfter: A filter to limit results to those dataset contents whose creation is scheduled on or after the given time. See the field triggers.schedule in the CreateDataset request. (timestamp)
    ///   - logger: Logger use during operation
    @inlinable
    public func listDatasetContents(
        datasetName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scheduledBefore: Date? = nil,
        scheduledOnOrAfter: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDatasetContentsResponse {
        let input = ListDatasetContentsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            scheduledBefore: scheduledBefore, 
            scheduledOnOrAfter: scheduledOnOrAfter
        )
        return try await self.listDatasetContents(input, logger: logger)
    }

    /// Retrieves information about datasets.
    @Sendable
    @inlinable
    public func listDatasets(_ input: ListDatasetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDatasetsResponse {
        try await self.client.execute(
            operation: "ListDatasets", 
            path: "/datasets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about datasets.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDatasets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDatasetsResponse {
        let input = ListDatasetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDatasets(input, logger: logger)
    }

    /// Retrieves a list of data stores.
    @Sendable
    @inlinable
    public func listDatastores(_ input: ListDatastoresRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDatastoresResponse {
        try await self.client.execute(
            operation: "ListDatastores", 
            path: "/datastores", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of data stores.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDatastores(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDatastoresResponse {
        let input = ListDatastoresRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDatastores(input, logger: logger)
    }

    /// Retrieves a list of pipelines.
    @Sendable
    @inlinable
    public func listPipelines(_ input: ListPipelinesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPipelinesResponse {
        try await self.client.execute(
            operation: "ListPipelines", 
            path: "/pipelines", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of pipelines.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPipelines(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPipelinesResponse {
        let input = ListPipelinesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPipelines(input, logger: logger)
    }

    /// Lists the tags (metadata) that you have assigned to the resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags (metadata) that you have assigned to the resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource whose tags you want to list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Sets or updates the IoT Analytics logging options. If you update the value of any loggingOptions field, it takes up to one minute for the change to take effect. Also, if you change the policy attached to the role you specified in the roleArn field (for example, to correct an invalid policy), it takes up to five minutes for that change to take effect.
    @Sendable
    @inlinable
    public func putLoggingOptions(_ input: PutLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "PutLoggingOptions", 
            path: "/logging", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets or updates the IoT Analytics logging options. If you update the value of any loggingOptions field, it takes up to one minute for the change to take effect. Also, if you change the policy attached to the role you specified in the roleArn field (for example, to correct an invalid policy), it takes up to five minutes for that change to take effect.
    ///
    /// Parameters:
    ///   - loggingOptions: The new values of the IoT Analytics logging options.
    ///   - logger: Logger use during operation
    @inlinable
    public func putLoggingOptions(
        loggingOptions: LoggingOptions,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = PutLoggingOptionsRequest(
            loggingOptions: loggingOptions
        )
        return try await self.putLoggingOptions(input, logger: logger)
    }

    /// Simulates the results of running a pipeline activity on a message payload.
    @Sendable
    @inlinable
    public func runPipelineActivity(_ input: RunPipelineActivityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RunPipelineActivityResponse {
        try await self.client.execute(
            operation: "RunPipelineActivity", 
            path: "/pipelineactivities/run", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Simulates the results of running a pipeline activity on a message payload.
    ///
    /// Parameters:
    ///   - payloads: The sample message payloads on which the pipeline activity is run.
    ///   - pipelineActivity: The pipeline activity that is run. This must not be a channel activity or a data store activity because these activities are used in a pipeline only to load the original message and to store the (possibly) transformed message. If a Lambda activity is specified, only short-running Lambda functions (those with a timeout of less than 30 seconds or less) can be used.
    ///   - logger: Logger use during operation
    @inlinable
    public func runPipelineActivity(
        payloads: [AWSBase64Data],
        pipelineActivity: PipelineActivity,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RunPipelineActivityResponse {
        let input = RunPipelineActivityRequest(
            payloads: payloads, 
            pipelineActivity: pipelineActivity
        )
        return try await self.runPipelineActivity(input, logger: logger)
    }

    /// Retrieves a sample of messages from the specified channel ingested during the specified timeframe. Up to 10 messages can be retrieved.
    @Sendable
    @inlinable
    public func sampleChannelData(_ input: SampleChannelDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SampleChannelDataResponse {
        try await self.client.execute(
            operation: "SampleChannelData", 
            path: "/channels/{channelName}/sample", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a sample of messages from the specified channel ingested during the specified timeframe. Up to 10 messages can be retrieved.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel whose message samples are retrieved.
    ///   - endTime: The end of the time window from which sample messages are retrieved.
    ///   - maxMessages: The number of sample messages to be retrieved. The limit is 10. The default is also 10.
    ///   - startTime: The start of the time window from which sample messages are retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func sampleChannelData(
        channelName: String,
        endTime: Date? = nil,
        maxMessages: Int? = nil,
        startTime: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SampleChannelDataResponse {
        let input = SampleChannelDataRequest(
            channelName: channelName, 
            endTime: endTime, 
            maxMessages: maxMessages, 
            startTime: startTime
        )
        return try await self.sampleChannelData(input, logger: logger)
    }

    /// Starts the reprocessing of raw message data through the pipeline.
    @Sendable
    @inlinable
    public func startPipelineReprocessing(_ input: StartPipelineReprocessingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartPipelineReprocessingResponse {
        try await self.client.execute(
            operation: "StartPipelineReprocessing", 
            path: "/pipelines/{pipelineName}/reprocessing", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts the reprocessing of raw message data through the pipeline.
    ///
    /// Parameters:
    ///   - channelMessages: Specifies one or more sets of channel messages that you want to reprocess. If you use the channelMessages object, you must not specify a value for startTime and endTime.
    ///   - endTime: The end time (exclusive) of raw message data that is reprocessed. If you specify a value for the endTime parameter, you must not use the channelMessages object.
    ///   - pipelineName: The name of the pipeline on which to start reprocessing.
    ///   - startTime: The start time (inclusive) of raw message data that is reprocessed. If you specify a value for the startTime parameter, you must not use the channelMessages object.
    ///   - logger: Logger use during operation
    @inlinable
    public func startPipelineReprocessing(
        channelMessages: ChannelMessages? = nil,
        endTime: Date? = nil,
        pipelineName: String,
        startTime: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartPipelineReprocessingResponse {
        let input = StartPipelineReprocessingRequest(
            channelMessages: channelMessages, 
            endTime: endTime, 
            pipelineName: pipelineName, 
            startTime: startTime
        )
        return try await self.startPipelineReprocessing(input, logger: logger)
    }

    /// Adds to or modifies the tags of the given resource. Tags are metadata that can be used to manage a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds to or modifies the tags of the given resource. Tags are metadata that can be used to manage a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource whose tags you want to modify.
    ///   - tags: The new or modified tags for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the given tags (metadata) from the resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the given tags (metadata) from the resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource whose tags you want to remove.
    ///   - tagKeys: The keys of those tags which you want to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Used to update the settings of a channel.
    @Sendable
    @inlinable
    public func updateChannel(_ input: UpdateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateChannel", 
            path: "/channels/{channelName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to update the settings of a channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel to be updated.
    ///   - channelStorage: Where channel data is stored. You can choose one of serviceManagedS3 or customerManagedS3 storage. If not specified, the default is serviceManagedS3. You can't change this storage option after the channel is created.
    ///   - retentionPeriod: How long, in days, message data is kept for the channel. The retention period can't be updated if the channel's Amazon S3 storage is customer-managed.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateChannel(
        channelName: String,
        channelStorage: ChannelStorage? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateChannelRequest(
            channelName: channelName, 
            channelStorage: channelStorage, 
            retentionPeriod: retentionPeriod
        )
        return try await self.updateChannel(input, logger: logger)
    }

    /// Updates the settings of a dataset.
    @Sendable
    @inlinable
    public func updateDataset(_ input: UpdateDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateDataset", 
            path: "/datasets/{datasetName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the settings of a dataset.
    ///
    /// Parameters:
    ///   - actions: A list of DatasetAction objects.
    ///   - contentDeliveryRules: When dataset contents are created, they are delivered to destinations specified here.
    ///   - datasetName: The name of the dataset to update.
    ///   - lateDataRules: A list of data rules that send notifications to CloudWatch, when data arrives late. To specify lateDataRules, the dataset must use a DeltaTimer filter.
    ///   - retentionPeriod: How long, in days, dataset contents are kept for the dataset.
    ///   - triggers: A list of DatasetTrigger objects. The list can be empty or can contain up to five DatasetTrigger objects.
    ///   - versioningConfiguration: Optional. How many versions of dataset contents are kept. If not specified or set to null, only the latest version plus the latest succeeded version (if they are different) are kept for the time period specified by the retentionPeriod parameter. For more information, see Keeping Multiple Versions of IoT Analytics datasets in the IoT Analytics User Guide.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataset(
        actions: [DatasetAction],
        contentDeliveryRules: [DatasetContentDeliveryRule]? = nil,
        datasetName: String,
        lateDataRules: [LateDataRule]? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        triggers: [DatasetTrigger]? = nil,
        versioningConfiguration: VersioningConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateDatasetRequest(
            actions: actions, 
            contentDeliveryRules: contentDeliveryRules, 
            datasetName: datasetName, 
            lateDataRules: lateDataRules, 
            retentionPeriod: retentionPeriod, 
            triggers: triggers, 
            versioningConfiguration: versioningConfiguration
        )
        return try await self.updateDataset(input, logger: logger)
    }

    /// Used to update the settings of a data store.
    @Sendable
    @inlinable
    public func updateDatastore(_ input: UpdateDatastoreRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateDatastore", 
            path: "/datastores/{datastoreName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to update the settings of a data store.
    ///
    /// Parameters:
    ///   - datastoreName: The name of the data store to be updated.
    ///   - datastoreStorage: Where data in a data store is stored.. You can choose serviceManagedS3 storage, customerManagedS3 storage, or iotSiteWiseMultiLayerStorage storage. The default is serviceManagedS3. You can't change the choice of Amazon S3 storage after your data store is created.
    ///   - fileFormatConfiguration: Contains the configuration information of file formats.  IoT Analytics data stores support JSON and Parquet. The default file format is JSON. You can specify only one format. You can't change the file format after you create the data store.
    ///   - retentionPeriod: How long, in days, message data is kept for the data store. The retention period can't be updated if the data store's Amazon S3 storage is customer-managed.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDatastore(
        datastoreName: String,
        datastoreStorage: DatastoreStorage? = nil,
        fileFormatConfiguration: FileFormatConfiguration? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateDatastoreRequest(
            datastoreName: datastoreName, 
            datastoreStorage: datastoreStorage, 
            fileFormatConfiguration: fileFormatConfiguration, 
            retentionPeriod: retentionPeriod
        )
        return try await self.updateDatastore(input, logger: logger)
    }

    /// Updates the settings of a pipeline. You must specify both a channel and a datastore activity and, optionally, as many as 23 additional activities in the pipelineActivities array.
    @Sendable
    @inlinable
    public func updatePipeline(_ input: UpdatePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdatePipeline", 
            path: "/pipelines/{pipelineName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the settings of a pipeline. You must specify both a channel and a datastore activity and, optionally, as many as 23 additional activities in the pipelineActivities array.
    ///
    /// Parameters:
    ///   - pipelineActivities: A list of PipelineActivity objects. Activities perform transformations on your messages, such as removing, renaming or adding message attributes; filtering messages based on attribute values; invoking your Lambda functions on messages for advanced processing; or performing mathematical transformations to normalize device data. The list can be 2-25 PipelineActivity objects and must contain both a channel and a datastore activity. Each entry in the list must contain only one activity. For example:  pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ... ]
    ///   - pipelineName: The name of the pipeline to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePipeline(
        pipelineActivities: [PipelineActivity],
        pipelineName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdatePipelineRequest(
            pipelineActivities: pipelineActivities, 
            pipelineName: pipelineName
        )
        return try await self.updatePipeline(input, logger: logger)
    }
}

extension IoTAnalytics {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: IoTAnalytics, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IoTAnalytics {
    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        _ input: ListChannelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        return .init(
            input: input,
            command: self.listChannels,
            inputKey: \ListChannelsRequest.nextToken,
            outputKey: \ListChannelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        let input = ListChannelsRequest(
            maxResults: maxResults
        )
        return self.listChannelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDatasetContents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetContentsPaginator(
        _ input: ListDatasetContentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDatasetContentsRequest, ListDatasetContentsResponse> {
        return .init(
            input: input,
            command: self.listDatasetContents,
            inputKey: \ListDatasetContentsRequest.nextToken,
            outputKey: \ListDatasetContentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDatasetContents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetName: The name of the dataset whose contents information you want to list.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - scheduledBefore: A filter to limit results to those dataset contents whose creation is scheduled before the given time. See the field triggers.schedule in the CreateDataset request. (timestamp)
    ///   - scheduledOnOrAfter: A filter to limit results to those dataset contents whose creation is scheduled on or after the given time. See the field triggers.schedule in the CreateDataset request. (timestamp)
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetContentsPaginator(
        datasetName: String,
        maxResults: Int? = nil,
        scheduledBefore: Date? = nil,
        scheduledOnOrAfter: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDatasetContentsRequest, ListDatasetContentsResponse> {
        let input = ListDatasetContentsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            scheduledBefore: scheduledBefore, 
            scheduledOnOrAfter: scheduledOnOrAfter
        )
        return self.listDatasetContentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        _ input: ListDatasetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        return .init(
            input: input,
            command: self.listDatasets,
            inputKey: \ListDatasetsRequest.nextToken,
            outputKey: \ListDatasetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        let input = ListDatasetsRequest(
            maxResults: maxResults
        )
        return self.listDatasetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDatastores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatastoresPaginator(
        _ input: ListDatastoresRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDatastoresRequest, ListDatastoresResponse> {
        return .init(
            input: input,
            command: self.listDatastores,
            inputKey: \ListDatastoresRequest.nextToken,
            outputKey: \ListDatastoresResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDatastores(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatastoresPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDatastoresRequest, ListDatastoresResponse> {
        let input = ListDatastoresRequest(
            maxResults: maxResults
        )
        return self.listDatastoresPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPipelines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPipelinesPaginator(
        _ input: ListPipelinesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPipelinesRequest, ListPipelinesResponse> {
        return .init(
            input: input,
            command: self.listPipelines,
            inputKey: \ListPipelinesRequest.nextToken,
            outputKey: \ListPipelinesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPipelines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request. The default value is 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPipelinesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPipelinesRequest, ListPipelinesResponse> {
        let input = ListPipelinesRequest(
            maxResults: maxResults
        )
        return self.listPipelinesPaginator(input, logger: logger)
    }
}

extension IoTAnalytics.ListChannelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTAnalytics.ListChannelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTAnalytics.ListDatasetContentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTAnalytics.ListDatasetContentsRequest {
        return .init(
            datasetName: self.datasetName,
            maxResults: self.maxResults,
            nextToken: token,
            scheduledBefore: self.scheduledBefore,
            scheduledOnOrAfter: self.scheduledOnOrAfter
        )
    }
}

extension IoTAnalytics.ListDatasetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTAnalytics.ListDatasetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTAnalytics.ListDatastoresRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTAnalytics.ListDatastoresRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTAnalytics.ListPipelinesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTAnalytics.ListPipelinesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
