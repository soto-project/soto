//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MQ {
    // MARK: Enums

    public enum AuthenticationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ldap = "LDAP"
        case simple = "SIMPLE"
        public var description: String { return self.rawValue }
    }

    public enum BrokerState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case criticalActionRequired = "CRITICAL_ACTION_REQUIRED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case rebootInProgress = "REBOOT_IN_PROGRESS"
        case replica = "REPLICA"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BrokerStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebs = "EBS"
        case efs = "EFS"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case crdr = "CRDR"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeStandbyMultiAz = "ACTIVE_STANDBY_MULTI_AZ"
        case clusterMultiAz = "CLUSTER_MULTI_AZ"
        case singleInstance = "SINGLE_INSTANCE"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activemq = "ACTIVEMQ"
        case rabbitmq = "RABBITMQ"
        public var description: String { return self.rawValue }
    }

    public enum PromoteMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failover = "FAILOVER"
        case switchover = "SWITCHOVER"
        public var description: String { return self.rawValue }
    }

    public enum SanitizationWarningReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disallowedAttributeRemoved = "DISALLOWED_ATTRIBUTE_REMOVED"
        case disallowedElementRemoved = "DISALLOWED_ELEMENT_REMOVED"
        case invalidAttributeValueRemoved = "INVALID_ATTRIBUTE_VALUE_REMOVED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActionRequired: AWSDecodableShape {
        /// The code you can use to find instructions on the action required to resolve your broker issue.
        public let actionRequiredCode: String?
        /// Information about the action required to resolve your broker issue.
        public let actionRequiredInfo: String?

        @inlinable
        public init(actionRequiredCode: String? = nil, actionRequiredInfo: String? = nil) {
            self.actionRequiredCode = actionRequiredCode
            self.actionRequiredInfo = actionRequiredInfo
        }

        private enum CodingKeys: String, CodingKey {
            case actionRequiredCode = "actionRequiredCode"
            case actionRequiredInfo = "actionRequiredInfo"
        }
    }

    public struct AvailabilityZone: AWSDecodableShape {
        /// Id for the availability zone.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct BadRequestException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct BrokerEngineType: AWSDecodableShape {
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The list of engine versions.
        public let engineVersions: [EngineVersion]?

        @inlinable
        public init(engineType: EngineType? = nil, engineVersions: [EngineVersion]? = nil) {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "engineType"
            case engineVersions = "engineVersions"
        }
    }

    public struct BrokerInstance: AWSDecodableShape {
        /// The brokers web console URL.
        public let consoleURL: String?
        /// The broker's wire-level protocol endpoints.
        public let endpoints: [String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public let ipAddress: String?

        @inlinable
        public init(consoleURL: String? = nil, endpoints: [String]? = nil, ipAddress: String? = nil) {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }

        private enum CodingKeys: String, CodingKey {
            case consoleURL = "consoleURL"
            case endpoints = "endpoints"
            case ipAddress = "ipAddress"
        }
    }

    public struct BrokerInstanceOption: AWSDecodableShape {
        /// The list of available az.
        public let availabilityZones: [AvailabilityZone]?
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The broker's instance type.
        public let hostInstanceType: String?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of supported deployment modes.
        public let supportedDeploymentModes: [DeploymentMode]?
        /// The list of supported engine versions.
        public let supportedEngineVersions: [String]?

        @inlinable
        public init(availabilityZones: [AvailabilityZone]? = nil, engineType: EngineType? = nil, hostInstanceType: String? = nil, storageType: BrokerStorageType? = nil, supportedDeploymentModes: [DeploymentMode]? = nil, supportedEngineVersions: [String]? = nil) {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "availabilityZones"
            case engineType = "engineType"
            case hostInstanceType = "hostInstanceType"
            case storageType = "storageType"
            case supportedDeploymentModes = "supportedDeploymentModes"
            case supportedEngineVersions = "supportedEngineVersions"
        }
    }

    public struct BrokerSummary: AWSDecodableShape {
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The broker's name. This value is unique in your Amazon Web Services account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String?
        /// The broker's status.
        public let brokerState: BrokerState?
        /// The time when the broker was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The broker's deployment mode.
        public let deploymentMode: DeploymentMode?
        /// The type of broker engine.
        public let engineType: EngineType?
        /// The broker's instance type.
        public let hostInstanceType: String?

        @inlinable
        public init(brokerArn: String? = nil, brokerId: String? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, created: Date? = nil, deploymentMode: DeploymentMode? = nil, engineType: EngineType? = nil, hostInstanceType: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn = "brokerArn"
            case brokerId = "brokerId"
            case brokerName = "brokerName"
            case brokerState = "brokerState"
            case created = "created"
            case deploymentMode = "deploymentMode"
            case engineType = "engineType"
            case hostInstanceType = "hostInstanceType"
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// Required. The ARN of the configuration.
        public let arn: String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The description of the configuration.
        public let description: String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For a list of supported engine versions, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// Required. The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// The list of all tags associated with this configuration.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, description: String? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authenticationStrategy = "authenticationStrategy"
            case created = "created"
            case description = "description"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case id = "id"
            case latestRevision = "latestRevision"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct ConfigurationId: AWSEncodableShape & AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// The revision number of the configuration.
        public let revision: Int?

        @inlinable
        public init(id: String? = nil, revision: Int? = nil) {
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revision = "revision"
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// Required. The date and time of the configuration revision.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The description of the configuration revision.
        public let description: String?
        /// Required. The revision number of the configuration.
        public let revision: Int?

        @inlinable
        public init(created: Date? = nil, description: String? = nil, revision: Int? = nil) {
            self.created = created
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case created = "created"
            case description = "description"
            case revision = "revision"
        }
    }

    public struct Configurations: AWSDecodableShape {
        /// The broker's current configuration.
        public let current: ConfigurationId?
        /// The history of configurations applied to the broker.
        public let history: [ConfigurationId]?
        /// The broker's pending configuration.
        public let pending: ConfigurationId?

        @inlinable
        public init(current: ConfigurationId? = nil, history: [ConfigurationId]? = nil, pending: ConfigurationId? = nil) {
            self.current = current
            self.history = history
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case current = "current"
            case history = "history"
            case pending = "pending"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct CreateBrokerRequest: AWSEncodableShape {
        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot. Set to true by default, if no value is specified. Must be set to true for ActiveMQ brokers version 5.18 and above and for RabbitMQ brokers version 3.13 and above.
        public let autoMinorVersionUpgrade: Bool?
        /// Required. The broker's name. This value must be unique in your Amazon Web Services account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters. Do not add personally identifiable information (PII) or other confidential or sensitive information in broker names. Broker names are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker names are not intended to be used for private or sensitive data.
        public let brokerName: String?
        /// A list of information about the configuration.
        public let configuration: ConfigurationId?
        /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
        public let creatorRequestId: String?
        /// Defines whether this broker is a part of a data replication pair.
        public let dataReplicationMode: DataReplicationMode?
        /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when dataReplicationMode is set to CRDR.
        public let dataReplicationPrimaryBrokerArn: String?
        /// Required. The broker's deployment mode.
        public let deploymentMode: DeploymentMode?
        /// Encryption options for the broker.
        public let encryptionOptions: EncryptionOptions?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// Required. The broker's instance type.
        public let hostInstanceType: String?
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataInput?
        /// Enables Amazon CloudWatch logging for brokers.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
        public let publiclyAccessible: Bool?
        /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
        public let securityGroups: [String]?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a shared VPC for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your Amazon Web Services account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your Amazon Web Services account.
        public let subnetIds: [String]?
        /// Create tags when creating the broker.
        public let tags: [String: String]?
        /// The list of broker users (persons or applications) who can access queues and topics. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
        public let users: [User]?

        @inlinable
        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerName: String? = nil, configuration: ConfigurationId? = nil, creatorRequestId: String? = CreateBrokerRequest.idempotencyToken(), dataReplicationMode: DataReplicationMode? = nil, dataReplicationPrimaryBrokerArn: String? = nil, deploymentMode: DeploymentMode? = nil, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, publiclyAccessible: Bool? = nil, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [User]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerName = brokerName
            self.configuration = configuration
            self.creatorRequestId = creatorRequestId
            self.dataReplicationMode = dataReplicationMode
            self.dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArn
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy = "authenticationStrategy"
            case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
            case brokerName = "brokerName"
            case configuration = "configuration"
            case creatorRequestId = "creatorRequestId"
            case dataReplicationMode = "dataReplicationMode"
            case dataReplicationPrimaryBrokerArn = "dataReplicationPrimaryBrokerArn"
            case deploymentMode = "deploymentMode"
            case encryptionOptions = "encryptionOptions"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case hostInstanceType = "hostInstanceType"
            case ldapServerMetadata = "ldapServerMetadata"
            case logs = "logs"
            case maintenanceWindowStartTime = "maintenanceWindowStartTime"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroups = "securityGroups"
            case storageType = "storageType"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case users = "users"
        }
    }

    public struct CreateBrokerResponse: AWSDecodableShape {
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?

        @inlinable
        public init(brokerArn: String? = nil, brokerId: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn = "brokerArn"
            case brokerId = "brokerId"
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// Create tags when creating the configuration.
        public let tags: [String: String]?

        @inlinable
        public init(authenticationStrategy: AuthenticationStrategy? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy = "authenticationStrategy"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        /// Required. The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authenticationStrategy = "authenticationStrategy"
            case created = "created"
            case id = "id"
            case latestRevision = "latestRevision"
            case name = "name"
        }
    }

    public struct CreateTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String?
        /// Defines if this user is intended for CRDR replication purposes.
        public let replicationUser: Bool?
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        @inlinable
        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String? = nil, replicationUser: Bool? = nil, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.replicationUser = replicationUser
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            try container.encodeIfPresent(self.consoleAccess, forKey: .consoleAccess)
            try container.encodeIfPresent(self.groups, forKey: .groups)
            try container.encodeIfPresent(self.password, forKey: .password)
            try container.encodeIfPresent(self.replicationUser, forKey: .replicationUser)
            request.encodePath(self.username, key: "Username")
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess = "consoleAccess"
            case groups = "groups"
            case password = "password"
            case replicationUser = "replicationUser"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DataReplicationCounterpart: AWSDecodableShape {
        /// Required. The unique broker id generated by Amazon MQ.
        public let brokerId: String?
        /// Required. The region of the broker.
        public let region: String?

        @inlinable
        public init(brokerId: String? = nil, region: String? = nil) {
            self.brokerId = brokerId
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId = "brokerId"
            case region = "region"
        }
    }

    public struct DataReplicationMetadataOutput: AWSDecodableShape {
        /// Describes the replica/primary broker. Only returned if this broker is currently set as a primary or replica in the broker's dataReplicationRole property.
        public let dataReplicationCounterpart: DataReplicationCounterpart?
        /// Defines the role of this broker in a data replication pair. When a replica broker is promoted to primary, this role is interchanged.
        public let dataReplicationRole: String?

        @inlinable
        public init(dataReplicationCounterpart: DataReplicationCounterpart? = nil, dataReplicationRole: String? = nil) {
            self.dataReplicationCounterpart = dataReplicationCounterpart
            self.dataReplicationRole = dataReplicationRole
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationCounterpart = "dataReplicationCounterpart"
            case dataReplicationRole = "dataReplicationRole"
        }
    }

    public struct DeleteBrokerRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        @inlinable
        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrokerResponse: AWSDecodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?

        @inlinable
        public init(brokerId: String? = nil) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId = "brokerId"
        }
    }

    public struct DeleteTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String
        /// An array of tag keys to delete
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        @inlinable
        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            request.encodePath(self.username, key: "Username")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeBrokerEngineTypesRequest: AWSEncodableShape {
        /// Filter response by engine type.
        public let engineType: String?
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(engineType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.engineType, key: "engineType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerEngineTypesResponse: AWSDecodableShape {
        /// List of available engine types and versions.
        public let brokerEngineTypes: [BrokerEngineType]?
        /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(brokerEngineTypes: [BrokerEngineType]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerEngineTypes = brokerEngineTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEngineTypes = "brokerEngineTypes"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeBrokerInstanceOptionsRequest: AWSEncodableShape {
        /// Filter response by engine type.
        public let engineType: String?
        /// Filter response by host instance type.
        public let hostInstanceType: String?
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// Filter response by storage type.
        public let storageType: String?

        @inlinable
        public init(engineType: String? = nil, hostInstanceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, storageType: String? = nil) {
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.storageType = storageType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.engineType, key: "engineType")
            request.encodeQuery(self.hostInstanceType, key: "hostInstanceType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.storageType, key: "storageType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerInstanceOptionsResponse: AWSDecodableShape {
        /// List of available broker instance options.
        public let brokerInstanceOptions: [BrokerInstanceOption]?
        /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(brokerInstanceOptions: [BrokerInstanceOption]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerInstanceOptions = brokerInstanceOptions
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerInstanceOptions = "brokerInstanceOptions"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeBrokerRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        @inlinable
        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerResponse: AWSDecodableShape {
        /// Actions required for a broker.
        public let actionsRequired: [ActionRequired]?
        /// The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot.
        public let autoMinorVersionUpgrade: Bool?
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// A list of information about allocated brokers.
        public let brokerInstances: [BrokerInstance]?
        /// The broker's name. This value must be unique in your Amazon Web Services account account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String?
        /// The broker's status.
        public let brokerState: BrokerState?
        /// The list of all revisions for the specified configuration.
        public let configurations: Configurations?
        /// The time when the broker was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
        public let dataReplicationMetadata: DataReplicationMetadataOutput?
        /// Describes whether this broker is a part of a data replication pair.
        public let dataReplicationMode: DataReplicationMode?
        /// The broker's deployment mode.
        public let deploymentMode: DeploymentMode?
        /// Encryption options for the broker.
        public let encryptionOptions: EncryptionOptions?
        /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine version. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// The broker's instance type.
        public let hostInstanceType: String?
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        public let ldapServerMetadata: LdapServerMetadataOutput?
        /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
        public let logs: LogsSummary?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
        public let pendingAuthenticationStrategy: AuthenticationStrategy?
        /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
        public let pendingDataReplicationMetadata: DataReplicationMetadataOutput?
        /// Describes whether this broker will be a part of a data replication pair after reboot.
        public let pendingDataReplicationMode: DataReplicationMode?
        /// The broker engine version to upgrade to. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let pendingEngineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let pendingHostInstanceType: String?
        /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
        public let pendingLdapServerMetadata: LdapServerMetadataOutput?
        /// The list of pending security groups to authorize connections to brokers.
        public let pendingSecurityGroups: [String]?
        /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
        public let publiclyAccessible: Bool?
        /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
        public let securityGroups: [String]?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
        public let subnetIds: [String]?
        /// The list of all tags associated with this broker.
        public let tags: [String: String]?
        /// The list of all broker usernames for the specified broker.
        public let users: [UserSummary]?

        @inlinable
        public init(actionsRequired: [ActionRequired]? = nil, authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerArn: String? = nil, brokerId: String? = nil, brokerInstances: [BrokerInstance]? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, configurations: Configurations? = nil, created: Date? = nil, dataReplicationMetadata: DataReplicationMetadataOutput? = nil, dataReplicationMode: DataReplicationMode? = nil, deploymentMode: DeploymentMode? = nil, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: LogsSummary? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, pendingAuthenticationStrategy: AuthenticationStrategy? = nil, pendingDataReplicationMetadata: DataReplicationMetadataOutput? = nil, pendingDataReplicationMode: DataReplicationMode? = nil, pendingEngineVersion: String? = nil, pendingHostInstanceType: String? = nil, pendingLdapServerMetadata: LdapServerMetadataOutput? = nil, pendingSecurityGroups: [String]? = nil, publiclyAccessible: Bool? = nil, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [UserSummary]? = nil) {
            self.actionsRequired = actionsRequired
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerInstances = brokerInstances
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.configurations = configurations
            self.created = created
            self.dataReplicationMetadata = dataReplicationMetadata
            self.dataReplicationMode = dataReplicationMode
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
            self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
            self.pendingDataReplicationMode = pendingDataReplicationMode
            self.pendingEngineVersion = pendingEngineVersion
            self.pendingHostInstanceType = pendingHostInstanceType
            self.pendingLdapServerMetadata = pendingLdapServerMetadata
            self.pendingSecurityGroups = pendingSecurityGroups
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case actionsRequired = "actionsRequired"
            case authenticationStrategy = "authenticationStrategy"
            case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
            case brokerArn = "brokerArn"
            case brokerId = "brokerId"
            case brokerInstances = "brokerInstances"
            case brokerName = "brokerName"
            case brokerState = "brokerState"
            case configurations = "configurations"
            case created = "created"
            case dataReplicationMetadata = "dataReplicationMetadata"
            case dataReplicationMode = "dataReplicationMode"
            case deploymentMode = "deploymentMode"
            case encryptionOptions = "encryptionOptions"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case hostInstanceType = "hostInstanceType"
            case ldapServerMetadata = "ldapServerMetadata"
            case logs = "logs"
            case maintenanceWindowStartTime = "maintenanceWindowStartTime"
            case pendingAuthenticationStrategy = "pendingAuthenticationStrategy"
            case pendingDataReplicationMetadata = "pendingDataReplicationMetadata"
            case pendingDataReplicationMode = "pendingDataReplicationMode"
            case pendingEngineVersion = "pendingEngineVersion"
            case pendingHostInstanceType = "pendingHostInstanceType"
            case pendingLdapServerMetadata = "pendingLdapServerMetadata"
            case pendingSecurityGroups = "pendingSecurityGroups"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroups = "securityGroups"
            case storageType = "storageType"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case users = "users"
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String

        @inlinable
        public init(configurationId: String) {
            self.configurationId = configurationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationId, key: "ConfigurationId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        /// Required. The ARN of the configuration.
        public let arn: String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The description of the configuration.
        public let description: String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For a list of supported engine versions, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// Required. The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// The list of all tags associated with this configuration.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, description: String? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authenticationStrategy = "authenticationStrategy"
            case created = "created"
            case description = "description"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case id = "id"
            case latestRevision = "latestRevision"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// The revision of the configuration.
        public let configurationRevision: String

        @inlinable
        public init(configurationId: String, configurationRevision: String) {
            self.configurationId = configurationId
            self.configurationRevision = configurationRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationId, key: "ConfigurationId")
            request.encodePath(self.configurationRevision, key: "ConfigurationRevision")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Amazon MQ for ActiveMQ: the base64-encoded XML configuration. Amazon MQ for RabbitMQ: base64-encoded Cuttlefish.
        public let data: String?
        /// The description of the configuration.
        public let description: String?

        @inlinable
        public init(configurationId: String? = nil, created: Date? = nil, data: String? = nil, description: String? = nil) {
            self.configurationId = configurationId
            self.created = created
            self.data = data
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case created = "created"
            case data = "data"
            case description = "description"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        @inlinable
        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            request.encodePath(self.username, key: "Username")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// The status of the changes pending for the ActiveMQ user.
        public let pending: UserPendingChanges?
        /// Describes whether the user is intended for data replication
        public let replicationUser: Bool?
        /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String?

        @inlinable
        public init(brokerId: String? = nil, consoleAccess: Bool? = nil, groups: [String]? = nil, pending: UserPendingChanges? = nil, replicationUser: Bool? = nil, username: String? = nil) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pending = pending
            self.replicationUser = replicationUser
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId = "brokerId"
            case consoleAccess = "consoleAccess"
            case groups = "groups"
            case pending = "pending"
            case replicationUser = "replicationUser"
            case username = "username"
        }
    }

    public struct EncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The customer master key (CMK) to use for the A KMS (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public let kmsKeyId: String?
        /// Enables the use of an Amazon Web Services owned CMK using KMS (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        public let useAwsOwnedKey: Bool?

        @inlinable
        public init(kmsKeyId: String? = nil, useAwsOwnedKey: Bool? = nil) {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
            case useAwsOwnedKey = "useAwsOwnedKey"
        }
    }

    public struct EngineVersion: AWSDecodableShape {
        /// Id for the version.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct ForbiddenException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct InternalServerErrorException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct LdapServerMetadataInput: AWSEncodableShape {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        public let hosts: [String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        public let roleBase: String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountPassword: String?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountUsername: String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        public let userSearchMatching: String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        @inlinable
        public init(hosts: [String]? = nil, roleBase: String? = nil, roleName: String? = nil, roleSearchMatching: String? = nil, roleSearchSubtree: Bool? = nil, serviceAccountPassword: String? = nil, serviceAccountUsername: String? = nil, userBase: String? = nil, userRoleName: String? = nil, userSearchMatching: String? = nil, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts = "hosts"
            case roleBase = "roleBase"
            case roleName = "roleName"
            case roleSearchMatching = "roleSearchMatching"
            case roleSearchSubtree = "roleSearchSubtree"
            case serviceAccountPassword = "serviceAccountPassword"
            case serviceAccountUsername = "serviceAccountUsername"
            case userBase = "userBase"
            case userRoleName = "userRoleName"
            case userSearchMatching = "userSearchMatching"
            case userSearchSubtree = "userSearchSubtree"
        }
    }

    public struct LdapServerMetadataOutput: AWSDecodableShape {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        public let hosts: [String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        public let roleBase: String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountUsername: String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        public let userSearchMatching: String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        @inlinable
        public init(hosts: [String]? = nil, roleBase: String? = nil, roleName: String? = nil, roleSearchMatching: String? = nil, roleSearchSubtree: Bool? = nil, serviceAccountUsername: String? = nil, userBase: String? = nil, userRoleName: String? = nil, userSearchMatching: String? = nil, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts = "hosts"
            case roleBase = "roleBase"
            case roleName = "roleName"
            case roleSearchMatching = "roleSearchMatching"
            case roleSearchSubtree = "roleSearchSubtree"
            case serviceAccountUsername = "serviceAccountUsername"
            case userBase = "userBase"
            case userRoleName = "userRoleName"
            case userSearchMatching = "userSearchMatching"
            case userSearchSubtree = "userSearchSubtree"
        }
    }

    public struct ListBrokersRequest: AWSEncodableShape {
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrokersResponse: AWSDecodableShape {
        /// A list of information about all brokers.
        public let brokerSummaries: [BrokerSummary]?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(brokerSummaries: [BrokerSummary]? = nil, nextToken: String? = nil) {
            self.brokerSummaries = brokerSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerSummaries = "brokerSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(configurationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationId, key: "ConfigurationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String?
        /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// The list of all revisions for the specified configuration.
        public let revisions: [ConfigurationRevision]?

        @inlinable
        public init(configurationId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case revisions = "revisions"
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// The list of all revisions for the specified configuration.
        public let configurations: [Configuration]?
        /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(configurations: [Configuration]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "configurations"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        @inlinable
        public init(brokerId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
        public let users: [UserSummary]?

        @inlinable
        public init(brokerId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, users: [UserSummary]? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId = "brokerId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case users = "users"
        }
    }

    public struct Logs: AWSEncodableShape & AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        @inlinable
        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit = "audit"
            case general = "general"
        }
    }

    public struct LogsSummary: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public let auditLogGroup: String?
        /// Enables general logging.
        public let general: Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        public let generalLogGroup: String?
        /// The list of information about logs pending to be deployed for the specified broker.
        public let pending: PendingLogs?

        @inlinable
        public init(audit: Bool? = nil, auditLogGroup: String? = nil, general: Bool? = nil, generalLogGroup: String? = nil, pending: PendingLogs? = nil) {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case audit = "audit"
            case auditLogGroup = "auditLogGroup"
            case general = "general"
            case generalLogGroup = "generalLogGroup"
            case pending = "pending"
        }
    }

    public struct NotFoundException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct PendingLogs: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        @inlinable
        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit = "audit"
            case general = "general"
        }
    }

    public struct PromoteRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The Promote mode requested. Note: Valid values for the parameter are SWITCHOVER, FAILOVER.
        public let mode: PromoteMode?

        @inlinable
        public init(brokerId: String, mode: PromoteMode? = nil) {
            self.brokerId = brokerId
            self.mode = mode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            try container.encodeIfPresent(self.mode, forKey: .mode)
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
        }
    }

    public struct PromoteResponse: AWSDecodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?

        @inlinable
        public init(brokerId: String? = nil) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId = "brokerId"
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        @inlinable
        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct SanitizationWarning: AWSDecodableShape {
        /// The name of the configuration attribute that has been sanitized.
        public let attributeName: String?
        /// The name of the configuration element that has been sanitized.
        public let elementName: String?
        /// The reason for which the configuration elements or attributes were sanitized.
        public let reason: SanitizationWarningReason?

        @inlinable
        public init(attributeName: String? = nil, elementName: String? = nil, reason: SanitizationWarningReason? = nil) {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case elementName = "elementName"
            case reason = "reason"
        }
    }

    public struct UnauthorizedException: AWSErrorShape {
        /// The attribute which caused the error.
        public let errorAttribute: String?
        /// The explanation of the error.
        public let message: String?

        @inlinable
        public init(errorAttribute: String? = nil, message: String? = nil) {
            self.errorAttribute = errorAttribute
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorAttribute = "errorAttribute"
            case message = "message"
        }
    }

    public struct UpdateBrokerRequest: AWSEncodableShape {
        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot. Must be set to true for ActiveMQ brokers version 5.18 and above and for RabbitMQ brokers version 3.13 and above.
        public let autoMinorVersionUpgrade: Bool?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// A list of information about the configuration.
        public let configuration: ConfigurationId?
        /// Defines whether this broker is a part of a data replication pair.
        public let dataReplicationMode: DataReplicationMode?
        /// The broker engine version. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide. When upgrading to ActiveMQ version 5.18 and above or RabbitMQ version 3.13 and above, you must have autoMinorVersionUpgrade set to true for the broker.
        public let engineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let hostInstanceType: String?
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataInput?
        /// Enables Amazon CloudWatch logging for brokers.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        public let securityGroups: [String]?

        @inlinable
        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String, configuration: ConfigurationId? = nil, dataReplicationMode: DataReplicationMode? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.dataReplicationMode = dataReplicationMode
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.securityGroups = securityGroups
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authenticationStrategy, forKey: .authenticationStrategy)
            try container.encodeIfPresent(self.autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
            request.encodePath(self.brokerId, key: "BrokerId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.dataReplicationMode, forKey: .dataReplicationMode)
            try container.encodeIfPresent(self.engineVersion, forKey: .engineVersion)
            try container.encodeIfPresent(self.hostInstanceType, forKey: .hostInstanceType)
            try container.encodeIfPresent(self.ldapServerMetadata, forKey: .ldapServerMetadata)
            try container.encodeIfPresent(self.logs, forKey: .logs)
            try container.encodeIfPresent(self.maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
            try container.encodeIfPresent(self.securityGroups, forKey: .securityGroups)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy = "authenticationStrategy"
            case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
            case configuration = "configuration"
            case dataReplicationMode = "dataReplicationMode"
            case engineVersion = "engineVersion"
            case hostInstanceType = "hostInstanceType"
            case ldapServerMetadata = "ldapServerMetadata"
            case logs = "logs"
            case maintenanceWindowStartTime = "maintenanceWindowStartTime"
            case securityGroups = "securityGroups"
        }
    }

    public struct UpdateBrokerResponse: AWSDecodableShape {
        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot.
        public let autoMinorVersionUpgrade: Bool?
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The ID of the updated configuration.
        public let configuration: ConfigurationId?
        /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
        public let dataReplicationMetadata: DataReplicationMetadataOutput?
        /// Describes whether this broker is a part of a data replication pair.
        public let dataReplicationMode: DataReplicationMode?
        /// The broker engine version to upgrade to. For more information, see the ActiveMQ version management and the RabbitMQ version management sections in the Amazon MQ Developer Guide.
        public let engineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let hostInstanceType: String?
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataOutput?
        /// The list of information about logs to be enabled for the specified broker.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
        public let pendingDataReplicationMetadata: DataReplicationMetadataOutput?
        /// Describes whether this broker will be a part of a data replication pair after reboot.
        public let pendingDataReplicationMode: DataReplicationMode?
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        public let securityGroups: [String]?

        @inlinable
        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String? = nil, configuration: ConfigurationId? = nil, dataReplicationMetadata: DataReplicationMetadataOutput? = nil, dataReplicationMode: DataReplicationMode? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, pendingDataReplicationMetadata: DataReplicationMetadataOutput? = nil, pendingDataReplicationMode: DataReplicationMode? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.dataReplicationMetadata = dataReplicationMetadata
            self.dataReplicationMode = dataReplicationMode
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
            self.pendingDataReplicationMode = pendingDataReplicationMode
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy = "authenticationStrategy"
            case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
            case brokerId = "brokerId"
            case configuration = "configuration"
            case dataReplicationMetadata = "dataReplicationMetadata"
            case dataReplicationMode = "dataReplicationMode"
            case engineVersion = "engineVersion"
            case hostInstanceType = "hostInstanceType"
            case ldapServerMetadata = "ldapServerMetadata"
            case logs = "logs"
            case maintenanceWindowStartTime = "maintenanceWindowStartTime"
            case pendingDataReplicationMetadata = "pendingDataReplicationMetadata"
            case pendingDataReplicationMode = "pendingDataReplicationMode"
            case securityGroups = "securityGroups"
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// Amazon MQ for Active MQ: The base64-encoded XML configuration. Amazon MQ for RabbitMQ: the base64-encoded Cuttlefish configuration.
        public let data: String?
        /// The description of the configuration.
        public let description: String?

        @inlinable
        public init(configurationId: String, data: String? = nil, description: String? = nil) {
            self.configurationId = configurationId
            self.data = data
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationId, key: "ConfigurationId")
            try container.encodeIfPresent(self.data, forKey: .data)
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case description = "description"
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// The list of the first 20 warnings about the configuration elements or attributes that were sanitized.
        public let warnings: [SanitizationWarning]?

        @inlinable
        public init(arn: String? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, warnings: [SanitizationWarning]? = nil) {
            self.arn = arn
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case created = "created"
            case id = "id"
            case latestRevision = "latestRevision"
            case name = "name"
            case warnings = "warnings"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String?
        /// Defines whether the user is intended for data replication.
        public let replicationUser: Bool?
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        @inlinable
        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String? = nil, replicationUser: Bool? = nil, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.replicationUser = replicationUser
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.brokerId, key: "BrokerId")
            try container.encodeIfPresent(self.consoleAccess, forKey: .consoleAccess)
            try container.encodeIfPresent(self.groups, forKey: .groups)
            try container.encodeIfPresent(self.password, forKey: .password)
            try container.encodeIfPresent(self.replicationUser, forKey: .replicationUser)
            request.encodePath(self.username, key: "Username")
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess = "consoleAccess"
            case groups = "groups"
            case password = "password"
            case replicationUser = "replicationUser"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct User: AWSEncodableShape {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public let groups: [String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String?
        /// Defines if this user is intended for CRDR replication purposes.
        public let replicationUser: Bool?
        /// The username of the broker user. The following restrictions apply to broker usernames: For Amazon MQ for ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. para>For Amazon MQ for RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long. Do not add personally identifiable information (PII) or other confidential or sensitive information in broker usernames. Broker usernames are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker usernames are not intended to be used for private or sensitive data.
        public let username: String?

        @inlinable
        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, password: String? = nil, replicationUser: Bool? = nil, username: String? = nil) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.replicationUser = replicationUser
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess = "consoleAccess"
            case groups = "groups"
            case password = "password"
            case replicationUser = "replicationUser"
            case username = "username"
        }
    }

    public struct UserPendingChanges: AWSDecodableShape {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// Required. The type of change pending for the ActiveMQ user.
        public let pendingChange: ChangeType?

        @inlinable
        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, pendingChange: ChangeType? = nil) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess = "consoleAccess"
            case groups = "groups"
            case pendingChange = "pendingChange"
        }
    }

    public struct UserSummary: AWSDecodableShape {
        /// The type of change pending for the broker user.
        public let pendingChange: ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String?

        @inlinable
        public init(pendingChange: ChangeType? = nil, username: String? = nil) {
            self.pendingChange = pendingChange
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case pendingChange = "pendingChange"
            case username = "username"
        }
    }

    public struct WeeklyStartTime: AWSEncodableShape & AWSDecodableShape {
        /// Required. The day of the week.
        public let dayOfWeek: DayOfWeek?
        /// Required. The time, in 24-hour format.
        public let timeOfDay: String?
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public let timeZone: String?

        @inlinable
        public init(dayOfWeek: DayOfWeek? = nil, timeOfDay: String? = nil, timeZone: String? = nil) {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek = "dayOfWeek"
            case timeOfDay = "timeOfDay"
            case timeZone = "timeZone"
        }
    }
}

// MARK: - Errors

/// Error enum for MQ
public struct MQErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MQ
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returns information about an error.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Returns information about an error.
    public static var conflictException: Self { .init(.conflictException) }
    /// Returns information about an error.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// Returns information about an error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// Returns information about an error.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// Returns information about an error.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension MQErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "BadRequestException": MQ.BadRequestException.self,
        "ConflictException": MQ.ConflictException.self,
        "ForbiddenException": MQ.ForbiddenException.self,
        "InternalServerErrorException": MQ.InternalServerErrorException.self,
        "NotFoundException": MQ.NotFoundException.self,
        "UnauthorizedException": MQ.UnauthorizedException.self
    ]
}

extension MQErrorType: Equatable {
    public static func == (lhs: MQErrorType, rhs: MQErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MQErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
