//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension MQ {
    // MARK: Enums

    public enum AuthenticationStrategy: String, CustomStringConvertible, Codable, _SotoSendable {
        case ldap = "LDAP"
        case simple = "SIMPLE"
        public var description: String { return self.rawValue }
    }

    public enum BrokerState: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case criticalActionRequired = "CRITICAL_ACTION_REQUIRED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case rebootInProgress = "REBOOT_IN_PROGRESS"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BrokerStorageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ebs = "EBS"
        case efs = "EFS"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, _SotoSendable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case activeStandbyMultiAz = "ACTIVE_STANDBY_MULTI_AZ"
        case clusterMultiAz = "CLUSTER_MULTI_AZ"
        case singleInstance = "SINGLE_INSTANCE"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable, _SotoSendable {
        case activemq = "ACTIVEMQ"
        case rabbitmq = "RABBITMQ"
        public var description: String { return self.rawValue }
    }

    public enum SanitizationWarningReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case disallowedAttributeRemoved = "DISALLOWED_ATTRIBUTE_REMOVED"
        case disallowedElementRemoved = "DISALLOWED_ELEMENT_REMOVED"
        case invalidAttributeValueRemoved = "INVALID_ATTRIBUTE_VALUE_REMOVED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActionRequired: AWSDecodableShape {
        /// The code you can use to resolve your broker issue when the broker is in a CRITICAL_ACTION_REQUIRED state. You can find instructions by choosing the link for your code from the list of action required codes in Amazon MQ action required codes. Each code references a topic with detailed information, instructions, and recommendations for how to resolve the issue and prevent future occurrences.
        public let actionRequiredCode: String?
        /// Information about the action required to resolve your broker issue when the broker is in a CRITICAL_ACTION_REQUIRED state.
        public let actionRequiredInfo: String?

        public init(actionRequiredCode: String? = nil, actionRequiredInfo: String? = nil) {
            self.actionRequiredCode = actionRequiredCode
            self.actionRequiredInfo = actionRequiredInfo
        }

        private enum CodingKeys: String, CodingKey {
            case actionRequiredCode
            case actionRequiredInfo
        }
    }

    public struct AvailabilityZone: AWSDecodableShape {
        /// Id for the availability zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct BrokerEngineType: AWSDecodableShape {
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The list of engine versions.
        public let engineVersions: [EngineVersion]?

        public init(engineType: EngineType? = nil, engineVersions: [EngineVersion]? = nil) {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case engineType
            case engineVersions
        }
    }

    public struct BrokerInstance: AWSDecodableShape {
        /// The brokers web console URL.
        public let consoleURL: String?
        /// The broker's wire-level protocol endpoints.
        public let endpoints: [String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public let ipAddress: String?

        public init(consoleURL: String? = nil, endpoints: [String]? = nil, ipAddress: String? = nil) {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }

        private enum CodingKeys: String, CodingKey {
            case consoleURL
            case endpoints
            case ipAddress
        }
    }

    public struct BrokerInstanceOption: AWSDecodableShape {
        /// The list of available az.
        public let availabilityZones: [AvailabilityZone]?
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The broker's instance type.
        public let hostInstanceType: String?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of supported deployment modes.
        public let supportedDeploymentModes: [DeploymentMode]?
        /// The list of supported engine versions.
        public let supportedEngineVersions: [String]?

        public init(availabilityZones: [AvailabilityZone]? = nil, engineType: EngineType? = nil, hostInstanceType: String? = nil, storageType: BrokerStorageType? = nil, supportedDeploymentModes: [DeploymentMode]? = nil, supportedEngineVersions: [String]? = nil) {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones
            case engineType
            case hostInstanceType
            case storageType
            case supportedDeploymentModes
            case supportedEngineVersions
        }
    }

    public struct BrokerSummary: AWSDecodableShape {
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The broker's name. This value is unique in your AWS account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String?
        /// The broker's status.
        public let brokerState: BrokerState?
        /// The time when the broker was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The broker's deployment mode.
        public let deploymentMode: DeploymentMode
        /// The type of broker engine.
        public let engineType: EngineType
        /// The broker's instance type.
        public let hostInstanceType: String?

        public init(brokerArn: String? = nil, brokerId: String? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, created: Date? = nil, deploymentMode: DeploymentMode, engineType: EngineType, hostInstanceType: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn
            case brokerId
            case brokerName
            case brokerState
            case created
            case deploymentMode
            case engineType
            case hostInstanceType
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// Required. The ARN of the configuration.
        public let arn: String
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy
        /// Required. The date and time of the configuration revision.
        @CustomCoding<ISO8601DateCoder>
        public var created: Date
        /// Required. The description of the configuration.
        public let description: String
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType
        /// Required. The broker engine's version. For a list of supported engine versions, see, Supported engines.
        public let engineVersion: String
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String
        /// Required. The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String
        /// The list of all tags associated with this configuration.
        public let tags: [String: String]?

        public init(arn: String, authenticationStrategy: AuthenticationStrategy, created: Date, description: String, engineType: EngineType, engineVersion: String, id: String, latestRevision: ConfigurationRevision, name: String, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case description
            case engineType
            case engineVersion
            case id
            case latestRevision
            case name
            case tags
        }
    }

    public struct ConfigurationId: AWSEncodableShape & AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String
        /// The revision number of the configuration.
        public let revision: Int?

        public init(id: String, revision: Int? = nil) {
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case revision
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// Required. The date and time of the configuration revision.
        @CustomCoding<ISO8601DateCoder>
        public var created: Date
        /// The description of the configuration revision.
        public let description: String?
        /// Required. The revision number of the configuration.
        public let revision: Int

        public init(created: Date, description: String? = nil, revision: Int) {
            self.created = created
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case created
            case description
            case revision
        }
    }

    public struct Configurations: AWSDecodableShape {
        /// The broker's current configuration.
        public let current: ConfigurationId?
        /// The history of configurations applied to the broker.
        public let history: [ConfigurationId]?
        /// The broker's pending configuration.
        public let pending: ConfigurationId?

        public init(current: ConfigurationId? = nil, history: [ConfigurationId]? = nil, pending: ConfigurationId? = nil) {
            self.current = current
            self.history = history
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case current
            case history
            case pending
        }
    }

    public struct CreateBrokerRequest: AWSEncodableShape {
        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot. Set to true by default, if no value is specified.
        public let autoMinorVersionUpgrade: Bool
        /// Required. The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String
        /// A list of information about the configuration.
        public let configuration: ConfigurationId?
        /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. Note: We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
        public let creatorRequestId: String?
        /// Required. The broker's deployment mode.
        public let deploymentMode: DeploymentMode
        /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
        public let encryptionOptions: EncryptionOptions?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType
        /// Required. The broker engine's version. For a list of supported engine versions, see Supported engines.
        public let engineVersion: String
        /// Required. The broker's instance type.
        public let hostInstanceType: String
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataInput?
        /// Enables Amazon CloudWatch logging for brokers.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
        public let publiclyAccessible: Bool
        /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
        public let securityGroups: [String]?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a shared VPC for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your AWS account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your AWS account.
        public let subnetIds: [String]?
        /// Create tags when creating the broker.
        public let tags: [String: String]?
        /// Required. The list of broker users (persons or applications) who can access queues and topics. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Amazon MQ for RabbitMQ When you create an Amazon MQ for RabbitMQ broker, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
        public let users: [User]

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool, brokerName: String, configuration: ConfigurationId? = nil, creatorRequestId: String? = CreateBrokerRequest.idempotencyToken(), deploymentMode: DeploymentMode, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType, engineVersion: String, hostInstanceType: String, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, publiclyAccessible: Bool, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [User]) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerName = brokerName
            self.configuration = configuration
            self.creatorRequestId = creatorRequestId
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerName
            case configuration
            case creatorRequestId
            case deploymentMode
            case encryptionOptions
            case engineType
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case publiclyAccessible
            case securityGroups
            case storageType
            case subnetIds
            case tags
            case users
        }
    }

    public struct CreateBrokerResponse: AWSDecodableShape {
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?

        public init(brokerArn: String? = nil, brokerId: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn
            case brokerId
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType
        /// Required. The broker engine's version. For a list of supported engine versions, see Supported engines.
        public let engineVersion: String
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String
        /// Create tags when creating the configuration.
        public let tags: [String: String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, engineType: EngineType, engineVersion: String, name: String, tags: [String: String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case engineType
            case engineVersion
            case name
            case tags
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        /// Required. The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?

        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case id
            case latestRevision
            case name
        }
    }

    public struct CreateTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId")),
            AWSMemberEncoding(label: "username", location: .uri("Username"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrokerResponse: AWSDecodableShape {
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?

        public init(brokerId: String? = nil) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
        }
    }

    public struct DeleteTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String
        /// An array of tag keys to delete
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId")),
            AWSMemberEncoding(label: "username", location: .uri("Username"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeBrokerEngineTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring("engineType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Filter response by engine type.
        public let engineType: String?
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(engineType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerEngineTypesResponse: AWSDecodableShape {
        /// List of available engine types and versions.
        public let brokerEngineTypes: [BrokerEngineType]?
        /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(brokerEngineTypes: [BrokerEngineType]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerEngineTypes = brokerEngineTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEngineTypes
            case maxResults
            case nextToken
        }
    }

    public struct DescribeBrokerInstanceOptionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring("engineType")),
            AWSMemberEncoding(label: "hostInstanceType", location: .querystring("hostInstanceType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "storageType", location: .querystring("storageType"))
        ]

        /// Filter response by engine type.
        public let engineType: String?
        /// Filter response by host instance type.
        public let hostInstanceType: String?
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// Filter response by storage type.
        public let storageType: String?

        public init(engineType: String? = nil, hostInstanceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, storageType: String? = nil) {
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerInstanceOptionsResponse: AWSDecodableShape {
        /// List of available broker instance options.
        public let brokerInstanceOptions: [BrokerInstanceOption]?
        /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(brokerInstanceOptions: [BrokerInstanceOption]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerInstanceOptions = brokerInstanceOptions
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerInstanceOptions
            case maxResults
            case nextToken
        }
    }

    public struct DescribeBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerResponse: AWSDecodableShape {
        /// A list of actions required for a broker.
        public let actionsRequired: [ActionRequired]?
        /// The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
        public let autoMinorVersionUpgrade: Bool?
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// A list of information about allocated brokers.
        public let brokerInstances: [BrokerInstance]?
        /// The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String?
        /// The broker's status.
        public let brokerState: BrokerState?
        /// The list of all revisions for the specified configuration.
        public let configurations: Configurations?
        /// The time when the broker was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The broker's deployment mode.
        public let deploymentMode: DeploymentMode?
        /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
        public let encryptionOptions: EncryptionOptions?
        /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// The broker engine's version. For a list of supported engine versions, see Supported engines.
        public let engineVersion: String?
        /// The broker's instance type.
        public let hostInstanceType: String?
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        public let ldapServerMetadata: LdapServerMetadataOutput?
        /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
        public let logs: LogsSummary?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
        public let pendingAuthenticationStrategy: AuthenticationStrategy?
        /// The broker engine version to upgrade to. For a list of supported engine versions, see Supported engines.
        public let pendingEngineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let pendingHostInstanceType: String?
        /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
        public let pendingLdapServerMetadata: LdapServerMetadataOutput?
        /// The list of pending security groups to authorize connections to brokers.
        public let pendingSecurityGroups: [String]?
        /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
        public let publiclyAccessible: Bool?
        /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
        public let securityGroups: [String]?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
        public let subnetIds: [String]?
        /// The list of all tags associated with this broker.
        public let tags: [String: String]?
        /// The list of all broker usernames for the specified broker.
        public let users: [UserSummary]?

        public init(actionsRequired: [ActionRequired]? = nil, authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerArn: String? = nil, brokerId: String? = nil, brokerInstances: [BrokerInstance]? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, configurations: Configurations? = nil, created: Date? = nil, deploymentMode: DeploymentMode? = nil, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: LogsSummary? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, pendingAuthenticationStrategy: AuthenticationStrategy? = nil, pendingEngineVersion: String? = nil, pendingHostInstanceType: String? = nil, pendingLdapServerMetadata: LdapServerMetadataOutput? = nil, pendingSecurityGroups: [String]? = nil, publiclyAccessible: Bool? = nil, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [UserSummary]? = nil) {
            self.actionsRequired = actionsRequired
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerInstances = brokerInstances
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.configurations = configurations
            self.created = created
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
            self.pendingEngineVersion = pendingEngineVersion
            self.pendingHostInstanceType = pendingHostInstanceType
            self.pendingLdapServerMetadata = pendingLdapServerMetadata
            self.pendingSecurityGroups = pendingSecurityGroups
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case actionsRequired
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerArn
            case brokerId
            case brokerInstances
            case brokerName
            case brokerState
            case configurations
            case created
            case deploymentMode
            case encryptionOptions
            case engineType
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case pendingAuthenticationStrategy
            case pendingEngineVersion
            case pendingHostInstanceType
            case pendingLdapServerMetadata
            case pendingSecurityGroups
            case publiclyAccessible
            case securityGroups
            case storageType
            case subnetIds
            case tags
            case users
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri("ConfigurationId"))
        ]

        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String

        public init(configurationId: String) {
            self.configurationId = configurationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        /// Required. The ARN of the configuration.
        public let arn: String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The description of the configuration.
        public let description: String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType?
        /// Required. The broker engine's version. For a list of supported engine versions, see, Supported engines.
        public let engineVersion: String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// Required. The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// The list of all tags associated with this configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, description: String? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case description
            case engineType
            case engineVersion
            case id
            case latestRevision
            case name
            case tags
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri("ConfigurationId")),
            AWSMemberEncoding(label: "configurationRevision", location: .uri("ConfigurationRevision"))
        ]

        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// The revision of the configuration.
        public let configurationRevision: String

        public init(configurationId: String, configurationRevision: String) {
            self.configurationId = configurationId
            self.configurationRevision = configurationRevision
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The base64-encoded XML configuration.
        public let data: String?
        /// The description of the configuration.
        public let description: String?

        public init(configurationId: String? = nil, created: Date? = nil, data: String? = nil, description: String? = nil) {
            self.configurationId = configurationId
            self.created = created
            self.data = data
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId
            case created
            case data
            case description
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId")),
            AWSMemberEncoding(label: "username", location: .uri("Username"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// The status of the changes pending for the ActiveMQ user.
        public let pending: UserPendingChanges?
        /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String?

        public init(brokerId: String? = nil, consoleAccess: Bool? = nil, groups: [String]? = nil, pending: UserPendingChanges? = nil, username: String? = nil) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pending = pending
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
            case consoleAccess
            case groups
            case pending
            case username
        }
    }

    public struct EncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The customer master key (CMK) to use for the AWS Key Management Service (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public let kmsKeyId: String?
        /// Enables the use of an AWS owned CMK using AWS Key Management Service (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        public let useAwsOwnedKey: Bool

        public init(kmsKeyId: String? = nil, useAwsOwnedKey: Bool) {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId
            case useAwsOwnedKey
        }
    }

    public struct EngineVersion: AWSDecodableShape {
        /// Id for the version.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct LdapServerMetadataInput: AWSEncodableShape {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        public let hosts: [String]
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        public let roleBase: String
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountPassword: String
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountUsername: String
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        public let userSearchMatching: String
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        public init(hosts: [String], roleBase: String, roleName: String? = nil, roleSearchMatching: String, roleSearchSubtree: Bool? = nil, serviceAccountPassword: String, serviceAccountUsername: String, userBase: String, userRoleName: String? = nil, userSearchMatching: String, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts
            case roleBase
            case roleName
            case roleSearchMatching
            case roleSearchSubtree
            case serviceAccountPassword
            case serviceAccountUsername
            case userBase
            case userRoleName
            case userSearchMatching
            case userSearchSubtree
        }
    }

    public struct LdapServerMetadataOutput: AWSDecodableShape {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        public let hosts: [String]
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        public let roleBase: String
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        public let serviceAccountUsername: String
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        public let userSearchMatching: String
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        public init(hosts: [String], roleBase: String, roleName: String? = nil, roleSearchMatching: String, roleSearchSubtree: Bool? = nil, serviceAccountUsername: String, userBase: String, userRoleName: String? = nil, userSearchMatching: String, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts
            case roleBase
            case roleName
            case roleSearchMatching
            case roleSearchSubtree
            case serviceAccountUsername
            case userBase
            case userRoleName
            case userSearchMatching
            case userSearchSubtree
        }
    }

    public struct ListBrokersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrokersResponse: AWSDecodableShape {
        /// A list of information about all brokers.
        public let brokerSummaries: [BrokerSummary]?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(brokerSummaries: [BrokerSummary]? = nil, nextToken: String? = nil) {
            self.brokerSummaries = brokerSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerSummaries
            case nextToken
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri("ConfigurationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(configurationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String?
        /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// The list of all revisions for the specified configuration.
        public let revisions: [ConfigurationRevision]?

        public init(configurationId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId
            case maxResults
            case nextToken
            case revisions
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// The list of all revisions for the specified configuration.
        public let configurations: [Configuration]?
        /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations
            case maxResults
            case nextToken
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource tag.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?

        public init(brokerId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        public let maxResults: Int?
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        public let nextToken: String?
        /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
        public let users: [UserSummary]?

        public init(brokerId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, users: [UserSummary]? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
            case maxResults
            case nextToken
            case users
        }
    }

    public struct Logs: AWSEncodableShape & AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case general
        }
    }

    public struct LogsSummary: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public let auditLogGroup: String?
        /// Enables general logging.
        public let general: Bool
        /// The location of the CloudWatch Logs log group where general logs are sent.
        public let generalLogGroup: String
        /// The list of information about logs pending to be deployed for the specified broker.
        public let pending: PendingLogs?

        public init(audit: Bool? = nil, auditLogGroup: String? = nil, general: Bool, generalLogGroup: String, pending: PendingLogs? = nil) {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case auditLogGroup
            case general
            case generalLogGroup
            case pending
        }
    }

    public struct PendingLogs: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case general
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct SanitizationWarning: AWSDecodableShape {
        /// The name of the XML attribute that has been sanitized.
        public let attributeName: String?
        /// The name of the XML element that has been sanitized.
        public let elementName: String?
        /// Required. The reason for which the XML elements or attributes were sanitized.
        public let reason: SanitizationWarningReason

        public init(attributeName: String? = nil, elementName: String? = nil, reason: SanitizationWarningReason) {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case elementName
            case reason
        }
    }

    public struct UpdateBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId"))
        ]

        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
        public let autoMinorVersionUpgrade: Bool?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// A list of information about the configuration.
        public let configuration: ConfigurationId?
        /// The broker engine version. For a list of supported engine versions, see Supported engines.
        public let engineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let hostInstanceType: String?
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataInput?
        /// Enables Amazon CloudWatch logging for brokers.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        public let securityGroups: [String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String, configuration: ConfigurationId? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case configuration
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case securityGroups
        }
    }

    public struct UpdateBrokerResponse: AWSDecodableShape {
        /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy?
        /// The new boolean value that specifies whether broker engines automatically upgrade to new minor versions as new versions are released and supported by Amazon MQ.
        public let autoMinorVersionUpgrade: Bool?
        /// Required. The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The ID of the updated configuration.
        public let configuration: ConfigurationId?
        /// The broker engine version to upgrade to. For a list of supported engine versions, see Supported engines.
        public let engineVersion: String?
        /// The broker's host instance type to upgrade to. For a list of supported instance types, see Broker instance types.
        public let hostInstanceType: String?
        /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
        public let ldapServerMetadata: LdapServerMetadataOutput?
        /// The list of information about logs to be enabled for the specified broker.
        public let logs: Logs?
        /// The parameters that determine the WeeklyStartTime.
        public let maintenanceWindowStartTime: WeeklyStartTime?
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        public let securityGroups: [String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String? = nil, configuration: ConfigurationId? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerId
            case configuration
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case securityGroups
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri("ConfigurationId"))
        ]

        /// The unique ID that Amazon MQ generates for the configuration.
        public let configurationId: String
        /// Required. The base64-encoded XML configuration.
        public let data: String
        /// The description of the configuration.
        public let description: String?

        public init(configurationId: String, data: String, description: String? = nil) {
            self.configurationId = configurationId
            self.data = data
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case description
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        /// Required. The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Required. The date and time of the configuration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String?
        /// The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String?
        /// The list of the first 20 warnings about the configuration XML elements or attributes that were sanitized.
        public let warnings: [SanitizationWarning]?

        public init(arn: String? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, warnings: [SanitizationWarning]? = nil) {
            self.arn = arn
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case created
            case id
            case latestRevision
            case name
            case warnings
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri("BrokerId")),
            AWSMemberEncoding(label: "username", location: .uri("Username"))
        ]

        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String?
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String? = nil, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct User: AWSEncodableShape {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public let groups: [String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String
        /// important>Amazon MQ for ActiveMQ For ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long./important> Amazon MQ for RabbitMQ For RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
        public let username: String

        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, password: String, username: String) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
            case username
        }
    }

    public struct UserPendingChanges: AWSDecodableShape {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// Required. The type of change pending for the ActiveMQ user.
        public let pendingChange: ChangeType

        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, pendingChange: ChangeType) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case pendingChange
        }
    }

    public struct UserSummary: AWSDecodableShape {
        /// The type of change pending for the broker user.
        public let pendingChange: ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(pendingChange: ChangeType? = nil, username: String) {
            self.pendingChange = pendingChange
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case pendingChange
            case username
        }
    }

    public struct WeeklyStartTime: AWSEncodableShape & AWSDecodableShape {
        /// Required. The day of the week.
        public let dayOfWeek: DayOfWeek
        /// Required. The time, in 24-hour format.
        public let timeOfDay: String
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public let timeZone: String?

        public init(dayOfWeek: DayOfWeek, timeOfDay: String, timeZone: String? = nil) {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek
            case timeOfDay
            case timeZone
        }
    }
}

// MARK: - Errors

/// Error enum for MQ
public struct MQErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MQ
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returns information about an error.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Returns information about an error.
    public static var conflictException: Self { .init(.conflictException) }
    /// Returns information about an error.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// Returns information about an error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// Returns information about an error.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// Returns information about an error.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension MQErrorType: Equatable {
    public static func == (lhs: MQErrorType, rhs: MQErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MQErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
