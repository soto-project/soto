//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension MQ {
    // MARK: Enums

    public enum AuthenticationStrategy: String, CustomStringConvertible, Codable {
        case ldap = "LDAP"
        case simple = "SIMPLE"
        public var description: String { return self.rawValue }
    }

    public enum BrokerState: String, CustomStringConvertible, Codable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case rebootInProgress = "REBOOT_IN_PROGRESS"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BrokerStorageType: String, CustomStringConvertible, Codable {
        case ebs = "EBS"
        case efs = "EFS"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentMode: String, CustomStringConvertible, Codable {
        case activeStandbyMultiAz = "ACTIVE_STANDBY_MULTI_AZ"
        case clusterMultiAz = "CLUSTER_MULTI_AZ"
        case singleInstance = "SINGLE_INSTANCE"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable {
        case activemq = "ACTIVEMQ"
        case rabbitmq = "RABBITMQ"
        public var description: String { return self.rawValue }
    }

    public enum SanitizationWarningReason: String, CustomStringConvertible, Codable {
        case disallowedAttributeRemoved = "DISALLOWED_ATTRIBUTE_REMOVED"
        case disallowedElementRemoved = "DISALLOWED_ELEMENT_REMOVED"
        case invalidAttributeValueRemoved = "INVALID_ATTRIBUTE_VALUE_REMOVED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AvailabilityZone: AWSDecodableShape {
        /// Id for the availability zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct BrokerEngineType: AWSDecodableShape {
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The list of engine versions.
        public let engineVersions: [EngineVersion]?

        public init(engineType: EngineType? = nil, engineVersions: [EngineVersion]? = nil) {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case engineType
            case engineVersions
        }
    }

    public struct BrokerInstance: AWSDecodableShape {
        /// The brokers web console URL.
        public let consoleURL: String?
        /// The broker's wire-level protocol endpoints.
        public let endpoints: [String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public let ipAddress: String?

        public init(consoleURL: String? = nil, endpoints: [String]? = nil, ipAddress: String? = nil) {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }

        private enum CodingKeys: String, CodingKey {
            case consoleURL
            case endpoints
            case ipAddress
        }
    }

    public struct BrokerInstanceOption: AWSDecodableShape {
        /// The list of available az.
        public let availabilityZones: [AvailabilityZone]?
        /// The broker's engine type.
        public let engineType: EngineType?
        /// The broker's instance type.
        public let hostInstanceType: String?
        /// The broker's storage type.
        public let storageType: BrokerStorageType?
        /// The list of supported deployment modes.
        public let supportedDeploymentModes: [DeploymentMode]?
        /// The list of supported engine versions.
        public let supportedEngineVersions: [String]?

        public init(availabilityZones: [AvailabilityZone]? = nil, engineType: EngineType? = nil, hostInstanceType: String? = nil, storageType: BrokerStorageType? = nil, supportedDeploymentModes: [DeploymentMode]? = nil, supportedEngineVersions: [String]? = nil) {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones
            case engineType
            case hostInstanceType
            case storageType
            case supportedDeploymentModes
            case supportedEngineVersions
        }
    }

    public struct BrokerSummary: AWSDecodableShape {
        /// The broker's Amazon Resource Name (ARN).
        public let brokerArn: String?
        /// The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The broker's name. This value is unique in your AWS account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public let brokerName: String?
        /// The broker's status.
        public let brokerState: BrokerState?
        /// The time when the broker was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The broker's deployment mode.
        public let deploymentMode: DeploymentMode
        /// The type of broker engine.
        public let engineType: EngineType
        /// The broker's instance type.
        public let hostInstanceType: String?

        public init(brokerArn: String? = nil, brokerId: String? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, created: Date? = nil, deploymentMode: DeploymentMode, engineType: EngineType, hostInstanceType: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn
            case brokerId
            case brokerName
            case brokerState
            case created
            case deploymentMode
            case engineType
            case hostInstanceType
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// Required. The ARN of the configuration.
        public let arn: String
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        public let authenticationStrategy: AuthenticationStrategy
        /// Required. The date and time of the configuration revision.
        @CustomCoding<ISO8601DateCoder>
        public var created: Date
        /// Required. The description of the configuration.
        public let description: String
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        public let engineType: EngineType
        /// Required. The broker engine's version. For a list of supported engine versions, see, Supported engines.
        public let engineVersion: String
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String
        /// Required. The latest revision of the configuration.
        public let latestRevision: ConfigurationRevision
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        public let name: String
        /// The list of all tags associated with this configuration.
        public let tags: [String: String]?

        public init(arn: String, authenticationStrategy: AuthenticationStrategy, created: Date, description: String, engineType: EngineType, engineVersion: String, id: String, latestRevision: ConfigurationRevision, name: String, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case description
            case engineType
            case engineVersion
            case id
            case latestRevision
            case name
            case tags
        }
    }

    public struct ConfigurationId: AWSEncodableShape & AWSDecodableShape {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        public let id: String
        /// The revision number of the configuration.
        public let revision: Int?

        public init(id: String, revision: Int? = nil) {
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case revision
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// Required. The date and time of the configuration revision.
        @CustomCoding<ISO8601DateCoder>
        public var created: Date
        /// The description of the configuration revision.
        public let description: String?
        /// Required. The revision number of the configuration.
        public let revision: Int

        public init(created: Date, description: String? = nil, revision: Int) {
            self.created = created
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case created
            case description
            case revision
        }
    }

    public struct Configurations: AWSDecodableShape {
        /// The broker's current configuration.
        public let current: ConfigurationId?
        /// The history of configurations applied to the broker.
        public let history: [ConfigurationId]?
        /// The broker's pending configuration.
        public let pending: ConfigurationId?

        public init(current: ConfigurationId? = nil, history: [ConfigurationId]? = nil, pending: ConfigurationId? = nil) {
            self.current = current
            self.history = history
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case current
            case history
            case pending
        }
    }

    public struct CreateBrokerRequest: AWSEncodableShape {
        public let authenticationStrategy: AuthenticationStrategy?
        public let autoMinorVersionUpgrade: Bool
        public let brokerName: String
        public let configuration: ConfigurationId?
        public let creatorRequestId: String?
        public let deploymentMode: DeploymentMode
        public let encryptionOptions: EncryptionOptions?
        public let engineType: EngineType
        public let engineVersion: String
        public let hostInstanceType: String
        public let ldapServerMetadata: LdapServerMetadataInput?
        public let logs: Logs?
        public let maintenanceWindowStartTime: WeeklyStartTime?
        public let publiclyAccessible: Bool
        public let securityGroups: [String]?
        public let storageType: BrokerStorageType?
        public let subnetIds: [String]?
        public let tags: [String: String]?
        public let users: [User]

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool, brokerName: String, configuration: ConfigurationId? = nil, creatorRequestId: String? = CreateBrokerRequest.idempotencyToken(), deploymentMode: DeploymentMode, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType, engineVersion: String, hostInstanceType: String, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, publiclyAccessible: Bool, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [User]) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerName = brokerName
            self.configuration = configuration
            self.creatorRequestId = creatorRequestId
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerName
            case configuration
            case creatorRequestId
            case deploymentMode
            case encryptionOptions
            case engineType
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case publiclyAccessible
            case securityGroups
            case storageType
            case subnetIds
            case tags
            case users
        }
    }

    public struct CreateBrokerResponse: AWSDecodableShape {
        public let brokerArn: String?
        public let brokerId: String?

        public init(brokerArn: String? = nil, brokerId: String? = nil) {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerArn
            case brokerId
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        public let authenticationStrategy: AuthenticationStrategy?
        public let engineType: EngineType
        public let engineVersion: String
        public let name: String
        public let tags: [String: String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, engineType: EngineType, engineVersion: String, name: String, tags: [String: String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case engineType
            case engineVersion
            case name
            case tags
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        public let arn: String?
        public let authenticationStrategy: AuthenticationStrategy?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        public let id: String?
        public let latestRevision: ConfigurationRevision?
        public let name: String?

        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case id
            case latestRevision
            case name
        }
    }

    public struct CreateTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id")),
            AWSMemberEncoding(label: "username", location: .uri(locationName: "username"))
        ]

        public let brokerId: String
        public let consoleAccess: Bool?
        public let groups: [String]?
        public let password: String
        public let username: String

        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id"))
        ]

        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrokerResponse: AWSDecodableShape {
        public let brokerId: String?

        public init(brokerId: String? = nil) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
        }
    }

    public struct DeleteTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id")),
            AWSMemberEncoding(label: "username", location: .uri(locationName: "username"))
        ]

        public let brokerId: String
        public let username: String

        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeBrokerEngineTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring(locationName: "engineType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let engineType: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(engineType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerEngineTypesResponse: AWSDecodableShape {
        public let brokerEngineTypes: [BrokerEngineType]?
        public let maxResults: Int?
        public let nextToken: String?

        public init(brokerEngineTypes: [BrokerEngineType]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerEngineTypes = brokerEngineTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEngineTypes
            case maxResults
            case nextToken
        }
    }

    public struct DescribeBrokerInstanceOptionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring(locationName: "engineType")),
            AWSMemberEncoding(label: "hostInstanceType", location: .querystring(locationName: "hostInstanceType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "storageType", location: .querystring(locationName: "storageType"))
        ]

        public let engineType: String?
        public let hostInstanceType: String?
        public let maxResults: Int?
        public let nextToken: String?
        public let storageType: String?

        public init(engineType: String? = nil, hostInstanceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, storageType: String? = nil) {
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerInstanceOptionsResponse: AWSDecodableShape {
        public let brokerInstanceOptions: [BrokerInstanceOption]?
        public let maxResults: Int?
        public let nextToken: String?

        public init(brokerInstanceOptions: [BrokerInstanceOption]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerInstanceOptions = brokerInstanceOptions
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerInstanceOptions
            case maxResults
            case nextToken
        }
    }

    public struct DescribeBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id"))
        ]

        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBrokerResponse: AWSDecodableShape {
        public let authenticationStrategy: AuthenticationStrategy?
        public let autoMinorVersionUpgrade: Bool?
        public let brokerArn: String?
        public let brokerId: String?
        public let brokerInstances: [BrokerInstance]?
        public let brokerName: String?
        public let brokerState: BrokerState?
        public let configurations: Configurations?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        public let deploymentMode: DeploymentMode?
        public let encryptionOptions: EncryptionOptions?
        public let engineType: EngineType?
        public let engineVersion: String?
        public let hostInstanceType: String?
        public let ldapServerMetadata: LdapServerMetadataOutput?
        public let logs: LogsSummary?
        public let maintenanceWindowStartTime: WeeklyStartTime?
        public let pendingAuthenticationStrategy: AuthenticationStrategy?
        public let pendingEngineVersion: String?
        public let pendingHostInstanceType: String?
        public let pendingLdapServerMetadata: LdapServerMetadataOutput?
        public let pendingSecurityGroups: [String]?
        public let publiclyAccessible: Bool?
        public let securityGroups: [String]?
        public let storageType: BrokerStorageType?
        public let subnetIds: [String]?
        public let tags: [String: String]?
        public let users: [UserSummary]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerArn: String? = nil, brokerId: String? = nil, brokerInstances: [BrokerInstance]? = nil, brokerName: String? = nil, brokerState: BrokerState? = nil, configurations: Configurations? = nil, created: Date? = nil, deploymentMode: DeploymentMode? = nil, encryptionOptions: EncryptionOptions? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: LogsSummary? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, pendingAuthenticationStrategy: AuthenticationStrategy? = nil, pendingEngineVersion: String? = nil, pendingHostInstanceType: String? = nil, pendingLdapServerMetadata: LdapServerMetadataOutput? = nil, pendingSecurityGroups: [String]? = nil, publiclyAccessible: Bool? = nil, securityGroups: [String]? = nil, storageType: BrokerStorageType? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, users: [UserSummary]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerInstances = brokerInstances
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.configurations = configurations
            self.created = created
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
            self.pendingEngineVersion = pendingEngineVersion
            self.pendingHostInstanceType = pendingHostInstanceType
            self.pendingLdapServerMetadata = pendingLdapServerMetadata
            self.pendingSecurityGroups = pendingSecurityGroups
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerArn
            case brokerId
            case brokerInstances
            case brokerName
            case brokerState
            case configurations
            case created
            case deploymentMode
            case encryptionOptions
            case engineType
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case pendingAuthenticationStrategy
            case pendingEngineVersion
            case pendingHostInstanceType
            case pendingLdapServerMetadata
            case pendingSecurityGroups
            case publiclyAccessible
            case securityGroups
            case storageType
            case subnetIds
            case tags
            case users
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri(locationName: "configuration-id"))
        ]

        public let configurationId: String

        public init(configurationId: String) {
            self.configurationId = configurationId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        public let arn: String?
        public let authenticationStrategy: AuthenticationStrategy?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        public let description: String?
        public let engineType: EngineType?
        public let engineVersion: String?
        public let id: String?
        public let latestRevision: ConfigurationRevision?
        public let name: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authenticationStrategy: AuthenticationStrategy? = nil, created: Date? = nil, description: String? = nil, engineType: EngineType? = nil, engineVersion: String? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authenticationStrategy
            case created
            case description
            case engineType
            case engineVersion
            case id
            case latestRevision
            case name
            case tags
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri(locationName: "configuration-id")),
            AWSMemberEncoding(label: "configurationRevision", location: .uri(locationName: "configuration-revision"))
        ]

        public let configurationId: String
        public let configurationRevision: String

        public init(configurationId: String, configurationRevision: String) {
            self.configurationId = configurationId
            self.configurationRevision = configurationRevision
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        public let configurationId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        public let data: String?
        public let description: String?

        public init(configurationId: String? = nil, created: Date? = nil, data: String? = nil, description: String? = nil) {
            self.configurationId = configurationId
            self.created = created
            self.data = data
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId
            case created
            case data
            case description
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id")),
            AWSMemberEncoding(label: "username", location: .uri(locationName: "username"))
        ]

        public let brokerId: String
        public let username: String

        public init(brokerId: String, username: String) {
            self.brokerId = brokerId
            self.username = username
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        public let brokerId: String?
        public let consoleAccess: Bool?
        public let groups: [String]?
        public let pending: UserPendingChanges?
        public let username: String?

        public init(brokerId: String? = nil, consoleAccess: Bool? = nil, groups: [String]? = nil, pending: UserPendingChanges? = nil, username: String? = nil) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pending = pending
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
            case consoleAccess
            case groups
            case pending
            case username
        }
    }

    public struct EncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The customer master key (CMK) to use for the AWS Key Management Service (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public let kmsKeyId: String?
        /// Enables the use of an AWS owned CMK using AWS Key Management Service (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        public let useAwsOwnedKey: Bool

        public init(kmsKeyId: String? = nil, useAwsOwnedKey: Bool) {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId
            case useAwsOwnedKey
        }
    }

    public struct EngineVersion: AWSDecodableShape {
        /// Id for the version.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct LdapServerMetadataInput: AWSEncodableShape {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        public let hosts: [String]
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp,
        ///                   dc=example, dc=com.
        public let roleBase: String
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        public let serviceAccountPassword: String
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        public let serviceAccountUsername: String
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp,
        ///                   dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example,
        ///                   dc=com.
        public let userSearchMatching: String
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        public init(hosts: [String], roleBase: String, roleName: String? = nil, roleSearchMatching: String, roleSearchSubtree: Bool? = nil, serviceAccountPassword: String, serviceAccountUsername: String, userBase: String, userRoleName: String? = nil, userSearchMatching: String, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts
            case roleBase
            case roleName
            case roleSearchMatching
            case roleSearchSubtree
            case serviceAccountPassword
            case serviceAccountUsername
            case userBase
            case userRoleName
            case userSearchMatching
            case userSearchSubtree
        }
    }

    public struct LdapServerMetadataOutput: AWSDecodableShape {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        public let hosts: [String]
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp,
        ///                   dc=example, dc=com.
        public let roleBase: String
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public let roleName: String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        public let roleSearchMatching: String
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        public let serviceAccountUsername: String
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp,
        ///                   dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        public let userBase: String
        /// Specifies the name of the LDAP attribute for the user group membership.
        public let userRoleName: String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example,
        ///                dc=com.
        public let userSearchMatching: String
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        public init(hosts: [String], roleBase: String, roleName: String? = nil, roleSearchMatching: String, roleSearchSubtree: Bool? = nil, serviceAccountUsername: String, userBase: String, userRoleName: String? = nil, userSearchMatching: String, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        private enum CodingKeys: String, CodingKey {
            case hosts
            case roleBase
            case roleName
            case roleSearchMatching
            case roleSearchSubtree
            case serviceAccountUsername
            case userBase
            case userRoleName
            case userSearchMatching
            case userSearchSubtree
        }
    }

    public struct ListBrokersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrokersResponse: AWSDecodableShape {
        public let brokerSummaries: [BrokerSummary]?
        public let nextToken: String?

        public init(brokerSummaries: [BrokerSummary]? = nil, nextToken: String? = nil) {
            self.brokerSummaries = brokerSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case brokerSummaries
            case nextToken
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri(locationName: "configuration-id")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let configurationId: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(configurationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        public let configurationId: String?
        public let maxResults: Int?
        public let nextToken: String?
        public let revisions: [ConfigurationRevision]?

        public init(configurationId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId
            case maxResults
            case nextToken
            case revisions
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        public let configurations: [Configuration]?
        public let maxResults: Int?
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations
            case maxResults
            case nextToken
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let brokerId: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(brokerId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        public let brokerId: String?
        public let maxResults: Int?
        public let nextToken: String?
        public let users: [UserSummary]?

        public init(brokerId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, users: [UserSummary]? = nil) {
            self.brokerId = brokerId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case brokerId
            case maxResults
            case nextToken
            case users
        }
    }

    public struct Logs: AWSEncodableShape & AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case general
        }
    }

    public struct LogsSummary: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public let auditLogGroup: String?
        /// Enables general logging.
        public let general: Bool
        /// The location of the CloudWatch Logs log group where general logs are sent.
        public let generalLogGroup: String
        /// The list of information about logs pending to be deployed for the specified broker.
        public let pending: PendingLogs?

        public init(audit: Bool? = nil, auditLogGroup: String? = nil, general: Bool, generalLogGroup: String, pending: PendingLogs? = nil) {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case auditLogGroup
            case general
            case generalLogGroup
            case pending
        }
    }

    public struct PendingLogs: AWSDecodableShape {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public let audit: Bool?
        /// Enables general logging.
        public let general: Bool?

        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit
            case general
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id"))
        ]

        public let brokerId: String

        public init(brokerId: String) {
            self.brokerId = brokerId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct SanitizationWarning: AWSDecodableShape {
        /// The name of the XML attribute that has been sanitized.
        public let attributeName: String?
        /// The name of the XML element that has been sanitized.
        public let elementName: String?
        /// Required. The reason for which the XML elements or attributes were sanitized.
        public let reason: SanitizationWarningReason

        public init(attributeName: String? = nil, elementName: String? = nil, reason: SanitizationWarningReason) {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case elementName
            case reason
        }
    }

    public struct UpdateBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id"))
        ]

        public let authenticationStrategy: AuthenticationStrategy?
        public let autoMinorVersionUpgrade: Bool?
        public let brokerId: String
        public let configuration: ConfigurationId?
        public let engineVersion: String?
        public let hostInstanceType: String?
        public let ldapServerMetadata: LdapServerMetadataInput?
        public let logs: Logs?
        public let maintenanceWindowStartTime: WeeklyStartTime?
        public let securityGroups: [String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String, configuration: ConfigurationId? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataInput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case configuration
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case securityGroups
        }
    }

    public struct UpdateBrokerResponse: AWSDecodableShape {
        public let authenticationStrategy: AuthenticationStrategy?
        public let autoMinorVersionUpgrade: Bool?
        public let brokerId: String?
        public let configuration: ConfigurationId?
        public let engineVersion: String?
        public let hostInstanceType: String?
        public let ldapServerMetadata: LdapServerMetadataOutput?
        public let logs: Logs?
        public let maintenanceWindowStartTime: WeeklyStartTime?
        public let securityGroups: [String]?

        public init(authenticationStrategy: AuthenticationStrategy? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerId: String? = nil, configuration: ConfigurationId? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: LdapServerMetadataOutput? = nil, logs: Logs? = nil, maintenanceWindowStartTime: WeeklyStartTime? = nil, securityGroups: [String]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerId = brokerId
            self.configuration = configuration
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy
            case autoMinorVersionUpgrade
            case brokerId
            case configuration
            case engineVersion
            case hostInstanceType
            case ldapServerMetadata
            case logs
            case maintenanceWindowStartTime
            case securityGroups
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configurationId", location: .uri(locationName: "configuration-id"))
        ]

        public let configurationId: String
        public let data: String
        public let description: String?

        public init(configurationId: String, data: String, description: String? = nil) {
            self.configurationId = configurationId
            self.data = data
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case description
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        public let id: String?
        public let latestRevision: ConfigurationRevision?
        public let name: String?
        public let warnings: [SanitizationWarning]?

        public init(arn: String? = nil, created: Date? = nil, id: String? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, warnings: [SanitizationWarning]? = nil) {
            self.arn = arn
            self.created = created
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case created
            case id
            case latestRevision
            case name
            case warnings
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "brokerId", location: .uri(locationName: "broker-id")),
            AWSMemberEncoding(label: "username", location: .uri(locationName: "username"))
        ]

        public let brokerId: String
        public let consoleAccess: Bool?
        public let groups: [String]?
        public let password: String?
        public let username: String

        public init(brokerId: String, consoleAccess: Bool? = nil, groups: [String]? = nil, password: String? = nil, username: String) {
            self.brokerId = brokerId
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct User: AWSEncodableShape {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public let groups: [String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        public let password: String
        /// important>Amazon MQ for ActiveMQ For ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long./important> Amazon MQ for RabbitMQ For RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
        public let username: String

        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, password: String, username: String) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case password
            case username
        }
    }

    public struct UserPendingChanges: AWSDecodableShape {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public let consoleAccess: Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let groups: [String]?
        /// Required. The type of change pending for the ActiveMQ user.
        public let pendingChange: ChangeType

        public init(consoleAccess: Bool? = nil, groups: [String]? = nil, pendingChange: ChangeType) {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }

        private enum CodingKeys: String, CodingKey {
            case consoleAccess
            case groups
            case pendingChange
        }
    }

    public struct UserSummary: AWSDecodableShape {
        /// The type of change pending for the broker user.
        public let pendingChange: ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public let username: String

        public init(pendingChange: ChangeType? = nil, username: String) {
            self.pendingChange = pendingChange
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case pendingChange
            case username
        }
    }

    public struct WeeklyStartTime: AWSEncodableShape & AWSDecodableShape {
        /// Required. The day of the week.
        public let dayOfWeek: DayOfWeek
        /// Required. The time, in 24-hour format.
        public let timeOfDay: String
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public let timeZone: String?

        public init(dayOfWeek: DayOfWeek, timeOfDay: String, timeZone: String? = nil) {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek
            case timeOfDay
            case timeZone
        }
    }
}
