//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ConnectCampaignsV2 {
    // MARK: Enums

    public enum CampaignDeletionPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteAll = "DELETE_ALL"
        case retainAll = "RETAIN_ALL"
        public var description: String { return self.rawValue }
    }

    public enum CampaignState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Campaign is in completed state
        case completed = "Completed"
        /// Campaign is in failed state
        case failed = "Failed"
        /// Campaign is in initialized state
        case initialized = "Initialized"
        /// Campaign is in paused state
        case paused = "Paused"
        /// Campaign is in running state
        case running = "Running"
        /// Campaign is in stopped state
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public enum ChannelSubtype: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        case sms = "SMS"
        case telephony = "TELEPHONY"
        public var description: String { return self.rawValue }
    }

    public enum CommunicationLimitTimeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        public var description: String { return self.rawValue }
    }

    public enum CommunicationLimitsConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allChannelSubtypes = "ALL_CHANNEL_SUBTYPES"
        public var description: String { return self.rawValue }
    }

    public enum CommunicationTimeConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        case sms = "SMS"
        case telephony = "TELEPHONY"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case campaignEmail = "Campaign-Email"
        case campaignOrchestration = "Campaign-Orchestration"
        case campaignSMS = "Campaign-SMS"
        case campaignTelephony = "Campaign-Telephony"
        public var description: String { return self.rawValue }
    }

    public enum FailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Request throttled due to large number of pending dial requests
        case bufferLimitExceeded = "BufferLimitExceeded"
        /// The request failed to satisfy the constraints specified by the service
        case invalidInput = "InvalidInput"
        /// The request was throttled due to excessive usage
        case requestThrottled = "RequestThrottled"
        /// Unexpected error during processing of request
        case unknownError = "UnknownError"
        public var description: String { return self.rawValue }
    }

    public enum GetCampaignStateBatchFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The specified resource was not found
        case resourceNotFound = "ResourceNotFound"
        /// Unexpected error during processing of request
        case unknownError = "UnknownError"
        public var description: String { return self.rawValue }
    }

    public enum InstanceIdFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Equals operator
        case eq = "Eq"
        public var description: String { return self.rawValue }
    }

    public enum InstanceOnboardingJobFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventBridgeAccessDenied = "EVENT_BRIDGE_ACCESS_DENIED"
        case eventBridgeManagedRuleLimitExceeded = "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED"
        case iamAccessDenied = "IAM_ACCESS_DENIED"
        case internalFailure = "INTERNAL_FAILURE"
        case kmsAccessDenied = "KMS_ACCESS_DENIED"
        case kmsKeyNotFound = "KMS_KEY_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum InstanceOnboardingJobStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum LocalTimeZoneDetectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case areaCode = "AREA_CODE"
        case zipCode = "ZIP_CODE"
        public var description: String { return self.rawValue }
    }

    public enum ProfileOutboundRequestFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The specified resource conflicts with another resource
        case conflict = "Conflict"
        /// The request failed to satisfy the constraints specified by the service
        case invalidInput = "InvalidInput"
        /// Request throttled due to large number of requests
        case requestThrottled = "RequestThrottled"
        /// The specified resource was not found
        case resourceNotFound = "ResourceNotFound"
        /// Unexpected error during processing of request
        case unknownError = "UnknownError"
        public var description: String { return self.rawValue }
    }

    public enum ChannelSubtypeParameters: AWSEncodableShape, Sendable {
        case email(EmailChannelSubtypeParameters)
        case sms(SmsChannelSubtypeParameters)
        case telephony(TelephonyChannelSubtypeParameters)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .email(let value):
                try container.encode(value, forKey: .email)
            case .sms(let value):
                try container.encode(value, forKey: .sms)
            case .telephony(let value):
                try container.encode(value, forKey: .telephony)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .email(let value):
                try value.validate(name: "\(name).email")
            case .sms(let value):
                try value.validate(name: "\(name).sms")
            case .telephony(let value):
                try value.validate(name: "\(name).telephony")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
            case sms = "sms"
            case telephony = "telephony"
        }
    }

    public enum IntegrationConfig: AWSEncodableShape, Sendable {
        case customerProfiles(CustomerProfilesIntegrationConfig)
        case qConnect(QConnectIntegrationConfig)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customerProfiles(let value):
                try container.encode(value, forKey: .customerProfiles)
            case .qConnect(let value):
                try container.encode(value, forKey: .qConnect)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customerProfiles(let value):
                try value.validate(name: "\(name).customerProfiles")
            case .qConnect(let value):
                try value.validate(name: "\(name).qConnect")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfiles = "customerProfiles"
            case qConnect = "qConnect"
        }
    }

    public enum IntegrationIdentifier: AWSEncodableShape, Sendable {
        case customerProfiles(CustomerProfilesIntegrationIdentifier)
        case qConnect(QConnectIntegrationIdentifier)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customerProfiles(let value):
                try container.encode(value, forKey: .customerProfiles)
            case .qConnect(let value):
                try container.encode(value, forKey: .qConnect)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customerProfiles(let value):
                try value.validate(name: "\(name).customerProfiles")
            case .qConnect(let value):
                try value.validate(name: "\(name).qConnect")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfiles = "customerProfiles"
            case qConnect = "qConnect"
        }
    }

    public enum IntegrationSummary: AWSDecodableShape, Sendable {
        case customerProfiles(CustomerProfilesIntegrationSummary)
        case qConnect(QConnectIntegrationSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customerProfiles:
                let value = try container.decode(CustomerProfilesIntegrationSummary.self, forKey: .customerProfiles)
                self = .customerProfiles(value)
            case .qConnect:
                let value = try container.decode(QConnectIntegrationSummary.self, forKey: .qConnect)
                self = .qConnect(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfiles = "customerProfiles"
            case qConnect = "qConnect"
        }
    }

    public enum Source: AWSEncodableShape & AWSDecodableShape, Sendable {
        case customerProfilesSegmentArn(String)
        case eventTrigger(EventTrigger)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customerProfilesSegmentArn:
                let value = try container.decode(String.self, forKey: .customerProfilesSegmentArn)
                self = .customerProfilesSegmentArn(value)
            case .eventTrigger:
                let value = try container.decode(EventTrigger.self, forKey: .eventTrigger)
                self = .eventTrigger(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customerProfilesSegmentArn(let value):
                try container.encode(value, forKey: .customerProfilesSegmentArn)
            case .eventTrigger(let value):
                try container.encode(value, forKey: .eventTrigger)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customerProfilesSegmentArn(let value):
                try self.validate(value, name: "customerProfilesSegmentArn", parent: name, max: 500)
                try self.validate(value, name: "customerProfilesSegmentArn", parent: name, min: 20)
                try self.validate(value, name: "customerProfilesSegmentArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            case .eventTrigger(let value):
                try value.validate(name: "\(name).eventTrigger")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfilesSegmentArn = "customerProfilesSegmentArn"
            case eventTrigger = "eventTrigger"
        }
    }

    public enum TelephonyOutboundMode: AWSEncodableShape & AWSDecodableShape, Sendable {
        case agentless(AgentlessConfig)
        case predictive(PredictiveConfig)
        case progressive(ProgressiveConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .agentless:
                let value = try container.decode(AgentlessConfig.self, forKey: .agentless)
                self = .agentless(value)
            case .predictive:
                let value = try container.decode(PredictiveConfig.self, forKey: .predictive)
                self = .predictive(value)
            case .progressive:
                let value = try container.decode(ProgressiveConfig.self, forKey: .progressive)
                self = .progressive(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .agentless(let value):
                try container.encode(value, forKey: .agentless)
            case .predictive(let value):
                try container.encode(value, forKey: .predictive)
            case .progressive(let value):
                try container.encode(value, forKey: .progressive)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .predictive(let value):
                try value.validate(name: "\(name).predictive")
            case .progressive(let value):
                try value.validate(name: "\(name).progressive")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentless = "agentless"
            case predictive = "predictive"
            case progressive = "progressive"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct AgentlessConfig: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AnswerMachineDetectionConfig: AWSEncodableShape & AWSDecodableShape {
        /// Enable or disable await answer machine prompt
        public let awaitAnswerMachinePrompt: Bool?
        /// Enable or disable answering machine detection
        public let enableAnswerMachineDetection: Bool

        @inlinable
        public init(awaitAnswerMachinePrompt: Bool? = nil, enableAnswerMachineDetection: Bool) {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }

        private enum CodingKeys: String, CodingKey {
            case awaitAnswerMachinePrompt = "awaitAnswerMachinePrompt"
            case enableAnswerMachineDetection = "enableAnswerMachineDetection"
        }
    }

    public struct Campaign: AWSDecodableShape {
        public let arn: String
        public let channelSubtypeConfig: ChannelSubtypeConfig
        public let communicationLimitsOverride: CommunicationLimitsConfig?
        public let communicationTimeConfig: CommunicationTimeConfig?
        public let connectCampaignFlowArn: String?
        public let connectInstanceId: String
        public let id: String
        public let name: String
        public let schedule: Schedule?
        public let source: Source?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelSubtypeConfig: ChannelSubtypeConfig, communicationLimitsOverride: CommunicationLimitsConfig? = nil, communicationTimeConfig: CommunicationTimeConfig? = nil, connectCampaignFlowArn: String? = nil, connectInstanceId: String, id: String, name: String, schedule: Schedule? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelSubtypeConfig = channelSubtypeConfig
            self.communicationLimitsOverride = communicationLimitsOverride
            self.communicationTimeConfig = communicationTimeConfig
            self.connectCampaignFlowArn = connectCampaignFlowArn
            self.connectInstanceId = connectInstanceId
            self.id = id
            self.name = name
            self.schedule = schedule
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelSubtypeConfig = "channelSubtypeConfig"
            case communicationLimitsOverride = "communicationLimitsOverride"
            case communicationTimeConfig = "communicationTimeConfig"
            case connectCampaignFlowArn = "connectCampaignFlowArn"
            case connectInstanceId = "connectInstanceId"
            case id = "id"
            case name = "name"
            case schedule = "schedule"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CampaignFilters: AWSEncodableShape {
        public let instanceIdFilter: InstanceIdFilter?

        @inlinable
        public init(instanceIdFilter: InstanceIdFilter? = nil) {
            self.instanceIdFilter = instanceIdFilter
        }

        public func validate(name: String) throws {
            try self.instanceIdFilter?.validate(name: "\(name).instanceIdFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceIdFilter = "instanceIdFilter"
        }
    }

    public struct CampaignSummary: AWSDecodableShape {
        public let arn: String
        public let channelSubtypes: [ChannelSubtype]
        public let connectCampaignFlowArn: String?
        public let connectInstanceId: String
        public let id: String
        public let name: String
        public let schedule: Schedule?

        @inlinable
        public init(arn: String, channelSubtypes: [ChannelSubtype], connectCampaignFlowArn: String? = nil, connectInstanceId: String, id: String, name: String, schedule: Schedule? = nil) {
            self.arn = arn
            self.channelSubtypes = channelSubtypes
            self.connectCampaignFlowArn = connectCampaignFlowArn
            self.connectInstanceId = connectInstanceId
            self.id = id
            self.name = name
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelSubtypes = "channelSubtypes"
            case connectCampaignFlowArn = "connectCampaignFlowArn"
            case connectInstanceId = "connectInstanceId"
            case id = "id"
            case name = "name"
            case schedule = "schedule"
        }
    }

    public struct ChannelSubtypeConfig: AWSEncodableShape & AWSDecodableShape {
        public let email: EmailChannelSubtypeConfig?
        public let sms: SmsChannelSubtypeConfig?
        public let telephony: TelephonyChannelSubtypeConfig?

        @inlinable
        public init(email: EmailChannelSubtypeConfig? = nil, sms: SmsChannelSubtypeConfig? = nil, telephony: TelephonyChannelSubtypeConfig? = nil) {
            self.email = email
            self.sms = sms
            self.telephony = telephony
        }

        public func validate(name: String) throws {
            try self.email?.validate(name: "\(name).email")
            try self.sms?.validate(name: "\(name).sms")
            try self.telephony?.validate(name: "\(name).telephony")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
            case sms = "sms"
            case telephony = "telephony"
        }
    }

    public struct CommunicationLimit: AWSEncodableShape & AWSDecodableShape {
        /// The number of days to consider with regards to this limit.
        public let frequency: Int
        /// Maximum number of contacts allowed for a given target within the given frequency.
        public let maxCountPerRecipient: Int
        public let unit: CommunicationLimitTimeUnit

        @inlinable
        public init(frequency: Int, maxCountPerRecipient: Int, unit: CommunicationLimitTimeUnit) {
            self.frequency = frequency
            self.maxCountPerRecipient = maxCountPerRecipient
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "frequency"
            case maxCountPerRecipient = "maxCountPerRecipient"
            case unit = "unit"
        }
    }

    public struct CommunicationLimitsConfig: AWSEncodableShape & AWSDecodableShape {
        public let allChannelSubtypes: CommunicationLimits?

        @inlinable
        public init(allChannelSubtypes: CommunicationLimits? = nil) {
            self.allChannelSubtypes = allChannelSubtypes
        }

        public func validate(name: String) throws {
            try self.allChannelSubtypes?.validate(name: "\(name).allChannelSubtypes")
        }

        private enum CodingKeys: String, CodingKey {
            case allChannelSubtypes = "allChannelSubtypes"
        }
    }

    public struct CommunicationTimeConfig: AWSEncodableShape & AWSDecodableShape {
        public let email: TimeWindow?
        public let localTimeZoneConfig: LocalTimeZoneConfig
        public let sms: TimeWindow?
        public let telephony: TimeWindow?

        @inlinable
        public init(email: TimeWindow? = nil, localTimeZoneConfig: LocalTimeZoneConfig, sms: TimeWindow? = nil, telephony: TimeWindow? = nil) {
            self.email = email
            self.localTimeZoneConfig = localTimeZoneConfig
            self.sms = sms
            self.telephony = telephony
        }

        public func validate(name: String) throws {
            try self.email?.validate(name: "\(name).email")
            try self.localTimeZoneConfig.validate(name: "\(name).localTimeZoneConfig")
            try self.sms?.validate(name: "\(name).sms")
            try self.telephony?.validate(name: "\(name).telephony")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
            case localTimeZoneConfig = "localTimeZoneConfig"
            case sms = "sms"
            case telephony = "telephony"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct CreateCampaignRequest: AWSEncodableShape {
        public let channelSubtypeConfig: ChannelSubtypeConfig
        public let communicationLimitsOverride: CommunicationLimitsConfig?
        public let communicationTimeConfig: CommunicationTimeConfig?
        public let connectCampaignFlowArn: String?
        public let connectInstanceId: String
        public let name: String
        public let schedule: Schedule?
        public let source: Source?
        public let tags: [String: String]?

        @inlinable
        public init(channelSubtypeConfig: ChannelSubtypeConfig, communicationLimitsOverride: CommunicationLimitsConfig? = nil, communicationTimeConfig: CommunicationTimeConfig? = nil, connectCampaignFlowArn: String? = nil, connectInstanceId: String, name: String, schedule: Schedule? = nil, source: Source? = nil, tags: [String: String]? = nil) {
            self.channelSubtypeConfig = channelSubtypeConfig
            self.communicationLimitsOverride = communicationLimitsOverride
            self.communicationTimeConfig = communicationTimeConfig
            self.connectCampaignFlowArn = connectCampaignFlowArn
            self.connectInstanceId = connectInstanceId
            self.name = name
            self.schedule = schedule
            self.source = source
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.channelSubtypeConfig.validate(name: "\(name).channelSubtypeConfig")
            try self.communicationLimitsOverride?.validate(name: "\(name).communicationLimitsOverride")
            try self.communicationTimeConfig?.validate(name: "\(name).communicationTimeConfig")
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, max: 500)
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, min: 20)
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
            try self.source?.validate(name: "\(name).source")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtypeConfig = "channelSubtypeConfig"
            case communicationLimitsOverride = "communicationLimitsOverride"
            case communicationTimeConfig = "communicationTimeConfig"
            case connectCampaignFlowArn = "connectCampaignFlowArn"
            case connectInstanceId = "connectInstanceId"
            case name = "name"
            case schedule = "schedule"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CreateCampaignResponse: AWSDecodableShape {
        public let arn: String?
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CustomerProfilesIntegrationConfig: AWSEncodableShape {
        public let domainArn: String
        public let objectTypeNames: [EventType: String]

        @inlinable
        public init(domainArn: String, objectTypeNames: [EventType: String]) {
            self.domainArn = domainArn
            self.objectTypeNames = objectTypeNames
        }

        public func validate(name: String) throws {
            try self.validate(self.domainArn, name: "domainArn", parent: name, max: 500)
            try self.validate(self.domainArn, name: "domainArn", parent: name, min: 20)
            try self.validate(self.domainArn, name: "domainArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.objectTypeNames.forEach {
                try validate($0.value, name: "objectTypeNames[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "objectTypeNames[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case objectTypeNames = "objectTypeNames"
        }
    }

    public struct CustomerProfilesIntegrationIdentifier: AWSEncodableShape {
        public let domainArn: String

        @inlinable
        public init(domainArn: String) {
            self.domainArn = domainArn
        }

        public func validate(name: String) throws {
            try self.validate(self.domainArn, name: "domainArn", parent: name, max: 500)
            try self.validate(self.domainArn, name: "domainArn", parent: name, min: 20)
            try self.validate(self.domainArn, name: "domainArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
        }
    }

    public struct CustomerProfilesIntegrationSummary: AWSDecodableShape {
        public let domainArn: String
        public let objectTypeNames: [EventType: String]

        @inlinable
        public init(domainArn: String, objectTypeNames: [EventType: String]) {
            self.domainArn = domainArn
            self.objectTypeNames = objectTypeNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case objectTypeNames = "objectTypeNames"
        }
    }

    public struct DeleteCampaignChannelSubtypeConfigRequest: AWSEncodableShape {
        public let channelSubtype: ChannelSubtype
        public let id: String

        @inlinable
        public init(channelSubtype: ChannelSubtype, id: String) {
            self.channelSubtype = channelSubtype
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelSubtype, key: "channelSubtype")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCampaignCommunicationLimitsRequest: AWSEncodableShape {
        public let config: CommunicationLimitsConfigType
        public let id: String

        @inlinable
        public init(config: CommunicationLimitsConfigType, id: String) {
            self.config = config
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.config, key: "config")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCampaignCommunicationTimeRequest: AWSEncodableShape {
        public let config: CommunicationTimeConfigType
        public let id: String

        @inlinable
        public init(config: CommunicationTimeConfigType, id: String) {
            self.config = config
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.config, key: "config")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectInstanceConfigRequest: AWSEncodableShape {
        public let campaignDeletionPolicy: CampaignDeletionPolicy?
        public let connectInstanceId: String

        @inlinable
        public init(campaignDeletionPolicy: CampaignDeletionPolicy? = nil, connectInstanceId: String) {
            self.campaignDeletionPolicy = campaignDeletionPolicy
            self.connectInstanceId = connectInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.campaignDeletionPolicy, key: "campaignDeletionPolicy")
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectInstanceIntegrationRequest: AWSEncodableShape {
        public let connectInstanceId: String
        public let integrationIdentifier: IntegrationIdentifier

        @inlinable
        public init(connectInstanceId: String, integrationIdentifier: IntegrationIdentifier) {
            self.connectInstanceId = connectInstanceId
            self.integrationIdentifier = integrationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
            try container.encode(self.integrationIdentifier, forKey: .integrationIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.integrationIdentifier.validate(name: "\(name).integrationIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case integrationIdentifier = "integrationIdentifier"
        }
    }

    public struct DeleteInstanceOnboardingJobRequest: AWSEncodableShape {
        public let connectInstanceId: String

        @inlinable
        public init(connectInstanceId: String) {
            self.connectInstanceId = connectInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCampaignResponse: AWSDecodableShape {
        public let campaign: Campaign?

        @inlinable
        public init(campaign: Campaign? = nil) {
            self.campaign = campaign
        }

        private enum CodingKeys: String, CodingKey {
            case campaign = "campaign"
        }
    }

    public struct EmailChannelSubtypeConfig: AWSEncodableShape & AWSDecodableShape {
        public let capacity: Double?
        public let defaultOutboundConfig: EmailOutboundConfig
        public let outboundMode: EmailOutboundMode

        @inlinable
        public init(capacity: Double? = nil, defaultOutboundConfig: EmailOutboundConfig, outboundMode: EmailOutboundMode) {
            self.capacity = capacity
            self.defaultOutboundConfig = defaultOutboundConfig
            self.outboundMode = outboundMode
        }

        public func validate(name: String) throws {
            try self.validate(self.capacity, name: "capacity", parent: name, max: 1.0)
            try self.validate(self.capacity, name: "capacity", parent: name, min: 0.01)
            try self.defaultOutboundConfig.validate(name: "\(name).defaultOutboundConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case defaultOutboundConfig = "defaultOutboundConfig"
            case outboundMode = "outboundMode"
        }
    }

    public struct EmailChannelSubtypeParameters: AWSEncodableShape {
        public let connectSourceEmailAddress: String?
        public let destinationEmailAddress: String
        public let templateArn: String?
        public let templateParameters: [String: String]

        @inlinable
        public init(connectSourceEmailAddress: String? = nil, destinationEmailAddress: String, templateArn: String? = nil, templateParameters: [String: String]) {
            self.connectSourceEmailAddress = connectSourceEmailAddress
            self.destinationEmailAddress = destinationEmailAddress
            self.templateArn = templateArn
            self.templateParameters = templateParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, max: 255)
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, min: 1)
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, pattern: "[^\\s@]+@[^\\s@]+\\.[^\\s@]+")
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, max: 255)
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, min: 1)
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, pattern: "[^\\s@]+@[^\\s@]+\\.[^\\s@]+")
            try self.validate(self.templateArn, name: "templateArn", parent: name, max: 500)
            try self.validate(self.templateArn, name: "templateArn", parent: name, min: 20)
            try self.validate(self.templateArn, name: "templateArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.templateParameters.forEach {
                try validate($0.key, name: "templateParameters.key", parent: name, max: 32767)
                try validate($0.key, name: "templateParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectSourceEmailAddress = "connectSourceEmailAddress"
            case destinationEmailAddress = "destinationEmailAddress"
            case templateArn = "templateArn"
            case templateParameters = "templateParameters"
        }
    }

    public struct EmailOutboundConfig: AWSEncodableShape & AWSDecodableShape {
        public let connectSourceEmailAddress: String
        public let sourceEmailAddressDisplayName: String?
        public let wisdomTemplateArn: String

        @inlinable
        public init(connectSourceEmailAddress: String, sourceEmailAddressDisplayName: String? = nil, wisdomTemplateArn: String) {
            self.connectSourceEmailAddress = connectSourceEmailAddress
            self.sourceEmailAddressDisplayName = sourceEmailAddressDisplayName
            self.wisdomTemplateArn = wisdomTemplateArn
        }

        public func validate(name: String) throws {
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, max: 255)
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, min: 1)
            try self.validate(self.connectSourceEmailAddress, name: "connectSourceEmailAddress", parent: name, pattern: "[^\\s@]+@[^\\s@]+\\.[^\\s@]+")
            try self.validate(self.sourceEmailAddressDisplayName, name: "sourceEmailAddressDisplayName", parent: name, max: 256)
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, max: 500)
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, min: 20)
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectSourceEmailAddress = "connectSourceEmailAddress"
            case sourceEmailAddressDisplayName = "sourceEmailAddressDisplayName"
            case wisdomTemplateArn = "wisdomTemplateArn"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        public let enabled: Bool
        public let encryptionType: EncryptionType?
        public let keyArn: String?

        @inlinable
        public init(enabled: Bool, encryptionType: EncryptionType? = nil, keyArn: String? = nil) {
            self.enabled = enabled
            self.encryptionType = encryptionType
            self.keyArn = keyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.keyArn, name: "keyArn", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case encryptionType = "encryptionType"
            case keyArn = "keyArn"
        }
    }

    public struct EventTrigger: AWSEncodableShape & AWSDecodableShape {
        public let customerProfilesDomainArn: String?

        @inlinable
        public init(customerProfilesDomainArn: String? = nil) {
            self.customerProfilesDomainArn = customerProfilesDomainArn
        }

        public func validate(name: String) throws {
            try self.validate(self.customerProfilesDomainArn, name: "customerProfilesDomainArn", parent: name, max: 500)
            try self.validate(self.customerProfilesDomainArn, name: "customerProfilesDomainArn", parent: name, min: 20)
            try self.validate(self.customerProfilesDomainArn, name: "customerProfilesDomainArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case customerProfilesDomainArn = "customerProfilesDomainArn"
        }
    }

    public struct FailedCampaignStateResponse: AWSDecodableShape {
        public let campaignId: String?
        public let failureCode: GetCampaignStateBatchFailureCode?

        @inlinable
        public init(campaignId: String? = nil, failureCode: GetCampaignStateBatchFailureCode? = nil) {
            self.campaignId = campaignId
            self.failureCode = failureCode
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "campaignId"
            case failureCode = "failureCode"
        }
    }

    public struct FailedProfileOutboundRequest: AWSDecodableShape {
        public let clientToken: String?
        public let failureCode: ProfileOutboundRequestFailureCode?
        public let id: String?

        @inlinable
        public init(clientToken: String? = nil, failureCode: ProfileOutboundRequestFailureCode? = nil, id: String? = nil) {
            self.clientToken = clientToken
            self.failureCode = failureCode
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case failureCode = "failureCode"
            case id = "id"
        }
    }

    public struct FailedRequest: AWSDecodableShape {
        public let clientToken: String?
        public let failureCode: FailureCode?
        public let id: String?

        @inlinable
        public init(clientToken: String? = nil, failureCode: FailureCode? = nil, id: String? = nil) {
            self.clientToken = clientToken
            self.failureCode = failureCode
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case failureCode = "failureCode"
            case id = "id"
        }
    }

    public struct GetCampaignStateBatchRequest: AWSEncodableShape {
        public let campaignIds: [String]

        @inlinable
        public init(campaignIds: [String]) {
            self.campaignIds = campaignIds
        }

        public func validate(name: String) throws {
            try self.campaignIds.forEach {
                try validate($0, name: "campaignIds[]", parent: name, max: 256)
                try validate($0, name: "campaignIds[]", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case campaignIds = "campaignIds"
        }
    }

    public struct GetCampaignStateBatchResponse: AWSDecodableShape {
        public let failedRequests: [FailedCampaignStateResponse]?
        public let successfulRequests: [SuccessfulCampaignStateResponse]?

        @inlinable
        public init(failedRequests: [FailedCampaignStateResponse]? = nil, successfulRequests: [SuccessfulCampaignStateResponse]? = nil) {
            self.failedRequests = failedRequests
            self.successfulRequests = successfulRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "failedRequests"
            case successfulRequests = "successfulRequests"
        }
    }

    public struct GetCampaignStateRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCampaignStateResponse: AWSDecodableShape {
        public let state: CampaignState?

        @inlinable
        public init(state: CampaignState? = nil) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct GetConnectInstanceConfigRequest: AWSEncodableShape {
        public let connectInstanceId: String

        @inlinable
        public init(connectInstanceId: String) {
            self.connectInstanceId = connectInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectInstanceConfigResponse: AWSDecodableShape {
        public let connectInstanceConfig: InstanceConfig?

        @inlinable
        public init(connectInstanceConfig: InstanceConfig? = nil) {
            self.connectInstanceConfig = connectInstanceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case connectInstanceConfig = "connectInstanceConfig"
        }
    }

    public struct GetInstanceOnboardingJobStatusRequest: AWSEncodableShape {
        public let connectInstanceId: String

        @inlinable
        public init(connectInstanceId: String) {
            self.connectInstanceId = connectInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInstanceOnboardingJobStatusResponse: AWSDecodableShape {
        public let connectInstanceOnboardingJobStatus: InstanceOnboardingJobStatus?

        @inlinable
        public init(connectInstanceOnboardingJobStatus: InstanceOnboardingJobStatus? = nil) {
            self.connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case connectInstanceOnboardingJobStatus = "connectInstanceOnboardingJobStatus"
        }
    }

    public struct InstanceConfig: AWSDecodableShape {
        public let connectInstanceId: String
        public let encryptionConfig: EncryptionConfig
        public let serviceLinkedRoleArn: String

        @inlinable
        public init(connectInstanceId: String, encryptionConfig: EncryptionConfig, serviceLinkedRoleArn: String) {
            self.connectInstanceId = connectInstanceId
            self.encryptionConfig = encryptionConfig
            self.serviceLinkedRoleArn = serviceLinkedRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectInstanceId = "connectInstanceId"
            case encryptionConfig = "encryptionConfig"
            case serviceLinkedRoleArn = "serviceLinkedRoleArn"
        }
    }

    public struct InstanceIdFilter: AWSEncodableShape {
        public let `operator`: InstanceIdFilterOperator
        public let value: String

        @inlinable
        public init(operator: InstanceIdFilterOperator, value: String) {
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct InstanceOnboardingJobStatus: AWSDecodableShape {
        public let connectInstanceId: String
        public let failureCode: InstanceOnboardingJobFailureCode?
        public let status: InstanceOnboardingJobStatusCode

        @inlinable
        public init(connectInstanceId: String, failureCode: InstanceOnboardingJobFailureCode? = nil, status: InstanceOnboardingJobStatusCode) {
            self.connectInstanceId = connectInstanceId
            self.failureCode = failureCode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case connectInstanceId = "connectInstanceId"
            case failureCode = "failureCode"
            case status = "status"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvalidCampaignStateException: AWSErrorShape {
        public let message: String
        public let state: CampaignState
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, state: CampaignState, xAmzErrorType: String? = nil) {
            self.message = message
            self.state = state
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.state = try container.decode(CampaignState.self, forKey: .state)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case state = "state"
        }
    }

    public struct InvalidStateException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListCampaignsRequest: AWSEncodableShape {
        public let filters: CampaignFilters?
        public let maxResults: Int?
        public let nextToken: String?

        @inlinable
        public init(filters: CampaignFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCampaignsResponse: AWSDecodableShape {
        public let campaignSummaryList: [CampaignSummary]?
        public let nextToken: String?

        @inlinable
        public init(campaignSummaryList: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaignSummaryList = campaignSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaignSummaryList = "campaignSummaryList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectInstanceIntegrationsRequest: AWSEncodableShape {
        public let connectInstanceId: String
        public let maxResults: Int?
        public let nextToken: String?

        @inlinable
        public init(connectInstanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectInstanceId = connectInstanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectInstanceIntegrationsResponse: AWSDecodableShape {
        public let integrationSummaryList: [IntegrationSummary]?
        public let nextToken: String?

        @inlinable
        public init(integrationSummaryList: [IntegrationSummary]? = nil, nextToken: String? = nil) {
            self.integrationSummaryList = integrationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case integrationSummaryList = "integrationSummaryList"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LocalTimeZoneConfig: AWSEncodableShape & AWSDecodableShape {
        public let defaultTimeZone: String?
        public let localTimeZoneDetection: [LocalTimeZoneDetectionType]?

        @inlinable
        public init(defaultTimeZone: String? = nil, localTimeZoneDetection: [LocalTimeZoneDetectionType]? = nil) {
            self.defaultTimeZone = defaultTimeZone
            self.localTimeZoneDetection = localTimeZoneDetection
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultTimeZone, name: "defaultTimeZone", parent: name, max: 50)
            try self.validate(self.defaultTimeZone, name: "defaultTimeZone", parent: name, pattern: "^[a-zA-Z0-9_\\-/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultTimeZone = "defaultTimeZone"
            case localTimeZoneDetection = "localTimeZoneDetection"
        }
    }

    public struct OutboundRequest: AWSEncodableShape {
        public let channelSubtypeParameters: ChannelSubtypeParameters
        public let clientToken: String
        @CustomCoding<ISO8601DateCoder>
        public var expirationTime: Date

        @inlinable
        public init(channelSubtypeParameters: ChannelSubtypeParameters, clientToken: String, expirationTime: Date) {
            self.channelSubtypeParameters = channelSubtypeParameters
            self.clientToken = clientToken
            self.expirationTime = expirationTime
        }

        public func validate(name: String) throws {
            try self.channelSubtypeParameters.validate(name: "\(name).channelSubtypeParameters")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 200)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtypeParameters = "channelSubtypeParameters"
            case clientToken = "clientToken"
            case expirationTime = "expirationTime"
        }
    }

    public struct PauseCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PredictiveConfig: AWSEncodableShape & AWSDecodableShape {
        public let bandwidthAllocation: Double

        @inlinable
        public init(bandwidthAllocation: Double) {
            self.bandwidthAllocation = bandwidthAllocation
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthAllocation, name: "bandwidthAllocation", parent: name, max: 1.0)
            try self.validate(self.bandwidthAllocation, name: "bandwidthAllocation", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthAllocation = "bandwidthAllocation"
        }
    }

    public struct ProfileOutboundRequest: AWSEncodableShape {
        public let clientToken: String
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        public let profileId: String

        @inlinable
        public init(clientToken: String, expirationTime: Date? = nil, profileId: String) {
            self.clientToken = clientToken
            self.expirationTime = expirationTime
            self.profileId = profileId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 200)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case expirationTime = "expirationTime"
            case profileId = "profileId"
        }
    }

    public struct ProgressiveConfig: AWSEncodableShape & AWSDecodableShape {
        public let bandwidthAllocation: Double

        @inlinable
        public init(bandwidthAllocation: Double) {
            self.bandwidthAllocation = bandwidthAllocation
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthAllocation, name: "bandwidthAllocation", parent: name, max: 1.0)
            try self.validate(self.bandwidthAllocation, name: "bandwidthAllocation", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthAllocation = "bandwidthAllocation"
        }
    }

    public struct PutConnectInstanceIntegrationRequest: AWSEncodableShape {
        public let connectInstanceId: String
        public let integrationConfig: IntegrationConfig

        @inlinable
        public init(connectInstanceId: String, integrationConfig: IntegrationConfig) {
            self.connectInstanceId = connectInstanceId
            self.integrationConfig = integrationConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
            try container.encode(self.integrationConfig, forKey: .integrationConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.integrationConfig.validate(name: "\(name).integrationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case integrationConfig = "integrationConfig"
        }
    }

    public struct PutOutboundRequestBatchRequest: AWSEncodableShape {
        public let id: String
        public let outboundRequests: [OutboundRequest]

        @inlinable
        public init(id: String, outboundRequests: [OutboundRequest]) {
            self.id = id
            self.outboundRequests = outboundRequests
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.outboundRequests, forKey: .outboundRequests)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            try self.outboundRequests.forEach {
                try $0.validate(name: "\(name).outboundRequests[]")
            }
            try self.validate(self.outboundRequests, name: "outboundRequests", parent: name, max: 25)
            try self.validate(self.outboundRequests, name: "outboundRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case outboundRequests = "outboundRequests"
        }
    }

    public struct PutOutboundRequestBatchResponse: AWSDecodableShape {
        public let failedRequests: [FailedRequest]?
        public let successfulRequests: [SuccessfulRequest]?

        @inlinable
        public init(failedRequests: [FailedRequest]? = nil, successfulRequests: [SuccessfulRequest]? = nil) {
            self.failedRequests = failedRequests
            self.successfulRequests = successfulRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "failedRequests"
            case successfulRequests = "successfulRequests"
        }
    }

    public struct PutProfileOutboundRequestBatchRequest: AWSEncodableShape {
        public let id: String
        public let profileOutboundRequests: [ProfileOutboundRequest]

        @inlinable
        public init(id: String, profileOutboundRequests: [ProfileOutboundRequest]) {
            self.id = id
            self.profileOutboundRequests = profileOutboundRequests
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.profileOutboundRequests, forKey: .profileOutboundRequests)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            try self.profileOutboundRequests.forEach {
                try $0.validate(name: "\(name).profileOutboundRequests[]")
            }
            try self.validate(self.profileOutboundRequests, name: "profileOutboundRequests", parent: name, max: 20)
            try self.validate(self.profileOutboundRequests, name: "profileOutboundRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case profileOutboundRequests = "profileOutboundRequests"
        }
    }

    public struct PutProfileOutboundRequestBatchResponse: AWSDecodableShape {
        public let failedRequests: [FailedProfileOutboundRequest]?
        public let successfulRequests: [SuccessfulProfileOutboundRequest]?

        @inlinable
        public init(failedRequests: [FailedProfileOutboundRequest]? = nil, successfulRequests: [SuccessfulProfileOutboundRequest]? = nil) {
            self.failedRequests = failedRequests
            self.successfulRequests = successfulRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "failedRequests"
            case successfulRequests = "successfulRequests"
        }
    }

    public struct QConnectIntegrationConfig: AWSEncodableShape {
        public let knowledgeBaseArn: String

        @inlinable
        public init(knowledgeBaseArn: String) {
            self.knowledgeBaseArn = knowledgeBaseArn
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, max: 500)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, min: 20)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
        }
    }

    public struct QConnectIntegrationIdentifier: AWSEncodableShape {
        public let knowledgeBaseArn: String

        @inlinable
        public init(knowledgeBaseArn: String) {
            self.knowledgeBaseArn = knowledgeBaseArn
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, max: 500)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, min: 20)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
        }
    }

    public struct QConnectIntegrationSummary: AWSDecodableShape {
        public let knowledgeBaseArn: String

        @inlinable
        public init(knowledgeBaseArn: String) {
            self.knowledgeBaseArn = knowledgeBaseArn
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RestrictedPeriod: AWSEncodableShape & AWSDecodableShape {
        public let endDate: String
        public let name: String?
        public let startDate: String

        @inlinable
        public init(endDate: String, name: String? = nil, startDate: String) {
            self.endDate = endDate
            self.name = name
            self.startDate = startDate
        }

        public func validate(name: String) throws {
            try self.validate(self.endDate, name: "endDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.startDate, name: "startDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case name = "name"
            case startDate = "startDate"
        }
    }

    public struct ResumeCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        public let refreshFrequency: String?
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        @inlinable
        public init(endTime: Date, refreshFrequency: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.refreshFrequency = refreshFrequency
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.refreshFrequency, name: "refreshFrequency", parent: name, max: 50)
            try self.validate(self.refreshFrequency, name: "refreshFrequency", parent: name, pattern: "^P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case refreshFrequency = "refreshFrequency"
            case startTime = "startTime"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SmsChannelSubtypeConfig: AWSEncodableShape & AWSDecodableShape {
        public let capacity: Double?
        public let defaultOutboundConfig: SmsOutboundConfig
        public let outboundMode: SmsOutboundMode

        @inlinable
        public init(capacity: Double? = nil, defaultOutboundConfig: SmsOutboundConfig, outboundMode: SmsOutboundMode) {
            self.capacity = capacity
            self.defaultOutboundConfig = defaultOutboundConfig
            self.outboundMode = outboundMode
        }

        public func validate(name: String) throws {
            try self.validate(self.capacity, name: "capacity", parent: name, max: 1.0)
            try self.validate(self.capacity, name: "capacity", parent: name, min: 0.01)
            try self.defaultOutboundConfig.validate(name: "\(name).defaultOutboundConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case defaultOutboundConfig = "defaultOutboundConfig"
            case outboundMode = "outboundMode"
        }
    }

    public struct SmsChannelSubtypeParameters: AWSEncodableShape {
        public let connectSourcePhoneNumberArn: String?
        public let destinationPhoneNumber: String
        public let templateArn: String?
        public let templateParameters: [String: String]

        @inlinable
        public init(connectSourcePhoneNumberArn: String? = nil, destinationPhoneNumber: String, templateArn: String? = nil, templateParameters: [String: String]) {
            self.connectSourcePhoneNumberArn = connectSourcePhoneNumberArn
            self.destinationPhoneNumber = destinationPhoneNumber
            self.templateArn = templateArn
            self.templateParameters = templateParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, max: 500)
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, min: 20)
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^[\\d\\-+]*$")
            try self.validate(self.templateArn, name: "templateArn", parent: name, max: 500)
            try self.validate(self.templateArn, name: "templateArn", parent: name, min: 20)
            try self.validate(self.templateArn, name: "templateArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.templateParameters.forEach {
                try validate($0.key, name: "templateParameters.key", parent: name, max: 32767)
                try validate($0.key, name: "templateParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectSourcePhoneNumberArn = "connectSourcePhoneNumberArn"
            case destinationPhoneNumber = "destinationPhoneNumber"
            case templateArn = "templateArn"
            case templateParameters = "templateParameters"
        }
    }

    public struct SmsOutboundConfig: AWSEncodableShape & AWSDecodableShape {
        public let connectSourcePhoneNumberArn: String
        public let wisdomTemplateArn: String

        @inlinable
        public init(connectSourcePhoneNumberArn: String, wisdomTemplateArn: String) {
            self.connectSourcePhoneNumberArn = connectSourcePhoneNumberArn
            self.wisdomTemplateArn = wisdomTemplateArn
        }

        public func validate(name: String) throws {
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, max: 500)
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, min: 20)
            try self.validate(self.connectSourcePhoneNumberArn, name: "connectSourcePhoneNumberArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, max: 500)
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, min: 20)
            try self.validate(self.wisdomTemplateArn, name: "wisdomTemplateArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectSourcePhoneNumberArn = "connectSourcePhoneNumberArn"
            case wisdomTemplateArn = "wisdomTemplateArn"
        }
    }

    public struct StartCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartInstanceOnboardingJobRequest: AWSEncodableShape {
        public let connectInstanceId: String
        public let encryptionConfig: EncryptionConfig

        @inlinable
        public init(connectInstanceId: String, encryptionConfig: EncryptionConfig) {
            self.connectInstanceId = connectInstanceId
            self.encryptionConfig = encryptionConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectInstanceId, key: "connectInstanceId")
            try container.encode(self.encryptionConfig, forKey: .encryptionConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, max: 256)
            try self.validate(self.connectInstanceId, name: "connectInstanceId", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
            try self.encryptionConfig.validate(name: "\(name).encryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "encryptionConfig"
        }
    }

    public struct StartInstanceOnboardingJobResponse: AWSDecodableShape {
        public let connectInstanceOnboardingJobStatus: InstanceOnboardingJobStatus?

        @inlinable
        public init(connectInstanceOnboardingJobStatus: InstanceOnboardingJobStatus? = nil) {
            self.connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case connectInstanceOnboardingJobStatus = "connectInstanceOnboardingJobStatus"
        }
    }

    public struct StopCampaignRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SuccessfulCampaignStateResponse: AWSDecodableShape {
        public let campaignId: String?
        public let state: CampaignState?

        @inlinable
        public init(campaignId: String? = nil, state: CampaignState? = nil) {
            self.campaignId = campaignId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "campaignId"
            case state = "state"
        }
    }

    public struct SuccessfulProfileOutboundRequest: AWSDecodableShape {
        public let clientToken: String?
        public let id: String?

        @inlinable
        public init(clientToken: String? = nil, id: String? = nil) {
            self.clientToken = clientToken
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct SuccessfulRequest: AWSDecodableShape {
        public let clientToken: String?
        public let id: String?

        @inlinable
        public init(clientToken: String? = nil, id: String? = nil) {
            self.clientToken = clientToken
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public let arn: String
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TelephonyChannelSubtypeConfig: AWSEncodableShape & AWSDecodableShape {
        public let capacity: Double?
        public let connectQueueId: String?
        public let defaultOutboundConfig: TelephonyOutboundConfig
        public let outboundMode: TelephonyOutboundMode

        @inlinable
        public init(capacity: Double? = nil, connectQueueId: String? = nil, defaultOutboundConfig: TelephonyOutboundConfig, outboundMode: TelephonyOutboundMode) {
            self.capacity = capacity
            self.connectQueueId = connectQueueId
            self.defaultOutboundConfig = defaultOutboundConfig
            self.outboundMode = outboundMode
        }

        public func validate(name: String) throws {
            try self.validate(self.capacity, name: "capacity", parent: name, max: 1.0)
            try self.validate(self.capacity, name: "capacity", parent: name, min: 0.01)
            try self.validate(self.connectQueueId, name: "connectQueueId", parent: name, max: 500)
            try self.defaultOutboundConfig.validate(name: "\(name).defaultOutboundConfig")
            try self.outboundMode.validate(name: "\(name).outboundMode")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case connectQueueId = "connectQueueId"
            case defaultOutboundConfig = "defaultOutboundConfig"
            case outboundMode = "outboundMode"
        }
    }

    public struct TelephonyChannelSubtypeParameters: AWSEncodableShape {
        public let answerMachineDetectionConfig: AnswerMachineDetectionConfig?
        public let attributes: [String: String]
        public let connectSourcePhoneNumber: String?
        public let destinationPhoneNumber: String

        @inlinable
        public init(answerMachineDetectionConfig: AnswerMachineDetectionConfig? = nil, attributes: [String: String], connectSourcePhoneNumber: String? = nil, destinationPhoneNumber: String) {
            self.answerMachineDetectionConfig = answerMachineDetectionConfig
            self.attributes = attributes
            self.connectSourcePhoneNumber = connectSourcePhoneNumber
            self.destinationPhoneNumber = destinationPhoneNumber
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.connectSourcePhoneNumber, name: "connectSourcePhoneNumber", parent: name, max: 100)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^[\\d\\-+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case answerMachineDetectionConfig = "answerMachineDetectionConfig"
            case attributes = "attributes"
            case connectSourcePhoneNumber = "connectSourcePhoneNumber"
            case destinationPhoneNumber = "destinationPhoneNumber"
        }
    }

    public struct TelephonyOutboundConfig: AWSEncodableShape & AWSDecodableShape {
        public let answerMachineDetectionConfig: AnswerMachineDetectionConfig?
        public let connectContactFlowId: String
        public let connectSourcePhoneNumber: String?

        @inlinable
        public init(answerMachineDetectionConfig: AnswerMachineDetectionConfig? = nil, connectContactFlowId: String, connectSourcePhoneNumber: String? = nil) {
            self.answerMachineDetectionConfig = answerMachineDetectionConfig
            self.connectContactFlowId = connectContactFlowId
            self.connectSourcePhoneNumber = connectSourcePhoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.connectContactFlowId, name: "connectContactFlowId", parent: name, max: 500)
            try self.validate(self.connectSourcePhoneNumber, name: "connectSourcePhoneNumber", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case answerMachineDetectionConfig = "answerMachineDetectionConfig"
            case connectContactFlowId = "connectContactFlowId"
            case connectSourcePhoneNumber = "connectSourcePhoneNumber"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TimeRange: AWSEncodableShape & AWSDecodableShape {
        public let endTime: String
        public let startTime: String

        @inlinable
        public init(endTime: String, startTime: String) {
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.endTime, name: "endTime", parent: name, pattern: "^T\\d{2}:\\d{2}$")
            try self.validate(self.startTime, name: "startTime", parent: name, pattern: "^T\\d{2}:\\d{2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct TimeWindow: AWSEncodableShape & AWSDecodableShape {
        public let openHours: OpenHours
        public let restrictedPeriods: RestrictedPeriods?

        @inlinable
        public init(openHours: OpenHours, restrictedPeriods: RestrictedPeriods? = nil) {
            self.openHours = openHours
            self.restrictedPeriods = restrictedPeriods
        }

        public func validate(name: String) throws {
            try self.restrictedPeriods?.validate(name: "\(name).restrictedPeriods")
        }

        private enum CodingKeys: String, CodingKey {
            case openHours = "openHours"
            case restrictedPeriods = "restrictedPeriods"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public let arn: String
        public let tagKeys: [String]

        @inlinable
        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCampaignChannelSubtypeConfigRequest: AWSEncodableShape {
        public let channelSubtypeConfig: ChannelSubtypeConfig
        public let id: String

        @inlinable
        public init(channelSubtypeConfig: ChannelSubtypeConfig, id: String) {
            self.channelSubtypeConfig = channelSubtypeConfig
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channelSubtypeConfig, forKey: .channelSubtypeConfig)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.channelSubtypeConfig.validate(name: "\(name).channelSubtypeConfig")
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtypeConfig = "channelSubtypeConfig"
        }
    }

    public struct UpdateCampaignCommunicationLimitsRequest: AWSEncodableShape {
        public let communicationLimitsOverride: CommunicationLimitsConfig
        public let id: String

        @inlinable
        public init(communicationLimitsOverride: CommunicationLimitsConfig, id: String) {
            self.communicationLimitsOverride = communicationLimitsOverride
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.communicationLimitsOverride, forKey: .communicationLimitsOverride)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.communicationLimitsOverride.validate(name: "\(name).communicationLimitsOverride")
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case communicationLimitsOverride = "communicationLimitsOverride"
        }
    }

    public struct UpdateCampaignCommunicationTimeRequest: AWSEncodableShape {
        public let communicationTimeConfig: CommunicationTimeConfig
        public let id: String

        @inlinable
        public init(communicationTimeConfig: CommunicationTimeConfig, id: String) {
            self.communicationTimeConfig = communicationTimeConfig
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.communicationTimeConfig, forKey: .communicationTimeConfig)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.communicationTimeConfig.validate(name: "\(name).communicationTimeConfig")
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case communicationTimeConfig = "communicationTimeConfig"
        }
    }

    public struct UpdateCampaignFlowAssociationRequest: AWSEncodableShape {
        public let connectCampaignFlowArn: String
        public let id: String

        @inlinable
        public init(connectCampaignFlowArn: String, id: String) {
            self.connectCampaignFlowArn = connectCampaignFlowArn
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.connectCampaignFlowArn, forKey: .connectCampaignFlowArn)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, max: 500)
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, min: 20)
            try self.validate(self.connectCampaignFlowArn, name: "connectCampaignFlowArn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:[a-zA-Z0-9-]+:[a-z]{2}-[a-z]+-\\d{1,2}:[a-zA-Z0-9-]+:[^:]+(?:/[^:]+)*(?:/[^:]+)?(?:\\:[^:]+)?$")
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectCampaignFlowArn = "connectCampaignFlowArn"
        }
    }

    public struct UpdateCampaignNameRequest: AWSEncodableShape {
        public let id: String
        public let name: String

        @inlinable
        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateCampaignScheduleRequest: AWSEncodableShape {
        public let id: String
        public let schedule: Schedule

        @inlinable
        public init(id: String, schedule: Schedule) {
            self.id = id
            self.schedule = schedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.schedule, forKey: .schedule)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            try self.schedule.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "schedule"
        }
    }

    public struct UpdateCampaignSourceRequest: AWSEncodableShape {
        public let id: String
        public let source: Source

        @inlinable
        public init(id: String, source: Source) {
            self.id = id
            self.source = source
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.source, forKey: .source)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9\\-:/]*$")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let message: String
        public let xAmzErrorType: String?

        @inlinable
        public init(message: String, xAmzErrorType: String? = nil) {
            self.message = message
            self.xAmzErrorType = xAmzErrorType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.xAmzErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct CommunicationLimits: AWSEncodableShape & AWSDecodableShape {
        public let communicationLimitsList: [CommunicationLimit]?

        @inlinable
        public init(communicationLimitsList: [CommunicationLimit]? = nil) {
            self.communicationLimitsList = communicationLimitsList
        }

        public func validate(name: String) throws {
            try self.validate(self.communicationLimitsList, name: "communicationLimitsList", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case communicationLimitsList = "communicationLimitsList"
        }
    }

    public struct EmailOutboundMode: AWSEncodableShape & AWSDecodableShape {
        public let agentless: AgentlessConfig?

        @inlinable
        public init(agentless: AgentlessConfig? = nil) {
            self.agentless = agentless
        }

        private enum CodingKeys: String, CodingKey {
            case agentless = "agentless"
        }
    }

    public struct OpenHours: AWSEncodableShape & AWSDecodableShape {
        public let dailyHours: [DayOfWeek: [TimeRange]]?

        @inlinable
        public init(dailyHours: [DayOfWeek: [TimeRange]]? = nil) {
            self.dailyHours = dailyHours
        }

        private enum CodingKeys: String, CodingKey {
            case dailyHours = "dailyHours"
        }
    }

    public struct RestrictedPeriods: AWSEncodableShape & AWSDecodableShape {
        public let restrictedPeriodList: [RestrictedPeriod]?

        @inlinable
        public init(restrictedPeriodList: [RestrictedPeriod]? = nil) {
            self.restrictedPeriodList = restrictedPeriodList
        }

        public func validate(name: String) throws {
            try self.restrictedPeriodList?.forEach {
                try $0.validate(name: "\(name).restrictedPeriodList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case restrictedPeriodList = "restrictedPeriodList"
        }
    }

    public struct SmsOutboundMode: AWSEncodableShape & AWSDecodableShape {
        public let agentless: AgentlessConfig?

        @inlinable
        public init(agentless: AgentlessConfig? = nil) {
            self.agentless = agentless
        }

        private enum CodingKeys: String, CodingKey {
            case agentless = "agentless"
        }
    }
}

// MARK: - Errors

/// Error enum for ConnectCampaignsV2
public struct ConnectCampaignsV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidCampaignStateException = "InvalidCampaignStateException"
        case invalidStateException = "InvalidStateException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConnectCampaignsV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// Request processing failed because of an error or failure with the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request could not be processed because of conflict in the current state of the campaign.
    public static var invalidCampaignStateException: Self { .init(.invalidCampaignStateException) }
    /// The request could not be processed because of conflict in the current state.
    public static var invalidStateException: Self { .init(.invalidStateException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension ConnectCampaignsV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": ConnectCampaignsV2.AccessDeniedException.self,
        "ConflictException": ConnectCampaignsV2.ConflictException.self,
        "InternalServerException": ConnectCampaignsV2.InternalServerException.self,
        "InvalidCampaignStateException": ConnectCampaignsV2.InvalidCampaignStateException.self,
        "InvalidStateException": ConnectCampaignsV2.InvalidStateException.self,
        "ResourceNotFoundException": ConnectCampaignsV2.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": ConnectCampaignsV2.ServiceQuotaExceededException.self,
        "ThrottlingException": ConnectCampaignsV2.ThrottlingException.self,
        "ValidationException": ConnectCampaignsV2.ValidationException.self
    ]
}

extension ConnectCampaignsV2ErrorType: Equatable {
    public static func == (lhs: ConnectCampaignsV2ErrorType, rhs: ConnectCampaignsV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectCampaignsV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
