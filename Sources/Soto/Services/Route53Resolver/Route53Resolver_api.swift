//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Route53Resolver service.
///
/// When you create a VPC using Amazon VPC, you automatically get DNS resolution within the VPC
/// 			from Route 53 Resolver. By default, Resolver answers DNS queries for VPC domain names
/// 			such as domain names for EC2 instances or Elastic Load Balancing load balancers.
/// 			Resolver performs recursive lookups against public name servers for all other domain
/// 			names. You can also configure DNS resolution between your VPC and your network over a Direct Connect or VPN connection:  Forward DNS queries from resolvers on your network to Route 53 Resolver  DNS resolvers on your network can forward DNS queries to Resolver in a specified VPC. This allows your DNS resolvers
/// 			to easily resolve domain names for Amazon Web Services resources such as EC2 instances or records in a Route 53 private hosted zone.
/// 			For more information, see
/// 			How DNS Resolvers
/// 			on Your Network Forward DNS Queries to Route 53 Resolver in the Amazon Route 53 Developer Guide.  Conditionally forward queries from a VPC to resolvers on your network  You can configure Resolver to forward queries that it receives from EC2 instances in your VPCs to DNS resolvers on your network.
/// 			To forward selected queries, you create Resolver rules that specify the domain names for the DNS queries that you want to forward
/// 			(such as example.com), and the IP addresses of the DNS resolvers on your network that you want to forward the queries to.
/// 			If a query matches multiple rules (example.com, acme.example.com), Resolver chooses the rule with the most specific match
/// 			(acme.example.com) and forwards the query to the IP addresses that you specified in that rule. For more information, see
/// 			How Route 53 Resolver
/// 			Forwards DNS Queries from Your VPCs to Your Network in the Amazon Route 53 Developer Guide. Like Amazon VPC, Resolver is Regional. In each Region where you have VPCs, you can choose
/// 			whether to forward queries from your VPCs to your network (outbound queries), from your
/// 			network to your VPCs (inbound queries), or both.
public struct Route53Resolver: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Route53Resolver client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "Route53Resolver",
            serviceName: "Route53Resolver",
            serviceIdentifier: "route53resolver",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2018-04-01",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: Route53ResolverErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "af-south-1": "route53resolver.af-south-1.api.aws",
            "ap-east-1": "route53resolver.ap-east-1.api.aws",
            "ap-northeast-1": "route53resolver.ap-northeast-1.api.aws",
            "ap-northeast-2": "route53resolver.ap-northeast-2.api.aws",
            "ap-northeast-3": "route53resolver.ap-northeast-3.api.aws",
            "ap-south-1": "route53resolver.ap-south-1.api.aws",
            "ap-south-2": "route53resolver.ap-south-2.api.aws",
            "ap-southeast-1": "route53resolver.ap-southeast-1.api.aws",
            "ap-southeast-2": "route53resolver.ap-southeast-2.api.aws",
            "ap-southeast-3": "route53resolver.ap-southeast-3.api.aws",
            "ap-southeast-4": "route53resolver.ap-southeast-4.api.aws",
            "ap-southeast-5": "route53resolver.ap-southeast-5.api.aws",
            "ap-southeast-7": "route53resolver.ap-southeast-7.api.aws",
            "ca-central-1": "route53resolver.ca-central-1.api.aws",
            "ca-west-1": "route53resolver.ca-west-1.api.aws",
            "cn-north-1": "route53resolver.cn-north-1.api.amazonwebservices.com.cn",
            "cn-northwest-1": "route53resolver.cn-northwest-1.api.amazonwebservices.com.cn",
            "eu-central-1": "route53resolver.eu-central-1.api.aws",
            "eu-central-2": "route53resolver.eu-central-2.api.aws",
            "eu-north-1": "route53resolver.eu-north-1.api.aws",
            "eu-south-1": "route53resolver.eu-south-1.api.aws",
            "eu-south-2": "route53resolver.eu-south-2.api.aws",
            "eu-west-1": "route53resolver.eu-west-1.api.aws",
            "eu-west-2": "route53resolver.eu-west-2.api.aws",
            "eu-west-3": "route53resolver.eu-west-3.api.aws",
            "il-central-1": "route53resolver.il-central-1.api.aws",
            "me-central-1": "route53resolver.me-central-1.api.aws",
            "me-south-1": "route53resolver.me-south-1.api.aws",
            "mx-central-1": "route53resolver.mx-central-1.api.aws",
            "sa-east-1": "route53resolver.sa-east-1.api.aws",
            "us-east-1": "route53resolver.us-east-1.api.aws",
            "us-east-2": "route53resolver.us-east-2.api.aws",
            "us-gov-east-1": "route53resolver.us-gov-east-1.api.aws",
            "us-gov-west-1": "route53resolver.us-gov-west-1.api.aws",
            "us-west-1": "route53resolver.us-west-1.api.aws",
            "us-west-2": "route53resolver.us-west-2.api.aws"
        ]),
        [.dualstack, .fips]: .init(endpoints: [
            "ca-central-1": "route53resolver-fips.ca-central-1.api.aws",
            "ca-west-1": "route53resolver-fips.ca-west-1.api.aws",
            "us-east-1": "route53resolver-fips.us-east-1.api.aws",
            "us-east-2": "route53resolver-fips.us-east-2.api.aws",
            "us-gov-east-1": "route53resolver.us-gov-east-1.api.aws",
            "us-gov-west-1": "route53resolver.us-gov-west-1.api.aws",
            "us-west-1": "route53resolver-fips.us-west-1.api.aws",
            "us-west-2": "route53resolver-fips.us-west-2.api.aws"
        ]),
        [.fips]: .init(endpoints: [
            "ca-central-1": "route53resolver-fips.ca-central-1.amazonaws.com",
            "ca-west-1": "route53resolver-fips.ca-west-1.amazonaws.com",
            "us-east-1": "route53resolver-fips.us-east-1.amazonaws.com",
            "us-east-2": "route53resolver-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "route53resolver.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "route53resolver.us-gov-west-1.amazonaws.com",
            "us-west-1": "route53resolver-fips.us-west-1.amazonaws.com",
            "us-west-2": "route53resolver-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Associates a FirewallRuleGroup with a VPC, to provide DNS filtering for the VPC.
    @Sendable
    @inlinable
    public func associateFirewallRuleGroup(_ input: AssociateFirewallRuleGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateFirewallRuleGroupResponse {
        try await self.client.execute(
            operation: "AssociateFirewallRuleGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a FirewallRuleGroup with a VPC, to provide DNS filtering for the VPC.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request and that allows failed requests to be
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group.
    ///   - mutationProtection: If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.  When you create the association, the default setting is DISABLED.
    ///   - name: A name that lets you identify the association, to manage and use it.
    ///   - priority: The setting that determines the processing order of the rule group among the rule
    ///   - tags: A list of the tag keys and values that you want to associate with the rule group association.
    ///   - vpcId: The unique identifier of the VPC that you want to associate with the rule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateFirewallRuleGroup(
        creatorRequestId: String = AssociateFirewallRuleGroupRequest.idempotencyToken(),
        firewallRuleGroupId: String,
        mutationProtection: MutationProtectionStatus? = nil,
        name: String,
        priority: Int,
        tags: [Tag]? = nil,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateFirewallRuleGroupResponse {
        let input = AssociateFirewallRuleGroupRequest(
            creatorRequestId: creatorRequestId, 
            firewallRuleGroupId: firewallRuleGroupId, 
            mutationProtection: mutationProtection, 
            name: name, 
            priority: priority, 
            tags: tags, 
            vpcId: vpcId
        )
        return try await self.associateFirewallRuleGroup(input, logger: logger)
    }

    /// Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
    /// 			submit one AssociateResolverEndpointIpAddress request for each IP address. To remove an IP address from an endpoint, see
    /// 			DisassociateResolverEndpointIpAddress.
    ///
    @Sendable
    @inlinable
    public func associateResolverEndpointIpAddress(_ input: AssociateResolverEndpointIpAddressRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateResolverEndpointIpAddressResponse {
        try await self.client.execute(
            operation: "AssociateResolverEndpointIpAddress", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
    /// 			submit one AssociateResolverEndpointIpAddress request for each IP address. To remove an IP address from an endpoint, see
    /// 			DisassociateResolverEndpointIpAddress.
    ///
    ///
    /// Parameters:
    ///   - ipAddress: Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID,
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to associate IP addresses with.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateResolverEndpointIpAddress(
        ipAddress: IpAddressUpdate,
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateResolverEndpointIpAddressResponse {
        let input = AssociateResolverEndpointIpAddressRequest(
            ipAddress: ipAddress, 
            resolverEndpointId: resolverEndpointId
        )
        return try await self.associateResolverEndpointIpAddress(input, logger: logger)
    }

    /// Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
    /// 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one AssociateResolverQueryLogConfig
    /// 			request for each VPC.  The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.  To remove a VPC from a query logging configuration, see
    /// 			DisassociateResolverQueryLogConfig.
    ///
    @Sendable
    @inlinable
    public func associateResolverQueryLogConfig(_ input: AssociateResolverQueryLogConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateResolverQueryLogConfigResponse {
        try await self.client.execute(
            operation: "AssociateResolverQueryLogConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
    /// 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one AssociateResolverQueryLogConfig
    /// 			request for each VPC.  The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.  To remove a VPC from a query logging configuration, see
    /// 			DisassociateResolverQueryLogConfig.
    ///
    ///
    /// Parameters:
    ///   - resolverQueryLogConfigId: The ID of the query logging configuration that you want to associate a VPC with.
    ///   - resourceId: The ID of an Amazon VPC that you want this query logging configuration to log queries for.  The VPCs and the query logging configuration must be in the same Region.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateResolverQueryLogConfig(
        resolverQueryLogConfigId: String,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateResolverQueryLogConfigResponse {
        let input = AssociateResolverQueryLogConfigRequest(
            resolverQueryLogConfigId: resolverQueryLogConfigId, 
            resourceId: resourceId
        )
        return try await self.associateResolverQueryLogConfig(input, logger: logger)
    }

    /// Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
    /// 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
    /// 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
    /// 			CreateResolverRule.
    @Sendable
    @inlinable
    public func associateResolverRule(_ input: AssociateResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateResolverRuleResponse {
        try await self.client.execute(
            operation: "AssociateResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
    /// 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
    /// 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
    /// 			CreateResolverRule.
    ///
    /// Parameters:
    ///   - name: A name for the association that you're creating between a Resolver rule and a VPC.
    ///   - resolverRuleId: The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use
    ///   - vpcId: The ID of the VPC that you want to associate the Resolver rule with.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateResolverRule(
        name: String? = nil,
        resolverRuleId: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateResolverRuleResponse {
        let input = AssociateResolverRuleRequest(
            name: name, 
            resolverRuleId: resolverRuleId, 
            vpcId: vpcId
        )
        return try await self.associateResolverRule(input, logger: logger)
    }

    /// Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using ImportFirewallDomains, or with domain strings, using UpdateFirewallDomains.
    @Sendable
    @inlinable
    public func createFirewallDomainList(_ input: CreateFirewallDomainListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFirewallDomainListResponse {
        try await self.client.execute(
            operation: "CreateFirewallDomainList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using ImportFirewallDomains, or with domain strings, using UpdateFirewallDomains.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request and that allows you to retry failed requests
    ///   - name: A name that lets you identify the domain list to manage and use it.
    ///   - tags: A list of the tag keys and values that you want to associate with the domain list.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFirewallDomainList(
        creatorRequestId: String = CreateFirewallDomainListRequest.idempotencyToken(),
        name: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFirewallDomainListResponse {
        let input = CreateFirewallDomainListRequest(
            creatorRequestId: creatorRequestId, 
            name: name, 
            tags: tags
        )
        return try await self.createFirewallDomainList(input, logger: logger)
    }

    /// Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.
    @Sendable
    @inlinable
    public func createFirewallRule(_ input: CreateFirewallRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFirewallRuleResponse {
        try await self.client.execute(
            operation: "CreateFirewallRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.
    ///
    /// Parameters:
    ///   - action: The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule:    ALLOW - Permit the request to go through. Not available for DNS Firewall Advanced rules.    ALERT - Permit the request and send metrics and logs to Cloud Watch.    BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    ///   - blockOverrideDnsType: The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockOverrideDomain: The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockOverrideTtl: The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockResponse: The way that you want DNS Firewall to block the request, used with the rule action
    ///   - confidenceThreshold: 			The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule. The confidence
    ///   - creatorRequestId: A unique string that identifies the request and that allows you to retry failed requests
    ///   - dnsThreatProtection: 			Use to create a DNS Firewall Advanced rule.
    ///   - firewallDomainListId: The ID of the domain list that you want to use in the rule. Can't be used together with DnsThreatProtecton.
    ///   - firewallDomainRedirectionAction: 			How you want the the rule to evaluate DNS redirection in the DNS redirection chain, such as CNAME or DNAME.
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group where you want to create the rule.
    ///   - name: A name that lets you identify the rule in the rule group.
    ///   - priority: The setting that determines the processing order of the rule in the rule group. DNS Firewall  processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group.  To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You  can change the priority setting for the rules in a rule group at any time.
    ///   - qtype: 			The DNS query type you want the rule to evaluate. Allowed values are;
    ///   - logger: Logger use during operation
    @inlinable
    public func createFirewallRule(
        action: Action,
        blockOverrideDnsType: BlockOverrideDnsType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: BlockResponse? = nil,
        confidenceThreshold: ConfidenceThreshold? = nil,
        creatorRequestId: String = CreateFirewallRuleRequest.idempotencyToken(),
        dnsThreatProtection: DnsThreatProtection? = nil,
        firewallDomainListId: String? = nil,
        firewallDomainRedirectionAction: FirewallDomainRedirectionAction? = nil,
        firewallRuleGroupId: String,
        name: String,
        priority: Int,
        qtype: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFirewallRuleResponse {
        let input = CreateFirewallRuleRequest(
            action: action, 
            blockOverrideDnsType: blockOverrideDnsType, 
            blockOverrideDomain: blockOverrideDomain, 
            blockOverrideTtl: blockOverrideTtl, 
            blockResponse: blockResponse, 
            confidenceThreshold: confidenceThreshold, 
            creatorRequestId: creatorRequestId, 
            dnsThreatProtection: dnsThreatProtection, 
            firewallDomainListId: firewallDomainListId, 
            firewallDomainRedirectionAction: firewallDomainRedirectionAction, 
            firewallRuleGroupId: firewallRuleGroupId, 
            name: name, 
            priority: priority, 
            qtype: qtype
        )
        return try await self.createFirewallRule(input, logger: logger)
    }

    /// Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group  by calling CreateFirewallRule.
    @Sendable
    @inlinable
    public func createFirewallRuleGroup(_ input: CreateFirewallRuleGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFirewallRuleGroupResponse {
        try await self.client.execute(
            operation: "CreateFirewallRuleGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group  by calling CreateFirewallRule.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string defined by you to identify the request. This allows you to retry failed
    ///   - name: A name that lets you identify the rule group, to manage and use it.
    ///   - tags: A list of the tag keys and values that you want to associate with the rule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFirewallRuleGroup(
        creatorRequestId: String = CreateFirewallRuleGroupRequest.idempotencyToken(),
        name: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFirewallRuleGroupResponse {
        let input = CreateFirewallRuleGroupRequest(
            creatorRequestId: creatorRequestId, 
            name: name, 
            tags: tags
        )
        return try await self.createFirewallRuleGroup(input, logger: logger)
    }

    /// Creates a Route 53 Resolver on an Outpost.
    @Sendable
    @inlinable
    public func createOutpostResolver(_ input: CreateOutpostResolverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateOutpostResolverResponse {
        try await self.client.execute(
            operation: "CreateOutpostResolver", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Route 53 Resolver on an Outpost.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request
    ///   - instanceCount: Number of Amazon EC2 instances for the
    ///   - name: A friendly name that lets you easily find a configuration in the
    ///   - outpostArn: The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
    ///   - preferredInstanceType: 		The Amazon EC2 instance type. If you specify this, you must also specify a value for the OutpostArn.
    ///   - tags: 			A string that helps identify the Route 53 Resolvers on Outpost.
    ///   - logger: Logger use during operation
    @inlinable
    public func createOutpostResolver(
        creatorRequestId: String,
        instanceCount: Int? = nil,
        name: String,
        outpostArn: String,
        preferredInstanceType: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateOutpostResolverResponse {
        let input = CreateOutpostResolverRequest(
            creatorRequestId: creatorRequestId, 
            instanceCount: instanceCount, 
            name: name, 
            outpostArn: outpostArn, 
            preferredInstanceType: preferredInstanceType, 
            tags: tags
        )
        return try await self.createOutpostResolver(input, logger: logger)
    }

    /// Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:   An inbound Resolver endpoint forwards DNS queries to the DNS service for a VPC
    /// 				from your network.   An outbound Resolver endpoint forwards DNS queries from the DNS service for a VPC
    /// 				to your network.
    @Sendable
    @inlinable
    public func createResolverEndpoint(_ input: CreateResolverEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResolverEndpointResponse {
        try await self.client.execute(
            operation: "CreateResolverEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:   An inbound Resolver endpoint forwards DNS queries to the DNS service for a VPC
    /// 				from your network.   An outbound Resolver endpoint forwards DNS queries from the DNS service for a VPC
    /// 				to your network.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request and that allows failed requests to be retried
    ///   - direction: Specify the applicable value:    INBOUND: Resolver forwards DNS queries to the DNS service for a VPC from your network    OUTBOUND: Resolver forwards DNS queries from the DNS service for a VPC to your network
    ///   - ipAddresses: The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
    ///   - name: A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    ///   - outpostArn: The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a
    ///   - preferredInstanceType: The  instance type. If you specify this, you must also specify a value for the OutpostArn.
    ///   - protocols: 			The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only.
    ///   - resolverEndpointType: 			For the endpoint type you can choose either IPv4, IPv6, or dual-stack.
    ///   - securityGroupIds: The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify
    ///   - tags: A list of the tag keys and values that you want to associate with the endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResolverEndpoint(
        creatorRequestId: String,
        direction: ResolverEndpointDirection,
        ipAddresses: [IpAddressRequest],
        name: String? = nil,
        outpostArn: String? = nil,
        preferredInstanceType: String? = nil,
        protocols: [`Protocol`]? = nil,
        resolverEndpointType: ResolverEndpointType? = nil,
        securityGroupIds: [String],
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResolverEndpointResponse {
        let input = CreateResolverEndpointRequest(
            creatorRequestId: creatorRequestId, 
            direction: direction, 
            ipAddresses: ipAddresses, 
            name: name, 
            outpostArn: outpostArn, 
            preferredInstanceType: preferredInstanceType, 
            protocols: protocols, 
            resolverEndpointType: resolverEndpointType, 
            securityGroupIds: securityGroupIds, 
            tags: tags
        )
        return try await self.createResolverEndpoint(input, logger: logger)
    }

    /// Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
    /// 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration. To specify which VPCs you want to log queries for, you use AssociateResolverQueryLogConfig. For more information, see
    /// 			AssociateResolverQueryLogConfig.  You can optionally use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services accounts. The other accounts
    /// 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
    /// 			VPCs that are associated with the configuration.
    @Sendable
    @inlinable
    public func createResolverQueryLogConfig(_ input: CreateResolverQueryLogConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResolverQueryLogConfigResponse {
        try await self.client.execute(
            operation: "CreateResolverQueryLogConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
    /// 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration. To specify which VPCs you want to log queries for, you use AssociateResolverQueryLogConfig. For more information, see
    /// 			AssociateResolverQueryLogConfig.  You can optionally use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services accounts. The other accounts
    /// 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
    /// 			VPCs that are associated with the configuration.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request and that allows failed requests to be retried
    ///   - destinationArn: The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group,
    ///   - name: The name that you want to give the query logging configuration.
    ///   - tags: A list of the tag keys and values that you want to associate with the query logging configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResolverQueryLogConfig(
        creatorRequestId: String = CreateResolverQueryLogConfigRequest.idempotencyToken(),
        destinationArn: String,
        name: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResolverQueryLogConfigResponse {
        let input = CreateResolverQueryLogConfigRequest(
            creatorRequestId: creatorRequestId, 
            destinationArn: destinationArn, 
            name: name, 
            tags: tags
        )
        return try await self.createResolverQueryLogConfig(input, logger: logger)
    }

    /// For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
    /// 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.
    @Sendable
    @inlinable
    public func createResolverRule(_ input: CreateResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResolverRuleResponse {
        try await self.client.execute(
            operation: "CreateResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
    /// 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.
    ///
    /// Parameters:
    ///   - creatorRequestId: A unique string that identifies the request and that allows failed requests to be retried
    ///   - domainName: DNS queries for this domain name are forwarded to the IP addresses that you specify in TargetIps. If a query matches
    ///   - name: A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
    ///   - resolverEndpointId: The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify
    ///   - ruleType: When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
    ///   - tags: A list of the tag keys and values that you want to associate with the endpoint.
    ///   - targetIps: The IPs that you want Resolver to forward DNS queries to. You can specify either Ipv4 or Ipv6 addresses but not both in the same rule. Separate IP addresses with a space.  TargetIps is available only when the value of Rule type is FORWARD.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResolverRule(
        creatorRequestId: String,
        domainName: String? = nil,
        name: String? = nil,
        resolverEndpointId: String? = nil,
        ruleType: RuleTypeOption,
        tags: [Tag]? = nil,
        targetIps: [TargetAddress]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResolverRuleResponse {
        let input = CreateResolverRuleRequest(
            creatorRequestId: creatorRequestId, 
            domainName: domainName, 
            name: name, 
            resolverEndpointId: resolverEndpointId, 
            ruleType: ruleType, 
            tags: tags, 
            targetIps: targetIps
        )
        return try await self.createResolverRule(input, logger: logger)
    }

    /// Deletes the specified domain list.
    @Sendable
    @inlinable
    public func deleteFirewallDomainList(_ input: DeleteFirewallDomainListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFirewallDomainListResponse {
        try await self.client.execute(
            operation: "DeleteFirewallDomainList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified domain list.
    ///
    /// Parameters:
    ///   - firewallDomainListId: The ID of the domain list that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFirewallDomainList(
        firewallDomainListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFirewallDomainListResponse {
        let input = DeleteFirewallDomainListRequest(
            firewallDomainListId: firewallDomainListId
        )
        return try await self.deleteFirewallDomainList(input, logger: logger)
    }

    /// Deletes the specified firewall rule.
    @Sendable
    @inlinable
    public func deleteFirewallRule(_ input: DeleteFirewallRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFirewallRuleResponse {
        try await self.client.execute(
            operation: "DeleteFirewallRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified firewall rule.
    ///
    /// Parameters:
    ///   - firewallDomainListId: The ID of the domain list that's used in the rule.
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to delete the rule from.
    ///   - firewallThreatProtectionId: 			The ID that is created for a DNS Firewall Advanced rule.
    ///   - qtype: 			The DNS query type that the rule you are deleting evaluates. Allowed values are;
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFirewallRule(
        firewallDomainListId: String? = nil,
        firewallRuleGroupId: String,
        firewallThreatProtectionId: String? = nil,
        qtype: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFirewallRuleResponse {
        let input = DeleteFirewallRuleRequest(
            firewallDomainListId: firewallDomainListId, 
            firewallRuleGroupId: firewallRuleGroupId, 
            firewallThreatProtectionId: firewallThreatProtectionId, 
            qtype: qtype
        )
        return try await self.deleteFirewallRule(input, logger: logger)
    }

    /// Deletes the specified firewall rule group.
    @Sendable
    @inlinable
    public func deleteFirewallRuleGroup(_ input: DeleteFirewallRuleGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFirewallRuleGroupResponse {
        try await self.client.execute(
            operation: "DeleteFirewallRuleGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified firewall rule group.
    ///
    /// Parameters:
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFirewallRuleGroup(
        firewallRuleGroupId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFirewallRuleGroupResponse {
        let input = DeleteFirewallRuleGroupRequest(
            firewallRuleGroupId: firewallRuleGroupId
        )
        return try await self.deleteFirewallRuleGroup(input, logger: logger)
    }

    /// Deletes a Resolver on the Outpost.
    @Sendable
    @inlinable
    public func deleteOutpostResolver(_ input: DeleteOutpostResolverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteOutpostResolverResponse {
        try await self.client.execute(
            operation: "DeleteOutpostResolver", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Resolver on the Outpost.
    ///
    /// Parameters:
    ///   - id: A unique string that identifies the Resolver on the Outpost.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteOutpostResolver(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteOutpostResolverResponse {
        let input = DeleteOutpostResolverRequest(
            id: id
        )
        return try await self.deleteOutpostResolver(input, logger: logger)
    }

    /// Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
    /// 			Resolver endpoint:    Inbound: DNS queries from your network are no longer routed
    /// 				to the DNS service for the specified VPC.    Outbound: DNS queries from a VPC are no longer routed to your network.
    @Sendable
    @inlinable
    public func deleteResolverEndpoint(_ input: DeleteResolverEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResolverEndpointResponse {
        try await self.client.execute(
            operation: "DeleteResolverEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
    /// 			Resolver endpoint:    Inbound: DNS queries from your network are no longer routed
    /// 				to the DNS service for the specified VPC.    Outbound: DNS queries from a VPC are no longer routed to your network.
    ///
    /// Parameters:
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResolverEndpoint(
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResolverEndpointResponse {
        let input = DeleteResolverEndpointRequest(
            resolverEndpointId: resolverEndpointId
        )
        return try await self.deleteResolverEndpoint(input, logger: logger)
    }

    /// Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
    /// 			associated with the configuration. This also applies if the query logging configuration is shared with other Amazon Web Services accounts, and
    /// 			the other accounts have associated VPCs with the shared configuration. Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
    /// 			DisassociateResolverQueryLogConfig. If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
    /// 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
    /// 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
    /// 			disassociated from the configuration.
    @Sendable
    @inlinable
    public func deleteResolverQueryLogConfig(_ input: DeleteResolverQueryLogConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResolverQueryLogConfigResponse {
        try await self.client.execute(
            operation: "DeleteResolverQueryLogConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
    /// 			associated with the configuration. This also applies if the query logging configuration is shared with other Amazon Web Services accounts, and
    /// 			the other accounts have associated VPCs with the shared configuration. Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
    /// 			DisassociateResolverQueryLogConfig. If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
    /// 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
    /// 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
    /// 			disassociated from the configuration.
    ///
    /// Parameters:
    ///   - resolverQueryLogConfigId: The ID of the query logging configuration that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResolverQueryLogConfig(
        resolverQueryLogConfigId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResolverQueryLogConfigResponse {
        let input = DeleteResolverQueryLogConfigRequest(
            resolverQueryLogConfigId: resolverQueryLogConfigId
        )
        return try await self.deleteResolverQueryLogConfig(input, logger: logger)
    }

    /// Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
    /// 			associated the Resolver rule with. For more information, see
    /// 			DisassociateResolverRule.
    @Sendable
    @inlinable
    public func deleteResolverRule(_ input: DeleteResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResolverRuleResponse {
        try await self.client.execute(
            operation: "DeleteResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
    /// 			associated the Resolver rule with. For more information, see
    /// 			DisassociateResolverRule.
    ///
    /// Parameters:
    ///   - resolverRuleId: The ID of the Resolver rule that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResolverRule(
        resolverRuleId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResolverRuleResponse {
        let input = DeleteResolverRuleRequest(
            resolverRuleId: resolverRuleId
        )
        return try await self.deleteResolverRule(input, logger: logger)
    }

    /// Disassociates a FirewallRuleGroup from a VPC, to remove DNS filtering from the VPC.
    @Sendable
    @inlinable
    public func disassociateFirewallRuleGroup(_ input: DisassociateFirewallRuleGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateFirewallRuleGroupResponse {
        try await self.client.execute(
            operation: "DisassociateFirewallRuleGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates a FirewallRuleGroup from a VPC, to remove DNS filtering from the VPC.
    ///
    /// Parameters:
    ///   - firewallRuleGroupAssociationId: The identifier of the FirewallRuleGroupAssociation.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateFirewallRuleGroup(
        firewallRuleGroupAssociationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateFirewallRuleGroupResponse {
        let input = DisassociateFirewallRuleGroupRequest(
            firewallRuleGroupAssociationId: firewallRuleGroupAssociationId
        )
        return try await self.disassociateFirewallRuleGroup(input, logger: logger)
    }

    /// Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
    /// 			submit one DisassociateResolverEndpointIpAddress request for each IP address. To add an IP address to an endpoint, see
    /// 			AssociateResolverEndpointIpAddress.
    ///
    @Sendable
    @inlinable
    public func disassociateResolverEndpointIpAddress(_ input: DisassociateResolverEndpointIpAddressRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateResolverEndpointIpAddressResponse {
        try await self.client.execute(
            operation: "DisassociateResolverEndpointIpAddress", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
    /// 			submit one DisassociateResolverEndpointIpAddress request for each IP address. To add an IP address to an endpoint, see
    /// 			AssociateResolverEndpointIpAddress.
    ///
    ///
    /// Parameters:
    ///   - ipAddress: The IPv4 address that you want to remove from a Resolver endpoint.
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to disassociate an IP address from.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateResolverEndpointIpAddress(
        ipAddress: IpAddressUpdate,
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateResolverEndpointIpAddressResponse {
        let input = DisassociateResolverEndpointIpAddressRequest(
            ipAddress: ipAddress, 
            resolverEndpointId: resolverEndpointId
        )
        return try await self.disassociateResolverEndpointIpAddress(input, logger: logger)
    }

    /// Disassociates a VPC from a query logging configuration.  Before you can delete a query logging configuration, you must first disassociate all VPCs
    /// 				from the configuration. If you used Resource Access Manager (RAM) to share a
    /// 				query logging configuration with other accounts, VPCs can be disassociated from the
    /// 				configuration in the following ways:   The accounts that you shared the configuration with can disassociate VPCs from the configuration.   You can stop sharing the configuration.
    @Sendable
    @inlinable
    public func disassociateResolverQueryLogConfig(_ input: DisassociateResolverQueryLogConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateResolverQueryLogConfigResponse {
        try await self.client.execute(
            operation: "DisassociateResolverQueryLogConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates a VPC from a query logging configuration.  Before you can delete a query logging configuration, you must first disassociate all VPCs
    /// 				from the configuration. If you used Resource Access Manager (RAM) to share a
    /// 				query logging configuration with other accounts, VPCs can be disassociated from the
    /// 				configuration in the following ways:   The accounts that you shared the configuration with can disassociate VPCs from the configuration.   You can stop sharing the configuration.
    ///
    /// Parameters:
    ///   - resolverQueryLogConfigId: The ID of the query logging configuration that you want to disassociate a specified VPC from.
    ///   - resourceId: The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateResolverQueryLogConfig(
        resolverQueryLogConfigId: String,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateResolverQueryLogConfigResponse {
        let input = DisassociateResolverQueryLogConfigRequest(
            resolverQueryLogConfigId: resolverQueryLogConfigId, 
            resourceId: resourceId
        )
        return try await self.disassociateResolverQueryLogConfig(input, logger: logger)
    }

    /// Removes the association between a specified Resolver rule and a specified VPC.  If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
    /// 				domain name that you specified in the Resolver rule.
    @Sendable
    @inlinable
    public func disassociateResolverRule(_ input: DisassociateResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateResolverRuleResponse {
        try await self.client.execute(
            operation: "DisassociateResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the association between a specified Resolver rule and a specified VPC.  If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
    /// 				domain name that you specified in the Resolver rule.
    ///
    /// Parameters:
    ///   - resolverRuleId: The ID of the Resolver rule that you want to disassociate from the specified VPC.
    ///   - vpcId: The ID of the VPC that you want to disassociate the Resolver rule from.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateResolverRule(
        resolverRuleId: String,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateResolverRuleResponse {
        let input = DisassociateResolverRuleRequest(
            resolverRuleId: resolverRuleId, 
            vpcId: vpcId
        )
        return try await self.disassociateResolverRule(input, logger: logger)
    }

    /// Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
    /// 			single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    @Sendable
    @inlinable
    public func getFirewallConfig(_ input: GetFirewallConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallConfigResponse {
        try await self.client.execute(
            operation: "GetFirewallConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
    /// 			single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    ///
    /// Parameters:
    ///   - resourceId: The ID of the VPC from Amazon VPC that the configuration is for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallConfig(
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallConfigResponse {
        let input = GetFirewallConfigRequest(
            resourceId: resourceId
        )
        return try await self.getFirewallConfig(input, logger: logger)
    }

    /// Retrieves the specified firewall domain list.
    @Sendable
    @inlinable
    public func getFirewallDomainList(_ input: GetFirewallDomainListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallDomainListResponse {
        try await self.client.execute(
            operation: "GetFirewallDomainList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified firewall domain list.
    ///
    /// Parameters:
    ///   - firewallDomainListId: The ID of the domain list.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallDomainList(
        firewallDomainListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallDomainListResponse {
        let input = GetFirewallDomainListRequest(
            firewallDomainListId: firewallDomainListId
        )
        return try await self.getFirewallDomainList(input, logger: logger)
    }

    /// Retrieves the specified firewall rule group.
    @Sendable
    @inlinable
    public func getFirewallRuleGroup(_ input: GetFirewallRuleGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallRuleGroupResponse {
        try await self.client.execute(
            operation: "GetFirewallRuleGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified firewall rule group.
    ///
    /// Parameters:
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallRuleGroup(
        firewallRuleGroupId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallRuleGroupResponse {
        let input = GetFirewallRuleGroupRequest(
            firewallRuleGroupId: firewallRuleGroupId
        )
        return try await self.getFirewallRuleGroup(input, logger: logger)
    }

    /// Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.
    @Sendable
    @inlinable
    public func getFirewallRuleGroupAssociation(_ input: GetFirewallRuleGroupAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallRuleGroupAssociationResponse {
        try await self.client.execute(
            operation: "GetFirewallRuleGroupAssociation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.
    ///
    /// Parameters:
    ///   - firewallRuleGroupAssociationId: The identifier of the FirewallRuleGroupAssociation.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallRuleGroupAssociation(
        firewallRuleGroupAssociationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallRuleGroupAssociationResponse {
        let input = GetFirewallRuleGroupAssociationRequest(
            firewallRuleGroupAssociationId: firewallRuleGroupAssociationId
        )
        return try await self.getFirewallRuleGroupAssociation(input, logger: logger)
    }

    /// Returns the Identity and Access Management (Amazon Web Services IAM) policy for sharing the 	specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM).
    @Sendable
    @inlinable
    public func getFirewallRuleGroupPolicy(_ input: GetFirewallRuleGroupPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallRuleGroupPolicyResponse {
        try await self.client.execute(
            operation: "GetFirewallRuleGroupPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the Identity and Access Management (Amazon Web Services IAM) policy for sharing the 	specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM).
    ///
    /// Parameters:
    ///   - arn: The ARN (Amazon Resource Name) for the rule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallRuleGroupPolicy(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallRuleGroupPolicyResponse {
        let input = GetFirewallRuleGroupPolicyRequest(
            arn: arn
        )
        return try await self.getFirewallRuleGroupPolicy(input, logger: logger)
    }

    /// Gets information about a specified Resolver on the Outpost, such as its instance count and
    /// 			type, name, and the current status of the Resolver.
    @Sendable
    @inlinable
    public func getOutpostResolver(_ input: GetOutpostResolverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetOutpostResolverResponse {
        try await self.client.execute(
            operation: "GetOutpostResolver", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified Resolver on the Outpost, such as its instance count and
    /// 			type, name, and the current status of the Resolver.
    ///
    /// Parameters:
    ///   - id: The ID of the Resolver on the Outpost.
    ///   - logger: Logger use during operation
    @inlinable
    public func getOutpostResolver(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetOutpostResolverResponse {
        let input = GetOutpostResolverRequest(
            id: id
        )
        return try await self.getOutpostResolver(input, logger: logger)
    }

    /// Retrieves the behavior configuration of Route 53 Resolver behavior for a single VPC from
    /// 				Amazon Virtual Private Cloud.
    @Sendable
    @inlinable
    public func getResolverConfig(_ input: GetResolverConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverConfigResponse {
        try await self.client.execute(
            operation: "GetResolverConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the behavior configuration of Route 53 Resolver behavior for a single VPC from
    /// 				Amazon Virtual Private Cloud.
    ///
    /// Parameters:
    ///   - resourceId: Resource ID of the Amazon VPC that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverConfig(
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverConfigResponse {
        let input = GetResolverConfigRequest(
            resourceId: resourceId
        )
        return try await self.getResolverConfig(input, logger: logger)
    }

    /// Gets DNSSEC validation information for a specified resource.
    @Sendable
    @inlinable
    public func getResolverDnssecConfig(_ input: GetResolverDnssecConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverDnssecConfigResponse {
        try await self.client.execute(
            operation: "GetResolverDnssecConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets DNSSEC validation information for a specified resource.
    ///
    /// Parameters:
    ///   - resourceId: The ID of the virtual private cloud (VPC) for the DNSSEC validation status.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverDnssecConfig(
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverDnssecConfigResponse {
        let input = GetResolverDnssecConfigRequest(
            resourceId: resourceId
        )
        return try await self.getResolverDnssecConfig(input, logger: logger)
    }

    /// Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
    /// 			current status of the endpoint.
    @Sendable
    @inlinable
    public func getResolverEndpoint(_ input: GetResolverEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverEndpointResponse {
        try await self.client.execute(
            operation: "GetResolverEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
    /// 			current status of the endpoint.
    ///
    /// Parameters:
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverEndpoint(
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverEndpointResponse {
        let input = GetResolverEndpointRequest(
            resolverEndpointId: resolverEndpointId
        )
        return try await self.getResolverEndpoint(input, logger: logger)
    }

    /// Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
    /// 			is logging queries for and the location that logs are sent to.
    @Sendable
    @inlinable
    public func getResolverQueryLogConfig(_ input: GetResolverQueryLogConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverQueryLogConfigResponse {
        try await self.client.execute(
            operation: "GetResolverQueryLogConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
    /// 			is logging queries for and the location that logs are sent to.
    ///
    /// Parameters:
    ///   - resolverQueryLogConfigId: The ID of the Resolver query logging configuration that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverQueryLogConfig(
        resolverQueryLogConfigId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverQueryLogConfigResponse {
        let input = GetResolverQueryLogConfigRequest(
            resolverQueryLogConfigId: resolverQueryLogConfigId
        )
        return try await self.getResolverQueryLogConfig(input, logger: logger)
    }

    /// Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
    /// 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.
    @Sendable
    @inlinable
    public func getResolverQueryLogConfigAssociation(_ input: GetResolverQueryLogConfigAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverQueryLogConfigAssociationResponse {
        try await self.client.execute(
            operation: "GetResolverQueryLogConfigAssociation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
    /// 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.
    ///
    /// Parameters:
    ///   - resolverQueryLogConfigAssociationId: The ID of the Resolver query logging configuration association that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverQueryLogConfigAssociation(
        resolverQueryLogConfigAssociationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverQueryLogConfigAssociationResponse {
        let input = GetResolverQueryLogConfigAssociationRequest(
            resolverQueryLogConfigAssociationId: resolverQueryLogConfigAssociationId
        )
        return try await self.getResolverQueryLogConfigAssociation(input, logger: logger)
    }

    /// Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
    /// 			operations and resources that you want to allow another Amazon Web Services account to be able to use.
    @Sendable
    @inlinable
    public func getResolverQueryLogConfigPolicy(_ input: GetResolverQueryLogConfigPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverQueryLogConfigPolicyResponse {
        try await self.client.execute(
            operation: "GetResolverQueryLogConfigPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
    /// 			operations and resources that you want to allow another Amazon Web Services account to be able to use.
    ///
    /// Parameters:
    ///   - arn: The ARN of the query logging configuration that you want to get the query logging policy for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverQueryLogConfigPolicy(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverQueryLogConfigPolicyResponse {
        let input = GetResolverQueryLogConfigPolicyRequest(
            arn: arn
        )
        return try await self.getResolverQueryLogConfigPolicy(input, logger: logger)
    }

    /// Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
    /// 			outbound Resolver endpoint that the rule is associated with.
    @Sendable
    @inlinable
    public func getResolverRule(_ input: GetResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverRuleResponse {
        try await self.client.execute(
            operation: "GetResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
    /// 			outbound Resolver endpoint that the rule is associated with.
    ///
    /// Parameters:
    ///   - resolverRuleId: The ID of the Resolver rule that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverRule(
        resolverRuleId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverRuleResponse {
        let input = GetResolverRuleRequest(
            resolverRuleId: resolverRuleId
        )
        return try await self.getResolverRule(input, logger: logger)
    }

    /// Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
    /// 			AssociateResolverRule.
    @Sendable
    @inlinable
    public func getResolverRuleAssociation(_ input: GetResolverRuleAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverRuleAssociationResponse {
        try await self.client.execute(
            operation: "GetResolverRuleAssociation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
    /// 			AssociateResolverRule.
    ///
    /// Parameters:
    ///   - resolverRuleAssociationId: The ID of the Resolver rule association that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverRuleAssociation(
        resolverRuleAssociationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverRuleAssociationResponse {
        let input = GetResolverRuleAssociationRequest(
            resolverRuleAssociationId: resolverRuleAssociationId
        )
        return try await self.getResolverRuleAssociation(input, logger: logger)
    }

    /// Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
    /// 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use.
    @Sendable
    @inlinable
    public func getResolverRulePolicy(_ input: GetResolverRulePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResolverRulePolicyResponse {
        try await self.client.execute(
            operation: "GetResolverRulePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
    /// 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use.
    ///
    /// Parameters:
    ///   - arn: The ID of the Resolver rule that you want to get the Resolver rule policy for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResolverRulePolicy(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResolverRulePolicyResponse {
        let input = GetResolverRulePolicyRequest(
            arn: arn
        )
        return try await self.getResolverRulePolicy(input, logger: logger)
    }

    /// Imports domain names from a file into a domain list, for use in a DNS firewall rule group.  Each domain specification in your domain list must satisfy the following
    /// 	requirements:    It can optionally start with * (asterisk).   With the exception of the optional starting asterisk, it must only contain 	   the following characters: A-Z, a-z, 	   0-9, - (hyphen).   It must be from 1-255 characters in length.
    @Sendable
    @inlinable
    public func importFirewallDomains(_ input: ImportFirewallDomainsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportFirewallDomainsResponse {
        try await self.client.execute(
            operation: "ImportFirewallDomains", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports domain names from a file into a domain list, for use in a DNS firewall rule group.  Each domain specification in your domain list must satisfy the following
    /// 	requirements:    It can optionally start with * (asterisk).   With the exception of the optional starting asterisk, it must only contain 	   the following characters: A-Z, a-z, 	   0-9, - (hyphen).   It must be from 1-255 characters in length.
    ///
    /// Parameters:
    ///   - domainFileUrl: The fully qualified URL or URI of the file stored in Amazon Simple Storage Service
    ///   - firewallDomainListId: The ID of the domain list that you want to modify with the import operation.
    ///   - operation: What you want DNS Firewall to do with the domains that are listed in the file. This must be set to REPLACE, which updates the domain list to exactly match the list in the file.
    ///   - logger: Logger use during operation
    @inlinable
    public func importFirewallDomains(
        domainFileUrl: String,
        firewallDomainListId: String,
        operation: FirewallDomainImportOperation,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportFirewallDomainsResponse {
        let input = ImportFirewallDomainsRequest(
            domainFileUrl: domainFileUrl, 
            firewallDomainListId: firewallDomainListId, 
            operation: operation
        )
        return try await self.importFirewallDomains(input, logger: logger)
    }

    /// Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs.  A single call might return only a partial list of the configurations. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallConfigs(_ input: ListFirewallConfigsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallConfigsResponse {
        try await self.client.execute(
            operation: "ListFirewallConfigs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs.  A single call might return only a partial list of the configurations. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallConfigs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallConfigsResponse {
        let input = ListFirewallConfigsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallConfigs(input, logger: logger)
    }

    /// Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling ListFirewallDomains.  A single call to this list operation might return only a partial list of the domain lists. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallDomainLists(_ input: ListFirewallDomainListsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallDomainListsResponse {
        try await self.client.execute(
            operation: "ListFirewallDomainLists", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling ListFirewallDomains.  A single call to this list operation might return only a partial list of the domain lists. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallDomainLists(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallDomainListsResponse {
        let input = ListFirewallDomainListsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallDomainLists(input, logger: logger)
    }

    /// Retrieves the domains that you have defined for the specified firewall domain list.   A single call might return only a partial list of the domains. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallDomains(_ input: ListFirewallDomainsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallDomainsResponse {
        try await self.client.execute(
            operation: "ListFirewallDomains", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the domains that you have defined for the specified firewall domain list.   A single call might return only a partial list of the domains. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - firewallDomainListId: The ID of the domain list whose domains you want to retrieve.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallDomains(
        firewallDomainListId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallDomainsResponse {
        let input = ListFirewallDomainsRequest(
            firewallDomainListId: firewallDomainListId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallDomains(input, logger: logger)
    }

    /// Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group.  A single call might return only a partial list of the associations. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallRuleGroupAssociations(_ input: ListFirewallRuleGroupAssociationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallRuleGroupAssociationsResponse {
        try await self.client.execute(
            operation: "ListFirewallRuleGroupAssociations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group.  A single call might return only a partial list of the associations. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to retrieve the associations for. Leave this blank to retrieve associations for any rule group.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - priority: The setting that determines the processing order of the rule group among the rule
    ///   - status: The association Status setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.
    ///   - vpcId: The unique identifier of the VPC that you want to retrieve the associations for. Leave this blank to retrieve associations for any VPC.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallRuleGroupAssociations(
        firewallRuleGroupId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        priority: Int? = nil,
        status: FirewallRuleGroupAssociationStatus? = nil,
        vpcId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallRuleGroupAssociationsResponse {
        let input = ListFirewallRuleGroupAssociationsRequest(
            firewallRuleGroupId: firewallRuleGroupId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            priority: priority, 
            status: status, 
            vpcId: vpcId
        )
        return try await self.listFirewallRuleGroupAssociations(input, logger: logger)
    }

    /// Retrieves the minimal high-level information for the rule groups that you have defined.   A single call might return only a partial list of the rule groups. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallRuleGroups(_ input: ListFirewallRuleGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallRuleGroupsResponse {
        try await self.client.execute(
            operation: "ListFirewallRuleGroups", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the minimal high-level information for the rule groups that you have defined.   A single call might return only a partial list of the rule groups. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallRuleGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallRuleGroupsResponse {
        let input = ListFirewallRuleGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallRuleGroups(input, logger: logger)
    }

    /// Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC.  A single call might return only a partial list of the rules. For information, see MaxResults.
    @Sendable
    @inlinable
    public func listFirewallRules(_ input: ListFirewallRulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallRulesResponse {
        try await self.client.execute(
            operation: "ListFirewallRules", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC.  A single call might return only a partial list of the rules. For information, see MaxResults.
    ///
    /// Parameters:
    ///   - action: Optional additional filter for the rules to retrieve. The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule:    ALLOW - Permit the request to go through. Not availabe for DNS Firewall Advanced rules.    ALERT - Permit the request to go through but send an alert to the logs.    BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to retrieve the rules for.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - nextToken: For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects  specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next  batch of objects, use the token that was returned for the prior request in your next request.
    ///   - priority: Optional additional filter for the rules to retrieve. The setting that determines the processing order of the rules in a rule group. DNS Firewall  processes the rules in a rule group by order of priority, starting from the lowest setting.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallRules(
        action: Action? = nil,
        firewallRuleGroupId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        priority: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallRulesResponse {
        let input = ListFirewallRulesRequest(
            action: action, 
            firewallRuleGroupId: firewallRuleGroupId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            priority: priority
        )
        return try await self.listFirewallRules(input, logger: logger)
    }

    /// Lists all the Resolvers on Outposts that were created using the current Amazon Web Services account.
    @Sendable
    @inlinable
    public func listOutpostResolvers(_ input: ListOutpostResolversRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOutpostResolversResponse {
        try await self.client.execute(
            operation: "ListOutpostResolvers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the Resolvers on Outposts that were created using the current Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of Resolvers on the Outpost that you want to return in the response to a
    ///   - nextToken: For the first ListOutpostResolver request, omit this value.
    ///   - outpostArn: The Amazon Resource Name (ARN) of the Outpost.
    ///   - logger: Logger use during operation
    @inlinable
    public func listOutpostResolvers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        outpostArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOutpostResolversResponse {
        let input = ListOutpostResolversRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            outpostArn: outpostArn
        )
        return try await self.listOutpostResolvers(input, logger: logger)
    }

    /// Retrieves the Resolver configurations that you have defined.
    /// 			Route 53 Resolver uses the configurations to manage DNS resolution behavior for your VPCs.
    @Sendable
    @inlinable
    public func listResolverConfigs(_ input: ListResolverConfigsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverConfigsResponse {
        try await self.client.execute(
            operation: "ListResolverConfigs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the Resolver configurations that you have defined.
    /// 			Route 53 Resolver uses the configurations to manage DNS resolution behavior for your VPCs.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of Resolver configurations that you want to return in the response to
    ///   - nextToken: (Optional) If the current Amazon Web Services account has more than MaxResults Resolver configurations, use
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverConfigs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverConfigsResponse {
        let input = ListResolverConfigsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResolverConfigs(input, logger: logger)
    }

    /// Lists the configurations for DNSSEC validation that are associated with the current Amazon Web Services account.
    @Sendable
    @inlinable
    public func listResolverDnssecConfigs(_ input: ListResolverDnssecConfigsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverDnssecConfigsResponse {
        try await self.client.execute(
            operation: "ListResolverDnssecConfigs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the configurations for DNSSEC validation that are associated with the current Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of objects.
    ///   - maxResults:  Optional: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return.
    ///   - nextToken: (Optional) If the current Amazon Web Services account has more than MaxResults DNSSEC configurations, use NextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverDnssecConfigs(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverDnssecConfigsResponse {
        let input = ListResolverDnssecConfigsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResolverDnssecConfigs(input, logger: logger)
    }

    /// Gets the IP addresses for a specified Resolver endpoint.
    @Sendable
    @inlinable
    public func listResolverEndpointIpAddresses(_ input: ListResolverEndpointIpAddressesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverEndpointIpAddressesResponse {
        try await self.client.execute(
            operation: "ListResolverEndpointIpAddresses", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the IP addresses for a specified Resolver endpoint.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of IP addresses that you want to return in the response to a ListResolverEndpointIpAddresses request.
    ///   - nextToken: For the first ListResolverEndpointIpAddresses request, omit this value. If the specified Resolver endpoint has more than MaxResults IP addresses, you can submit another
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to get IP addresses for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverEndpointIpAddresses(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverEndpointIpAddressesResponse {
        let input = ListResolverEndpointIpAddressesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resolverEndpointId: resolverEndpointId
        )
        return try await self.listResolverEndpointIpAddresses(input, logger: logger)
    }

    /// Lists all the Resolver endpoints that were created using the current Amazon Web Services account.
    @Sendable
    @inlinable
    public func listResolverEndpoints(_ input: ListResolverEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverEndpointsResponse {
        try await self.client.execute(
            operation: "ListResolverEndpoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the Resolver endpoints that were created using the current Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints.  If you submit a second or subsequent ListResolverEndpoints request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of Resolver endpoints that you want to return in the response to a ListResolverEndpoints request.
    ///   - nextToken: For the first ListResolverEndpoints request, omit this value. If you have more than MaxResults Resolver endpoints, you can submit another ListResolverEndpoints request
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverEndpoints(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverEndpointsResponse {
        let input = ListResolverEndpointsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResolverEndpoints(input, logger: logger)
    }

    /// Lists information about associations between Amazon VPCs and query logging configurations.
    @Sendable
    @inlinable
    public func listResolverQueryLogConfigAssociations(_ input: ListResolverQueryLogConfigAssociationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverQueryLogConfigAssociationsResponse {
        try await self.client.execute(
            operation: "ListResolverQueryLogConfigAssociations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about associations between Amazon VPCs and query logging configurations.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of query logging associations.  If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of query logging associations that you want to return in the response to a ListResolverQueryLogConfigAssociations request.
    ///   - nextToken: For the first ListResolverQueryLogConfigAssociations request, omit this value. If there are more than MaxResults query logging associations that match the values that you specify for Filters,
    ///   - sortBy: The element that you want Resolver to sort query logging associations by.   If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter,
    ///   - sortOrder: If you specified a value for SortBy, the order that you want query logging associations to be listed in,
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverQueryLogConfigAssociations(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverQueryLogConfigAssociationsResponse {
        let input = ListResolverQueryLogConfigAssociationsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return try await self.listResolverQueryLogConfigAssociations(input, logger: logger)
    }

    /// Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
    /// 			DNS query logs and specifies the VPCs that you want to log queries for.
    @Sendable
    @inlinable
    public func listResolverQueryLogConfigs(_ input: ListResolverQueryLogConfigsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverQueryLogConfigsResponse {
        try await self.client.execute(
            operation: "ListResolverQueryLogConfigs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
    /// 			DNS query logs and specifies the VPCs that you want to log queries for.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of query logging configurations.  If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of query logging configurations that you want to return in the response to a ListResolverQueryLogConfigs request.
    ///   - nextToken: For the first ListResolverQueryLogConfigs request, omit this value. If there are more than MaxResults query logging configurations that match the values that you specify for Filters,
    ///   - sortBy: The element that you want Resolver to sort query logging configurations by.   If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter,
    ///   - sortOrder: If you specified a value for SortBy, the order that you want query logging configurations to be listed in,
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverQueryLogConfigs(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverQueryLogConfigsResponse {
        let input = ListResolverQueryLogConfigsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return try await self.listResolverQueryLogConfigs(input, logger: logger)
    }

    /// Lists the associations that were created between Resolver rules and VPCs using the current Amazon Web Services account.
    @Sendable
    @inlinable
    public func listResolverRuleAssociations(_ input: ListResolverRuleAssociationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverRuleAssociationsResponse {
        try await self.client.execute(
            operation: "ListResolverRuleAssociations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the associations that were created between Resolver rules and VPCs using the current Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID.  If you submit a second or subsequent ListResolverRuleAssociations request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of rule associations that you want to return in the response to a ListResolverRuleAssociations request.
    ///   - nextToken: For the first ListResolverRuleAssociation request, omit this value. If you have more than MaxResults rule associations, you can submit another ListResolverRuleAssociation request
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverRuleAssociations(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverRuleAssociationsResponse {
        let input = ListResolverRuleAssociationsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResolverRuleAssociations(input, logger: logger)
    }

    /// Lists the Resolver rules that were created using the current Amazon Web Services account.
    @Sendable
    @inlinable
    public func listResolverRules(_ input: ListResolverRulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResolverRulesResponse {
        try await self.client.execute(
            operation: "ListResolverRules", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the Resolver rules that were created using the current Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filters: An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint.  If you submit a second or subsequent ListResolverRules request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of Resolver rules that you want to return in the response to a ListResolverRules request.
    ///   - nextToken: For the first ListResolverRules request, omit this value. If you have more than MaxResults Resolver rules, you can submit another ListResolverRules request
    ///   - logger: Logger use during operation
    @inlinable
    public func listResolverRules(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResolverRulesResponse {
        let input = ListResolverRulesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResolverRules(input, logger: logger)
    }

    /// Lists the tags that you associated with the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags that you associated with the specified resource.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of tags that you want to return in the response to a ListTagsForResource request.
    ///   - nextToken: For the first ListTagsForResource request, omit this value. If you have more than MaxResults tags, you can submit another ListTagsForResource request
    ///   - resourceArn: The Amazon Resource Name (ARN) for the resource that you want to list tags for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Attaches an Identity and Access Management (Amazon Web Services IAM) policy for sharing the rule
    /// 			group. You can use the policy to share the rule group using Resource Access Manager
    /// 			(RAM).
    @Sendable
    @inlinable
    public func putFirewallRuleGroupPolicy(_ input: PutFirewallRuleGroupPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutFirewallRuleGroupPolicyResponse {
        try await self.client.execute(
            operation: "PutFirewallRuleGroupPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Attaches an Identity and Access Management (Amazon Web Services IAM) policy for sharing the rule
    /// 			group. You can use the policy to share the rule group using Resource Access Manager
    /// 			(RAM).
    ///
    /// Parameters:
    ///   - arn: The ARN (Amazon Resource Name) for the rule group that you want to share.
    ///   - firewallRuleGroupPolicy: The Identity and Access Management (Amazon Web Services IAM) policy to attach to the rule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func putFirewallRuleGroupPolicy(
        arn: String,
        firewallRuleGroupPolicy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutFirewallRuleGroupPolicyResponse {
        let input = PutFirewallRuleGroupPolicyRequest(
            arn: arn, 
            firewallRuleGroupPolicy: firewallRuleGroupPolicy
        )
        return try await self.putFirewallRuleGroupPolicy(input, logger: logger)
    }

    /// Specifies an Amazon Web Services account that you want to share a query logging configuration with, the query logging configuration that you want to share,
    /// 			and the operations that you want the account to be able to perform on the configuration.
    @Sendable
    @inlinable
    public func putResolverQueryLogConfigPolicy(_ input: PutResolverQueryLogConfigPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResolverQueryLogConfigPolicyResponse {
        try await self.client.execute(
            operation: "PutResolverQueryLogConfigPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Specifies an Amazon Web Services account that you want to share a query logging configuration with, the query logging configuration that you want to share,
    /// 			and the operations that you want the account to be able to perform on the configuration.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the account that you want to share rules with.
    ///   - resolverQueryLogConfigPolicy: An Identity and Access Management policy statement that lists the query logging configurations that you want to share with another Amazon Web Services account
    ///   - logger: Logger use during operation
    @inlinable
    public func putResolverQueryLogConfigPolicy(
        arn: String,
        resolverQueryLogConfigPolicy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResolverQueryLogConfigPolicyResponse {
        let input = PutResolverQueryLogConfigPolicyRequest(
            arn: arn, 
            resolverQueryLogConfigPolicy: resolverQueryLogConfigPolicy
        )
        return try await self.putResolverQueryLogConfigPolicy(input, logger: logger)
    }

    /// Specifies an Amazon Web Services rule that you want to share with another account, the account that you want to share the rule with,
    /// 			and the operations that you want the account to be able to perform on the rule.
    @Sendable
    @inlinable
    public func putResolverRulePolicy(_ input: PutResolverRulePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResolverRulePolicyResponse {
        try await self.client.execute(
            operation: "PutResolverRulePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Specifies an Amazon Web Services rule that you want to share with another account, the account that you want to share the rule with,
    /// 			and the operations that you want the account to be able to perform on the rule.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the rule that you want to share with another account.
    ///   - resolverRulePolicy: An Identity and Access Management policy statement that lists the rules that you want to share with another Amazon Web Services account and the operations that you want the account
    ///   - logger: Logger use during operation
    @inlinable
    public func putResolverRulePolicy(
        arn: String,
        resolverRulePolicy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResolverRulePolicyResponse {
        let input = PutResolverRulePolicyRequest(
            arn: arn, 
            resolverRulePolicy: resolverRulePolicy
        )
        return try await self.putResolverRulePolicy(input, logger: logger)
    }

    /// Adds one or more tags to a specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds one or more tags to a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable
    ///   - tags: The tags that you want to add to the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from a specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes one or more tags from a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable
    ///   - tagKeys: The tags that you want to remove to the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of the firewall behavior provided by DNS Firewall for a single
    /// 			VPC from Amazon Virtual Private Cloud (Amazon VPC).
    @Sendable
    @inlinable
    public func updateFirewallConfig(_ input: UpdateFirewallConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallConfigResponse {
        try await self.client.execute(
            operation: "UpdateFirewallConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of the firewall behavior provided by DNS Firewall for a single
    /// 			VPC from Amazon Virtual Private Cloud (Amazon VPC).
    ///
    /// Parameters:
    ///   - firewallFailOpen: Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.    By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability.  DNS Firewall blocks queries that it is unable to evaluate properly.    If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it  is unable to properly evaluate them.    This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
    ///   - resourceId: The ID of the VPC that the configuration is for.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallConfig(
        firewallFailOpen: FirewallFailOpenStatus,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallConfigResponse {
        let input = UpdateFirewallConfigRequest(
            firewallFailOpen: firewallFailOpen, 
            resourceId: resourceId
        )
        return try await self.updateFirewallConfig(input, logger: logger)
    }

    /// Updates the firewall domain list from an array of domain specifications.
    @Sendable
    @inlinable
    public func updateFirewallDomains(_ input: UpdateFirewallDomainsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallDomainsResponse {
        try await self.client.execute(
            operation: "UpdateFirewallDomains", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the firewall domain list from an array of domain specifications.
    ///
    /// Parameters:
    ///   - domains: A list of domains to use in the update operation.  There is a limit of 1000 domains per request.  Each domain specification in your domain list must satisfy the following
    ///   - firewallDomainListId: The ID of the domain list whose domains you want to update.
    ///   - operation: What you want DNS Firewall to do with the domains that you are providing:     ADD - Add the domains to the ones that are already in the domain list.     REMOVE - Search the domain list for the domains and remove them from the list.    REPLACE - Update the domain list to exactly match the list that you are providing.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallDomains(
        domains: [String],
        firewallDomainListId: String,
        operation: FirewallDomainUpdateOperation,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallDomainsResponse {
        let input = UpdateFirewallDomainsRequest(
            domains: domains, 
            firewallDomainListId: firewallDomainListId, 
            operation: operation
        )
        return try await self.updateFirewallDomains(input, logger: logger)
    }

    /// Updates the specified firewall rule.
    @Sendable
    @inlinable
    public func updateFirewallRule(_ input: UpdateFirewallRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallRuleResponse {
        try await self.client.execute(
            operation: "UpdateFirewallRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified firewall rule.
    ///
    /// Parameters:
    ///   - action: The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule:    ALLOW - Permit the request to go through. Not available for DNS Firewall Advanced rules.    ALERT - Permit the request to go through but send an alert to the logs.    BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    ///   - blockOverrideDnsType: The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockOverrideDomain: The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockOverrideTtl: The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockResponse: The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.    NODATA - Respond indicating that the query was successful, but no response is available for it.    NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.    OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    ///   - confidenceThreshold: 			The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule. The confidence
    ///   - dnsThreatProtection: 			The type of the DNS Firewall Advanced rule. Valid values are:
    ///   - firewallDomainListId: The ID of the domain list to use in the rule.
    ///   - firewallDomainRedirectionAction: 			How you want the the rule to evaluate DNS redirection in the DNS redirection chain, such as CNAME or DNAME.
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group for the rule.
    ///   - firewallThreatProtectionId: 			The DNS Firewall Advanced rule ID.
    ///   - name: The name of the rule.
    ///   - priority: The setting that determines the processing order of the rule in the rule group. DNS Firewall  processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group.  To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You  can change the priority setting for the rules in a rule group at any time.
    ///   - qtype: 			The DNS query type you want the rule to evaluate. Allowed values are;
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallRule(
        action: Action? = nil,
        blockOverrideDnsType: BlockOverrideDnsType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: BlockResponse? = nil,
        confidenceThreshold: ConfidenceThreshold? = nil,
        dnsThreatProtection: DnsThreatProtection? = nil,
        firewallDomainListId: String? = nil,
        firewallDomainRedirectionAction: FirewallDomainRedirectionAction? = nil,
        firewallRuleGroupId: String,
        firewallThreatProtectionId: String? = nil,
        name: String? = nil,
        priority: Int? = nil,
        qtype: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallRuleResponse {
        let input = UpdateFirewallRuleRequest(
            action: action, 
            blockOverrideDnsType: blockOverrideDnsType, 
            blockOverrideDomain: blockOverrideDomain, 
            blockOverrideTtl: blockOverrideTtl, 
            blockResponse: blockResponse, 
            confidenceThreshold: confidenceThreshold, 
            dnsThreatProtection: dnsThreatProtection, 
            firewallDomainListId: firewallDomainListId, 
            firewallDomainRedirectionAction: firewallDomainRedirectionAction, 
            firewallRuleGroupId: firewallRuleGroupId, 
            firewallThreatProtectionId: firewallThreatProtectionId, 
            name: name, 
            priority: priority, 
            qtype: qtype
        )
        return try await self.updateFirewallRule(input, logger: logger)
    }

    /// Changes the association of a FirewallRuleGroup with a VPC. The association enables DNS filtering for the VPC.
    @Sendable
    @inlinable
    public func updateFirewallRuleGroupAssociation(_ input: UpdateFirewallRuleGroupAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallRuleGroupAssociationResponse {
        try await self.client.execute(
            operation: "UpdateFirewallRuleGroupAssociation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Changes the association of a FirewallRuleGroup with a VPC. The association enables DNS filtering for the VPC.
    ///
    /// Parameters:
    ///   - firewallRuleGroupAssociationId: The identifier of the FirewallRuleGroupAssociation.
    ///   - mutationProtection: If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
    ///   - name: The name of the rule group association.
    ///   - priority: The setting that determines the processing order of the rule group among the rule
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallRuleGroupAssociation(
        firewallRuleGroupAssociationId: String,
        mutationProtection: MutationProtectionStatus? = nil,
        name: String? = nil,
        priority: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallRuleGroupAssociationResponse {
        let input = UpdateFirewallRuleGroupAssociationRequest(
            firewallRuleGroupAssociationId: firewallRuleGroupAssociationId, 
            mutationProtection: mutationProtection, 
            name: name, 
            priority: priority
        )
        return try await self.updateFirewallRuleGroupAssociation(input, logger: logger)
    }

    /// You can use UpdateOutpostResolver to  update the instance count, type, or  name of a Resolver on an Outpost.
    @Sendable
    @inlinable
    public func updateOutpostResolver(_ input: UpdateOutpostResolverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateOutpostResolverResponse {
        try await self.client.execute(
            operation: "UpdateOutpostResolver", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// You can use UpdateOutpostResolver to  update the instance count, type, or  name of a Resolver on an Outpost.
    ///
    /// Parameters:
    ///   - id: A unique string that identifies Resolver on an Outpost.
    ///   - instanceCount: The Amazon EC2 instance count for a Resolver on the Outpost.
    ///   - name: Name of the Resolver on the Outpost.
    ///   - preferredInstanceType: 			Amazon EC2 instance type.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateOutpostResolver(
        id: String,
        instanceCount: Int? = nil,
        name: String? = nil,
        preferredInstanceType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateOutpostResolverResponse {
        let input = UpdateOutpostResolverRequest(
            id: id, 
            instanceCount: instanceCount, 
            name: name, 
            preferredInstanceType: preferredInstanceType
        )
        return try await self.updateOutpostResolver(input, logger: logger)
    }

    /// Updates the behavior configuration of Route 53 Resolver behavior for a single VPC from
    /// 				Amazon Virtual Private Cloud.
    @Sendable
    @inlinable
    public func updateResolverConfig(_ input: UpdateResolverConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResolverConfigResponse {
        try await self.client.execute(
            operation: "UpdateResolverConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the behavior configuration of Route 53 Resolver behavior for a single VPC from
    /// 				Amazon Virtual Private Cloud.
    ///
    /// Parameters:
    ///   - autodefinedReverseFlag: Indicates whether or not the Resolver will create autodefined rules for reverse DNS
    ///   - resourceId: Resource ID of the Amazon VPC that you want to update the Resolver configuration for.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResolverConfig(
        autodefinedReverseFlag: AutodefinedReverseFlag,
        resourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResolverConfigResponse {
        let input = UpdateResolverConfigRequest(
            autodefinedReverseFlag: autodefinedReverseFlag, 
            resourceId: resourceId
        )
        return try await self.updateResolverConfig(input, logger: logger)
    }

    /// Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.
    @Sendable
    @inlinable
    public func updateResolverDnssecConfig(_ input: UpdateResolverDnssecConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResolverDnssecConfigResponse {
        try await self.client.execute(
            operation: "UpdateResolverDnssecConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.
    ///
    /// Parameters:
    ///   - resourceId: The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.
    ///   - validation: The new value that you are specifying for DNSSEC validation for the VPC. The value can be ENABLE
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResolverDnssecConfig(
        resourceId: String,
        validation: Validation,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResolverDnssecConfigResponse {
        let input = UpdateResolverDnssecConfigRequest(
            resourceId: resourceId, 
            validation: validation
        )
        return try await self.updateResolverDnssecConfig(input, logger: logger)
    }

    /// Updates the name, or endpoint type for an inbound or an outbound Resolver endpoint.
    /// 			You can only update between IPV4 and DUALSTACK, IPV6 endpoint type can't be updated to other type.
    @Sendable
    @inlinable
    public func updateResolverEndpoint(_ input: UpdateResolverEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResolverEndpointResponse {
        try await self.client.execute(
            operation: "UpdateResolverEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the name, or endpoint type for an inbound or an outbound Resolver endpoint.
    /// 			You can only update between IPV4 and DUALSTACK, IPV6 endpoint type can't be updated to other type.
    ///
    /// Parameters:
    ///   - name: The name of the Resolver endpoint that you want to update.
    ///   - protocols: 			The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only.
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to update.
    ///   - resolverEndpointType: 			Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries.
    ///   - updateIpAddresses: 			Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResolverEndpoint(
        name: String? = nil,
        protocols: [`Protocol`]? = nil,
        resolverEndpointId: String,
        resolverEndpointType: ResolverEndpointType? = nil,
        updateIpAddresses: [UpdateIpAddress]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResolverEndpointResponse {
        let input = UpdateResolverEndpointRequest(
            name: name, 
            protocols: protocols, 
            resolverEndpointId: resolverEndpointId, 
            resolverEndpointType: resolverEndpointType, 
            updateIpAddresses: updateIpAddresses
        )
        return try await self.updateResolverEndpoint(input, logger: logger)
    }

    /// Updates settings for a specified Resolver rule. ResolverRuleId is required, and all other parameters are optional.
    /// 			If you don't specify a parameter, it retains its current value.
    @Sendable
    @inlinable
    public func updateResolverRule(_ input: UpdateResolverRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResolverRuleResponse {
        try await self.client.execute(
            operation: "UpdateResolverRule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates settings for a specified Resolver rule. ResolverRuleId is required, and all other parameters are optional.
    /// 			If you don't specify a parameter, it retains its current value.
    ///
    /// Parameters:
    ///   - config: The new settings for the Resolver rule.
    ///   - resolverRuleId: The ID of the Resolver rule that you want to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResolverRule(
        config: ResolverRuleConfig,
        resolverRuleId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResolverRuleResponse {
        let input = UpdateResolverRuleRequest(
            config: config, 
            resolverRuleId: resolverRuleId
        )
        return try await self.updateResolverRule(input, logger: logger)
    }
}

extension Route53Resolver {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Route53Resolver, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Route53Resolver {
    /// Return PaginatorSequence for operation ``listFirewallConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallConfigsPaginator(
        _ input: ListFirewallConfigsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallConfigsRequest, ListFirewallConfigsResponse> {
        return .init(
            input: input,
            command: self.listFirewallConfigs,
            inputKey: \ListFirewallConfigsRequest.nextToken,
            outputKey: \ListFirewallConfigsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallConfigsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallConfigsRequest, ListFirewallConfigsResponse> {
        let input = ListFirewallConfigsRequest(
            maxResults: maxResults
        )
        return self.listFirewallConfigsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainListsPaginator(
        _ input: ListFirewallDomainListsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainListsRequest, ListFirewallDomainListsResponse> {
        return .init(
            input: input,
            command: self.listFirewallDomainLists,
            inputKey: \ListFirewallDomainListsRequest.nextToken,
            outputKey: \ListFirewallDomainListsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainListsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainListsRequest, ListFirewallDomainListsResponse> {
        let input = ListFirewallDomainListsRequest(
            maxResults: maxResults
        )
        return self.listFirewallDomainListsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainsPaginator(
        _ input: ListFirewallDomainsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainsRequest, ListFirewallDomainsResponse> {
        return .init(
            input: input,
            command: self.listFirewallDomains,
            inputKey: \ListFirewallDomainsRequest.nextToken,
            outputKey: \ListFirewallDomainsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - firewallDomainListId: The ID of the domain list whose domains you want to retrieve.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainsPaginator(
        firewallDomainListId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainsRequest, ListFirewallDomainsResponse> {
        let input = ListFirewallDomainsRequest(
            firewallDomainListId: firewallDomainListId, 
            maxResults: maxResults
        )
        return self.listFirewallDomainsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallRuleGroupAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRuleGroupAssociationsPaginator(
        _ input: ListFirewallRuleGroupAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallRuleGroupAssociationsRequest, ListFirewallRuleGroupAssociationsResponse> {
        return .init(
            input: input,
            command: self.listFirewallRuleGroupAssociations,
            inputKey: \ListFirewallRuleGroupAssociationsRequest.nextToken,
            outputKey: \ListFirewallRuleGroupAssociationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallRuleGroupAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to retrieve the associations for. Leave this blank to retrieve associations for any rule group.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - priority: The setting that determines the processing order of the rule group among the rule
    ///   - status: The association Status setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.
    ///   - vpcId: The unique identifier of the VPC that you want to retrieve the associations for. Leave this blank to retrieve associations for any VPC.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRuleGroupAssociationsPaginator(
        firewallRuleGroupId: String? = nil,
        maxResults: Int? = nil,
        priority: Int? = nil,
        status: FirewallRuleGroupAssociationStatus? = nil,
        vpcId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallRuleGroupAssociationsRequest, ListFirewallRuleGroupAssociationsResponse> {
        let input = ListFirewallRuleGroupAssociationsRequest(
            firewallRuleGroupId: firewallRuleGroupId, 
            maxResults: maxResults, 
            priority: priority, 
            status: status, 
            vpcId: vpcId
        )
        return self.listFirewallRuleGroupAssociationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallRuleGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRuleGroupsPaginator(
        _ input: ListFirewallRuleGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallRuleGroupsRequest, ListFirewallRuleGroupsResponse> {
        return .init(
            input: input,
            command: self.listFirewallRuleGroups,
            inputKey: \ListFirewallRuleGroupsRequest.nextToken,
            outputKey: \ListFirewallRuleGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallRuleGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRuleGroupsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallRuleGroupsRequest, ListFirewallRuleGroupsResponse> {
        let input = ListFirewallRuleGroupsRequest(
            maxResults: maxResults
        )
        return self.listFirewallRuleGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRulesPaginator(
        _ input: ListFirewallRulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallRulesRequest, ListFirewallRulesResponse> {
        return .init(
            input: input,
            command: self.listFirewallRules,
            inputKey: \ListFirewallRulesRequest.nextToken,
            outputKey: \ListFirewallRulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - action: Optional additional filter for the rules to retrieve. The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule:    ALLOW - Permit the request to go through. Not availabe for DNS Firewall Advanced rules.    ALERT - Permit the request to go through but send an alert to the logs.    BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
    ///   - firewallRuleGroupId: The unique identifier of the firewall rule group that you want to retrieve the rules for.
    ///   - maxResults: The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    ///   - priority: Optional additional filter for the rules to retrieve. The setting that determines the processing order of the rules in a rule group. DNS Firewall  processes the rules in a rule group by order of priority, starting from the lowest setting.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRulesPaginator(
        action: Action? = nil,
        firewallRuleGroupId: String,
        maxResults: Int? = nil,
        priority: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallRulesRequest, ListFirewallRulesResponse> {
        let input = ListFirewallRulesRequest(
            action: action, 
            firewallRuleGroupId: firewallRuleGroupId, 
            maxResults: maxResults, 
            priority: priority
        )
        return self.listFirewallRulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOutpostResolvers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOutpostResolversPaginator(
        _ input: ListOutpostResolversRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOutpostResolversRequest, ListOutpostResolversResponse> {
        return .init(
            input: input,
            command: self.listOutpostResolvers,
            inputKey: \ListOutpostResolversRequest.nextToken,
            outputKey: \ListOutpostResolversResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOutpostResolvers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of Resolvers on the Outpost that you want to return in the response to a
    ///   - outpostArn: The Amazon Resource Name (ARN) of the Outpost.
    ///   - logger: Logger used for logging
    @inlinable
    public func listOutpostResolversPaginator(
        maxResults: Int? = nil,
        outpostArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOutpostResolversRequest, ListOutpostResolversResponse> {
        let input = ListOutpostResolversRequest(
            maxResults: maxResults, 
            outpostArn: outpostArn
        )
        return self.listOutpostResolversPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverConfigsPaginator(
        _ input: ListResolverConfigsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverConfigsRequest, ListResolverConfigsResponse> {
        return .init(
            input: input,
            command: self.listResolverConfigs,
            inputKey: \ListResolverConfigsRequest.nextToken,
            outputKey: \ListResolverConfigsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of Resolver configurations that you want to return in the response to
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverConfigsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverConfigsRequest, ListResolverConfigsResponse> {
        let input = ListResolverConfigsRequest(
            maxResults: maxResults
        )
        return self.listResolverConfigsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverDnssecConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverDnssecConfigsPaginator(
        _ input: ListResolverDnssecConfigsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverDnssecConfigsRequest, ListResolverDnssecConfigsResponse> {
        return .init(
            input: input,
            command: self.listResolverDnssecConfigs,
            inputKey: \ListResolverDnssecConfigsRequest.nextToken,
            outputKey: \ListResolverDnssecConfigsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverDnssecConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of objects.
    ///   - maxResults:  Optional: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverDnssecConfigsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverDnssecConfigsRequest, ListResolverDnssecConfigsResponse> {
        let input = ListResolverDnssecConfigsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listResolverDnssecConfigsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverEndpointIpAddresses(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverEndpointIpAddressesPaginator(
        _ input: ListResolverEndpointIpAddressesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverEndpointIpAddressesRequest, ListResolverEndpointIpAddressesResponse> {
        return .init(
            input: input,
            command: self.listResolverEndpointIpAddresses,
            inputKey: \ListResolverEndpointIpAddressesRequest.nextToken,
            outputKey: \ListResolverEndpointIpAddressesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverEndpointIpAddresses(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of IP addresses that you want to return in the response to a ListResolverEndpointIpAddresses request.
    ///   - resolverEndpointId: The ID of the Resolver endpoint that you want to get IP addresses for.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverEndpointIpAddressesPaginator(
        maxResults: Int? = nil,
        resolverEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverEndpointIpAddressesRequest, ListResolverEndpointIpAddressesResponse> {
        let input = ListResolverEndpointIpAddressesRequest(
            maxResults: maxResults, 
            resolverEndpointId: resolverEndpointId
        )
        return self.listResolverEndpointIpAddressesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverEndpointsPaginator(
        _ input: ListResolverEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverEndpointsRequest, ListResolverEndpointsResponse> {
        return .init(
            input: input,
            command: self.listResolverEndpoints,
            inputKey: \ListResolverEndpointsRequest.nextToken,
            outputKey: \ListResolverEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints.  If you submit a second or subsequent ListResolverEndpoints request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of Resolver endpoints that you want to return in the response to a ListResolverEndpoints request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverEndpointsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverEndpointsRequest, ListResolverEndpointsResponse> {
        let input = ListResolverEndpointsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listResolverEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverQueryLogConfigAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverQueryLogConfigAssociationsPaginator(
        _ input: ListResolverQueryLogConfigAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverQueryLogConfigAssociationsRequest, ListResolverQueryLogConfigAssociationsResponse> {
        return .init(
            input: input,
            command: self.listResolverQueryLogConfigAssociations,
            inputKey: \ListResolverQueryLogConfigAssociationsRequest.nextToken,
            outputKey: \ListResolverQueryLogConfigAssociationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverQueryLogConfigAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of query logging associations.  If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of query logging associations that you want to return in the response to a ListResolverQueryLogConfigAssociations request.
    ///   - sortBy: The element that you want Resolver to sort query logging associations by.   If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter,
    ///   - sortOrder: If you specified a value for SortBy, the order that you want query logging associations to be listed in,
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverQueryLogConfigAssociationsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverQueryLogConfigAssociationsRequest, ListResolverQueryLogConfigAssociationsResponse> {
        let input = ListResolverQueryLogConfigAssociationsRequest(
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return self.listResolverQueryLogConfigAssociationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverQueryLogConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverQueryLogConfigsPaginator(
        _ input: ListResolverQueryLogConfigsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverQueryLogConfigsRequest, ListResolverQueryLogConfigsResponse> {
        return .init(
            input: input,
            command: self.listResolverQueryLogConfigs,
            inputKey: \ListResolverQueryLogConfigsRequest.nextToken,
            outputKey: \ListResolverQueryLogConfigsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverQueryLogConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of query logging configurations.  If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of query logging configurations that you want to return in the response to a ListResolverQueryLogConfigs request.
    ///   - sortBy: The element that you want Resolver to sort query logging configurations by.   If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter,
    ///   - sortOrder: If you specified a value for SortBy, the order that you want query logging configurations to be listed in,
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverQueryLogConfigsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverQueryLogConfigsRequest, ListResolverQueryLogConfigsResponse> {
        let input = ListResolverQueryLogConfigsRequest(
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return self.listResolverQueryLogConfigsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverRuleAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverRuleAssociationsPaginator(
        _ input: ListResolverRuleAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverRuleAssociationsRequest, ListResolverRuleAssociationsResponse> {
        return .init(
            input: input,
            command: self.listResolverRuleAssociations,
            inputKey: \ListResolverRuleAssociationsRequest.nextToken,
            outputKey: \ListResolverRuleAssociationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverRuleAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID.  If you submit a second or subsequent ListResolverRuleAssociations request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of rule associations that you want to return in the response to a ListResolverRuleAssociations request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverRuleAssociationsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverRuleAssociationsRequest, ListResolverRuleAssociationsResponse> {
        let input = ListResolverRuleAssociationsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listResolverRuleAssociationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResolverRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverRulesPaginator(
        _ input: ListResolverRulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResolverRulesRequest, ListResolverRulesResponse> {
        return .init(
            input: input,
            command: self.listResolverRules,
            inputKey: \ListResolverRulesRequest.nextToken,
            outputKey: \ListResolverRulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResolverRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint.  If you submit a second or subsequent ListResolverRules request and specify the NextToken parameter,
    ///   - maxResults: The maximum number of Resolver rules that you want to return in the response to a ListResolverRules request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResolverRulesPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResolverRulesRequest, ListResolverRulesResponse> {
        let input = ListResolverRulesRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listResolverRulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        _ input: ListTagsForResourceRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceRequest, ListTagsForResourceResponse> {
        return .init(
            input: input,
            command: self.listTagsForResource,
            inputKey: \ListTagsForResourceRequest.nextToken,
            outputKey: \ListTagsForResourceResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of tags that you want to return in the response to a ListTagsForResource request.
    ///   - resourceArn: The Amazon Resource Name (ARN) for the resource that you want to list tags for.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        maxResults: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceRequest, ListTagsForResourceResponse> {
        let input = ListTagsForResourceRequest(
            maxResults: maxResults, 
            resourceArn: resourceArn
        )
        return self.listTagsForResourcePaginator(input, logger: logger)
    }
}

extension Route53Resolver.ListFirewallConfigsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallConfigsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListFirewallDomainListsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallDomainListsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListFirewallDomainsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallDomainsRequest {
        return .init(
            firewallDomainListId: self.firewallDomainListId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListFirewallRuleGroupAssociationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallRuleGroupAssociationsRequest {
        return .init(
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority,
            status: self.status,
            vpcId: self.vpcId
        )
    }
}

extension Route53Resolver.ListFirewallRuleGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallRuleGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListFirewallRulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListFirewallRulesRequest {
        return .init(
            action: self.action,
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority
        )
    }
}

extension Route53Resolver.ListOutpostResolversRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListOutpostResolversRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            outpostArn: self.outpostArn
        )
    }
}

extension Route53Resolver.ListResolverConfigsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverConfigsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListResolverDnssecConfigsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverDnssecConfigsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListResolverEndpointIpAddressesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverEndpointIpAddressesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resolverEndpointId: self.resolverEndpointId
        )
    }
}

extension Route53Resolver.ListResolverEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverEndpointsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListResolverQueryLogConfigAssociationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverQueryLogConfigAssociationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension Route53Resolver.ListResolverQueryLogConfigsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverQueryLogConfigsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension Route53Resolver.ListResolverRuleAssociationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverRuleAssociationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListResolverRulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListResolverRulesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53Resolver.ListTagsForResourceRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53Resolver.ListTagsForResourceRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}
